<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>shell脚本编程基础 | naive的博客</title><meta name="keywords" content="linux,shell"><meta name="author" content="naive"><meta name="copyright" content="naive"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、构建基本脚本创建shell基本文件的第一行指定要使用的shell 1#!&#x2F;bin&#x2F;bash  写好一个文件之后需要执行，但是必须要让shell找到脚本  将shell脚本文件所处的目录添加到PATH环境变量中； 在提示符中用绝对或相对文件路径来引用shell脚本文件。  显示消息果在echo命令后面加上了一个字符串，该命令就能显示出这个文本字符串。 默认情况下，不需要使用引号将要显示的文本字符">
<meta property="og:type" content="article">
<meta property="og:title" content="shell脚本编程基础">
<meta property="og:url" content="http://yoursite.com/2021/09/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="naive的博客">
<meta property="og:description" content="一、构建基本脚本创建shell基本文件的第一行指定要使用的shell 1#!&#x2F;bin&#x2F;bash  写好一个文件之后需要执行，但是必须要让shell找到脚本  将shell脚本文件所处的目录添加到PATH环境变量中； 在提示符中用绝对或相对文件路径来引用shell脚本文件。  显示消息果在echo命令后面加上了一个字符串，该命令就能显示出这个文本字符串。 默认情况下，不需要使用引号将要显示的文本字符">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/img/photo-1442522772768-9032b6d10e3e.jpg">
<meta property="article:published_time" content="2021-09-20T13:02:26.000Z">
<meta property="article:modified_time" content="2021-09-27T15:33:36.445Z">
<meta property="article:author" content="naive">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/photo-1442522772768-9032b6d10e3e.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2021/09/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'shell脚本编程基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-27 23:33:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="naive的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">144</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/photo-1442522772768-9032b6d10e3e.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">naive的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">shell脚本编程基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-20T13:02:26.000Z" title="发表于 2021-09-20 21:02:26">2021-09-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-27T15:33:36.445Z" title="更新于 2021-09-27 23:33:36">2021-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>65分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="shell脚本编程基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、构建基本脚本"><a href="#一、构建基本脚本" class="headerlink" title="一、构建基本脚本"></a>一、构建基本脚本</h2><h3 id="创建shell基本"><a href="#创建shell基本" class="headerlink" title="创建shell基本"></a>创建shell基本</h3><p>文件的第一行指定要使用的shell</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure>

<p>写好一个文件之后需要执行，但是必须要让shell找到脚本</p>
<ul>
<li>将shell脚本文件所处的目录添加到PATH环境变量中；</li>
<li>在提示符中用绝对或相对文件路径来引用shell脚本文件。</li>
</ul>
<h3 id="显示消息"><a href="#显示消息" class="headerlink" title="显示消息"></a>显示消息</h3><p>果在<code>echo</code>命令后面加上了一个字符串，该命令就能显示出这个文本字符串。</p>
<p>默认情况下，不需要使用引号将要显示的文本字符串划定出来。echo命令可用单引号或双引号来划定文本字符串。需要在文本中使用其中一种引号，而用另外一种来将字符串划定起来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a test to see if you&#x27;re paying attention&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果想把文本字符串和命令输出显示在同一行中,用echo语句的<code>-n</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;The time and date are: &quot;</span></span><br><span class="line">date</span><br></pre></td></tr></table></figure>

<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>以在环境变量名称之前加上美元符（$）来使用这些环境变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;User info for userid: <span class="variable">$USER</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果需要转转义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The cost of the item is \$15&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>${variable}形式引用的变量。变量名两侧额外的花括号通常用来帮助识别美元符后的变量名。</p>
</blockquote>
<h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><p>使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格。</p>
<p>在脚本的整个生命周期里，shell脚本中定义的变量<strong>会一直保持着它们的值</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">days=10 </span><br><span class="line">guest=<span class="string">&quot;Katie&quot;</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$guest</span> checked in <span class="variable">$days</span> days ago&quot;</span> </span><br><span class="line">days=5 </span><br><span class="line">guest=<span class="string">&quot;Jessica&quot;</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$guest</span> checked in <span class="variable">$days</span> days ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#变量赋值</span></span><br><span class="line">value1=10 </span><br><span class="line">value2=<span class="variable">$value1</span>  <span class="comment">#10</span></span><br><span class="line">value3=value1   <span class="comment">#value1</span></span><br><span class="line"><span class="built_in">echo</span> The resulting value is <span class="variable">$value2</span></span><br></pre></td></tr></table></figure>

<p>变量每次被引用时，都会输出当前赋给它的值。<strong>引用一个变量值时需要使用美元符</strong>，而引用变量来<strong>对其进行赋值</strong>时则<strong>不要使用</strong>$。</p>
<h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h4><p>shell脚本可以从命令输出中提取信息，并将其赋给变量。</p>
<p>有两种方法可以将命令输出赋给变量：</p>
<ul>
<li>反引号字符（`）</li>
<li>$()格式</li>
</ul>
<p>命令替换允许你将shell命令的输出赋给变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testing=`date`</span><br><span class="line">testing=$(date)</span><br></pre></td></tr></table></figure>

<p>shell会运行命令替换符号中的命令，并将其输出赋给变量testing。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在脚本中通过命令替换获得当前日期并用它来生成唯一文件名。</span></span><br><span class="line"><span class="comment"># copy the /usr/bin directory listing to a log file </span></span><br><span class="line"><span class="comment"># +%y%m%d格式告诉date命令将日期显示为两位数的年月日的组合。140131</span></span><br><span class="line">today=$(date +%y%m%d) </span><br><span class="line">ls /usr/bin -al &gt; <span class="built_in">log</span>.<span class="variable">$today</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令替换会创建一个子shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是<strong>无法使用脚本中所创建的变量的。</strong></p>
<p>使用路径./运行命令的话，也会创建出子shell；要是运行命令的时候不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。</p>
</blockquote>
<h3 id="重定向输入和输出"><a href="#重定向输入和输出" class="headerlink" title="重定向输入和输出"></a>重定向输入和输出</h3><p>你想要保存某个命令的输出而不仅仅只是让它显示在显示器上。</p>
<h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重定向将命令的输出发送到一个文件中。&gt;</span></span><br><span class="line"><span class="built_in">command</span> &gt; outputfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果输出文件已经存在了，重定向操作符会用新的文件数据覆盖已有文件。</span></span><br><span class="line">date &gt; test6</span><br><span class="line"></span><br><span class="line"><span class="comment">#想要将命令的输出追加到已有文件中,用双大于号（&gt;&gt;）来追加数据。</span></span><br><span class="line">date &gt;&gt; test6</span><br></pre></td></tr></table></figure>

<h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h4><p>输入重定向将文件的内容重定向到命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &lt; inputfile</span><br><span class="line"></span><br><span class="line"><span class="comment">#wc &lt; test6</span></span><br><span class="line"><span class="comment">#wc命令可以对对数据中的文本进行计数。文本的行数/文本的词数/文本的字节数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#内联输入重定向,无需使用文件进行重定向，只需要在命令行中指定用于输入重定向的数据就可以了。</span></span><br><span class="line"><span class="comment">#指定一个文本标记来划分输入数据的开始和结尾。</span></span><br><span class="line"><span class="built_in">command</span> &lt;&lt; <span class="string">marker</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#在命令行上使用内联输入重定向时，shell会用PS2环境变量中定义的次提示符来提示输入数据。</span></span><br><span class="line"><span class="string">$  wc &lt;&lt; EOF </span></span><br><span class="line"><span class="string">&gt; test string 1 </span></span><br><span class="line"><span class="string">&gt; test string 2 </span></span><br><span class="line"><span class="string">&gt; test string 3 </span></span><br><span class="line"><span class="string">&gt; EOF</span></span><br></pre></td></tr></table></figure>

<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>有时需要将一个命令的输出作为另一个命令的输入。</p>
<p>我们不用将命令输出重定向到文件中，可以将其直接重定向到另一个命令。这个过程叫作<strong>管道连接（piping）</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2</span><br></pre></td></tr></table></figure>

<p>在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送给第二个命令。数据传输不会用到任何中间文件或缓冲区。</p>
<p>可以在一条命令中使用任意多条管道。可以持续地将命令的输出通过管道传给其他命令来细化操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qa | sort | more</span><br><span class="line">ls -l | more</span><br></pre></td></tr></table></figure>

<h3 id="执行数学运算"><a href="#执行数学运算" class="headerlink" title="执行数学运算"></a>执行数学运算</h3><h4 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h4><p>expr命令允许在命令行上处理数学表达式</p>
<p>expr命令能够识别少数的数学和字符串操作符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#许多expr命令操作符在shell中另有含义（比如星号）。当它们出现在在expr命令中时，会得到一些诡异的结果。</span></span><br><span class="line">$  expr 5 * 2</span><br><span class="line">expr: syntax error</span><br><span class="line"></span><br><span class="line">$ expr 5 \* 2</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h4 id="使用方括号"><a href="#使用方括号" class="headerlink" title="使用方括号"></a>使用方括号</h4><p>在bash中，在将一个数学运算结果赋给某个变量时，可以用美元符和方括号（<code>$[ operation ]</code>）将数学表达式围起来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$  var1=$[1 + 5] </span><br><span class="line">$  <span class="built_in">echo</span> <span class="variable">$var1</span> </span><br><span class="line">6 </span><br><span class="line">$  var2=$[<span class="variable">$var1</span> * 2] </span><br><span class="line">$  <span class="built_in">echo</span> <span class="variable">$var2</span> </span><br><span class="line">12 </span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>在bash shell脚本中进行算术运算会有一个主要的限制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">var1=100 </span><br><span class="line">var2=45 </span><br><span class="line">var3=$[<span class="variable">$var1</span> / <span class="variable">$var2</span>] </span><br><span class="line"><span class="built_in">echo</span> The final result is <span class="variable">$var3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">The final result is 2</span><br></pre></td></tr></table></figure>

<p>bash shell数学运算符只支持整数运算。</p>
<h4 id="浮点解决方案"><a href="#浮点解决方案" class="headerlink" title="浮点解决方案"></a>浮点解决方案</h4><p>用内建的bash计算器，叫作bc。</p>
<ol>
<li><p>bc基本用法</p>
<p>允许在命令行中输入浮点表达式，然后解释并计算该表达式可以识别</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数字（整数和浮点数）</span><br><span class="line">变量（简单变量和数组）</span><br><span class="line">注释（以#或C语言中的/* */开始的行）</span><br><span class="line">表达式</span><br><span class="line">编程语句（例如if-then语句）</span><br><span class="line">函数</span><br></pre></td></tr></table></figure>

<p>浮点运算是由内建变量scale控制的。必须将这个值设置为你希望在计算结果中保留的小数位</p>
<p>scale变量的默认值是0。在scale值被设置前，bash计算器的计算结果不包含小数位。在将其值设置成4后，bash计算器显示的结果包含四位小数。-q命令行选项可以不显示bash计算器冗长的欢迎信息.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$  bc -q </span><br><span class="line">3.44 / 5 </span><br><span class="line">0 </span><br><span class="line">scale=4 </span><br><span class="line">3.44 / 5 </span><br><span class="line">.6880 </span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
</li>
<li><p>在脚本中使用<strong>bc</strong> </p>
<p>可以用命令替换运行bc命令，并将输出赋给一个变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一部分options允许你设置变量。如果你需要不止一个变量，可以用分号将其分开。expression参数定义了通过bc执行的数学表达式。</span></span><br><span class="line">variable=$(<span class="built_in">echo</span> <span class="string">&quot;options; expression&quot;</span> | bc)</span><br><span class="line"></span><br><span class="line">var1=$(<span class="built_in">echo</span> <span class="string">&quot;scale=4; 3.44 / 5&quot;</span> | bc) </span><br><span class="line"><span class="built_in">echo</span> The answer is <span class="variable">$var1</span></span><br></pre></td></tr></table></figure>

<p>如果需要进行大量运算，在一个命令行中列出多个表达式就会有点麻烦。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用内联输入重定向，它允许你直接在命令行中重定向数据。，仍然需要命令替换符号将bc命令的输出赋给变量。</span></span><br><span class="line">variable=$(bc &lt;&lt; <span class="string">EOF </span></span><br><span class="line"><span class="string">options </span></span><br><span class="line"><span class="string">statements </span></span><br><span class="line"><span class="string">expressions </span></span><br><span class="line"><span class="string">EOF</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var1=10.46 </span><br><span class="line">var2=43.67 </span><br><span class="line">var3=33.2 </span><br><span class="line">var4=71 </span><br><span class="line">var5=$(bc &lt;&lt; <span class="string">EOF </span></span><br><span class="line"><span class="string">scale = 4 </span></span><br><span class="line"><span class="string">a1 = ( $var1 * $var2) </span></span><br><span class="line"><span class="string">b1 = ($var3 * $var4) </span></span><br><span class="line"><span class="string">a1 + b1 </span></span><br><span class="line"><span class="string">EOF</span> </span><br><span class="line">) </span><br><span class="line"><span class="built_in">echo</span> The final answer <span class="keyword">for</span> this mess is <span class="variable">$var5</span></span><br></pre></td></tr></table></figure>

<p>在bash计算器中创建的变量<strong>只在bash计算器中有效</strong>，不能在shell脚本中使用。</p>
</li>
</ol>
<h3 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h3><p>shell中运行的每个命令都使用退出状态码（exit status）告诉shell它已经运行完毕。退出状态码是一个0～255的整数值，在命令结束运行时由命令传给shell。可以捕获这个值并在脚本中使用。</p>
<h4 id="查看退出状态码"><a href="#查看退出状态码" class="headerlink" title="查看退出状态码"></a>查看退出状态码</h4><p><code>$?</code>来保存上个已执行命令的退出状态码。对于需要进行检查的命令，必须在其运行完毕后立刻查看或使用$?变量。它的值会变成由shell所执行的<strong>最后一条命令的退出状态码</strong>。</p>
<p>一个成功结束的命令的退出状态码是0。如果一个命令结束时有错误，退出状态码就是一个正数值。</p>
<table>
<thead>
<tr>
<th>状 态 码</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>命令成功结束</td>
</tr>
<tr>
<td>1</td>
<td>一般性未知错误</td>
</tr>
<tr>
<td>2</td>
<td>不适合的shell命令</td>
</tr>
<tr>
<td>126</td>
<td>命令不可执行</td>
</tr>
<tr>
<td>127</td>
<td>没找到命令</td>
</tr>
<tr>
<td>128</td>
<td>无效的退出参数</td>
</tr>
<tr>
<td>128+x</td>
<td>与Linux信号x相关的严重错误</td>
</tr>
<tr>
<td>130</td>
<td>通过Ctrl+C终止的命令</td>
</tr>
<tr>
<td>255</td>
<td>正常范围之外的退出状态码</td>
</tr>
</tbody></table>
<h4 id="exit-命令"><a href="#exit-命令" class="headerlink" title="exit 命令"></a>exit 命令</h4><p>shell脚本会以脚本中的最后一个命令的退出状态码退出。</p>
<p><code>exit</code>命令允许你在脚本结束时指定一个退出状态码。</p>
<p>因为退出状态码最大只能是255。超出这个区间，退出状态码被缩减到了0～255的区间。shell通过模运算得到这个结果。一个值的模就是被除后的余数。最终的结果是指定的数值除以256后得到的余数。</p>
<h2 id="二、结构化命令"><a href="#二、结构化命令" class="headerlink" title="二、结构化命令"></a>二、结构化命令</h2><h3 id="使用if-then-语句"><a href="#使用if-then-语句" class="headerlink" title="使用if-then 语句"></a>使用if-then 语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>bash shell的if语句会运行if后面的那个命令。如果该命令的退出状态码是0（该命令成功运行），位于then部分的命令就会被执行。。如果该命令的退出状态码是其他值，then部分的命令就不会被执行，bash shell会继续执行脚本中的下一个命令。fi语句用来表示if-then语句到此结束。</p>
<blockquote>
<p>if <em>command;</em> then<br> <em>commands</em><br>fi </p>
<p>通过把分号放在待求值的命令尾部，就<strong>可以将then语句放在同一行上</strong>了，这样看起来更像其他编程语言中的if-then语句。</p>
</blockquote>
<p>在then部分，你可以使用<strong>不止一条命令</strong>。可以像在脚本中的其他地方一样在这里列出多条命令。bash shell会将这些命令当成一个块</p>
<h3 id="if-then-else-语句"><a href="#if-then-else-语句" class="headerlink" title="if-then-else 语句"></a>if-then-else 语句</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">command</span></span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> commands</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"> commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>当if语句中的命令返回退出状态码0时，then部分中的命令会被执行，这跟普通的if-then语句一样。当if语句中的命令返回非零退出状态码时，bash shell会执行else部分中的命令。</p>
<h3 id="嵌套-if"><a href="#嵌套-if" class="headerlink" title="嵌套 if"></a>嵌套 if</h3><p>elif。这样就不用再书写多个if-then语句了。elif使用另一个if-then语句延续else部分。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> command1</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> commands</span><br><span class="line"><span class="keyword">elif</span> command2</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> more commands</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"> commands </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>elif语句行提供了另一个要测试的命令，这类似于原始的if语句行。如果elif后命令的退出状态码是0，则bash会执行第二个then语句部分的命令。使用这种嵌套方法，代码更清晰，逻辑更易懂。</p>
<h3 id="test-命令"><a href="#test-命令" class="headerlink" title="test 命令"></a>test 命令</h3><p>if-then语句是否能测试命令<strong>退出状态码之外的条件</strong>。答案是不能。</p>
<p><code>test</code>命令提供了在if-then语句中测试不同条件的途径。如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> condition</span><br></pre></td></tr></table></figure>

<p>bash shell提供了另一种条件测试方法，无需在if-then语句中声明test命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ] </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错。</p>
<p>test命令可以判断三类条件：</p>
<ul>
<li>数值比较</li>
<li>字符串比较</li>
<li>文件比较</li>
</ul>
<h4 id="1-数值比较"><a href="#1-数值比较" class="headerlink" title="1. 数值比较"></a>1. 数值比较</h4><table>
<thead>
<tr>
<th>比 较</th>
<th>描 述</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>n1 -eq n2</td>
<td>检查n1是否与n2相等</td>
<td>equal</td>
</tr>
<tr>
<td>n1 -ge n2</td>
<td>检查n1是否大于或等于n2</td>
<td>great than or equal</td>
</tr>
<tr>
<td>n1 -gt n2</td>
<td>检查n1是否大于n2</td>
<td>greater than</td>
</tr>
<tr>
<td>n1 -le n2</td>
<td>检查n1是否小于或等于n2</td>
<td>less than or equal</td>
</tr>
<tr>
<td>n1 -lt n2</td>
<td>检查n1是否小于n2</td>
<td>less than</td>
</tr>
<tr>
<td>n1 -ne n2</td>
<td>检查n1是否不等于n2</td>
<td>not equal</td>
</tr>
</tbody></table>
<h4 id="2-字符串比较"><a href="#2-字符串比较" class="headerlink" title="2.字符串比较"></a>2.字符串比较</h4><p>条件测试还允许比较字符串值。比较字符串比较烦琐，你马上就会看到。</p>
<table>
<thead>
<tr>
<th>比 较</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>str1 = str2</td>
<td>检查str1是否和str2相同</td>
</tr>
<tr>
<td>str1 != str2</td>
<td>检查str1是否和str2不同</td>
</tr>
<tr>
<td>str1 &lt; str2</td>
<td>检查str1是否比str2小</td>
</tr>
<tr>
<td>str1 &gt; str2</td>
<td>检查str1是否比str2大</td>
</tr>
<tr>
<td>-n str1</td>
<td>检查str1的长度是否非0</td>
</tr>
<tr>
<td>-z str1</td>
<td>检查str1的长度是否为0</td>
</tr>
</tbody></table>
<p>大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># mis-using string comparisons </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">val1=Testing </span><br><span class="line">val2=testing</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#转义</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$val1</span> \&gt; <span class="variable">$val2</span> ]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$val1</span> is greater than <span class="variable">$val2</span>&quot;</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$val1</span> is less than <span class="variable">$val2</span>&quot;</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在比较测试中，<strong>大写字母被认为是小于小写字母</strong>的。但sort命令恰好相反。当你将同样的字符串放进文件中并用sort命令排序时，小写字母会先出现。这是由各个命令使用的排序技术不同造成的。</p>
<p><strong>比较测试中使用的是标准的ASCII顺序</strong>，根据每个字符的ASCII数值来决定排序结果。sort命令使用的是<strong>系统的本地化语言设置中定义的排序顺序</strong>。对于英语，本地化设置指定了在排序顺序中小写字母出现在大写字母前。</p>
<h4 id="3-文件比较"><a href="#3-文件比较" class="headerlink" title="3.文件比较"></a>3.文件比较</h4><p>允许你测试Linux文件系统上文件和目录的状态。test命令的比较功能。</p>
<table>
<thead>
<tr>
<th>比 较</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>-d file</td>
<td>检查file是否存在并是一个目录</td>
</tr>
<tr>
<td>-e file</td>
<td>检查file是否存在</td>
</tr>
<tr>
<td>-f file</td>
<td>检查file是否存在并是一个文件</td>
</tr>
<tr>
<td>-r file</td>
<td>检查file是否存在并可读</td>
</tr>
<tr>
<td>-s file</td>
<td>检查file是否存在并非空</td>
</tr>
<tr>
<td>-w file</td>
<td>检查file是否存在并可写</td>
</tr>
<tr>
<td>-x file</td>
<td>检查file是否存在并可执行</td>
</tr>
<tr>
<td>-O file</td>
<td>检查file是否存在并属当前用户所有</td>
</tr>
<tr>
<td>-G file</td>
<td>检查file是否存在并且默认组与当前用户相同</td>
</tr>
<tr>
<td>file1 -nt file2</td>
<td>检查file1是否比file2新</td>
</tr>
<tr>
<td>file1 -ot file2</td>
<td>检查file1是否比file2旧</td>
</tr>
</tbody></table>
<h3 id="复合条件测试"><a href="#复合条件测试" class="headerlink" title="复合条件测试"></a>复合条件测试</h3><p>if-then语句允许你使用布尔逻辑来组合测试。有两种布尔运算符可用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ condition1 ] &amp;&amp; [ condition2 ] </span><br><span class="line">[ condition1 ] || [ condition2 ]</span><br></pre></td></tr></table></figure>

<p>要让then部分的命令执行，两个条件都必须满足。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing compound comparisons </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$HOME</span> ] &amp;&amp; [ -w <span class="variable">$HOME</span>/testing ] </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;The file exists and you can write to it&quot;</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;I cannot write to the file&quot;</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="if-then-的高级特性"><a href="#if-then-的高级特性" class="headerlink" title="if-then 的高级特性"></a>if-then 的高级特性</h3><h4 id="用于数学表达式的双括号"><a href="#用于数学表达式的双括号" class="headerlink" title="用于数学表达式的双括号"></a>用于数学表达式的双括号</h4><p>test命令只能在比较中使用简单的算术操作。双括号命令提供了更多的数学符号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(( expression ))</span><br></pre></td></tr></table></figure>

<p>双括号命令符号</p>
<table>
<thead>
<tr>
<th>符 号</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>val++</td>
<td>后增</td>
</tr>
<tr>
<td>val–</td>
<td>后减</td>
</tr>
<tr>
<td>++val</td>
<td>先增</td>
</tr>
<tr>
<td>–val</td>
<td>先减</td>
</tr>
<tr>
<td>!</td>
<td>逻辑求反</td>
</tr>
<tr>
<td>~</td>
<td>位求反</td>
</tr>
<tr>
<td>**</td>
<td>幂运算</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左位移</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右位移</td>
</tr>
<tr>
<td>&amp;</td>
<td>位布尔和</td>
</tr>
<tr>
<td>|</td>
<td>位布尔或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑和</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using double parenthesis </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">val1=10 </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> (( <span class="variable">$val1</span> ** 2 &gt; 90 )) </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> (( val2 = <span class="variable">$val1</span> ** 2 )) </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;The square of <span class="variable">$val1</span> is <span class="variable">$val2</span>&quot;</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h4 id="用于高级字符串处理功能的双方括号"><a href="#用于高级字符串处理功能的双方括号" class="headerlink" title="用于高级字符串处理功能的双方括号"></a>用于高级字符串处理功能的双方括号</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ expression ]]</span><br></pre></td></tr></table></figure>

<p>它提供了test命令未提供的另一个特性——模式匹配（pattern matching）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using pattern matching </span></span><br><span class="line"><span class="comment"># 定义一个正则表达式来匹配字符串值。</span></span><br><span class="line"><span class="comment"># 双方括号命令$USER环境变量进行匹配，看它是否以字母r开头。</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$USER</span> == r* ]] </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$USER</span>&quot;</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Sorry, I do not know you&quot;</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="case-命令"><a href="#case-命令" class="headerlink" title="case 命令"></a>case 命令</h3><p>在一组可能的值中寻找特定值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> variable <span class="keyword">in</span> </span><br><span class="line">pattern1 | pattern2) commands1;; </span><br><span class="line">pattern3) commands2;; </span><br><span class="line">*) default commands;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>case命令会将指定的变量与不同模式进行比较。可以通过竖线操作符在一行中分隔出多个模式模式。星号会捕获所有与已知模式不匹配的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using the case command </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$USER</span> <span class="keyword">in</span> </span><br><span class="line">rich | barbara) </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Welcome, <span class="variable">$USER</span>&quot;</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Please enjoy your visit&quot;</span>;; </span><br><span class="line">testing) </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Special testing account&quot;</span>;; </span><br><span class="line">jessica) </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Do not forget to log off when you&#x27;re done&quot;</span>;; </span><br><span class="line">*) </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Sorry, you are not allowed here&quot;</span>;; </span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line">$ ./test26.sh</span><br><span class="line">Welcome, rich </span><br><span class="line">Please enjoy your visit</span><br></pre></td></tr></table></figure>

<h2 id="三、循环结构化指令"><a href="#三、循环结构化指令" class="headerlink" title="三、循环结构化指令"></a>三、循环结构化指令</h2><h3 id="for-命令"><a href="#for-命令" class="headerlink" title="for 命令"></a>for 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> list </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> commands </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>在list参数中，你需要提供迭代中要用到的一系列值。</p>
<h4 id="1-读取列表中的值"><a href="#1-读取列表中的值" class="headerlink" title="1.读取列表中的值"></a>1.读取列表中的值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># basic for command </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> Alabama Alaska Arizona Arkansas California Colorado </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> The next state is <span class="variable">$test</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>每次for命令遍历值列表，它都会将列表中的下个值赋给$test变量。$test变量可以像for命令语句中的其他脚本变量一样使用。在最后一次迭代后，<strong>$test变量的值会在shell脚本的剩余部分一直保持有效</strong>。它会一直保持最后一次迭代的值。</p>
<h4 id="2-读取列表中的复杂值"><a href="#2-读取列表中的复杂值" class="headerlink" title="2.读取列表中的复杂值"></a>2.读取列表中的复杂值</h4><p>有时会遇到难处理的数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># another example of how not to use the for command </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> I don<span class="string">&#x27;t know if this&#x27;</span>ll work </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;word:<span class="variable">$test</span>&quot;</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line">$ ./badtest1 </span><br><span class="line">word:I </span><br><span class="line">word:dont know <span class="keyword">if</span> thisll </span><br><span class="line">word:work</span><br></pre></td></tr></table></figure>

<p>有2个解决方法</p>
<ul>
<li>使用转义字符（反斜线）来将单引号转义；</li>
<li>使用双引号来定义用到单引号的值。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># another example of how not to use the for command </span></span><br><span class="line"><span class="comment">#在第一个有问题的地方添加了反斜线字符来转义don&#x27;t中的单引号。在第二个有问题的地方将this&#x27;ll用双引号圈起来。</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">test</span> <span class="keyword">in</span> I don\<span class="string">&#x27;t know if &quot;this&#x27;</span>ll<span class="string">&quot; work </span></span><br><span class="line"><span class="string">do </span></span><br><span class="line"><span class="string"> echo &quot;</span>word:<span class="variable">$test</span><span class="string">&quot; </span></span><br><span class="line"><span class="string">done </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ ./test2 </span></span><br><span class="line"><span class="string">word:I </span></span><br><span class="line"><span class="string">word:don&#x27;t </span></span><br><span class="line"><span class="string">word:know </span></span><br><span class="line"><span class="string">word:if </span></span><br><span class="line"><span class="string">word:this&#x27;ll </span></span><br><span class="line"><span class="string">word:work</span></span><br></pre></td></tr></table></figure>

<h4 id="3-从变量读取列表"><a href="#3-从变量读取列表" class="headerlink" title="3.从变量读取列表"></a>3.从变量读取列表</h4><p>将一系列值都集中存储在了一个变量中，然后需要遍历变量中的整个列表。也可以通过for命令完成这个任务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using a variable to hold the list </span></span><br><span class="line">list=<span class="string">&quot;Alabama Alaska Arizona Arkansas Colorado&quot;</span> </span><br><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> <span class="variable">$list</span> </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Have you ever visited <span class="variable">$state</span>?&quot;</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h4 id="4-从命令读取值"><a href="#4-从命令读取值" class="headerlink" title="4. 从命令读取值"></a>4. 从命令读取值</h4><p>可以用命令替换来执行任何能产生输出的命令，然后在for命令中使用该命令的输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># reading values from a file </span></span><br><span class="line">file=<span class="string">&quot;states&quot;</span> </span><br><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> $(cat <span class="variable">$file</span>) </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Visit beautiful <span class="variable">$state</span>&quot;</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>并没有解决数据中有空格的问题。如果你列出了一个名字中有空格的单词，for命令仍然会将每个单词当作单独的值。</p>
<h4 id="5-更改字段分隔符"><a href="#5-更改字段分隔符" class="headerlink" title="5.更改字段分隔符"></a>5.更改字段分隔符</h4><p>特殊的环境变量IFS，叫作<strong>内部字段分隔符（internal field separator）</strong>。</p>
<p>IFS环境变量定义了bash shell用作字段分隔符的一系列字符。默认情况下，bash shell会将下列字符当作字段分隔符：</p>
<ul>
<li>空格</li>
<li>制表符</li>
<li>换行符</li>
</ul>
<p>bash shell在数据中看到了这些字符中的任意一个，它就会假定这表明了列表中一个新数据字段的开始。</p>
<p>可以在shell脚本中临时更改IFS环境变量的值来限制被bash shell当作字段分隔符的字符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFS=$<span class="string">&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># reading values from a file </span></span><br><span class="line">file=<span class="string">&quot;states&quot;</span> </span><br><span class="line"><span class="comment">#告诉bash shell在数据值中忽略空格和制表符</span></span><br><span class="line">IFS=$<span class="string">&#x27;\n&#x27;</span> </span><br><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> $(cat <span class="variable">$file</span>) </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Visit beautiful <span class="variable">$state</span>&quot;</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在处理代码量较大的脚本时，可能在一个地方需要修改IFS的值，然后忽略这次修改，在脚本的其他地方继续沿用IFS的默认值。一个可参考的安全实践是在改变IFS之前保存原来的IFS值，之后再恢复它。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IFS.OLD=<span class="variable">$IFS</span> </span><br><span class="line">IFS=$<span class="string">&#x27;\n&#x27;</span> </span><br><span class="line">&lt;在代码中使用新的IFS值&gt; </span><br><span class="line">IFS=<span class="variable">$IFS</span>.OLD</span><br></pre></td></tr></table></figure>

<p>保证了在脚本的后续操作中使用的是IFS的默认值。</p>
</blockquote>
<p>要遍历一个文件中用冒号分隔的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFS=:</span><br></pre></td></tr></table></figure>

<p>果要指定多个IFS字符，只要将它们在赋值行串起来就行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFS=$<span class="string">&#x27;\n&#x27;</span>:;<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-用通配符读取目录"><a href="#6-用通配符读取目录" class="headerlink" title="6.用通配符读取目录"></a>6.用通配符读取目录</h4><p>可以用for命令来自动遍历目录中的文件。必须在文件名或路径名中使用通配符。它会强制shell使用<strong>文件扩展匹配</strong>。文件扩展匹配是生成匹配指定通配符的文件名或路径名的过程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># iterate through all the files in a directory </span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> /home/rich/<span class="built_in">test</span>/* </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$file</span>&quot;</span> ] </span><br><span class="line"> <span class="keyword">then</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span> is a directory&quot;</span> </span><br><span class="line"> <span class="keyword">elif</span> [ -f <span class="string">&quot;<span class="variable">$file</span>&quot;</span> ] </span><br><span class="line"> <span class="keyword">then</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span> is a file&quot;</span> </span><br><span class="line"> <span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>在Linux中，<strong>目录名和文件名中包含空格当然是合法的</strong>。要适应这种情况，应该将$file变量用双引号圈起来。</p>
<p>也可以在for命令中列出多个目录通配符，将目录查找和列表合并进同一个for语句。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># iterating through multiple directories</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> /home/rich/.b* /home/rich/badtest </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$file</span>&quot;</span> ] </span><br><span class="line"> <span class="keyword">then</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span> is a directory&quot;</span> </span><br><span class="line"> <span class="keyword">elif</span> [ -f <span class="string">&quot;<span class="variable">$file</span>&quot;</span> ] </span><br><span class="line"> <span class="keyword">then</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span> is a file&quot;</span> </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span> doesn&#x27;t exist&quot;</span> </span><br><span class="line"> <span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">$ ./test7 </span><br><span class="line">/home/rich/.backup.timestamp is a file </span><br><span class="line">/home/rich/.bash_history is a file </span><br><span class="line">/home/rich/.bash_logout is a file </span><br><span class="line">/home/rich/.bash_profile is a file </span><br><span class="line">/home/rich/.bashrc is a file </span><br><span class="line">/home/rich/badtest doesn<span class="string">&#x27;t exist</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在数据列表中放入任何东西。<strong>即使文件或目录不存在</strong>，for语句也会尝试处理列表中的内容。在处理文件或目录时，这可能会是个问题。你无法知道你正在尝试遍历的目录是否存在：在处理之前测试一下文件或目录总是好的</p>
</blockquote>
<h3 id="C语言风格的for"><a href="#C语言风格的for" class="headerlink" title="C语言风格的for"></a>C语言风格的for</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( variable assignment ; condition ; iteration process ))</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing the C-style for loop </span></span><br><span class="line"><span class="keyword">for</span> (( i=1; i &lt;= 10; i++ )) </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;The next number is <span class="variable">$i</span>&quot;</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>r循环通过定义好的变量（本例中是变量i）来迭代执行这些命令。</p>
<p>如何使用多个变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># multiple variables </span></span><br><span class="line"><span class="keyword">for</span> (( a=1, b=10; a &lt;= 10; a++, b-- )) </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span> - <span class="variable">$b</span>&quot;</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="while-命令"><a href="#while-命令" class="headerlink" title="while 命令"></a>while 命令</h3><p>是if-then语句和for循环的混杂体</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">test</span> <span class="built_in">command</span> </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> other commands </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>test <em>command</em>的退出状态码<strong>必须随着循环中运行的命令而改变</strong>。如果退出状态码不发生变化， while循环就将一直不停地进行下去</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># while command test </span></span><br><span class="line">var1=10</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$var1</span> -gt 0 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$var1</span> </span><br><span class="line"> var1=$[ <span class="variable">$var1</span> - 1 ] </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>多个测试命令</strong></p>
<p>while命令允许你在while语句行定义多个测试命令。只有<strong>最后一个测试命令的退出状态码</strong>会被用来决定什么时候结束循环。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing a multicommand while loop </span></span><br><span class="line">var1=10 </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">echo</span> <span class="variable">$var1</span> </span><br><span class="line"> [ <span class="variable">$var1</span> -ge 0 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;This is inside the loop&quot;</span> </span><br><span class="line"> var1=$[ <span class="variable">$var1</span> - 1 ] </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">$ ./test11 </span><br><span class="line">10 </span><br><span class="line">This is inside the loop </span><br><span class="line">9 </span><br><span class="line">This is inside the loop </span><br><span class="line">8</span><br><span class="line">This is inside the loop </span><br><span class="line">7 </span><br><span class="line">This is inside the loop </span><br><span class="line">6 </span><br><span class="line">This is inside the loop </span><br><span class="line">5 </span><br><span class="line">This is inside the loop </span><br><span class="line">4 </span><br><span class="line">This is inside the loop </span><br><span class="line">3 </span><br><span class="line">This is inside the loop </span><br><span class="line">2 </span><br><span class="line">This is inside the loop </span><br><span class="line">1 </span><br><span class="line">This is inside the loop </span><br><span class="line">0 </span><br><span class="line">This is inside the loop </span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>echo测试命令被执行并显示了var变量的值（现在小于0了）。直到shell执行test测试命令，whle循环才会停止。</p>
<h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><p>until命令要求你指定一个通常返回非零退出状态码的测试命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until <span class="built_in">test</span> commands </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> other commands </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>可以在until命令语句中放入多个测试命令。只有最后一个命令的退出状态码决定了bash shell是否执行已定义的other <em>commands</em>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using the until command </span></span><br><span class="line">var1=100 </span><br><span class="line">until [ <span class="variable">$var1</span> -eq 0 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$var1</span> </span><br><span class="line"> var1=$[ <span class="variable">$var1</span> - 25 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ./test12 </span><br><span class="line">100 </span><br><span class="line">75 </span><br><span class="line">50 </span><br><span class="line">25</span><br><span class="line"></span><br><span class="line"><span class="comment">#多个命令</span></span><br><span class="line"><span class="comment">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using the until command </span></span><br><span class="line">var1=100 </span><br><span class="line">until <span class="built_in">echo</span> <span class="variable">$var1</span> </span><br><span class="line"> [ <span class="variable">$var1</span> -eq 0 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> Inside the loop: <span class="variable">$var1</span> </span><br><span class="line"> var1=$[ <span class="variable">$var1</span> - 25 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ./test13 </span><br><span class="line">100 </span><br><span class="line">Inside the loop: 100 </span><br><span class="line">75 </span><br><span class="line">Inside the loop: 75 </span><br><span class="line">50 </span><br><span class="line">Inside the loop: 50 </span><br><span class="line">25 </span><br><span class="line">Inside the loop: 25 </span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>循环语句可以在循环内使用任意类型的命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># nesting for loops </span></span><br><span class="line"><span class="keyword">for</span> (( a = 1; a &lt;= 3; a++ )) </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Starting loop <span class="variable">$a</span>:&quot;</span> </span><br><span class="line"> <span class="keyword">for</span> (( b = 1; b &lt;= 3; b++ )) </span><br><span class="line"> <span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot; Inside loop: <span class="variable">$b</span>&quot;</span> </span><br><span class="line"> <span class="keyword">done</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line">$ ./test14 </span><br><span class="line">Starting loop 1: </span><br><span class="line"> Inside loop: 1 </span><br><span class="line"> Inside loop: 2 </span><br><span class="line"> Inside loop: 3 </span><br><span class="line">Starting loop 2: </span><br><span class="line"> Inside loop: 1 </span><br><span class="line"> Inside loop: 2 </span><br><span class="line"> Inside loop: 3 </span><br><span class="line">Starting loop 3: </span><br><span class="line"> Inside loop: 1 </span><br><span class="line"> Inside loop: 2 </span><br><span class="line"> Inside loop: 3</span><br></pre></td></tr></table></figure>

<h3 id="循环处理文件数据"><a href="#循环处理文件数据" class="headerlink" title="循环处理文件数据"></a>循环处理文件数据</h3><ul>
<li><p>使用嵌套循环</p>
</li>
<li><p>修改IFS环境变量</p>
</li>
</ul>
<p>通过修改IFS环境变量，就能强制for命令将文件中的每行都当成单独的一个条目来处理，即便数据中有空格也是如此。一旦从文件中提取出了单独的行，可能需要再次利用循环来提取行中的数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># changing the IFS value </span></span><br><span class="line">IFS.OLD=<span class="variable">$IFS</span> </span><br><span class="line">IFS=$<span class="string">&#x27;\n&#x27;</span> </span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> $(cat /etc/passwd) </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Values in <span class="variable">$entry</span> –&quot;</span> </span><br><span class="line"> IFS=: </span><br><span class="line"> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="variable">$entry</span> </span><br><span class="line"> <span class="keyword">do</span> </span><br><span class="line"> 	<span class="built_in">echo</span> <span class="string">&quot; <span class="variable">$value</span>&quot;</span> </span><br><span class="line"> <span class="keyword">done</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>使用了两个不同的IFS值来解析数据。第一个IFS值解析出/etc/passwd文件中的单独的行。内部for循环接着将IFS的值修改为冒号，允许你从/etc/passwd的行中解析出单独的值。</p>
<h3 id="控制循环"><a href="#控制循环" class="headerlink" title="控制循环"></a>控制循环</h3><h4 id="break-命令"><a href="#break-命令" class="headerlink" title="break 命令"></a>break 命令</h4><p>break命令来退出任意类型的循环</p>
<ol>
<li><p>跳出单个循环</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># breaking out of a for loop </span></span><br><span class="line"><span class="keyword">for</span> var1 <span class="keyword">in</span> 1 2 3 4 5 6 7 8 9 10 </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="keyword">if</span> [ <span class="variable">$var1</span> -eq 5 ] </span><br><span class="line"> <span class="keyword">then</span> </span><br><span class="line"> 	<span class="built_in">break</span> </span><br><span class="line"> <span class="keyword">fi</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Iteration number: <span class="variable">$var1</span>&quot;</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The for loop is completed&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>跳出内部循环</p>
<p>处理多个循环时，break命令会自动终止你所在的最内层的循环。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># breaking out of an inner loop </span></span><br><span class="line"><span class="keyword">for</span> (( a = 1; a &lt; 4; a++ )) </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Outer loop: <span class="variable">$a</span>&quot;</span> </span><br><span class="line"> <span class="keyword">for</span> (( b = 1; b &lt; 100; b++ )) </span><br><span class="line"> <span class="keyword">do</span> </span><br><span class="line"> 	<span class="keyword">if</span> [ <span class="variable">$b</span> -eq 5 ] </span><br><span class="line"> 	<span class="keyword">then</span> </span><br><span class="line"> 		<span class="built_in">break</span> </span><br><span class="line"> 	<span class="keyword">fi</span></span><br><span class="line"> 	<span class="built_in">echo</span> <span class="string">&quot; Inner loop: <span class="variable">$b</span>&quot;</span> </span><br><span class="line"> <span class="keyword">done</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>跳出外部循环</p>
<p>break命令接受单个命令行参数值<code>break n</code>其中<em>n</em>指定了要跳出的循环层级。默认情况下，<em>n</em>为1，表明跳出的是当前的循环。如果你将<em>n</em>设为2，break命令就会停止下一级的外部循环。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># breaking out of an outer loop </span></span><br><span class="line"><span class="keyword">for</span> (( a = 1; a &lt; 4; a++ )) </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Outer loop: <span class="variable">$a</span>&quot;</span> </span><br><span class="line"> <span class="keyword">for</span> (( b = 1; b &lt; 100; b++ )) </span><br><span class="line"> <span class="keyword">do</span> </span><br><span class="line">     <span class="keyword">if</span> [ <span class="variable">$b</span> -gt 4 ] </span><br><span class="line">     <span class="keyword">then</span> </span><br><span class="line">     	<span class="built_in">break</span> 2 </span><br><span class="line">     <span class="keyword">fi</span> </span><br><span class="line">	 <span class="built_in">echo</span> <span class="string">&quot; Inner loop: <span class="variable">$b</span>&quot;</span> </span><br><span class="line"> <span class="keyword">done</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="continue-命令"><a href="#continue-命令" class="headerlink" title="continue 命令"></a>continue 命令</h4><p>提前中止某次循环中的命令，但并不会完全终止整个循环。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using the continue command </span></span><br><span class="line"><span class="keyword">for</span> (( var1 = 1; var1 &lt; 15; var1++ )) </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">     <span class="keyword">if</span> [ <span class="variable">$var1</span> -gt 5 ] &amp;&amp; [ <span class="variable">$var1</span> -lt 10 ] </span><br><span class="line">     <span class="keyword">then</span> </span><br><span class="line">     	<span class="built_in">continue</span> </span><br><span class="line">     <span class="keyword">fi</span> </span><br><span class="line">     <span class="built_in">echo</span> <span class="string">&quot;Iteration number: <span class="variable">$var1</span>&quot;</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>continue命令也允许通过命令行参数指定要继续执行哪一级循环：<code>continue n</code></p>
<h3 id="处理循环的输出输入"><a href="#处理循环的输出输入" class="headerlink" title="处理循环的输出输入"></a>处理循环的输出输入</h3><p>可以对循环的输出使用管道或进行重定向。这可以通过在done命令之后添加一个处理命令来实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> /home/rich/* </span><br><span class="line"> <span class="keyword">do</span> </span><br><span class="line"> <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$file</span>&quot;</span> ] </span><br><span class="line"> <span class="keyword">then</span> </span><br><span class="line"> 	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span> is a directory&quot;</span> </span><br><span class="line"> <span class="keyword">elif</span> </span><br><span class="line"> 	<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$file</span> is a file&quot;</span> </span><br><span class="line"> <span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">done</span> &gt; output.txt</span><br></pre></td></tr></table></figure>

<p>shell会将for命令的结果重定向到文件output.txt中，而不是显示在屏幕上。</p>
<p>读取文件的另外一种方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> -r line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span> &lt; filename.txt</span><br></pre></td></tr></table></figure>

<h2 id="四、处理用户的输入"><a href="#四、处理用户的输入" class="headerlink" title="四、处理用户的输入"></a>四、处理用户的输入</h2><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>向shell脚本传递数据的最基本方法是使用命令行参数。命令行参数允许在运行脚本时向命令行添加数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./addem 10 30</span><br></pre></td></tr></table></figure>

<h4 id="1-读取参数"><a href="#1-读取参数" class="headerlink" title="1.读取参数"></a>1.读取参数</h4><p>bash shell会将一些称为<strong>位置参数（positional parameter）</strong>的特殊变量分配给输入到命令行中的所有参数。这也包括shell所执行的脚本名称。位置参数变量是标准的数字：$0是程序名，$1是第一个参数，$2是第二个参数，依次类推，直到第九个参数$9。</p>
<p>每个参数都是用空格分隔的，所以shell会将空格当成两个值的分隔符。要在参数值中包含空格，<strong>必须要用引号</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./test3.sh <span class="string">&#x27;Rich Blum&#x27;</span></span><br><span class="line">Hello Rich Blum, glad to meet you.</span><br></pre></td></tr></table></figure>

<p>将文本字符串作为参数传递时，<strong>引号并非数据的一部分</strong>。它们只是表明数据的起止位置。</p>
<p>如果脚本需要的命令行参数<strong>不止9个</strong>，你仍然可以处理，但是需要稍微修改一下变量名。在第9个变量之后，你必须在变量数字周围加上<strong>花括号</strong>，比如${10}。</p>
<h4 id="2-读取脚本名"><a href="#2-读取脚本名" class="headerlink" title="2.读取脚本名"></a>2.读取脚本名</h4><p>用<code>$0</code>参数获取shell在命令行启动的<strong>脚本名</strong>。</p>
<p>如果使用另一个命令来运行shell脚本，命令会和脚本名混在一起，出现在$0参数中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./test5.sh</span><br><span class="line">The zero parameter is <span class="built_in">set</span> to: ./test5.sh</span><br></pre></td></tr></table></figure>

<p>得把脚本的运行路径给剥离掉。另外，还要删除与脚本名混杂在一起的命令。basename命令会返回不包含路径的脚本名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Using basename with the $0 parameter </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">name=$(basename <span class="variable">$0</span>) </span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="built_in">echo</span> The script name is: <span class="variable">$name</span></span><br></pre></td></tr></table></figure>

<h4 id="3-测试参数"><a href="#3-测试参数" class="headerlink" title="3.测试参数"></a>3.测试参数</h4><p>当脚本认为参数变量中会有数据而实际上并没有时，脚本很有可能会产生错误消息。这种写脚本的方法并不可取。在使用参数前一定要检查其中是否存在数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing parameters before use </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> 	<span class="built_in">echo</span> Hello <span class="variable">$1</span>, glad to meet you. </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"> 	<span class="built_in">echo</span> <span class="string">&quot;Sorry, you did not identify yourself. &quot;</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="特殊参数变量"><a href="#特殊参数变量" class="headerlink" title="特殊参数变量"></a>特殊参数变量</h3><h4 id="1-参数统计"><a href="#1-参数统计" class="headerlink" title="1.参数统计"></a>1.参数统计</h4><p>特殊变量$#含有脚本运行时携带的命令行参数的个数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ne 2 ] </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">     <span class="built_in">echo</span> </span><br><span class="line">     <span class="built_in">echo</span> Usage: test9.sh a b </span><br><span class="line">     <span class="built_in">echo</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">     total=$[ <span class="variable">$1</span> + <span class="variable">$2</span> ] </span><br><span class="line">     <span class="built_in">echo</span></span><br><span class="line">      	<span class="built_in">echo</span> The total is <span class="variable">$total</span> </span><br><span class="line">     <span class="built_in">echo</span> </span><br><span class="line"><span class="keyword">fi</span> </span><br></pre></td></tr></table></figure>

<p>if-then语句用<code>-ne</code>测试命令行参数数量。如果参数数量不对，会显示一条错误消息告知脚本的正确用法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing grabbing last parameter </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#$&#123;$#&#125;就代表了最后一个命令行参数变量?</span></span><br><span class="line"><span class="built_in">echo</span> The last parameter was <span class="variable">$&#123;$#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#必须将美元符换成感叹号。</span></span><br><span class="line"><span class="comment">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Grabbing the last parameter </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">params=<span class="variable">$#</span> </span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="built_in">echo</span> The last parameter is <span class="variable">$params</span> </span><br><span class="line"><span class="built_in">echo</span> The last parameter is <span class="variable">$&#123;!#&#125;</span></span><br><span class="line"></span><br><span class="line">$ bash test10.sh 1 2 3 4 5</span><br><span class="line">The last parameter is 5 </span><br><span class="line">The last parameter is 5</span><br><span class="line"></span><br><span class="line">$ bash test10.sh</span><br><span class="line">The last parameter is 0 </span><br><span class="line">The last parameter is test10.sh</span><br></pre></td></tr></table></figure>

<h4 id="2-抓取所有的数据"><a href="#2-抓取所有的数据" class="headerlink" title="2.抓取所有的数据"></a>2.抓取所有的数据</h4><p>有时候需要抓取命令行上提供的所有参数。这时候不需要先用$#变量来判断命令行上有多少参数，然后再进行遍历，使用一组其他的特殊变量来解决这个问题。</p>
<p><code>$*</code>和<code>$@</code>变量可以用来轻松访问所有的参数。</p>
<ul>
<li><code>$*</code>变量会将命令行上提供的所有参数当作一个单词保存。基本上$*变量会将这些参数视为一个整体，而不是多个个体。</li>
<li><code>$@</code>变量会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。就能够遍历所有的参数值，得到每个参数。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># testing $* and $@ </span></span><br><span class="line"><span class="comment"># $*</span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line">count=1 </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;$*&quot;</span> </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> 	<span class="built_in">echo</span> <span class="string">&quot;\$* Parameter #<span class="variable">$count</span> = <span class="variable">$param</span>&quot;</span> </span><br><span class="line"> 	count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># $@ </span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line">count=1 </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span> </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> 	<span class="built_in">echo</span> <span class="string">&quot;\$@ Parameter #<span class="variable">$count</span> = <span class="variable">$param</span>&quot;</span> </span><br><span class="line"> 	count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">$ ./test12.sh rich barbara katie jessica</span><br><span class="line">$* Parameter <span class="comment">#1 = rich barbara katie jessica </span></span><br><span class="line"><span class="variable">$@</span> Parameter <span class="comment">#1 = rich </span></span><br><span class="line"><span class="variable">$@</span> Parameter <span class="comment">#2 = barbara </span></span><br><span class="line"><span class="variable">$@</span> Parameter <span class="comment">#3 = katie </span></span><br><span class="line"><span class="variable">$@</span> Parameter <span class="comment">#4 = jessica</span></span><br></pre></td></tr></table></figure>

<h3 id="移动变量"><a href="#移动变量" class="headerlink" title="移动变量"></a>移动变量</h3><p>bash shell的shift命令能够用来操作命令行参数。shift命令会根据它们的相对位置来移动命令行参数。</p>
<p>在使用shift命令时，默认情况下它会将每个参数变量<strong>向左移动一个位置</strong>。所以，变量$3的值会移到$2中，变量$2的值会移到$1中，而变量$1的值则会被删除</p>
<p>是在你不知道到底有多少参数时。你可以只操作第一个参数，移动参数，然后继续操作第一个参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat test13.sh</span><br><span class="line"><span class="comment">#!/bin/bash </span></span><br><span class="line"><span class="comment"># demonstrating the shift command </span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line">count=1 </span><br><span class="line"><span class="comment">#测试第一个参数值的长度</span></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">     <span class="built_in">echo</span> <span class="string">&quot;Parameter #<span class="variable">$count</span> = <span class="variable">$1</span>&quot;</span> </span><br><span class="line">     count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line">     <span class="comment">#shift命令会将所有参数的位置移动一个位置。</span></span><br><span class="line">     <span class="built_in">shift</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">./test13.sh rich barbara katie jessica</span><br><span class="line">Parameter <span class="comment">#1 = rich </span></span><br><span class="line">Parameter <span class="comment">#2 = barbara </span></span><br><span class="line">Parameter <span class="comment">#3 = katie </span></span><br><span class="line">Parameter <span class="comment">#4 = jessica</span></span><br></pre></td></tr></table></figure>

<p>也可以一次性移动多个位置，只需要给shift命令提供一个参数，指明要移动的位置数就行了。<code>shift 2</code></p>
<h3 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h3><p>同时提供了参数和选项的bash命令。<strong>选项</strong>是跟在单破折线后面的单个字母，它能改变命令的行为。</p>
<h4 id="1-查找选项"><a href="#1-查找选项" class="headerlink" title="1.查找选项"></a>1.查找选项</h4><p>紧跟在脚本名之后，就跟命令行参数一样。</p>
<ol>
<li><p>处理简单选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用<span class="keyword">case</span>语句来判断某个参数是否为选项。</span><br><span class="line"><span class="comment">#!/bin/bash </span></span><br><span class="line"><span class="comment"># extracting command line options as parameters </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span> </span><br><span class="line"> -a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;; </span><br><span class="line"> -b) <span class="built_in">echo</span> <span class="string">&quot;Found the -b option&quot;</span> ;; </span><br><span class="line"> -c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;; </span><br><span class="line"> *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not an option&quot;</span> ;; </span><br><span class="line"> <span class="keyword">esac</span> </span><br><span class="line"> <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>case语句在命令行参数中找到一个选项，就处理一个选项。如果命令行上还提供了其他参数，你可以在case语句的通用情况处理部分中处理。</p>
</li>
<li><p>分离参数和选项</p>
<p>同时使用选项和参数的情况。用特殊字符来将二者分开,这个特殊字符是双破折线（<code>--</code>）。shell会用双破折线来表明选项列表结束。在双破折线之后，脚本就可以放心地将剩下的命令行参数当作参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># extracting options and parameters </span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span> </span><br><span class="line">      -a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;;       </span><br><span class="line">      -b) <span class="built_in">echo</span> <span class="string">&quot;Found the -b option&quot;</span>;; </span><br><span class="line">      -c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;;      </span><br><span class="line">      --) <span class="built_in">shift</span> </span><br><span class="line">          <span class="built_in">break</span> ;; </span><br><span class="line">       *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not an option&quot;</span>;; </span><br><span class="line">   <span class="keyword">esac</span> </span><br><span class="line">   <span class="built_in">shift</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="variable">$@</span> </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Parameter #<span class="variable">$count</span>: <span class="variable">$param</span>&quot;</span> </span><br><span class="line">   count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br></pre></td></tr></table></figure>

<p>在遇到双破折线时，脚本用break命令来跳出while循环。由于过早地跳出了循环，我们需要再加一条shift命令来将双破折线移出参数变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ./test16.sh -c -a -b -- test1 test2 test3</span><br><span class="line">Found the -c option </span><br><span class="line">Found the -a option </span><br><span class="line">Found the -b option </span><br><span class="line">Parameter <span class="comment">#1: test1</span></span><br><span class="line">Parameter <span class="comment">#2: test2 </span></span><br><span class="line">Parameter <span class="comment">#3: test3</span></span><br></pre></td></tr></table></figure>

<p>当脚本遇到双破折线时，它会停止处理选项，并将剩下的参数都当作命令行参数。</p>
</li>
<li><p>处理带值的选项</p>
<p>有些选项会带上一个额外的参数值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># extracting command line options and values </span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span> </span><br><span class="line">      -a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span>;; </span><br><span class="line">      -b) param=<span class="string">&quot;<span class="variable">$2</span>&quot;</span> </span><br><span class="line">          <span class="built_in">echo</span> <span class="string">&quot;Found the -b option, with parameter value <span class="variable">$param</span>&quot;</span>           	<span class="built_in">shift</span> ;; </span><br><span class="line">      -c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span>;; </span><br><span class="line">      --) <span class="built_in">shift</span> </span><br><span class="line">          <span class="built_in">break</span> ;; </span><br><span class="line">       *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not an option&quot;</span>;; </span><br><span class="line">   <span class="keyword">esac</span> </span><br><span class="line">   <span class="built_in">shift</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span> </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Parameter #<span class="variable">$count</span>: <span class="variable">$param</span>&quot;</span> </span><br><span class="line">   count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line">./test17.sh -a -b test1 -d</span><br><span class="line"></span><br><span class="line">Found the -a option </span><br><span class="line">Found the -b option, with parameter value test1 </span><br><span class="line">-d is not an option </span><br></pre></td></tr></table></figure>

<p>case语句定义了三个它要处理的选项。-b选项还需要一个额外的参数值。由于要处理的参数是$1，额外的参数值就应该位于$2（因为所有的参数在处理完之后都会被移出）。<strong>只要将参数值从$2变量中提取出来就可以了</strong>。当然，因为这个选项占用了两个参数位，所以你还需要使用shift命令多移动一个位置。</p>
<p>如果你想将多个选项放进一个参数中时，它就不能工作了。</p>
</li>
</ol>
<h4 id="2-使用-getopt-命令"><a href="#2-使用-getopt-命令" class="headerlink" title="2.使用 getopt 命令"></a>2.使用 getopt 命令</h4><p>它能够识别命令行参数，从而在脚本中解析它们时更方便。</p>
<ol>
<li><p>命令的格式</p>
<p>接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getopt optstring parameters</span><br></pre></td></tr></table></figure>

<p><code>optstring</code>它定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值。在optstring中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个<strong>冒号</strong>。getopt命令会基于你定义的optstring解析提供的参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getopt ab:<span class="built_in">cd</span> -a -b test1 -<span class="built_in">cd</span> test2 test3</span><br><span class="line">-a -b test1 -c -d -- test2 test3</span><br></pre></td></tr></table></figure>

<p>optstring定义了四个有效选项字母：a、b、c和d。冒号（:）被放在了字母b后面，因为b选项需要一个参数值。</p>
<p>如果指定了一个不在optstring中的选项，默认情况下，getopt命令会产生一条错误消息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getopt ab:<span class="built_in">cd</span> -a -b test1 -cde test2 test3</span><br><span class="line">getopt: invalid option -- e </span><br><span class="line"> -a -b test1 -c -d -- test2 test3</span><br></pre></td></tr></table></figure>

<p>如果想忽略这条错误消息，可以在命令后加-q选项。</p>
</li>
<li><p>在脚本中使用getopt</p>
<p>用getopt命令生成的格式化后的版本来替换已有的命令行选项和参数。用set命令.</p>
<p>set命令的选项之一是双破折线（–），它会<strong>将命令行参数替换成set命令的命令行值。</strong>该方法会将原始脚本的命令行参数传给getopt命令，之后再将getopt命令的输出传给set命令，<strong>用getopt格式化后的命令行参数来替换原始的命令行参数</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> -- $(getopt -q ab:<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Extract command line options &amp; values with getopt </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">set</span> -- $(getopt -q ab:<span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>) </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="keyword">while</span> [ -n <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span> </span><br><span class="line">     -a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;; </span><br><span class="line">     -b) param=<span class="string">&quot;<span class="variable">$2</span>&quot;</span> </span><br><span class="line">     	<span class="built_in">echo</span> <span class="string">&quot;Found the -b option, with parameter value <span class="variable">$param</span>&quot;</span> </span><br><span class="line">     	<span class="built_in">shift</span> ;; </span><br><span class="line">     -c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;; </span><br><span class="line">     --) <span class="built_in">shift</span> </span><br><span class="line">     	<span class="built_in">break</span> ;; </span><br><span class="line">     *) <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not an option&quot;</span>;; </span><br><span class="line">     <span class="keyword">esac</span></span><br><span class="line">     <span class="built_in">shift</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># 处理参数</span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span> </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> 	<span class="built_in">echo</span> <span class="string">&quot;Parameter #<span class="variable">$count</span>: <span class="variable">$param</span>&quot;</span> </span><br><span class="line"> 	count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br></pre></td></tr></table></figure>

<p>在getopt命令中仍然隐藏着一个小问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./test18.sh -a -b test1 -<span class="built_in">cd</span> <span class="string">&quot;test2 test3&quot;</span> test4</span><br><span class="line">Found the -a option </span><br><span class="line">Found the -b option, with parameter value <span class="string">&#x27;test1&#x27;</span> </span><br><span class="line">Found the -c option </span><br><span class="line">Parameter <span class="comment">#1: &#x27;test2 </span></span><br><span class="line">Parameter <span class="comment">#2: test3&#x27; </span></span><br><span class="line">Parameter <span class="comment">#3: &#x27;test4&#x27;</span></span><br></pre></td></tr></table></figure>

<p>getopt命令并<strong>不擅长处理带空格和引号的参数值</strong>。它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数。</p>
</li>
<li><p>使用更高级的 <code>getopts</code></p>
<p>内建于bash shell。与<code>getopt</code>不同，前者将命令行上选项和参数处理后只生成一个输出,而<code>getopts</code>命令能够和已有的shell参数变量配合默契。</p>
<p>每次调用它时，它一次只<strong>处理命令行上检测到的一个参数</strong>。处理完所有的参数后，它会退出并返回一个大于0的退出状态码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getopts</span> optstring variable</span><br></pre></td></tr></table></figure>

<p>类似于getopt的处理，要去掉错误消息的话，可以在optstring之前加一个<strong>冒号</strong>。<code>getopts</code>命令会用到两个环境变量。如果选项需要跟一个参数值，<strong>OPTARG</strong>环境变量就会保存这个值。<strong>OPTIND</strong>环境变量保存了参数列表中getopts正在处理的参数位置。这样就能在处理完选项之后继续处理其他命令行参数了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># simple demonstration of the getopts command </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :ab:c opt </span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span> </span><br><span class="line">         a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;; </span><br><span class="line">         b) <span class="built_in">echo</span> <span class="string">&quot;Found the -b option, with value <span class="variable">$OPTARG</span>&quot;</span>;; </span><br><span class="line">         c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;; </span><br><span class="line">         *) <span class="built_in">echo</span> <span class="string">&quot;Unknown option: <span class="variable">$opt</span>&quot;</span>;; </span><br><span class="line">     <span class="keyword">esac</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>每次迭代中存储它们的变量名（opt）。getopts命令解析命令行选项时会移除开头的单破折线，所以在case定义中不用单破折线。</p>
<p>可以在参数值中包含空格。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test19.sh -b <span class="string">&quot;test1 test2&quot;</span> -a</span><br></pre></td></tr></table></figure>

<p>将选项字母和参数值放在一起使用，而不用加空格。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test19.sh -abtest1</span><br></pre></td></tr></table></figure>

<p>能够将命令行上找到的所有未定义的选项统一输出成问号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ./test19.sh -d</span><br><span class="line">Unknown option: ? </span><br></pre></td></tr></table></figure>

<p>optstring中未定义的选项字母会以问号形式发送给代码。</p>
<p>getopts命令知道何时停止处理选项，并将参数留给你处理。在getopts处理每个选项时，它会将OPTIND环境变量值增一。在getopts完成处理时，你可以使用shift命令和OPTIND值来移动参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Processing options &amp; parameters with getopts </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :ab:<span class="built_in">cd</span> opt </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$opt</span>&quot;</span> <span class="keyword">in</span> </span><br><span class="line"> a) <span class="built_in">echo</span> <span class="string">&quot;Found the -a option&quot;</span> ;; </span><br><span class="line"> b) <span class="built_in">echo</span> <span class="string">&quot;Found the -b option, with value <span class="variable">$OPTARG</span>&quot;</span> ;; </span><br><span class="line"> c) <span class="built_in">echo</span> <span class="string">&quot;Found the -c option&quot;</span> ;; </span><br><span class="line"> d) <span class="built_in">echo</span> <span class="string">&quot;Found the -d option&quot;</span> ;; </span><br><span class="line"> *) <span class="built_in">echo</span> <span class="string">&quot;Unknown option: <span class="variable">$opt</span>&quot;</span> ;; </span><br><span class="line"> <span class="keyword">esac</span> </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">shift</span> $[ <span class="variable">$OPTIND</span> - 1 ] </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span> </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Parameter <span class="variable">$count</span>: <span class="variable">$param</span>&quot;</span> </span><br><span class="line"> count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">$ ./test20.sh -a -b test1 -d test2 test3 test4</span><br><span class="line">Found the -a option </span><br><span class="line">Found the -b option, with value test1 </span><br><span class="line">Found the -d option </span><br><span class="line">Parameter 1: test2 </span><br><span class="line">Parameter 2: test3 </span><br><span class="line">Parameter 3: test4</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="将选项标准化"><a href="#将选项标准化" class="headerlink" title="将选项标准化"></a>将选项标准化</h3><p>有些字母选项在Linux世界里已经拥有了某种程度的标准含义。如果能在shell脚本中支持这些选项，脚本看起来能更友好一些。常用的Linux命令选项:</p>
<table>
<thead>
<tr>
<th>选 项</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>显示所有对象</td>
</tr>
<tr>
<td>-c</td>
<td>生成一个计数</td>
</tr>
<tr>
<td>-d</td>
<td>指定一个目录</td>
</tr>
<tr>
<td>-e</td>
<td>扩展一个对象</td>
</tr>
<tr>
<td>-f</td>
<td>指定读入数据的文件</td>
</tr>
<tr>
<td>-h</td>
<td>显示命令的帮助信息</td>
</tr>
<tr>
<td>-i</td>
<td>忽略文本大小写</td>
</tr>
<tr>
<td>-l</td>
<td>产生输出的长格式版本</td>
</tr>
<tr>
<td>-n</td>
<td>使用非交互模式（批处理）</td>
</tr>
<tr>
<td>-o</td>
<td>将所有输出重定向到的指定的输出文件</td>
</tr>
<tr>
<td>-q</td>
<td>以安静模式运行</td>
</tr>
<tr>
<td>-r</td>
<td>递归地处理目录和文件</td>
</tr>
<tr>
<td>-s</td>
<td>以安静模式运行</td>
</tr>
<tr>
<td>-v</td>
<td>生成详细输出</td>
</tr>
<tr>
<td>-x</td>
<td>排除某个对象</td>
</tr>
<tr>
<td>-y</td>
<td>对所有问题回答yes</td>
</tr>
</tbody></table>
<h3 id="获得用户输入"><a href="#获得用户输入" class="headerlink" title="获得用户输入"></a>获得用户输入</h3><h4 id="1-基本的读取"><a href="#1-基本的读取" class="headerlink" title="1. 基本的读取"></a>1. 基本的读取</h4><p>read命令从标准输入（键盘）或另一个文件描述符中接受输入。在收到输入后，read命令会将数据放进一个变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment">#testing the read command </span></span><br><span class="line"><span class="comment"># echo命令使用了-n选项。该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行。</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Enter your name: &quot;</span> </span><br><span class="line"><span class="built_in">read</span> name </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$name</span>, welcome to my program. &quot;</span></span><br><span class="line"></span><br><span class="line"> ./test21.sh</span><br><span class="line">Enter your name: Rich Blum</span><br><span class="line">Hello Rich Blum, welcome to my program.</span><br></pre></td></tr></table></figure>

<p>read命令包含了<code>-p</code>选项，允许你直接在read命令行指定提示符。</p>
<p>read命令会将提示符后输入的所有数据分配给<strong>单个变量</strong>，要么你就指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就<strong>全部分配给最后一个变量</strong>。</p>
<p>在read命令行中不指定变量，read命令会将它收到的任何数据都放进特殊环境变量REPLY中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Testing the REPLY Environment variable </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter your name: &quot;</span> </span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="built_in">echo</span> Hello <span class="variable">$REPLY</span>, welcome to my program.</span><br></pre></td></tr></table></figure>

<h4 id="2-超时"><a href="#2-超时" class="headerlink" title="2.超时"></a>2.超时</h4><p>用<code>-t</code>选项来指定一个计时器。-t选项指定了read命令等待输入的秒数。当计时器过期后，read命令会返回一个非零退出状态码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># timing the data entry </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">read</span> -t 5 -p <span class="string">&quot;Please enter your name: &quot;</span> name </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Hello <span class="variable">$name</span>, welcome to my script&quot;</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"> <span class="built_in">echo</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Sorry, too slow! &quot;</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>让read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># getting just one character of input </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">read</span> -n1 -p <span class="string">&quot;Do you want to continue [Y/N]? &quot;</span> answer </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$answer</span> <span class="keyword">in</span> </span><br><span class="line">Y | y) <span class="built_in">echo</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;fine, continue on…&quot;</span>;; </span><br><span class="line">N | n) <span class="built_in">echo</span> </span><br><span class="line"> <span class="built_in">echo</span> OK, goodbye </span><br><span class="line"> <span class="built_in">exit</span>;; </span><br><span class="line"><span class="keyword">esac</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is the end of the script&quot;</span></span><br></pre></td></tr></table></figure>

<p>将<code>-n</code>选项和值1一起使用，告诉read命令在接受单个字符后退出。</p>
<h4 id="3-隐藏方式读取"><a href="#3-隐藏方式读取" class="headerlink" title="3.隐藏方式读取"></a>3.隐藏方式读取</h4><p>-s选项可以避免在read命令中输入的数据出现在显示器上上（实际上，数据会被显示，只是read命令会将文本颜色<strong>设成跟背景色一样</strong>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># hiding input data from the monitor </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">read</span> -s -p <span class="string">&quot;Enter your password: &quot;</span> pass</span><br><span class="line"><span class="built_in">echo</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Is your password really <span class="variable">$pass</span>? &quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-从文件中读取"><a href="#4-从文件中读取" class="headerlink" title="4.从文件中读取"></a>4.从文件中读取</h4><p>read命令来读取Linux系统上文件里保存的数据。每次调用read命令，它都会从文件中读取一行文本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># reading data from a file </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line">cat <span class="built_in">test</span> | <span class="keyword">while</span> <span class="built_in">read</span> line </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Line <span class="variable">$count</span>: <span class="variable">$line</span>&quot;</span> </span><br><span class="line"> count=$[ <span class="variable">$count</span> + 1] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Finished processing the file&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="五、呈现数据"><a href="#五、呈现数据" class="headerlink" title="五、呈现数据"></a>五、呈现数据</h2><h3 id="理解输入和输出"><a href="#理解输入和输出" class="headerlink" title="理解输入和输出"></a>理解输入和输出</h3><p>脚本输出的方法：</p>
<ul>
<li>在显示器屏幕上显示输出</li>
<li>将输出重定向到文件中</li>
</ul>
<h4 id="1-标准文件描述符"><a href="#1-标准文件描述符" class="headerlink" title="1.标准文件描述符"></a>1.标准文件描述符</h4><p>Linux系统将每个对象当作文件处理。这包括输入和输出进程。Linux用<strong>文件描述符（filedescriptor）</strong>来标识每个文件对象。文件描述符是一个<strong>非负整数</strong>，可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符。每个进程一次最多可以有九个文件描述符。bash shell保留了前三个文件描述符（0、1和2）</p>
<table>
<thead>
<tr>
<th>文件描述符</th>
<th>缩 写</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>STDIN</td>
<td>标准输入</td>
</tr>
<tr>
<td>1</td>
<td>STDOUT</td>
<td>标准输出</td>
</tr>
<tr>
<td>2</td>
<td>STDERR</td>
<td>标准错误</td>
</tr>
</tbody></table>
<ol>
<li><p><strong>STDIN</strong>： 代表shell的标准输入。对终端界面来说，标准输入是键盘。shell从STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。在使用输入重定向符号（&lt;）时，Linux会用重定向指定的文件来替换标准输入文件描述符。它会读取文件并提取数据，就如同它是键盘上键入的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat </span><br><span class="line">this is a <span class="built_in">test</span> </span><br><span class="line">this is a <span class="built_in">test</span> </span><br><span class="line">this is a second <span class="built_in">test</span>. </span><br><span class="line">this is a second <span class="built_in">test</span>.</span><br><span class="line"></span><br><span class="line">$ cat &lt; testfile </span><br><span class="line">This is the first line. </span><br><span class="line">This is the second line. </span><br><span class="line">This is the third line.</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>STDOUT</strong> :符代表shell的标准输出。在终端界面上，标准输出就是终端显示器。shell的所有输出（包括shell中运行的程序和脚本）会被定向到标准输出中，也就是显示器。<code>&gt;</code>覆盖，<code>&gt;&gt;</code>追加。</p>
<p>如果你对脚本使用了标准输出重定向：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls -al badfile &gt; test3 </span><br><span class="line">ls: cannot access badfile: No such file or directory</span><br></pre></td></tr></table></figure>

<p>shell创建了输出重定向文件，但错误消息却显示在了显示器屏幕上。注意，在显示test3文件的内容时并没有任何错误。test3文件创建成功了，只是里面是空的。</p>
<p>shell对于<strong>错误消息的处理是跟普通输出分开</strong>的。如果你创建了在后台模式下运行的shell脚本，通常你必须依赖发送到日志文件的输出消息。用这种方法的话，如果出现了错误信息，这些信息是不会出现在日志文件中的。你需要换种方法来处理。</p>
</li>
<li><p><strong>STDERR</strong> 代表shell的标准错误输出。shell或shell中运行的程序和脚本出错时生成的错误消息都会发送到这个位置。默认情况下，STDERR文件描述符会和STDOUT文件描述符指向同样的地方。也就是说，默认情况下，错误消息也会输出到显示器输出中。</p>
<p>但是，<strong>STDERR并不会随着STDOUT的重定向而发生改变</strong>。使用脚本时，也希望将错误消息保存到日志文件中的时候。</p>
</li>
</ol>
<h4 id="2-重定向错误"><a href="#2-重定向错误" class="headerlink" title="2.重定向错误"></a>2.重定向错误</h4><ol>
<li><p>只重定向错误：STDERR文件描述符被设成2。可以选择只重定向错误消息，将该文件描述符值放在重定向符号前。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al badfile 2&gt; test4</span><br></pre></td></tr></table></figure>
</li>
<li><p>重定向错误和数据:用<strong>两个重定向符号</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al <span class="built_in">test</span> test2 test3 badtest 2&gt; test6 1&gt; test7</span><br></pre></td></tr></table></figure>

<p>也可以将STDERR和STDOUT的输出重定向到同一个输出文件。bash shell提供了特殊的重定向符号<code>&amp;&gt;</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al <span class="built_in">test</span> test2 test3 badtest &amp;&gt; test7</span><br></pre></td></tr></table></figure>

<p>相较于标准输出，bash  shell<strong>自动赋予了错误消息更高的优先级</strong>。这样能够集中浏览错误信息了。</p>
</li>
</ol>
<h3 id="在脚本中重定向输出"><a href="#在脚本中重定向输出" class="headerlink" title="在脚本中重定向输出"></a>在脚本中重定向输出</h3><p>脚本中用STDOUT和STDERR文件描述符以在多个位置生成输出，只要简单地重定向相应的文件描述符就行了。</p>
<h4 id="1-临时重定向"><a href="#1-临时重定向" class="headerlink" title="1.临时重定向"></a>1.临时重定向</h4><p>可以将单独的一行输出重定向到STDERR。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is an error message&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure>

<p>默认情况下，Linux会将STDERR导向STDOUT。但是，如果在运行脚本时重定向了STDERR，脚本中所有导向STDERR的文本都会被重定向。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat test8 </span><br><span class="line"><span class="comment">#!/bin/bash </span></span><br><span class="line"><span class="comment"># testing STDERR messages </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is an error&quot;</span> &gt;&amp;2 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is normal output&quot;</span></span><br><span class="line"></span><br><span class="line">$ ./test8 </span><br><span class="line">This is an error </span><br><span class="line">This is normal output</span><br><span class="line"></span><br><span class="line">$ ./test8 2&gt; test9 </span><br><span class="line">This is normal output </span><br><span class="line">$ cat test9 </span><br><span class="line">This is an error</span><br></pre></td></tr></table></figure>

<h4 id="2-永久重定向"><a href="#2-永久重定向" class="headerlink" title="2.永久重定向"></a>2.永久重定向</h4><p>可以用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># redirecting all output to a file </span></span><br><span class="line"><span class="built_in">exec</span> 1&gt;testout </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a test of redirecting all output&quot;</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;from a script to another file.&quot;</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;without having to redirect every individual line&quot;</span></span><br></pre></td></tr></table></figure>

<p>exec命令会启动一个新shell并将STDOUT文件描述符重定向到文件。脚本中发给STDOUT的所有输出会被重定向到文件。</p>
<h3 id="在脚本中重定向输入"><a href="#在脚本中重定向输入" class="headerlink" title="在脚本中重定向输入"></a>在脚本中重定向输入</h3><p>可以使用与脚本中重定向STDOUT和STDERR相同的方法来将STDIN从键盘重定向到其他位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 0&lt; testfile</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># redirecting file input </span></span><br><span class="line"><span class="comment">#重定向只要在脚本需要输入时就会作用。</span></span><br><span class="line"><span class="built_in">exec</span> 0&lt; testfile </span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Line #<span class="variable">$count</span>: <span class="variable">$line</span>&quot;</span> </span><br><span class="line"> count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h4 id="创建自己的重定向"><a href="#创建自己的重定向" class="headerlink" title="创建自己的重定向"></a>创建自己的重定向</h4><h4 id="1-输出文件描述符"><a href="#1-输出文件描述符" class="headerlink" title="1.输出文件描述符"></a>1.输出文件描述符</h4><p>可以用exec命令来给输出分配文件描述符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using an alternative file descriptor </span></span><br><span class="line"><span class="built_in">exec</span> 3&gt;test13out </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This should display on the monitor&quot;</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;and this should be stored in the file&quot;</span> &gt;&amp;3 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Then this should be back on the monitor&quot;</span></span><br><span class="line"></span><br><span class="line">$ ./test13 </span><br><span class="line">This should display on the monitor </span><br><span class="line">Then this should be back on the monitor </span><br><span class="line">$ cat test13out </span><br><span class="line">and this should be stored <span class="keyword">in</span> the file</span><br></pre></td></tr></table></figure>

<p>也可以不用创建新文件，而是使用exec命令来将输出<strong>追加</strong>到现有文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 3&gt;&gt;test13out </span><br></pre></td></tr></table></figure>

<h4 id="2-重定向文件描述符"><a href="#2-重定向文件描述符" class="headerlink" title="2.重定向文件描述符"></a>2.重定向文件描述符</h4><p>可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用该文件描述符重定向回STDOUT。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># storing STDOUT, then coming back to it </span></span><br><span class="line"><span class="comment">#将文件描述符3重定向到文件描述符1的当前位置,送给文件描述符3的输出都将出现在显示器上。</span></span><br><span class="line"><span class="built_in">exec</span> 3&gt;&amp;1 </span><br><span class="line"><span class="comment">#将STDOUT重定向到文件，shell现在会将发送给STDOUT的输出直接重定向到输出文件中。</span></span><br><span class="line"><span class="comment">#文件描述符3仍然指向STDOUT原来的位置，也就是显示器。</span></span><br><span class="line"><span class="built_in">exec</span> 1&gt;test14out </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This should store in the output file&quot;</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;along with this line.&quot;</span></span><br><span class="line"><span class="comment">#脚本将STDOUT重定向到文件描述符3的当前位置（现在仍然是显示器）。</span></span><br><span class="line"><span class="built_in">exec</span> 1&gt;&amp;3 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Now things should be back to normal&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-输入文件描述符"><a href="#3-输入文件描述符" class="headerlink" title="3.输入文件描述符"></a>3.输入文件描述符</h4><p>在重定向到文件之前，先<strong>将STDIN文件描述符保存到另外一个文件描述符，然后在读取完文件之后再将STDIN恢复到它原来的位置</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redirecting input file descriptors </span></span><br><span class="line"><span class="comment">#文件描述符6用来保存STDIN的位置。</span></span><br><span class="line"><span class="built_in">exec</span> 6&lt;&amp;0 </span><br><span class="line"><span class="built_in">exec</span> 0&lt; testfile </span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Line #<span class="variable">$count</span>: <span class="variable">$line</span>&quot;</span> </span><br><span class="line"> count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment">#将STDIN重定向到文件描述符6</span></span><br><span class="line"><span class="built_in">exec</span> 0&lt;&amp;6 </span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Are you done now? &quot;</span> answer </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$answer</span> <span class="keyword">in</span> </span><br><span class="line">Y|y) <span class="built_in">echo</span> <span class="string">&quot;Goodbye&quot;</span>;; </span><br><span class="line">N|n) <span class="built_in">echo</span> <span class="string">&quot;Sorry, this is the end.&quot;</span>;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h3 id="列出打开的文件描述符"><a href="#列出打开的文件描述符" class="headerlink" title="列出打开的文件描述符"></a>列出打开的文件描述符</h3><p><code>lsof</code>命令会列出整个Linux系统打开的所有文件描述符。</p>
<h3 id="阻止命令输出"><a href="#阻止命令输出" class="headerlink" title="阻止命令输出"></a>阻止命令输出</h3><p>将STDERR重定向到一个叫作null文件的特殊文件。</p>
<p>在Linux系统上null文件的标准位置是<code>/dev/null</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al &gt; /dev/null</span><br></pre></td></tr></table></figure>

<h3 id="创建临时文件"><a href="#创建临时文件" class="headerlink" title="创建临时文件"></a>创建临时文件</h3><p>Linux使用/tmp目录来存放不需要永久保留的文件</p>
<p><code>mktemp</code>命令可以在/tmp目录中创建一个唯一的临时文件。</p>
<h4 id="1-创建本地临时文件"><a href="#1-创建本地临时文件" class="headerlink" title="1.创建本地临时文件"></a>1.创建本地临时文件</h4><p>mktemp会在本地目录中创建一个文件。要用mktemp命令在本地目录中创建一个临时文件，你只要指定一个文件名模板就行了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mktemp testing.XXXXXX </span><br><span class="line">$ ls -al testing* </span><br><span class="line">-rw------- 1 rich rich 0 Oct 17 21:30 testing.UfIi13</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempfile=$(mktemp test19.XXXXXX)</span><br></pre></td></tr></table></figure>

<h4 id="2-在-tmp-目录创建临时文件"><a href="#2-在-tmp-目录创建临时文件" class="headerlink" title="2.在/tmp 目录创建临时文件"></a>2.在/tmp 目录创建临时文件</h4><p>-t选项会强制mktemp命令来在系统的临时目录来创建该文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> mktemp -t test.XXXXXX </span><br><span class="line">/tmp/test.xG3374</span><br></pre></td></tr></table></figure>

<h4 id="3-创建临时目录"><a href="#3-创建临时目录" class="headerlink" title="3.创建临时目录"></a>3.创建临时目录</h4><p>-d选项告诉mktemp命令来创建一个临时目录而不是临时文件。</p>
<h3 id="记录消息"><a href="#记录消息" class="headerlink" title="记录消息"></a>记录消息</h3><p>将输出同时发送到显示器和日志文件</p>
<p>tee命令相当于管道的一个T型接头。它将从STDIN过来的数据同时发往两处。一处是</p>
<p>STDOUT，另一处是tee命令行所指定的文件名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee filename</span><br></pre></td></tr></table></figure>

<p>tee会<strong>重定向来自STDIN的数据</strong>，你可以用它配合管道命令来重定向命令输出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date | tee testfile </span><br><span class="line">Sun Oct 19 18:56:21 EDT 2014 </span><br><span class="line">$ cat testfile </span><br><span class="line">Sun Oct 19 18:56:21 EDT 2014</span><br></pre></td></tr></table></figure>

<p>默认情况下，tee命令会在每次使用时覆盖输出文件内容。<code>-a</code>将数据追加到文件中</p>
<h2 id="六、控制脚本"><a href="#六、控制脚本" class="headerlink" title="六、控制脚本"></a>六、控制脚本</h2><h3 id="处理信号"><a href="#处理信号" class="headerlink" title="处理信号"></a>处理信号</h3><table>
<thead>
<tr>
<th>信 号</th>
<th>值</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>挂起进程</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>终止进程</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>停止进程</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>无条件终止进程</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>尽可能终止进程</td>
</tr>
<tr>
<td>17</td>
<td>SIGSTOP</td>
<td>无条件停止进程，但不是终止进程</td>
</tr>
<tr>
<td>18</td>
<td>SIGTSTP</td>
<td>停止或暂停进程，但不终止进程</td>
</tr>
<tr>
<td>19</td>
<td>SIGCONT</td>
<td>继续运行停止的进程</td>
</tr>
</tbody></table>
<p>bash shell会<strong>忽略</strong>收到的任何SIGQUIT (3)和SIGTERM (15)信号。bash shell会处理收到的SIGHUP (1)和SIGINT (2)信号。</p>
<p>如果bash shell收到了<code>SIGHUP</code>信号，比如当你要离开一个交互式shell，它就会退出。退出之前，它会将<code>SIGHUP</code>信号传给所有由该shell所启动的进程。通过<code>SIGINT</code>信号，可以中断shell。Linux内核会停止为shell分配CPU处理时间。这</p>
<h4 id="1-生成信号"><a href="#1-生成信号" class="headerlink" title="1.生成信号"></a>1.生成信号</h4><ol>
<li><p>中断进程：<code>Ctrl+C</code>组合键会生成<code>SIGINT</code>信号</p>
</li>
<li><p>暂停进程：你可以在进程运行期间暂停进程，而无需终止它。<code>Ctrl+Z</code>组合键会生成一个<code>SIGTSTP</code>信号。停止（stopping）进程，跟终止（terminating）进程不同：停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。</p>
<p>如果你的shell会话中有一个已停止的作业，在退出shell时，bash会提醒你。可以用<code>ps</code>命令来查看已停止的作业。</p>
</li>
</ol>
<h4 id="2-捕获信号"><a href="#2-捕获信号" class="headerlink" title="2.捕获信号"></a>2.捕获信号</h4><p><code>trap</code>命令允许指定shell脚本要监看并从shell中拦截的Linux信号。如果脚本收到了<code>trap</code>命令中列出的信号，该信号不再由shell处理，而是交由本地处理。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">trap</span> commands signals</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Testing signal trapping </span></span><br><span class="line"><span class="comment"># 用到的trap命令会在每次检测到SIGINT信号时显示一行简单的文本消息。</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27; Sorry! I have trapped Ctrl-C&#x27;&quot;</span> SIGINT </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> This is a <span class="built_in">test</span> script </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 10 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Loop #<span class="variable">$count</span>&quot;</span> </span><br><span class="line"> sleep 1 </span><br><span class="line"> count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is the end of the test script&quot;</span></span><br><span class="line"></span><br><span class="line">./test1.sh</span><br><span class="line">This is a <span class="built_in">test</span> script </span><br><span class="line">Loop <span class="comment">#1 </span></span><br><span class="line">Loop <span class="comment">#2 </span></span><br><span class="line">Loop <span class="comment">#3 </span></span><br><span class="line">Loop <span class="comment">#4 </span></span><br><span class="line">Loop <span class="comment">#5 </span></span><br><span class="line">^C Sorry! I have trapped Ctrl-C </span><br><span class="line">Loop <span class="comment">#6 </span></span><br><span class="line">Loop <span class="comment">#7 </span></span><br><span class="line">Loop <span class="comment">#8 </span></span><br><span class="line">^C Sorry! I have trapped Ctrl-C </span><br><span class="line">Loop <span class="comment">#9 </span></span><br><span class="line">Loop <span class="comment">#10</span></span><br></pre></td></tr></table></figure>

<h4 id="3-捕获脚本退出"><a href="#3-捕获脚本退出" class="headerlink" title="3.捕获脚本退出"></a>3.捕获脚本退出</h4><p>也可以在shell脚本退出时进行捕获。要捕获shell脚本的退出，只要在trap命令后加上EXIT信号就行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Trapping the script exit </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo Goodbye...&quot;</span> EXIT </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Loop #<span class="variable">$count</span>&quot;</span> </span><br><span class="line"> sleep 1 </span><br><span class="line"> count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">Loop <span class="comment">#1 </span></span><br><span class="line">Loop <span class="comment">#2 </span></span><br><span class="line">Loop <span class="comment">#3 </span></span><br><span class="line">Loop <span class="comment">#4 </span></span><br><span class="line">Loop <span class="comment">#5 </span></span><br><span class="line">Goodbye...</span><br></pre></td></tr></table></figure>

<h4 id="4-修改或移除捕获"><a href="#4-修改或移除捕获" class="headerlink" title="4.修改或移除捕获"></a>4.修改或移除捕获</h4><p>使用带有新选项的trap命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Modifying a set trap </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27; Sorry... Ctrl-C is trapped.&#x27;&quot;</span> SIGINT </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Loop #<span class="variable">$count</span>&quot;</span> </span><br><span class="line"> sleep 1 </span><br><span class="line"> count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27; I modified the trap!&#x27;&quot;</span> SIGINT </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Second Loop #<span class="variable">$count</span>&quot;</span> </span><br><span class="line"> sleep 1 </span><br><span class="line"> count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line">don</span><br><span class="line"></span><br><span class="line">Loop <span class="comment">#1 </span></span><br><span class="line">Loop <span class="comment">#2 </span></span><br><span class="line">Loop <span class="comment">#3 </span></span><br><span class="line">^C Sorry... Ctrl-C is trapped. </span><br><span class="line">Loop <span class="comment">#4 </span></span><br><span class="line">Loop <span class="comment">#5 </span></span><br><span class="line">Second Loop <span class="comment">#1 </span></span><br><span class="line">Second Loop <span class="comment">#2 </span></span><br><span class="line">^C I modified the <span class="built_in">trap</span>! </span><br><span class="line">Second Loop <span class="comment">#3 </span></span><br><span class="line">Second Loop <span class="comment">#4 </span></span><br><span class="line">Second Loop <span class="comment">#5</span></span><br></pre></td></tr></table></figure>

<p>删除已设置好的捕获。在trap命令与希望恢复默认行为的信号列表之间加上两个破折号就行了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Removing a set trap </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;echo &#x27; Sorry... Ctrl-C is trapped.&#x27;&quot;</span> SIGINT </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Loop #<span class="variable">$count</span>&quot;</span> </span><br><span class="line"> sleep 1 </span><br><span class="line"> count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># Remove the trap </span></span><br><span class="line"><span class="built_in">trap</span> -- SIGINT </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I just removed the trap&quot;</span> </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">count=1 </span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$count</span> -le 5 ] </span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Second Loop #<span class="variable">$count</span>&quot;</span> </span><br><span class="line"> sleep 1 </span><br><span class="line"> count=$[ <span class="variable">$count</span> + 1 ] </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="以后台模式运行脚本"><a href="#以后台模式运行脚本" class="headerlink" title="以后台模式运行脚本"></a>以后台模式运行脚本</h3><h4 id="1-后台运行脚本"><a href="#1-后台运行脚本" class="headerlink" title="1.后台运行脚本"></a>1.后台运行脚本</h4><p>加个<code>&amp;</code>符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test4.sh &amp;</span><br></pre></td></tr></table></figure>

<p>当&amp;符放到命令后时，它会将命令和bash shell分离开来，将命令作为系统中的一个独立的后台进程运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] 3231</span><br></pre></td></tr></table></figure>

<p>方括号中的数字是shell分配给后台进程的作业号。下一个数是Linux系统分配给进程的进程ID（PID）</p>
<p>当后台进程结束时，它会在终端上显示出一条消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1] Done ./test4.sh</span><br></pre></td></tr></table></figure>

<p>当后台进程运行时，它<strong>仍然会使用终端显示器来显示STDOUT和STDERR消息。</strong></p>
<h4 id="2-运行多个后台作业"><a href="#2-运行多个后台作业" class="headerlink" title="2.运行多个后台作业"></a>2.运行多个后台作业</h4><p>ps命令，可以看到所有脚本处于运行状态。</p>
<p>每一个后台进程都和终端会话（pts/0）终端联系在一起。<strong>如果终端会话退出，那么后台进程也会随之退出。</strong></p>
<h3 id="在非控制台下运行脚本"><a href="#在非控制台下运行脚本" class="headerlink" title="在非控制台下运行脚本"></a>在非控制台下运行脚本</h3><p>想在终端会话中启动shell脚本，然后让脚本一直以后台模式运行到结束，即使退出了终端会话。这可以用<code>nohup</code>命令来实现。</p>
<p><code>nohup</code>命令运行了另外一个命令来阻断所有发送给该进程的<code>SIGHUP</code>信号。这会在退出终端会话时阻止进程退出。</p>
<p>在于，当你使用<code>nohup</code>命令时，如果关闭该会话，脚本会<strong>忽略</strong>终端会话发过来的SIGHUP信号。</p>
<p>由于nohup命令会解除终端与进程的关联，进程也就<strong>不再同STDOUT和STDERR联系在一起。</strong>为了保存该命令产生的输出，nohup命令会自动将STDOUT和STDERR的消息重定向到一个名为<code>nohup.out</code>的文件中。</p>
<h3 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h3><p>在作业停止后，Linux系统会让你选择是终止还是重启。你可以用kill命令终止该进程。要重启停止的进程需要向其发送一个<code>SIGCONT</code>信号。</p>
<h4 id="1-查看作业"><a href="#1-查看作业" class="headerlink" title="1.查看作业"></a>1.查看作业</h4><p><code>jobs</code>命令允许查看shell当前正在处理的作业。</p>
<p>脚本用$$变量来显示Linux系统分配给该脚本的PID</p>
<table>
<thead>
<tr>
<th>参 数</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td>列出进程的PID以及作业号</td>
</tr>
<tr>
<td>-n</td>
<td>只列出上次shell发出的通知后改变了状态的作业</td>
</tr>
<tr>
<td>-p</td>
<td>只列出作业的PID</td>
</tr>
<tr>
<td>-r</td>
<td>只列出运行中的作业</td>
</tr>
<tr>
<td>-s</td>
<td>只列出已停止的作业</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">jobs</span> -l</span><br><span class="line">[1]+ 1897 Stopped ./test10.sh </span><br><span class="line">[2]- 1917 Running ./test10.sh &gt; test10.out &amp;</span><br></pre></td></tr></table></figure>

<p>带<strong>加号</strong>的作业会被当做<strong>默认作业</strong>。在使用作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象。</p>
<p>当前的默认作业完成处理后，带减号的作业成为下一个默认作业。<strong>任何时候都只有一个带加号的作业和一个带减号的作业</strong>，不管shell中有多少个正在运行的作业。</p>
<h4 id="2-重启停止的作业"><a href="#2-重启停止的作业" class="headerlink" title="2.重启停止的作业"></a>2.重启停止的作业</h4><p>用bg命令加上作业号</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">bg</span> 2</span><br><span class="line">[2]+ ./test12.sh &amp;</span><br></pre></td></tr></table></figure>

<p>要以前台模式重启作业，可用带有作业号的fg命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">fg</span> 2</span><br><span class="line">./test12.sh</span><br></pre></td></tr></table></figure>

<h3 id="调整谦让度"><a href="#调整谦让度" class="headerlink" title="调整谦让度"></a>调整谦让度</h3><p>内核负责将CPU时间分配给系统上运行的每个进程。<strong>调度优先级（scheduling priority）</strong>是内核分配给进程的CPU时间（相对于其他进程）</p>
<blockquote>
<p>最低值-20是最高优先级，而最高值19是最低优先级，这太容易记混了。</p>
</blockquote>
<h4 id="1-nice-命令"><a href="#1-nice-命令" class="headerlink" title="1.nice 命令"></a>1.nice 命令</h4><p><code>nice</code>命令允许你设置命令启动时的调度优先级。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> nice -n 10 ./test4.sh &gt; test4.out &amp;</span><br><span class="line">[1] 4973</span><br></pre></td></tr></table></figure>

<p>nice命令<strong>阻止普通系统用户来提高命令的优先级</strong>。注意，指定的作业的确运行了，但是试图使用nice命令提高其优先级的操作却失败了。</p>
<p>nice命令的-n选项并不是必须的，只需要在破折号后面跟上优先级就行了。</p>
<h4 id="2-renice命令"><a href="#2-renice命令" class="headerlink" title="2.renice命令"></a>2.renice命令</h4><p>想改变系统上已运行命令的优先级。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./test11.sh &amp;</span><br><span class="line">[1] 5055 </span><br><span class="line">$ </span><br><span class="line">$ ps -p 5055 -o pid,ppid,ni,cmd</span><br><span class="line"> PID PPID NI CMD </span><br><span class="line"> 5055 4721 0 /bin/bash ./test11.sh</span><br><span class="line"> </span><br><span class="line">$ renice -n 10 -p 5055</span><br><span class="line">5055: old priority 0, new priority 10 </span><br><span class="line"></span><br><span class="line">$ ps -p 5055 -o pid,ppid,ni,cmd</span><br><span class="line"> PID PPID NI CMD </span><br><span class="line"> 5055 4721 10 /bin/bash ./test11.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>只能对<strong>属于你的进程</strong>执行renice； </li>
<li>只能通过renice<strong>降低进程的优先级</strong>；</li>
<li><strong>root</strong>用户可以通过renice来<strong>任意调整进程</strong>的优先级。</li>
</ul>
<h3 id="定时运行作业"><a href="#定时运行作业" class="headerlink" title="定时运行作业"></a>定时运行作业</h3><h4 id="at-命令来计划执行作业"><a href="#at-命令来计划执行作业" class="headerlink" title="at 命令来计划执行作业"></a><strong>at</strong> 命令来计划执行作业</h4><p>at命令会将作业提交到队列中，指定shell何时运行该作业。at的守护进程<code>atd</code>会以<strong>后台模式</strong>运行，检查作业队列来运行作业。</p>
<p><code>atd</code>守护进程会检查系统上的一个特殊目录（通常位于<code>/var/spool/at</code>）来获取用at命令提交的作业。默认情况下，<code>atd</code>守护进程会<strong>每60秒</strong>检查一下这个目录。有</p>
<ol>
<li><p>at命令的格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at [-f filename] time</span><br></pre></td></tr></table></figure>

<p>at命令会将STDIN的输入放到队列中。你可以用-f参数来指定用于<strong>读取命令</strong>（脚本文件）的文件名。</p>
<p>time格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">标准的小时和分钟格式，比如10:15。 </span><br><span class="line">AM/PM指示符，比如10:15 PM。 </span><br><span class="line">特定可命名时间，比如now、noon、midnight或者teatime（4 PM）。</span><br><span class="line">标准日期格式，比如MMDDYY、MM/DD/YY或DD.MM.YY。 </span><br><span class="line">文本日期，比如Jul 4或Dec 25，加不加年份均可。</span><br></pre></td></tr></table></figure>

<p>用-q参数指定不同的队列字母。</p>
</li>
<li><p>获取作业的输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//now指示at命令立刻执行该脚本。</span><br><span class="line">at -f test13.sh now</span><br></pre></td></tr></table></figure>

<p>使用at命令时，最好在脚本中对STDOUT和STDERR进行重定向</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># Test using at command </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This script ran at <span class="subst">$(date +%B%d,%T)</span>&quot;</span> &gt; test13b.out </span><br><span class="line"><span class="built_in">echo</span> &gt;&gt; test13b.out </span><br><span class="line">sleep 5 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is the script&#x27;s end...&quot;</span> &gt;&gt; test13b.out</span><br></pre></td></tr></table></figure>

<p><code>-M</code>选项来屏蔽作业产生的输出信息。</p>
</li>
<li><p>列出等待的作业<code>atq</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ at -M -f test13b.sh teatime</span><br><span class="line">job 17 at 2015-07-14 16:00 </span><br><span class="line">$ </span><br><span class="line">$ at -M -f test13b.sh tomorrow</span><br><span class="line">job 18 at 2015-07-15 13:03 </span><br><span class="line">$ </span><br><span class="line">$ at -M -f test13b.sh 13:30</span><br><span class="line">job 19 at 2015-07-14 13:30 </span><br><span class="line">$ </span><br><span class="line">$ at -M -f test13b.sh now</span><br><span class="line">job 20 at 2015-07-14 13:03 </span><br><span class="line">$ </span><br><span class="line">$ atq</span><br><span class="line">20 2015-07-14 13:03 = Christine </span><br><span class="line">18 2015-07-15 13:03 a Christine </span><br><span class="line">17 2015-07-14 16:00 a Christine </span><br><span class="line">19 2015-07-14 13:30 a Christineatq</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除作业<code>atrm</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atrm 18</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-安排需要定期执行的脚本"><a href="#2-安排需要定期执行的脚本" class="headerlink" title="2.安排需要定期执行的脚本"></a>2.安排需要定期执行的脚本</h4><p>统使用cron程序来安排要定期执行的作业。。cron程序会在后台运行并检查一个特殊的表（被称作cron时间表）</p>
<ol>
<li><p>cron时间表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">min hour dayofmonth month dayofweek <span class="built_in">command</span></span><br><span class="line"><span class="comment">#允许用特定值、取值范围（比如1~5）或者是通配符（星号）来指定条目。</span></span><br><span class="line"><span class="comment">#每天的10:15运行一个命令</span></span><br><span class="line">15 10 * * * <span class="built_in">command</span></span><br><span class="line"><span class="comment">#在每周一4:15 PM运行的命令</span></span><br><span class="line">15 16 * * 1 <span class="built_in">command</span></span><br><span class="line"><span class="comment">#在每个月的第一天中午12点执行命令。</span></span><br><span class="line">00 12 1 * * <span class="built_in">command</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在每个月的最后一天执行的命令</span></span><br><span class="line"><span class="comment">#if-then语句来检查明天的日期是不是01：</span></span><br><span class="line">00 12 * * * <span class="keyword">if</span> [`date +%d -d tomorrow` = 01 ] ; <span class="keyword">then</span> ; <span class="built_in">command</span></span><br></pre></td></tr></table></figure>

<p>命令列表必须指定要运行的命令或脚本的全路径名。</p>
</li>
<li><p>构建cron时间表 <code>crontab</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#要列出已有的cron时间表</span></span><br><span class="line">crontab -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览cron目录</p>
<p>对<strong>精确的执行时间要求</strong>不高，用预配置的cron脚本目录会更方便。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hourly、daily、monthly和weekly</span><br><span class="line"></span><br><span class="line">/etc/cron.*ly</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-使用新-shell-启动脚本"><a href="#3-使用新-shell-启动脚本" class="headerlink" title="3.使用新 shell 启动脚本"></a>3.使用新 shell 启动脚本</h4><p>希望为shell会话设置某些shell功能，或者只是为了确保已经设置了某个文件。</p>
<p>bash shell都会运行<code>.bashrc</code>文件。可以这样来验证：在主目录下的.bashrc文件中加入一条简单的echo语句，然后启动一个新shell。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bashrc </span></span><br><span class="line"><span class="comment"># Source global definitions </span></span><br><span class="line"><span class="keyword">if</span> [ -f /etc/bashrc ]; <span class="keyword">then</span> </span><br><span class="line"> . /etc/bashrc </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"><span class="comment"># User specific aliases and functions </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I&#x27;m in a new shell!&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>.bashrc</code>文件会运行两次：一次是当你登入bash shell时，另一次是当你启动一个bash shell时。</p>
<p>一个脚本在两个时刻都得以运行，可以把这个脚本放进该文件中。</p>
<h2 id="七、函数"><a href="#七、函数" class="headerlink" title="七、函数"></a>七、函数</h2><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><h4 id="1-创建函数"><a href="#1-创建函数" class="headerlink" title="1.创建函数"></a>1.创建函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> name &#123; </span><br><span class="line"> commands </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">name</span></span>() &#123; </span><br><span class="line">commands </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用函数"><a href="#2-使用函数" class="headerlink" title="2.使用函数"></a>2.使用函数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using a function in a script </span></span><br><span class="line"><span class="keyword">function</span> func1 &#123; </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;This is an example of a function&quot;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is the end of the loop&quot;</span> </span><br><span class="line">func1 </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Now this is the end of the script&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在函数<strong>被定义前使用函数</strong>，你会收到一条错误消息。</p>
</li>
<li><p>重定义了函数，新定义会覆盖原来函数的定义.</p>
</li>
</ul>
<h4 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3.返回值"></a>3.返回值</h4><p>bash shell会把函数当作一个小型脚本</p>
<ol>
<li><p><strong>默认退出状态码</strong> 0</p>
<p>用标准变量<code>$?</code>来确定函数的退出状态码。</p>
</li>
<li><p>使用 <strong>return</strong> 命令</p>
<p>return命令允许指定一个<strong>整数值</strong>来定义函数的退出状态码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using the return command in a function </span></span><br><span class="line"><span class="comment">#会将$value变量中用户输入的值翻倍</span></span><br><span class="line"><span class="keyword">function</span> dbl &#123; </span><br><span class="line"> <span class="built_in">read</span> -p <span class="string">&quot;Enter a value: &quot;</span> value </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;doubling the value&quot;</span> </span><br><span class="line"> <span class="built_in">return</span> $[ <span class="variable">$value</span> * 2 ] </span><br><span class="line">&#125; </span><br><span class="line">dbl </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The new value is $?&quot;</span></span><br></pre></td></tr></table></figure>

<p>退出状态码必须是<strong>0~255</strong>。任何大于256的值都会产生一个错误值。</p>
</li>
<li><p>使用函数输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这个命令会将dbl函数的输出赋给$result变量。</span></span><br><span class="line">result=<span class="string">&#x27;dbl&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using the echo to return a value </span></span><br><span class="line"><span class="keyword">function</span> dbl &#123; </span><br><span class="line"> <span class="built_in">read</span> -p <span class="string">&quot;Enter a value: &quot;</span> value </span><br><span class="line"> <span class="built_in">echo</span> $[ <span class="variable">$value</span> * 2 ] </span><br><span class="line">&#125; </span><br><span class="line">result=$(dbl)</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="在函数中使用变量"><a href="#在函数中使用变量" class="headerlink" title="在函数中使用变量"></a>在函数中使用变量</h3><h4 id="向函数传递参数"><a href="#向函数传递参数" class="headerlink" title="向函数传递参数"></a>向函数传递参数</h4><p>函数名会在$0变量中定义，函数命令行上的任何参数都会通过$1、$2等定义。</p>
<p><code>$#</code>来判断传给函数的参数数目。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># trying to access script parameters inside a function  这个脚本运行出错</span></span><br><span class="line"><span class="keyword">function</span> badfunc1 &#123; </span><br><span class="line"> <span class="comment">#函数也使用了$1和$2变量，但它们和脚本主体中的$1和$2变量并不相同。</span></span><br><span class="line"> <span class="built_in">echo</span> $[ <span class="variable">$1</span> * <span class="variable">$2</span> ] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 2 ] </span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"> value=$(badfunc1) </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;The result is <span class="variable">$value</span>&quot;</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;Usage: badtest1 a b&quot;</span> </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h4 id="在函数中处理变量"><a href="#在函数中处理变量" class="headerlink" title="在函数中处理变量"></a>在函数中处理变量</h4><ol>
<li><p>全局变量</p>
<p>如果你在脚本的<strong>主体部分</strong>定义了一个全局变量，那么可以在<strong>函数内读</strong>取它的值。在<strong>函数内</strong>定义了一个全局变量，可以在脚本的<strong>主体部分</strong>读取它的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using a global variable to pass a value </span></span><br><span class="line"><span class="keyword">function</span> dbl &#123;</span><br><span class="line"> value=$[ <span class="variable">$value</span> * 2 ] </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter a value: &quot;</span> value </span><br><span class="line">dbl </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The new value is: <span class="variable">$value</span>&quot;</span> </span><br><span class="line">$ </span><br><span class="line">$ ./test8 </span><br><span class="line">Enter a value: 450 </span><br><span class="line">The new value is: 900</span><br><span class="line"><span class="comment">#当dbl函数被调用时，该变量及其值在函数中都依然有效。如果变量在函数内被赋予了新值，那么在脚本中引用该变量时，新值也依然有效。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>局部变量</p>
<p>函数内部使用的<strong>任何变量都可以被声明成局部变量</strong>。要实现这一点，只要在变量声明的前面加上local关键字就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span> temp</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="数组变量和函数"><a href="#数组变量和函数" class="headerlink" title="数组变量和函数"></a>数组变量和函数</h3><h4 id="向函数传数组参数"><a href="#向函数传数组参数" class="headerlink" title="向函数传数组参数"></a>向函数传数组参数</h4><p>将该数组变量的值分解成单个的值，然后将这些值作为函数参数使用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># array variable to function test </span></span><br><span class="line"><span class="keyword">function</span> testit &#123; </span><br><span class="line"> <span class="built_in">local</span> newarray </span><br><span class="line"> newarray=(;<span class="string">&#x27;echo &quot;$@&quot;&#x27;</span>) </span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;The new array value is: <span class="variable">$&#123;newarray[*]&#125;</span>&quot;</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">myarray=(1 2 3 4 5) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The original array is <span class="variable">$&#123;myarray[*]&#125;</span>&quot;</span> </span><br><span class="line">testit <span class="variable">$&#123;myarray[*]&#125;</span> </span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h4 id="从函数返回数组"><a href="#从函数返回数组" class="headerlink" title="从函数返回数组"></a>从函数返回数组</h4><p>函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># returning an array value </span></span><br><span class="line"><span class="keyword">function</span> arraydblr &#123; </span><br><span class="line"> <span class="built_in">local</span> origarray </span><br><span class="line"> <span class="built_in">local</span> newarray </span><br><span class="line"> <span class="built_in">local</span> elements </span><br><span class="line"> <span class="built_in">local</span> i </span><br><span class="line"> origarray=($(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>)) </span><br><span class="line"> <span class="comment">#arraydblr函数将该数组重组到新的数组变量中，生成该输出数组变量的一个副本。</span></span><br><span class="line"> newarray=($(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>)) </span><br><span class="line"> elements=$[ <span class="variable">$#</span> - 1 ] </span><br><span class="line"> <span class="keyword">for</span> (( i = 0; i &lt;= <span class="variable">$elements</span>; i++ )) </span><br><span class="line"> &#123; </span><br><span class="line"> 	newarray[<span class="variable">$i</span>]=$[ <span class="variable">$&#123;origarray[$i]&#125;</span> * 2 ] </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;newarray[*]&#125;</span> </span><br><span class="line">&#125; </span><br><span class="line">myarray=(1 2 3 4 5) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The original array is: <span class="variable">$&#123;myarray[*]&#125;</span>&quot;</span> </span><br><span class="line">arg1=$(<span class="built_in">echo</span> <span class="variable">$&#123;myarray[*]&#125;</span>) </span><br><span class="line">result=($(arraydblr <span class="variable">$arg1</span>)) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The new array is: <span class="variable">$&#123;result[*]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h3><p>自成体系的函数不需要使用任何外部资源。这个特性使得函数可以递归地调用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using recursion </span></span><br><span class="line"><span class="comment">#计算阶乘</span></span><br><span class="line"><span class="keyword">function</span> factorial &#123; </span><br><span class="line"> <span class="keyword">if</span> [ <span class="variable">$1</span> -eq 1 ] </span><br><span class="line"> <span class="keyword">then</span> </span><br><span class="line"> 	<span class="built_in">echo</span> 1 </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">local</span> temp=$[ <span class="variable">$1</span> - 1 ] </span><br><span class="line"> 	<span class="built_in">local</span> result=$(factorial <span class="variable">$temp</span>) </span><br><span class="line"> 	<span class="built_in">echo</span> $[ <span class="variable">$result</span> * <span class="variable">$1</span> ] </span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Enter value: &quot;</span> value </span><br><span class="line">result=$(factorial <span class="variable">$value</span>) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The factorial of <span class="variable">$value</span> is: <span class="variable">$result</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h3><p>是创建一个包含脚本中所需函数的公用库文件。这里有个叫作<code>myfuncs</code>的库文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> addem &#123; </span><br><span class="line"> <span class="built_in">echo</span> $[ <span class="variable">$1</span> + <span class="variable">$2</span> ] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> multem &#123; </span><br><span class="line"> <span class="built_in">echo</span> $[ <span class="variable">$1</span> * <span class="variable">$2</span> ] </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> divem &#123; </span><br><span class="line"> <span class="keyword">if</span> [ <span class="variable">$2</span> -ne 0 ] </span><br><span class="line"> <span class="keyword">then</span> </span><br><span class="line">	<span class="built_in">echo</span> $[ <span class="variable">$1</span> / <span class="variable">$2</span> ] </span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> 	<span class="built_in">echo</span> -1 </span><br><span class="line"> <span class="keyword">fi</span> </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><code>source</code>会在当前shell上下文中执行命令，而不是创建一个新shell。<strong>点操作符（dot operator）。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash </span></span><br><span class="line"><span class="comment"># using a library file the wrong way </span></span><br><span class="line"><span class="built_in">source</span> myfuncs </span><br><span class="line">result=$(addem 10 15) </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The result is <span class="variable">$result</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="在命令行上使用函数"><a href="#在命令行上使用函数" class="headerlink" title="在命令行上使用函数"></a>在命令行上使用函数</h3><h4 id="在-bashrc-文件中定义函数"><a href="#在-bashrc-文件中定义函数" class="headerlink" title="在.bashrc 文件中定义函数"></a>在.bashrc 文件中定义函数</h4><ol>
<li><p>直接定义函数</p>
<p>可以直接在主目录下的.bashrc文件中定义函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .bashrc </span></span><br><span class="line"><span class="comment"># Source global definitions </span></span><br><span class="line"><span class="keyword">if</span> [ -r /etc/bashrc ]; <span class="keyword">then</span> </span><br><span class="line"> . /etc/bashrc </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">function</span> addem &#123; </span><br><span class="line"> <span class="built_in">echo</span> $[ <span class="variable">$1</span> + <span class="variable">$2</span> ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数会在下次启动新bash shell时生效。随后你就能在系统上任意地方使用这个函数了。</p>
</li>
<li><p>读取函数文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat .bashrc </span><br><span class="line"><span class="comment"># .bashrc </span></span><br><span class="line"><span class="comment"># Source global definitions </span></span><br><span class="line"><span class="keyword">if</span> [ -r /etc/bashrc ]; <span class="keyword">then</span> </span><br><span class="line"> . /etc/bashrc </span><br><span class="line"><span class="keyword">fi</span> </span><br><span class="line">. /home/rich/libraries/myfuncs</span><br></pre></td></tr></table></figure>





</li>
</ol>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/shell/">shell</a></div><div class="post_share"><div class="social-share" data-image="/./img/photo-1442522772768-9032b6d10e3e.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E8%84%9A%E6%9C%AC/"><img class="prev-cover" src="/./img/photo-1627819376920-9faac124cf13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">shell脚本</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C/"><img class="next-cover" src="/./img/photo-1627819376920-9faac124cf13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux命令行</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/09/23/操作系统/Linux脚本/" title="shell脚本"><img class="cover" src="/./img/photo-1627819376920-9faac124cf13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-23</div><div class="title">shell脚本</div></div></a></div><div><a href="/2021/10/05/操作系统/正则表达式/" title="正则表达式"><img class="cover" src="/./img/photo-1626811407568-2f41c53fff99.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-05</div><div class="title">正则表达式</div></div></a></div><div><a href="/2021/09/27/操作系统/Linux文本处理/" title="Linux文本处理"><img class="cover" src="/./img/photo-1627819376920-9faac124cf13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-27</div><div class="title">Linux文本处理</div></div></a></div><div><a href="/2021/09/18/操作系统/Linux命令行/" title="Linux命令行"><img class="cover" src="/./img/photo-1627819376920-9faac124cf13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-18</div><div class="title">Linux命令行</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%9E%84%E5%BB%BA%E5%9F%BA%E6%9C%AC%E8%84%9A%E6%9C%AC"><span class="toc-number">1.</span> <span class="toc-text">一、构建基本脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAshell%E5%9F%BA%E6%9C%AC"><span class="toc-number">1.1.</span> <span class="toc-text">创建shell基本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.</span> <span class="toc-text">显示消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">使用变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">用户变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.3.3.</span> <span class="toc-text">命令替换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">1.4.</span> <span class="toc-text">重定向输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.4.1.</span> <span class="toc-text">输出重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">1.4.2.</span> <span class="toc-text">输入重定向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">1.5.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-number">1.6.</span> <span class="toc-text">执行数学运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#expr"><span class="toc-number">1.6.1.</span> <span class="toc-text">expr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.6.2.</span> <span class="toc-text">使用方括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.6.3.</span> <span class="toc-text">浮点解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E8%84%9A%E6%9C%AC"><span class="toc-number">1.7.</span> <span class="toc-text">退出脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%80%80%E5%87%BA%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.7.1.</span> <span class="toc-text">查看退出状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exit-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.7.2.</span> <span class="toc-text">exit 命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BB%93%E6%9E%84%E5%8C%96%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">二、结构化命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8if-then-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.1.</span> <span class="toc-text">使用if-then 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-then-else-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.2.</span> <span class="toc-text">if-then-else 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97-if"><span class="toc-number">2.3.</span> <span class="toc-text">嵌套 if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#test-%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.</span> <span class="toc-text">test 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83"><span class="toc-number">2.4.1.</span> <span class="toc-text">1. 数值比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.字符串比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%96%87%E4%BB%B6%E6%AF%94%E8%BE%83"><span class="toc-number">2.4.3.</span> <span class="toc-text">3.文件比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">2.5.</span> <span class="toc-text">复合条件测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-then-%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-number">2.6.</span> <span class="toc-text">if-then 的高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%8F%8C%E6%8B%AC%E5%8F%B7"><span class="toc-number">2.6.1.</span> <span class="toc-text">用于数学表达式的双括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8C%E6%96%B9%E6%8B%AC%E5%8F%B7"><span class="toc-number">2.6.2.</span> <span class="toc-text">用于高级字符串处理功能的双方括号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#case-%E5%91%BD%E4%BB%A4"><span class="toc-number">2.7.</span> <span class="toc-text">case 命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%8C%96%E6%8C%87%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">三、循环结构化指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#for-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.</span> <span class="toc-text">for 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%BB%E5%8F%96%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.读取列表中的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%BB%E5%8F%96%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%A4%8D%E6%9D%82%E5%80%BC"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.读取列表中的复杂值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%8E%E5%8F%98%E9%87%8F%E8%AF%BB%E5%8F%96%E5%88%97%E8%A1%A8"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.从变量读取列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%8E%E5%91%BD%E4%BB%A4%E8%AF%BB%E5%8F%96%E5%80%BC"><span class="toc-number">3.1.4.</span> <span class="toc-text">4. 从命令读取值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%9B%B4%E6%94%B9%E5%AD%97%E6%AE%B5%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-number">3.1.5.</span> <span class="toc-text">5.更改字段分隔符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95"><span class="toc-number">3.1.6.</span> <span class="toc-text">6.用通配符读取目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E9%A3%8E%E6%A0%BC%E7%9A%84for"><span class="toc-number">3.2.</span> <span class="toc-text">C语言风格的for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.</span> <span class="toc-text">while 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#until"><span class="toc-number">3.4.</span> <span class="toc-text">until</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.5.</span> <span class="toc-text">嵌套循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">3.6.</span> <span class="toc-text">循环处理文件数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.7.</span> <span class="toc-text">控制循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#break-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.7.1.</span> <span class="toc-text">break 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#continue-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.7.2.</span> <span class="toc-text">continue 命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%BE%93%E5%87%BA%E8%BE%93%E5%85%A5"><span class="toc-number">3.8.</span> <span class="toc-text">处理循环的输出输入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5"><span class="toc-number">4.</span> <span class="toc-text">四、处理用户的输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">命令行参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%BB%E5%8F%96%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.读取参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%BB%E5%8F%96%E8%84%9A%E6%9C%AC%E5%90%8D"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.读取脚本名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B5%8B%E8%AF%95%E5%8F%82%E6%95%B0"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.测试参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F"><span class="toc-number">4.2.</span> <span class="toc-text">特殊参数变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%82%E6%95%B0%E7%BB%9F%E8%AE%A1"><span class="toc-number">4.2.1.</span> <span class="toc-text">1.参数统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8A%93%E5%8F%96%E6%89%80%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.抓取所有的数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.</span> <span class="toc-text">移动变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%80%89%E9%A1%B9"><span class="toc-number">4.4.</span> <span class="toc-text">处理选项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9F%A5%E6%89%BE%E9%80%89%E9%A1%B9"><span class="toc-number">4.4.1.</span> <span class="toc-text">1.查找选项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-getopt-%E5%91%BD%E4%BB%A4"><span class="toc-number">4.4.2.</span> <span class="toc-text">2.使用 getopt 命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E9%80%89%E9%A1%B9%E6%A0%87%E5%87%86%E5%8C%96"><span class="toc-number">4.5.</span> <span class="toc-text">将选项标准化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="toc-number">4.6.</span> <span class="toc-text">获得用户输入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">4.6.1.</span> <span class="toc-text">1. 基本的读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B6%85%E6%97%B6"><span class="toc-number">4.6.2.</span> <span class="toc-text">2.超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%9A%90%E8%97%8F%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96"><span class="toc-number">4.6.3.</span> <span class="toc-text">3.隐藏方式读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96"><span class="toc-number">4.6.4.</span> <span class="toc-text">4.从文件中读取</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%91%88%E7%8E%B0%E6%95%B0%E6%8D%AE"><span class="toc-number">5.</span> <span class="toc-text">五、呈现数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-number">5.1.</span> <span class="toc-text">理解输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">5.1.1.</span> <span class="toc-text">1.标准文件描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8D%E5%AE%9A%E5%90%91%E9%94%99%E8%AF%AF"><span class="toc-number">5.1.2.</span> <span class="toc-text">2.重定向错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%87%BA"><span class="toc-number">5.2.</span> <span class="toc-text">在脚本中重定向输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%B4%E6%97%B6%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.临时重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.永久重定向</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5"><span class="toc-number">5.3.</span> <span class="toc-text">在脚本中重定向输入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.3.1.</span> <span class="toc-text">创建自己的重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">5.3.2.</span> <span class="toc-text">1.输出文件描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8D%E5%AE%9A%E5%90%91%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">5.3.3.</span> <span class="toc-text">2.重定向文件描述符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">5.3.4.</span> <span class="toc-text">3.输入文件描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%87%BA%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">5.4.</span> <span class="toc-text">列出打开的文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA"><span class="toc-number">5.5.</span> <span class="toc-text">阻止命令输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-number">5.6.</span> <span class="toc-text">创建临时文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-number">5.6.1.</span> <span class="toc-text">1.创建本地临时文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9C%A8-tmp-%E7%9B%AE%E5%BD%95%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-number">5.6.2.</span> <span class="toc-text">2.在&#x2F;tmp 目录创建临时文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E7%9B%AE%E5%BD%95"><span class="toc-number">5.6.3.</span> <span class="toc-text">3.创建临时目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%B6%88%E6%81%AF"><span class="toc-number">5.7.</span> <span class="toc-text">记录消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%8E%A7%E5%88%B6%E8%84%9A%E6%9C%AC"><span class="toc-number">6.</span> <span class="toc-text">六、控制脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7"><span class="toc-number">6.1.</span> <span class="toc-text">处理信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%9F%E6%88%90%E4%BF%A1%E5%8F%B7"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.生成信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8D%95%E8%8E%B7%E4%BF%A1%E5%8F%B7"><span class="toc-number">6.1.2.</span> <span class="toc-text">2.捕获信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8D%95%E8%8E%B7%E8%84%9A%E6%9C%AC%E9%80%80%E5%87%BA"><span class="toc-number">6.1.3.</span> <span class="toc-text">3.捕获脚本退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BF%AE%E6%94%B9%E6%88%96%E7%A7%BB%E9%99%A4%E6%8D%95%E8%8E%B7"><span class="toc-number">6.1.4.</span> <span class="toc-text">4.修改或移除捕获</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%90%8E%E5%8F%B0%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC"><span class="toc-number">6.2.</span> <span class="toc-text">以后台模式运行脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.后台运行脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA%E5%90%8E%E5%8F%B0%E4%BD%9C%E4%B8%9A"><span class="toc-number">6.2.2.</span> <span class="toc-text">2.运行多个后台作业</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%9D%9E%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8B%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC"><span class="toc-number">6.3.</span> <span class="toc-text">在非控制台下运行脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6"><span class="toc-number">6.4.</span> <span class="toc-text">作业控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9F%A5%E7%9C%8B%E4%BD%9C%E4%B8%9A"><span class="toc-number">6.4.1.</span> <span class="toc-text">1.查看作业</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8D%E5%90%AF%E5%81%9C%E6%AD%A2%E7%9A%84%E4%BD%9C%E4%B8%9A"><span class="toc-number">6.4.2.</span> <span class="toc-text">2.重启停止的作业</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E8%B0%A6%E8%AE%A9%E5%BA%A6"><span class="toc-number">6.5.</span> <span class="toc-text">调整谦让度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-nice-%E5%91%BD%E4%BB%A4"><span class="toc-number">6.5.1.</span> <span class="toc-text">1.nice 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-renice%E5%91%BD%E4%BB%A4"><span class="toc-number">6.5.2.</span> <span class="toc-text">2.renice命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BD%9C%E4%B8%9A"><span class="toc-number">6.6.</span> <span class="toc-text">定时运行作业</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#at-%E5%91%BD%E4%BB%A4%E6%9D%A5%E8%AE%A1%E5%88%92%E6%89%A7%E8%A1%8C%E4%BD%9C%E4%B8%9A"><span class="toc-number">6.6.1.</span> <span class="toc-text">at 命令来计划执行作业</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%89%E6%8E%92%E9%9C%80%E8%A6%81%E5%AE%9A%E6%9C%9F%E6%89%A7%E8%A1%8C%E7%9A%84%E8%84%9A%E6%9C%AC"><span class="toc-number">6.6.2.</span> <span class="toc-text">2.安排需要定期执行的脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E6%96%B0-shell-%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC"><span class="toc-number">6.6.3.</span> <span class="toc-text">3.使用新 shell 启动脚本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">七、函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">基本函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.1.</span> <span class="toc-text">1.创建函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.2.</span> <span class="toc-text">2.使用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">7.1.3.</span> <span class="toc-text">3.返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">7.2.</span> <span class="toc-text">在函数中使用变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text">向函数传递参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A4%84%E7%90%86%E5%8F%98%E9%87%8F"><span class="toc-number">7.2.2.</span> <span class="toc-text">在函数中处理变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">数组变量和函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0"><span class="toc-number">7.3.1.</span> <span class="toc-text">向函数传数组参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84"><span class="toc-number">7.3.2.</span> <span class="toc-text">从函数返回数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92"><span class="toc-number">7.4.</span> <span class="toc-text">函数递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%BA%93"><span class="toc-number">7.5.</span> <span class="toc-text">创建库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">在命令行上使用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-bashrc-%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.1.</span> <span class="toc-text">在.bashrc 文件中定义函数</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By naive</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>