<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java并发编程实战--第三部分 活跃性、性能与测测 | naive的博客</title><meta name="keywords" content="多线程,笔记"><meta name="author" content="naive"><meta name="copyright" content="naive"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="十、避免活跃性危险10.1 死锁 锁顺序死锁：一个锁先锁left 在锁right,另一个锁先锁right再锁left,会发生死锁。  动态的锁顺序死锁 有时候，并不能清楚地知道是否在锁顺序上有足够的控制权来避免死锁的发生。 123456789101112131415&#x2F;&#x2F;注意:容易发生死锁!&#x2F;&#x2F;看似无害的代码，它将资金从一个账户转入另一个账户。在开始转账之前，首先要获得这两个Account对象的锁，">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发编程实战--第三部分 活跃性、性能与测测">
<meta property="og:url" content="http://yoursite.com/2021/01/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/index.html">
<meta property="og:site_name" content="naive的博客">
<meta property="og:description" content="十、避免活跃性危险10.1 死锁 锁顺序死锁：一个锁先锁left 在锁right,另一个锁先锁right再锁left,会发生死锁。  动态的锁顺序死锁 有时候，并不能清楚地知道是否在锁顺序上有足够的控制权来避免死锁的发生。 123456789101112131415&#x2F;&#x2F;注意:容易发生死锁!&#x2F;&#x2F;看似无害的代码，它将资金从一个账户转入另一个账户。在开始转账之前，首先要获得这两个Account对象的锁，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/img/photo-1465188162913-8fb5709d6d57.jpg">
<meta property="article:published_time" content="2021-01-23T11:47:32.000Z">
<meta property="article:modified_time" content="2021-08-08T08:00:52.764Z">
<meta property="article:author" content="naive">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/photo-1465188162913-8fb5709d6d57.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2021/01/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java并发编程实战--第三部分 活跃性、性能与测测',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-08 16:00:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="naive的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">29</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/photo-1465188162913-8fb5709d6d57.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">naive的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java并发编程实战--第三部分 活跃性、性能与测测</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-23T11:47:32.000Z" title="发表于 2021-01-23 19:47:32">2021-01-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-08T08:00:52.764Z" title="更新于 2021-08-08 16:00:52">2021-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java并发编程实战--第三部分 活跃性、性能与测测"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="十、避免活跃性危险"><a href="#十、避免活跃性危险" class="headerlink" title="十、避免活跃性危险"></a>十、避免活跃性危险</h2><h3 id="10-1-死锁"><a href="#10-1-死锁" class="headerlink" title="10.1 死锁"></a>10.1 死锁</h3><ul>
<li><p>锁顺序死锁：一个锁先锁left 在锁right,另一个锁先锁right再锁left,会发生死锁。</p>
</li>
<li><p><strong>动态的锁顺序死锁</strong></p>
<p>有时候，并不能清楚地知道是否在锁顺序上有足够的控制权来避免死锁的发生。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:容易发生死锁!</span></span><br><span class="line"><span class="comment">//看似无害的代码，它将资金从一个账户转入另一个账户。在开始转账之前，首先要获得这两个Account对象的锁，以确保通过原子方式来更新两个账户中的余额，同时又不破坏一些不变性条件，例如“账户的余额不能为负数”。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span> <span class="params">(Account fromAccount,</span></span></span><br><span class="line"><span class="params"><span class="function">					Account toAccount ,Dol1arAmount amount)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (fromAccount) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toAccount) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (fromAccount.getBalance( ).compareTo (amount) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException ( ) ;</span><br><span class="line">        	<span class="keyword">else</span> &#123;</span><br><span class="line">        		fromAccount.debit (amount) ;</span><br><span class="line">                toAccount .credit (amount) ;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个线程同时转账，一个从X向Y转账，另一个从Y向X转账，就会发生死锁。</p>
<p>可以使用System.identityHashCode方法，返回hash值，必须通过任意的方法来决定锁定顺序，但仍然有很小道可能发生死锁。</p>
</li>
<li><p><strong>在协作对象之间发送死锁。</strong>：这两个锁不一定在同一个方法中被获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:容易发生死锁!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line">	<span class="meta">@GuardedBy</span> (<span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> Point location,destination;<span class="comment">//位置和谜底</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher ; <span class="comment">//出租车车队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span> <span class="params">(Dispatcher dispatcher)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> location ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span> <span class="params">(Point location)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.location = location;</span><br><span class="line">		<span class="keyword">if</span> ( location. equals(destination))</span><br><span class="line">			dispatcher.notifyAvailable (<span class="keyword">this</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">	<span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> <span class="keyword">final</span> set&lt;Taxi&gt; taxis;</span><br><span class="line">	<span class="meta">@GuardedBy( &quot;this&quot; )</span> <span class="keyword">private</span> <span class="keyword">final</span> set&lt;Taxi&gt; availableTaxis;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">        taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt; ();</span><br><span class="line">        avai lableTaxis = <span class="keyword">new</span> Hashset&lt;Taxi&gt; ( ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span> <span class="params">(Taxi taxi)</span></span>&#123;</span><br><span class="line">    	availableTaxis.add (taxi) ;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> Image () ;</span><br><span class="line">        <span class="keyword">for</span> (Taxi t : taxis)</span><br><span class="line">        	image.drawMarker(t.getLocation ());</span><br><span class="line">        <span class="keyword">return</span> image ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果一个线程在收到GPS接收器的更新事件时调用setLocation，那么它将首先更新出租车的位置，然后判断它是否到达了目的地。如果已经到达，它会通知Dispatcher : 它需要一个新的目的地。因为<strong>setLocation和notifyAvailable都是同步方法，因此调用setLocatior的线程将首先获取Taxi的锁，然后获取 Dispatcher的锁。同样，调用getImage的线程将首先获取 Dispatcher锁，然后再获取每一个Taxi的锁（每次获取一个)。</strong><br>如果在持有锁时调用某个外部方法那么将出现活跃性问题。在这个外部方法中可能会荻取其他锁:（这可能会产生死锁）,或者阻塞时间过长，导致其他线程无法及时获得;当前被持有的锁。</p>
</li>
<li><p>开放调用</p>
<p><strong>如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用</strong>(Open Call)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以很容易地将Taxi和 Dispatcher修改为使用开放调用，从而消除发生死锁的风险。这需要使同步代码块仅被用于保护那些涉及共享状态的操作，。通常，如果只是为了语法紧凑或简单性（而不是因为整个方法必须通过--个锁来保护）而使用同步方法（而不是同步代码块)，那么就会导致问题。(此外，收缩同步代码块的保护范围还可以提高可伸缩性)</span></span><br><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line"> 	<span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> Point location，destination;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher ;</span><br><span class="line">	...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> location;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span> <span class="params">( Point location)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">boolean</span> reachedDestination ;</span><br><span class="line">    	<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    		<span class="keyword">this</span>.location = location ;</span><br><span class="line">    		reachedDestination = location.equals(destination) ;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">if</span>(reachedDestination)</span><br><span class="line">    		dispatcher.notifyAvailable(<span class="keyword">this</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">	<span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> <span class="keyword">final</span> set&lt;Taxi&gt; taxis;</span><br><span class="line">	GuardedBy ( <span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> <span class="keyword">final</span> set&lt;Taxi&gt; availableTaxis ;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span> <span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">    	availableTaxis.add (taxi) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Image <span class="title">getImage</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;Taxi&gt;copy ;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        	copy = <span class="keyword">new</span> Hashset&lt;Taxi&gt; (taxis) ;</span><br><span class="line">        &#125;</span><br><span class="line">        Image image = <span class="keyword">new</span> Image () ;</span><br><span class="line">        <span class="keyword">for</span> ( Taxi t : copy)</span><br><span class="line">        	image.drawMarker (t.getLocation ( ) ) ;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>资源死锁</p>
</li>
</ul>
<h3 id="10-2-死锁的避免和诊断"><a href="#10-2-死锁的避免和诊断" class="headerlink" title="10.2 死锁的避免和诊断"></a>10.2 死锁的避免和诊断</h3><p>在使用细粒度锁的程序中，可以通过使用一种<strong>两阶段策略（Two-Part Strategy）来检查代码中的死锁:首先，找出在什么地方将获取多个锁（使这个集合尽量小)，然后对所有这些实例进行全局分析，从而确保它们在整个程序中获取锁的顺序都保持一致。</strong></p>
<ul>
<li>支持定时的锁</li>
<li>通过现场转储信息来分析死锁</li>
</ul>
<h3 id="10-3-其他活跃性问题"><a href="#10-3-其他活跃性问题" class="headerlink" title="10.3 其他活跃性问题"></a>10.3 其他活跃性问题</h3><ul>
<li><p>饥饿：</p>
<p>线程由于无法访问它所需的资源而不能继续执行，就发生了饥饿。（CPU时钟周期）</p>
</li>
<li><p>糟糕的响应性</p>
</li>
<li><p>活锁</p>
<p>活锁(Livelock)是另一种形式的活跃性问题，该<strong>问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。</strong>活锁通常发生在处理事务消息的应用程序中﹔如果不能成功地处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头。如果消息处理器在处理某种特定类型的消息时存在错误并导致它失败，那么每当这个消息从队列中取出并传递到存在错误的处理器时，都会发生事务回滚。由于这条消息又被放回到队列开头，因此处理器将被反复调用，并返回相同的结果。</p>
<p><strong>要解决这个问题需要在重试机制上加入随机性。在并发程序中，通过等待随机长度的时间和回退可以有效的避免活锁</strong></p>
</li>
</ul>
<h2 id="十一、性能与可伸缩性"><a href="#十一、性能与可伸缩性" class="headerlink" title="十一、性能与可伸缩性"></a>十一、性能与可伸缩性</h2><h3 id="11-1-对性能的思考"><a href="#11-1-对性能的思考" class="headerlink" title="11.1 对性能的思考"></a>11.1 对性能的思考</h3><p>要想通过并发来获得更好的性能，需要努力做好两件事情:<strong>更有效地利用现有处理资源，以及在出现新的处理资源时使程序尽可能地利用这些新资源。</strong></p>
<h4 id="性能与可伸缩性"><a href="#性能与可伸缩性" class="headerlink" title="性能与可伸缩性"></a>性能与可伸缩性</h4><p>应用程序的性能可以采用多个指标来衡量，例如服务时间、延迟时间、吞吐率、效率、可伸缩性以及容量等。其中一-些指标（服务时间、等待时间〉用于衡量程序的“运行速度”，即某个指定的任务单元需要“多快”才能处理完成。另一些指标（生产量、吞吐量〉用于程序的“处理能力”，即在计算资源一定的情况下，能完成“多少”工作。<br>可伸缩性指的是，当增加计算资源时程序的吞吐量或者处理能力能理应地增加。</p>
<h3 id="11-2-Amdahl定律"><a href="#11-2-Amdahl定律" class="headerlink" title="11.2 Amdahl定律"></a>11.2 Amdahl定律</h3><p>Amdahl定律描述的是﹔在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中可并行组件与串行组件所占的比重。</p>
<p>假设应用程序中N个线程正在执行，这些线程从一个共享的工作队列中取出任务进行处理，而且这里的任务都不依赖于其他任务的执行结果或影响。暂时先不考虑任务是如何进入这个队列的，如果增加处理器，那么应用程序的性能是否会相应地发生变化?初看上去，这个程序似乎能完全并行化:各个任务之间不会相互等待，因此处理器越多,能够并发处理的任务也就越多。<strong>然而，在这个过程中包含了一个串行部分—从队列中获取任务。所有工作者线程都共享同一个工作队列，因此在对该队列进行并发访问时需要采用某种同步机制来维持队列的完整性。如果通过加锁来保护队列的状态，那么当一个线程从队列中取出任务时，其他需要获取下一个任务的线程就必须等待，这就是任务处理过程中的串行部分。</strong></p>
<p>单个任务的处理时间不仅包括执行任务Runnable的时间，也包括从共享队列中取出任务的时间。<strong>如果使用LinkedBlockingQueue作为工作队列，那么出列操作被阻塞的可能性将小于使用同步LinkedList时发生阻塞的可能性，因为LinkedBlockingQueue使用了一种可伸缩性更高的算法。</strong>然而，无论访问何种共享数据结构，基本上都会在程序中引入一个串行部分。<br>这个示例还忽略了另一种常见的串行操作:对结果进行处理。所有有用的计算都会生成某种结果或者产生某种效应——如果不会，那么可以将它们作为“死亡代码”删除掉。由于Runnable没有提供明确的结果处理过程，因此这些任务一定会产生某种效果，例如将它们的结果写入到日志或者保存到某个数据结构。通常，日志文件和结果容器都会由多个工作者线程共享，并且这也是一个串行部分。如果所有线程都将各自的计算结果保存到自行维护数据结构中，并且在所有任务都执行完成后再合并所有的结果，那么这种合并操作也是一个串行部分。</p>
<h3 id="11-3-线程引入的开销"><a href="#11-3-线程引入的开销" class="headerlink" title="11.3 线程引入的开销"></a>11.3 线程引入的开销</h3><ul>
<li><p>上下文切换</p>
<p>如果主线程是唯一的线程，那么它基本上不会被调度出去。另一方面，如果可运行的线程数大于CPU的数量，那么操作系统最终会将某个正在运行的线程调度出来，从而使其他线程能够使用CPU。这将导致一次上下文切换，在这个过程中将保存当前运行线程的执行上下文，并将新调度进来的线程的执行上下文设置为当前上下文。</p>
</li>
<li><p>内存同步</p>
<p>在synchronized和volatile提供的可见性保证中可能会使用一些特殊指令，即内存栅栏(Memory Barrier)。内存栅栏可以刷新缓存，使缓存无效，剧新硬件的写缓冲，以及停止执行管道。<strong>内存栅栏可能同样会对性能带来间接的影响，因为它们将抑制-些编译器优化操作。</strong>在内存栅栏中，大多数操作都是不能被重排序的。<br>现代的JVM能通过优化来去掉一些不会发生竞争的锁，从而减少不必要的同步开销。如果一个锁对象只能由当前线程访问，那么JVM就可以通过优化来去掉这个锁获取操作</p>
</li>
<li><p>阻塞</p>
</li>
</ul>
<h3 id="11-4-减少锁的竞争"><a href="#11-4-减少锁的竞争" class="headerlink" title="11.4 减少锁的竞争"></a>11.4 减少锁的竞争</h3><p>有两个因素将影响在锁上发生竞争的可能性:<strong>锁的请求频率，以及每次持有该锁的时间</strong>。如果二者的乘积很小，那么大多数获取锁的操作都不会发生竞争，因此在该锁上的竞争不会对可伸缩性造成严重影响。然而，如果在锁上的请求量很高，那么需要获取该锁的线程将被阻塞并等待。在极端情况下，即使仍有大量工作等待完成，处理器也会被闲置。</p>
<ul>
<li><p>缩小锁的范围</p>
</li>
<li><p>减小锁的粒度</p>
<p>降低线程请求锁的频率，锁分解和锁分段。</p>
</li>
<li><p>锁分段</p>
</li>
<li><p>避免热点域</p>
<p>将一些反复计算的结果缓存起来</p>
</li>
<li><p>一些代替独占锁的方法</p>
<ul>
<li>ReadWriteLock 读取不加锁，写加锁</li>
<li>原子变量 </li>
</ul>
</li>
</ul>
<h3 id="11-5-比较Map的性能"><a href="#11-5-比较Map的性能" class="headerlink" title="11.5 比较Map的性能"></a>11.5 比较Map的性能</h3><p>在单线程环境下，ConcurrentHashMap 的性能比同步的HashMap 的性能略好一些，但在并发环境中则要好得多。<br>在同步Map的实现中，可伸缩性的最主要阻碍在于整个 Map中只有一个锁，因此每次只有一个线程能够访问这个 Map。不同的是，ConcurrentHashMap对于大多数读操作并不会加锁,并且在写人操作以及其他一些需要锁的读操作中使用了锁分段技术。因此，多个线程能并发地访问这个Map而不会发生阻塞。<br>ConcurrentHashMap,ConcurrentSkipListMap,以及通过synchronizedMap来包装的HashMap 和TreeMap。前两种Map是线程安全的，而后两种通过同步容器确保线程安全性。</p>
<h3 id="11-6-减少上下文切换的开销"><a href="#11-6-减少上下文切换的开销" class="headerlink" title="11.6 减少上下文切换的开销"></a>11.6 减少上下文切换的开销</h3><p>在许多任务中都包含一些可能被阻塞的操作。<strong>当任务在运行和阻塞这两个状态之间转换时，就相当于一次上下文切换。在服务器应用程序中，发生阻塞的原因之一就是在处理请求时产生各种日志消息。</strong></p>
<p>在大多数日志框架中都是简单地对println进行包装，当需要记录某个消息时，只需将其写人日志文件中。在第7章的LogWriter中给出了另一种方法:<strong>记录日志的工作由一个专门的后台线程完成，而不是由发出请求的线程完成。</strong>从开发人员的角度来看，这两种方法基本上是相同的。但二者在性能上可能存在一些差异，这取决于日志操作的工作量，即有多少线程正在记录日志，以及其他一些因素，例如上下文切换的开销等。<br><strong>日志操作的服务时间包括与I/О流类相关的计算时间，如果IО操作被阻塞，那么还会包括线程被阻塞的时间。</strong><br>请<strong>求服务的时间不应该过长，主要有以下原因。首先，服务时间将影响服务质量:服务时间越长，就意味着有程序在获得结果时需要等待更长的时间。但更重要的是，服务时间越长，也就意味着存在越多的锁竞争。</strong></p>
<h2 id="十二、并发程序的测试"><a href="#十二、并发程序的测试" class="headerlink" title="十二、并发程序的测试"></a>十二、并发程序的测试</h2><p>有两类测试：安全性测试和活跃性测试。</p>
<p><strong>在进行安全性测试时，通常会采用测试不变性条件的形式，即判断某个类的行为是否与其规范保持一致。</strong>例如，<br>测试活跃性本身也存在问题。活跃性测试包括<strong>进展测试和无进展测试</strong>两方面，这些都是很难量化的——如何验证某个方法是被阻塞了，而不只是运行缓慢﹖同样，如何测试某个算法不会发生死锁﹖要等待多久才能宣告它发生了故障?<br>与活跃性测试相关的是性能测试。性能可以通过多个方面来衡量，包括:</p>
<ul>
<li>吞吐量:指一组并发任务中已完成任务所占的比例。</li>
<li>响应性．指请求从发出到完成之间的实际</li>
<li>可伸缩性：在增加更多的资源情况下，吞吐量的提示情况。</li>
</ul>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post_share"><div class="social-share" data-image="/./img/photo-1465188162913-8fb5709d6d57.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86(1)/"><img class="prev-cover" src="/./img/photo-1626277787644-47d530591292.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java并发编程实战--第四部分 高级主题</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86(2)/"><img class="next-cover" src="/./img/photo-1465188162913-8fb5709d6d57.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java并发编程实战--第二部分 结构化并发应用程序(2)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/01/22/读书笔记/java并发编程实战第二部分(2)/" title="java并发编程实战--第二部分 结构化并发应用程序(2)"><img class="cover" src="/./img/photo-1465188162913-8fb5709d6d57.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-22</div><div class="title">java并发编程实战--第二部分 结构化并发应用程序(2)</div></div></a></div><div><a href="/2021/01/24/读书笔记/java并发编程实战第四部分(1)/" title="java并发编程实战--第四部分 高级主题"><img class="cover" src="/./img/photo-1626277787644-47d530591292.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-24</div><div class="title">java并发编程实战--第四部分 高级主题</div></div></a></div><div><a href="/2021/01/20/读书笔记/java并发编程实战第二部分(1)/" title="java并发编程实战--第二部分 结构化并发应用程序(1)"><img class="cover" src="/./img/photo-1628009193228-076ab63d655a.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-20</div><div class="title">java并发编程实战--第二部分 结构化并发应用程序(1)</div></div></a></div><div><a href="/2020/08/25/读书笔记/java并发编程实战第一部分/" title="java并发编程实战--第一部分 基础知识"><img class="cover" src="/./img/photo-1626277787644-47d530591292.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-25</div><div class="title">java并发编程实战--第一部分 基础知识</div></div></a></div><div><a href="/2020/07/12/java基础/Java多线程/" title="多线程"><img class="cover" src="/./img/photo-1626277787644-47d530591292.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-12</div><div class="title">多线程</div></div></a></div><div><a href="/2020/07/15/java基础/java多线程(2)/" title="多线程（2）"><img class="cover" src="/./img/photo-1625777719130-0a8e07086117.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-15</div><div class="title">多线程（2）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E6%80%A7%E5%8D%B1%E9%99%A9"><span class="toc-number">1.</span> <span class="toc-text">十、避免活跃性危险</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E6%AD%BB%E9%94%81"><span class="toc-number">1.1.</span> <span class="toc-text">10.1 死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D%E5%92%8C%E8%AF%8A%E6%96%AD"><span class="toc-number">1.2.</span> <span class="toc-text">10.2 死锁的避免和诊断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E5%85%B6%E4%BB%96%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">10.3 其他活跃性问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">十一、性能与可伸缩性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-number">2.1.</span> <span class="toc-text">11.1 对性能的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%B8%8E%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7"><span class="toc-number">2.1.1.</span> <span class="toc-text">性能与可伸缩性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-Amdahl%E5%AE%9A%E5%BE%8B"><span class="toc-number">2.2.</span> <span class="toc-text">11.2 Amdahl定律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E7%BA%BF%E7%A8%8B%E5%BC%95%E5%85%A5%E7%9A%84%E5%BC%80%E9%94%80"><span class="toc-number">2.3.</span> <span class="toc-text">11.3 线程引入的开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E5%87%8F%E5%B0%91%E9%94%81%E7%9A%84%E7%AB%9E%E4%BA%89"><span class="toc-number">2.4.</span> <span class="toc-text">11.4 减少锁的竞争</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E6%AF%94%E8%BE%83Map%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">2.5.</span> <span class="toc-text">11.5 比较Map的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-%E5%87%8F%E5%B0%91%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%BC%80%E9%94%80"><span class="toc-number">2.6.</span> <span class="toc-text">11.6 减少上下文切换的开销</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">十二、并发程序的测试</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By naive</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>