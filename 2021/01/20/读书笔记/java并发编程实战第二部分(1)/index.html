<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java并发编程实战--第二部分 结构化并发应用程序(1) | naive的博客</title><meta name="keywords" content="多线程,笔记"><meta name="author" content="naive"><meta name="copyright" content="naive"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="六、任务执行6.1 在线程中执行任务大多数服务器应用程序都提供了一种自然的任务边界选择方式:以独立的客户请求为边界。Web服务器、邮件服务器、文件服务器、EJB容器以及数据库服务器等，这些服务器都能通过网络接受远程客户的连接请求。将独立的请求作为任务边界，既可以实现任务的独立性，又可以实现合理的任务规模。 串行的执行任务在单个线程中串行执行各项任务。 123456789class singleTh">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发编程实战--第二部分 结构化并发应用程序(1)">
<meta property="og:url" content="http://yoursite.com/2021/01/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86(1)/index.html">
<meta property="og:site_name" content="naive的博客">
<meta property="og:description" content="六、任务执行6.1 在线程中执行任务大多数服务器应用程序都提供了一种自然的任务边界选择方式:以独立的客户请求为边界。Web服务器、邮件服务器、文件服务器、EJB容器以及数据库服务器等，这些服务器都能通过网络接受远程客户的连接请求。将独立的请求作为任务边界，既可以实现任务的独立性，又可以实现合理的任务规模。 串行的执行任务在单个线程中串行执行各项任务。 123456789class singleTh">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/img/photo-1628009193228-076ab63d655a.jpg">
<meta property="article:published_time" content="2021-01-20T08:31:44.000Z">
<meta property="article:modified_time" content="2021-08-08T08:00:36.254Z">
<meta property="article:author" content="naive">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/photo-1628009193228-076ab63d655a.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2021/01/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86(1)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java并发编程实战--第二部分 结构化并发应用程序(1)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-08 16:00:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="naive的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/photo-1628009193228-076ab63d655a.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">naive的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java并发编程实战--第二部分 结构化并发应用程序(1)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-20T08:31:44.000Z" title="发表于 2021-01-20 16:31:44">2021-01-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-08T08:00:36.254Z" title="更新于 2021-08-08 16:00:36">2021-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java并发编程实战--第二部分 结构化并发应用程序(1)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="六、任务执行"><a href="#六、任务执行" class="headerlink" title="六、任务执行"></a>六、任务执行</h2><h3 id="6-1-在线程中执行任务"><a href="#6-1-在线程中执行任务" class="headerlink" title="6.1 在线程中执行任务"></a>6.1 在线程中执行任务</h3><p>大多数服务器应用程序都提供了一种自然的任务边界选择方式:以独立的客户请求为边界。Web服务器、邮件服务器、文件服务器、EJB容器以及数据库服务器等，这些服务器都能通过网络接受远程客户的连接请求。<strong>将独立的请求作为任务边界，既可以实现任务的独立性，又可以实现合理的任务规模。</strong></p>
<h4 id="串行的执行任务"><a href="#串行的执行任务" class="headerlink" title="串行的执行任务"></a>串行的执行任务</h4><p>在单个线程中串行执行各项任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleThreadwebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(string[] args)</span> <span class="keyword">throws</span> IOBxception </span>&#123;</span><br><span class="line">        serversocket socket = <span class="keyword">new</span> serverSocket (8o ) ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        	socket connection = socket .accept ( ) ;</span><br><span class="line">            handleRequest(connection) ;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它每次只能处理一个请求。<strong>在单线程的服务器中，阻塞不仅会推迟当前请求的完成时间，而且还将彻底阻止等待中的请求被处理。</strong>如果请求阻塞的时间过长，用户将认为服务器是不可用的，因为服务器看似失去了响应。同时，服务器的资源利用率非常低，因为当单线程在等待I/O操作完成时;CPU将处于空闲状态。<br>在服务器应用程序中，串行处理机制通常都无法提供高吞吐率或快速响应性。也有一些例外，例如，当任务数量很少且执行时间很长时，或者当服务器只为单个用户提供服务，并且该客户每次只发出一个请求时——但大多数服务器应用程序并不是按照这种方式来工作的。</p>
<h4 id="显示地为任务创建线程"><a href="#显示地为任务创建线程" class="headerlink" title="显示地为任务创建线程"></a>显示地为任务创建线程</h4><p>通过为每个请求创建一个线程来提供服务，实现更高的相应性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskwebserver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(string[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        serversocket socket - <span class="keyword">new</span> serversocket (8o) ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            finalSocket connection = socket.accept ( ) ;</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>&#123;</span><br><span class="line">                	handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadPerTaskWebServer在结构上类似于前面的单线程版本——<strong>主线程仍然不断地交替执行“接受外部连接”与“分发请求”等操作。区别在于，对于每个连接，主循环都将创建一个新线程来处理请求，而不是在主循环中进行处理。</strong>由此可得出3个主要结论:</p>
<ul>
<li><strong>任务处理过程从主线程中分离出</strong>来，使得主循环能够更快地重新等待下一个到来的连接。这使得程序在完成前面的请求之前可以接受新的请求，从而提高响应性。</li>
<li><strong>任务可以并行处理，从而能同时服务多个请求。</strong></li>
<li><strong>任务处理代码必须是线程安全的，因为当有多个任务时会并发地调用这段代码。</strong></li>
</ul>
<h4 id="无限制创建线程的不足"><a href="#无限制创建线程的不足" class="headerlink" title="无限制创建线程的不足"></a>无限制创建线程的不足</h4><p>当创建大量线程时：</p>
<ul>
<li><p>线程生命周期开销非常高。<strong>线程创建和销毁不是没有代价的。</strong></p>
</li>
<li><p>资源消耗。<strong>活跃的线程会消耗系统资源，尤其是内存。如果可运行的线程数量多于可月处理器的数量，那么有些线程将闲置。</strong>如果你已经拥有足够多的线程使所有CPU保持忙碌状态，那么再创建更多的线程反而会降低性能。</p>
</li>
<li><p>稳定性。在可创建线程的数量上存在一个限制。这个限制值将随着平台的不同而不同，并且受<strong>多个因素制约，包括JVM的启动参数、Thread构造函数中请求的栈大小，以及底层操竹系统对线程的限制等。</strong>如果破坏了这些限制，那么很可能抛出OutOfMemoryError异常。</p>
<p><strong>在一定的范围内，增加线程可以提高系统的吞吐率，但如果超出了这个范围，再创建更多的线程只会降低程序的执行速度，“为每个任务分配一个线程”这种方法的问题在于，它没有限制可创建线程的数量，只限制了远程用户提交HTTP请求的速率。</strong></p>
</li>
</ul>
<h3 id="6-2-Executor框架"><a href="#6-2-Executor框架" class="headerlink" title="6.2 Executor框架"></a>6.2 Executor框架</h3><p>任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。juc提供了一种灵活线程池实现作为Executor框架的一部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">execute</span> <span class="params">( Runnable command)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executor是一个接口。为异步任务执行框架提供了基础。<strong>它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。</strong><br>Executor基于<strong>生产者–消费者</strong>模式，提交任务的操作相当于生产者，执行任务的线程则相当于消费者。</p>
<h4 id="示例：基于Executor的Web服务器"><a href="#示例：基于Executor的Web服务器" class="headerlink" title="示例：基于Executor的Web服务器"></a>示例：基于Executor的Web服务器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">classraskExecutionwebserver &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exec = executors.newFixedThreadPool(NTHREADS);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(string [] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    	serversocket socket = <span class="keyword">new</span> serversocket (<span class="number">80</span>) ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> socket connection = socket.accept ( );</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">                    handleRequest (connection) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(task) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用Executor，将<strong>请求处理任务的提交与任务的实际执行解耦开来</strong>，并且只需采用另一种不同的Executor实现，就可以改变服务器的行为。改变Executor实现或配置所带来的影响要远远小于改变任务提交方式带来的影响。通常，Executor的配置是一次性的，因此在部署阶段可以完成，而提交任务的代码却会不断地扩散到整个程序中，增加了修改的难度。<br>我们可以很容易地将TaskExecutionWebServer修改为类似ThreadPerTaskWebServer的行为，只需使用一个为每个请求都创建新线程的Executor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span> <span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">new</span> Thread(r).start () ;</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h4><p>通过将任务的提交与执行解耦开来，从而无须太大的困难就可以为某种类型的任务指定和修改执行策略。在执行策略中定义了任务执行的“What、Where、When、How”等方面，包括:</p>
<ul>
<li>在<strong>什么( What）线程</strong>中执行任务?</li>
<li>任务按照<strong>什么( What）顺序</strong>执行（FIFO、LIFO、优先级）?</li>
<li><strong>有多少个（How Many)任务</strong>能并发执行?</li>
<li>在队列中<strong>有多少个（How Many)任务在等待</strong>执行?</li>
<li>如果系统由于过载而需要拒绝一个任务，那么应该<strong>选择哪一个(Which）任务</strong>?另外，<strong>如何(How)通知应用程序有任务被拒绝?</strong></li>
<li>在执行一个任务之前或之后，应该进行<strong>哪些(What）动作</strong>?<br>各种执行策略都是一种<strong>资源管理工具</strong>，最佳策略取决于可用的计算资源以及对服务质量的需求。</li>
</ul>
<p>每当看到下面这种形式的代码时:<code>new Thread(runnable) .start()</code>虑使用Executor来代替Thread。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>管理一组同构工作线程的资源池，线程池与工作队列相关，其中在工作队列中保存了所有等待执行的任务。工作者线程的任务很简单:从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。<br>“在线程池中执行任务”比“为每个任务分配一个线程”优势更多。<strong>通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。</strong>另一个额外的好处是，<strong>当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。</strong></p>
<p>同构Executors静态工厂方法来创建一个线程池：</p>
<p><code>newFixedThreadPool</code>。创建一个<strong>固定长度</strong>的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化(如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程)。<br><code>newCachedThreadPool</code>。创建一个<strong>可缓存的线程池</strong>，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。<br><code>newSingleThreadExecutor</code>。是一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。newSingleThreadExecutor能<strong>确保依照任务在队列中的顺序来串行执行</strong>（例如FIFO、LIFO、优先级)。<br><code>newScheduledThreadPool</code>。创建了一个<strong>固定长度的线程池，而且以延迟或定时的方式来执行任务</strong>，<br>newFixedThreadPool和newCachedThreadPool这两个工厂方法返回通用的ThreadPoolExecutor实例，这些实例可以直接用来构造专门用途的executor。</p>
<p>为每个任务分配一个线程变成基于线程池的策略，由于<strong>服务器不会创建数千个线程来争夺有限的CPU和内存资源，因此服务器的性能将平缓地降低。通过使用Executor，可以实现各种调优、管理、监视、记录日志、错误报告和其他功能</strong>。</p>
<h4 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h4><p>Executor的实现通常会创建线程来执行任务。但JVM只有在所有（非守护）线程全部终止后才会退出。因此，如果无法正确地关闭Executor，那么JVM将无法结束。</p>
<p>Executor以异步方式来执行任务，提交任务的状态不是立即可见的。<strong>Executor是为应用程序提供服务的，因而它们也是可关闭的（无论采用平缓的方式还是粗暴的方式)，并将在关闭操作中受影响的任务的状态反馈给应用程序。</strong><br><strong>为了解决执行服务的生命周期问题，Executor扩展了ExecutorService接口，添加了一些用于生命周期管理的方法</strong>（同时还有一些用于任务提交的便利方法)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>. <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span> <span class="params">()</span>  </span>;</span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span> <span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span> <span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span> <span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span> <span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//……其他用于任务提交的便利方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ExecutorService的生命周期有3种状态:<strong>运行、关闭和已终止</strong>。ExecutorService在初始创建时处于运行状态。<strong>shutdown方法将执行平缓的关闭过程:不再接受新的任务，同时等待已经提交的任务执行完成—―包括那些还未开始执行的任务。shutdownNow方法将执行粗暴的关闭过程:它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</strong><br>在ExecutorService关闭后提交的任务将由“拒绝执行处理器(Rejected Execution Handler)”来处理，<strong>它会抛弃任务，或者使得execute方法抛出一个未检查的RejectedExecutionException。</strong>等所有任务都完成后，ExecutorService将转入终止状态。<strong>可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询ExecutorService是否已经终止。通常在调用awaitTermination之后会立即调用shutdown，从而产生同步地关闭ExecutorService的效果</strong>。</p>
<h4 id="延迟任务与周期任务"><a href="#延迟任务与周期任务" class="headerlink" title="延迟任务与周期任务"></a>延迟任务与周期任务</h4><p>Timer类负责管理延迟任务(“在100ms后执行该任务”)以及周期任务(“每10ms执行一次该任务”)。然而，Timer存在一些缺陷，因此应该考虑使用<code>ScheduledThreadPoolExecutor</code> 来代替它。可以通过构造函数或<code>newScheduledThreadPool</code> 工厂方法来创建该类的对象。<br>Timer在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其他TimerTask的定时精确性。<br>Timer的另一个问题是，如果TimerTask抛出了一个未检查的异常，那么Timer将表现出糟糕的行为。<strong>Timer线程并不捕获异常，因此当TimerTask 抛出未检查的异常时将终止定时线程。</strong>这种情况下，Timer也不会恢复线程的执行，而是会错误地认为整个Timer都被取消了。因此，已经被调度但尚未执行的TimerTask将不会再执行，新的任务也不能被调度。这个问题称之为“线程泄漏“。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfTime</span> </span>&#123;</span><br><span class="line">    <span class="comment">//你认为程序6s结束，但是1s就结束了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(string[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	Timer timer = <span class="keyword">new</span> Timer () ;</span><br><span class="line">    	timer.schedule(<span class="keyword">new</span> ThrowTask ( ) , <span class="number">1</span>) ;</span><br><span class="line">        SECONDs.sleep (<span class="number">1</span>);</span><br><span class="line">    	timer.schedule (<span class="keyword">new</span> ThrowTask ( ) , <span class="number">1</span>) ;</span><br><span class="line">        SECONDs. sleep (<span class="number">5</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException( ) ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在Java 5.0或更高的JDK中，将很少使用Timer。</strong><br><strong>如果要构建自己的调度服务，那么可以使用DelayQueue，它实现了BlockingQueue，并为ScheduledThreadPoolExecutor提供调度功能。</strong>DelayQueue管理着一组Delayed对象。每个Delayed对象都有一个相应的延迟时间:在DelayQueue中，只有某个元素逾期后，才能从DelayQueue 中执行take操作。从DelayQueue中返回的对象将根据它们的延迟时间进行排序。</p>
<h3 id="6-3-找出可利用的并行性"><a href="#6-3-找出可利用的并行性" class="headerlink" title="6.3 找出可利用的并行性"></a>6.3 找出可利用的并行性</h3><p>如果要使用Executor，<strong>必须将任务表示为一个Runnable</strong>.大多数服务器应用程序存在一个边界：单个用户请求，在单个用户请求中仍存在并行性，如数据库服务器。</p>
<h4 id="示例：串行的页面渲染器"><a href="#示例：串行的页面渲染器" class="headerlink" title="示例：串行的页面渲染器"></a>示例：串行的页面渲染器</h4><p>最简单的方法就是对HTML文档进行串行处理。当遇到文本标签时，<strong>将其绘制到图像缓存中。当遇到图像引用时，先通过网络获取它，然后再将其绘制到图像缓存中。</strong>这很容易实现,程序只需将输入中的每个元素处理一次（甚至不需要缓存文档)，但这种方法可能会令用户感到烦恼，他们必须等待很长时间，直到显示所有的文本。<br>另一种串行执行方法更好一些，<strong>它先绘制文本元素，同时为图像预留出矩形的占位空间,在处理完了第一遍文本后，程序再开始下载图像，并将它们绘制到相应的占位空间中。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行渲染页面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singleThreadRenderer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span> <span class="params">(charsequence source)</span></span>&#123;</span><br><span class="line">        renderText ( source) ;</span><br><span class="line">        List&lt;ImageData&gt; imageData = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</span><br><span class="line">        <span class="keyword">for</span> (rmageInfo imageInfo : scanForImageInfo (source))</span><br><span class="line">        	imageData.add (imageInfo.downloadImage ( )) ;</span><br><span class="line">        <span class="keyword">for</span> ( ImageData data : imageData)</span><br><span class="line">        	renderImage (data) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="携带结果的任务Callable与Future"><a href="#携带结果的任务Callable与Future" class="headerlink" title="携带结果的任务Callable与Future"></a>携带结果的任务Callable与Future</h4><p>Executor框架使用Runnable作为其基本的任务表示形式。<strong>Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。</strong><br>许多任务实际上都是存在延迟的计算——执行数据库查询，从网络上获取资源，或者计算某个复杂的功能。对于这些任务，Callable是一种更好的抽象:<strong>它认为主入口点（即call）将返回一个值，并可能抛出一个异常。</strong><br>Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor执行的任务有4个生命周期阶段﹔<strong>创建、提交、开始和完成</strong>。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，<strong>已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能响应中断时，才能取消。取消一个已经完成的任务不会有任何影响。</strong><br><strong>Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。在 Future规范中包含的隐含意义是，任务的生命周期只能前进，不能后退，就像ExecutorService的生命周期一样。.当某个任务完成后，它就永远停留在“完成”状态上。</strong><br>get方法的行为取决于任务的状态（尚未开始、正在运行、已完成)。如果任务<strong>已经完成，那么get会立即返回或者抛出一个Exception，如果任务没有完成，那么get将阻塞并直到任务完成。</strong>如果任务抛出了异常，那么get将该异常封装为ExecutionException并重新抛出。如果任务被取消，那么get将抛出CancellationException。如果get抛出了ExecutionException，那么可以通过getCause来获得被封装的初始异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">V <span class="title">call</span> <span class="params">( )</span> <span class="keyword">throws</span> Exception </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span> <span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span> <span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span> <span class="params">( )</span> </span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span> <span class="params">( )</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, cancellationException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span> <span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,ExecutionException,</span></span><br><span class="line"><span class="function">    cancellationException,TimeoutException </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以通过许多种方法创建一个Future来描述任务。ExecutorService中的所有submit方法都将返回一个Future，从而将一个Runnable或Callable提交给Executor,</strong>并得到一个Future月来获得任务的执行结果或者取消任务。还可以显式地为某个指定的Runnable或Callable实例化一个FutureTask。</p>
<h4 id="示例-使用Future-实现页面渲染器"><a href="#示例-使用Future-实现页面渲染器" class="headerlink" title="示例:使用Future 实现页面渲染器"></a>示例:使用Future 实现页面渲染器</h4><p>首先将渲染过程分解为两个任务<strong>，一个是渲染所的文本，另一个是下载所有的图像。</strong>(因为其中一个任务是CPU密集型，而另一个任务是I/O密集型，因此这种方法即使在单CPU 系统上也能提升性能。)<br><strong>Callable和Future有助于表示这些协同任务之间的交互</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureRenderer</span> </span>&#123;	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = ... ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span> <span class="params">(charsequence source)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">final</span> List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);</span><br><span class="line">        <span class="comment">//创建了一个Callable来下载所有的图像，并将其提交到一个ExecutorService。</span></span><br><span class="line">        Callable&lt;List&lt;ImageData&gt;&gt; task =<span class="keyword">new</span> Callable&lt;List&lt;ImageData&gt;&gt; ( )&#123;</span><br><span class="line">    			<span class="function"><span class="keyword">public</span> List&lt;ImageData&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   					List&lt;ImageData&gt; result = <span class="keyword">new</span> ArrayList&lt;ImageData&gt; ( ) ;</span><br><span class="line">    				<span class="keyword">for</span> ( ImageInfo imageInfo : imageInfos)</span><br><span class="line">    					result.add (imageInfo. downloadImage ( ) );</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">    			&#125;</span><br><span class="line">    	&#125;;</span><br><span class="line">        <span class="comment">//返回一个描述任务执行情况的Future。当主任务需要图像时，它会等待Future.get的调用结果。如果幸运的话，当开始请求时所有图像就已经下载完成了，即使没有，至少图像的下载任务也已经提前开始了。</span></span><br><span class="line">    	Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit (task);</span><br><span class="line">        renderText (source) ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	List&lt;ImageData&gt; imageData =future.get ();</span><br><span class="line">            <span class="keyword">for</span> ( ImageData data : imageData)</span><br><span class="line">        		renderImage(data) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">       		<span class="comment">//重新设置线程的中断状态</span></span><br><span class="line">        	Thread.currentThread () .interrupt ( );<span class="comment">//由于不需要结果，因此取消任务</span></span><br><span class="line">        	future.cancel (<span class="keyword">true</span>) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> launderThrowable(e.getCause ());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get方法拥有“状态依赖”的内在特性，因而调用者不需要知道任务的状态，此外在任务提交和获得结果中包含的安全发布属性也确保了这个方法是线程安全的。</strong>Future.get 的异常处理代码将处理两个可能的问题:任务遇到一个Exception，或者调用get的线程在获得结果之前被中断<br>FutureRenderer使得渲染文本任务与下载图像数据的任务并发地执行。当所有图像下载完后，会显示到页面上。这将提升用户体验，不仅使用户更快地看到结果，还有效利用了并行性，但我们还可以做得更好。<strong>用户不必等到所有的图像都下载完成，而希望看到每当下载完一幅图像时就立即显示出来。</strong></p>
<h4 id="在异构任务并行化中查找的局限"><a href="#在异构任务并行化中查找的局限" class="headerlink" title="在异构任务并行化中查找的局限"></a>在异构任务并行化中查找的局限</h4><p>我们尝试并行地执行两个不同类型的任务——下载图像与渲染页面。然而，通过对异构任务进行并行化来获得重大的性能提升是很困难的。<br>两个人可以很好地分担洗碗的工作:其中一个人负责清洗，而另一个人负责烘干。然而,<strong>要将不同类型的任务平均分配给每个工人却并不容易。当人数增加时，如何确保他们能帮忙而不是妨碍其他人工作，或者在重新分配工作时，并不是容易的事情。</strong><br>当在多个工人之间分配异构的任务时，还有一个问题就是各个任务的大小可能完全不同。如果将两个任务A和B分配给两个工人，但A的执行时间是B的10倍，那么整个过程也只能加速9%。最后，当<strong>在多个工人之间分解任务时，还需要一定的任务协调开销</strong>:为了使任务分解能提高性能，这种开销不能高于并行性实现的提升。<br>FutureRenderer使用了两个任务，其中一个负责渲染文本，另一个负责下载图像。如果渲染文本的速度远远高于下载图像的速度（可能性很大)，那么程序的最终性能与串行执行时的性能差别不大，而代码却变得更复杂了。当使用两个线程时，至多能将速度提高一倍。<strong>因此,虽然做了许多工作来并发执行异构任务以提高并发度，但从中获得的并发性却是十分有限的。</strong><br><strong>只有当大量相互独立且同构的任务可以并发进行处理时，才能体现出将程序的.工作负载分配到多个任务中带来的真正性能提升。</strong></p>
<h4 id="CompletionServiceExecutor与-BlockingQueue"><a href="#CompletionServiceExecutor与-BlockingQueue" class="headerlink" title="CompletionServiceExecutor与 BlockingQueue"></a>CompletionServiceExecutor与 BlockingQueue</h4><p>如果向Executor提交了一组计算任务，并且希望在计算完成后获得结果，那么可以<strong>保留与每个任务关联的Future，然后反复使用get方法，同时将参数timeout 指定为0从而通过轮询来判断任务是否完成。</strong>这种方法虽然可行，但却有些繁琐。幸运的是，还有一种更好的方法:<strong>完成服务(CompletionService)。</strong><br><strong>CompletionService将Executor和 BlockingQueue的功能融合在一起。你可以将Callable任务提交给它来执行，然后使用类似于队列操作的 take和poll等方法来获得已完成的结果，而这些结果会在完成时将被封装为Future。</strong></p>
<h4 id="示例-使用CompletionService实现页面渲染器"><a href="#示例-使用CompletionService实现页面渲染器" class="headerlink" title="示例:使用CompletionService实现页面渲染器"></a>示例:使用CompletionService实现页面渲染器</h4><p>可以通过CompletionService从两个方面来提高页面渲染器的性能:<strong>缩短总运行时间以及提高响应性。为每一幅图像的下载都创建一个独立任务，并在线程池中执行它们，从而将串行的下载过程转换为并行的过程:这将减少下载所有图像的总时间。</strong>此外，通过从CompletionService中获取结果以及使每张图片在下载完成后立刻显示出来，能使用户获得一个更加动态和更高响应性的用户界面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line">	Renderer (Executorservice executor) &#123; <span class="keyword">this</span>.executor = executor; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span> <span class="params">(Charsequence source)</span></span>&#123;</span><br><span class="line">        List&lt;ImageInfo&gt; info = scanForImageInfo (source) ;</span><br><span class="line">        Completionservice&lt;ImageData&gt; completionservice = <span class="keyword">new</span> Executorcompletionservice&lt;ImageData&gt; (executor);</span><br><span class="line">        <span class="comment">//为每个图片都开启一个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ImageInfo imageInfo : info)</span><br><span class="line">        	completionservice.submit (<span class="keyword">new</span> callable&lt;ImageData&gt; ( ) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> ImageData <span class="title">call</span> <span class="params">()</span></span>&#123;</span><br><span class="line">                	<span class="keyword">return</span> imageinfo.downloadImage ( ) ;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;) ;</span><br><span class="line">        renderText (source) ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//陆续加载</span></span><br><span class="line">        	<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>, n = info.size( ) ; t &lt; n;t++)&#123;</span><br><span class="line">        		Future&lt;ImageData&gt; f = completionservice.take ( );</span><br><span class="line">                ImageData imageData = f.get ( ) ;</span><br><span class="line">        		renderImage (imageData) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        Thread.currentThread( ).interrupt ();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> launderThrowable(e.getCause ());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为任务设置时限"><a href="#为任务设置时限" class="headerlink" title="为任务设置时限"></a>为任务设置时限</h4><p>在有限时间内执行任务的主要困难在于，<strong>要确保得到答案的时间不会超过限定的时间，或者在限定的时间内无法获得答案。</strong>在支持时间限制的Future.get中支持这种需求:<strong>当结果可用时，它将立即返回，如果在指定时限内没有计算出结果，那么将抛出 TimeoutException。</strong><br>在使用限时任务时需要注意，<strong>当这些任务超时后应该立即停止</strong>，从而避免为继续计算一个不再使用的结果而浪费计算资源。要实现这个功能，可以由任务本身来管理它的限定时间,并且在超时后中止执行或取消任务。此时可再次使用Future，如果一个限时的get方法抛出了TimeoutException，那么可以通过Future来取消任务。如果编写的任务是可取消的，那么可以提前中止它，以免消耗过多的资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page <span class="title">renderPagewithAd</span> <span class="params">( )</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> endNanos = system.nanoTime ( ) +TIME_BUDGET;</span><br><span class="line">    <span class="comment">//它将获取广告的任务提交给一个Executor</span></span><br><span class="line">    Future&lt;Ad&gt; f = exec.submit (<span class="keyword">new</span> FetchAdTask ( )) ;</span><br><span class="line">    <span class="comment">//在等待广告的同时显示页面</span></span><br><span class="line">    Page page = renderPageBody ( );</span><br><span class="line">    Ad ad;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//只等待指定的时间长度</span></span><br><span class="line">        <span class="keyword">long</span> timeLeft = endNanos - system.nanoTime ( ) ;</span><br><span class="line">        ad = f.get (timeLeft,NANOSECONDS) ;</span><br><span class="line">    <span class="comment">//如果get超时，那么将取消广告获取任务，并转而使用默认的广告信</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">        ad = DEFAULT_AD;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (TimeoutException e)&#123;</span><br><span class="line">    	ad = DEFAULT_AD;</span><br><span class="line">    	f.cancel (<span class="keyword">true</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    page.setAd (ad);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="示例：旅行预订门户网站"><a href="#示例：旅行预订门户网站" class="headerlink" title="示例：旅行预订门户网站"></a>示例：旅行预订门户网站</h4><p>考虑这样一个旅行预定门户网站:用户输入旅行的日期和其他要求，门户网站获取并显示来自多条航线、旅店或汽车租赁公司的报价。在获取不同公司报价的过程中，可能会调用Web服务、访问数据库、执行一个EDI事务或其他机制。在这种情况下，<strong>不宜让页面的响应时间受限于最慢的响应时间，而应该只显示在指定时间内收到的信息。</strong>对于没有及时响应的服务提供者，页面可以忽略它们，或者显示–个提示信息，例如“Did not hear from Air Java in time。”<br><strong>从一个公司获得报价的过程与从其他公司获得报价的过程无关，因此可以将获取报价的过程当成一个任务，从而使获得报价的过程能并发执行。</strong>创建n个任务，将其提交到一个线程池，保留n个 Future，并使用限时的get方法通过Future串行地获取每一个结果，这一切都很简单，<strong>但还有一个更简单的方法—-—invokeAll。</strong><br>支持限时的invokeAll，将多个任务提交到一个ExecutorService并获得结果。InvokeAll方法的参数为一组任务，并返回一组Future。这两个集合有着相同的结构。<strong>invokeAll 按照任务集合中迭代器的顺序将所有的Future添加到返回的集合中，从而使调用者能将各个Future与其表示的Callable 关联起来。当所有任务都执行完毕时，或者调用线程被中断时，又或者超过指定时限时，invokeAll将返回。</strong>当超过指定时限后，任何还未完成的任务都会取消。当invokeAll返回后，每个任务要么正常地完成，要么被取消，而客户端代码可以调用get 或isCancelled来判断究竟是何种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QuoteTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">TravelQuote</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Travelcompany company ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelInfo travelInfo;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TravelQuote <span class="title">call</span> <span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> company.solicitQuote (travelInfo) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TravelQuote&gt; <span class="title">getRankedTravelQuotes</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TravelInfo travelInfo,Set&lt;Travelcompany&gt; companies,</span></span></span><br><span class="line"><span class="params"><span class="function">    Comparator&lt;TravelQuote&gt; ranking，<span class="keyword">long</span> time，TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//去那几个公司网站查找</span></span><br><span class="line">    List&lt;QuoteTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;QuoteTask&gt;( );</span><br><span class="line">    <span class="keyword">for</span> (Travelcompany company : companies)</span><br><span class="line">    	tasks.add(<span class="keyword">new</span> QuoteTask(company, travelInfo) ) ;</span><br><span class="line">    <span class="comment">//Future列表</span></span><br><span class="line">    List&lt;Future&lt;TravelQuote&gt;&gt; futures =exec.invokeAll(tasks, time, unit);</span><br><span class="line">    </span><br><span class="line">    List&lt;TravelQuote&gt; quotes =<span class="keyword">new</span> ArrayList&lt;TravelQuote&gt;(tasks.size ()) ;</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;QuoteTask&gt; taskIter = tasks.iterator () ;</span><br><span class="line">    <span class="comment">//遍历每一个Future,执行相应的搜索任务</span></span><br><span class="line">    <span class="keyword">for</span> (Future&lt;TravelQuote&gt; f : futures) &#123;</span><br><span class="line">    	QuoteTask task = taskIter.next ( ) ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将每一个搜索结果添加到最后的列表中</span></span><br><span class="line">        	quotes.add(f.get ()) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">        	quotes.add (task.getFailureQuote (e.getCause ())) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (cancellationException e) &#123;</span><br><span class="line">        	quotes.add (task.getTimeoutQuote(e) ) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort (quotes, ranking) ;</span><br><span class="line">    <span class="keyword">return</span> quotes ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、取消与关闭"><a href="#七、取消与关闭" class="headerlink" title="七、取消与关闭"></a>七、取消与关闭</h2><p>要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了<strong>中断</strong>（Interruption)，这是一种协作机制，能够使-一-个线程终止另一个线程的当前工作。<br>这种协作式的方法是必要的，我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。相反，在编写任务和服务时可以使用-一种协作的方式:<strong>当需要停止时，它们首先会清除当前正在执行的工作，然后再结束。</strong></p>
<h3 id="7-1-任务取消"><a href="#7-1-任务取消" class="headerlink" title="7.1 任务取消"></a>7.1 任务取消</h3><p><strong>如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就可以称为可取消的</strong>(Cancellable)。取消某个操作的原因很多:</p>
<ul>
<li><strong>用户请求取消</strong>。用户点击图形界面程序中的“取消”按钮，或者通过管理接口来发出取消请求，例如JMX (Java Management Extensions)。</li>
<li><strong>有时间限制的操作</strong></li>
<li>应用程序事件。例如，应用程序对某个问题空间进行分解并搜索，从而使不同的任务可以搜索问题空间中的不同区域。当其中一个任务找到了解决方案时，所有其他仍在搜索的任务都取消</li>
<li><strong>错误</strong>。</li>
<li><strong>关闭</strong>。当一个程序或服务关闭时，必须对正在处理和等待处理的工作执行某种操作。在平缓的关闭过程中，当前正在执行的任务将继续执行直到完成，而在立即关闭过程中，当前的任务则可能取消。</li>
</ul>
<p>其中一种协作机制能<strong>设置某个“已请求取消(Cancellation Requested)”标志</strong>，而任务将定期地查看该标志。如果设置了这个标志，那么任务将提前结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedEy</span> ( <span class="string">&quot;this&quot;</span> )</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Eist&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayList&lt;BigInteger&gt; ();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    	BigInteger p = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span> (!cancelled)&#123;</span><br><span class="line">    		p = p.nextProbablePrime ();</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    			primes.add(p) ;</span><br><span class="line">            &#125;</span><br><span class="line">   	 	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置cancelled标志</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span> <span class="params">( )</span> </span>&#123; cancelled = <span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title">get</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即让素数生成器运行1秒钟后取消。素数生成器通常并不会刚好在运行1秒钟后停止，因为在请求取消的时刻和run方法中循环执行下一次检查之间可能存在延迟。cancel方法由finally块调用，从而确保即使在调用sleep时被中断也能取消素数生成器的执行。如果cancel没有被调用，那么搜索素数的线程将永远运行下去，不断消耗CPU的时钟周期，并使得JVM不能正常退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;BigInteger&gt; <span class="title">asecondofPrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">	PrimeGenerator generator </span>= <span class="keyword">new</span> PrimeGenerator ();</span><br><span class="line">	<span class="keyword">new</span> Thread(generator).start( ) ;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		SECONDS.sleep(<span class="number">1</span>) ;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		generator.cancel();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> generator.get() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个可取消的任务必须拥有取消策略，<strong>其他代码如何(How）请求取消该任务，任务在可时(When)检查是否已经请求了取消，以及在响应取消请求时应该执行哪些（What）操作。</strong>。<br>PrimeGenerator使用了一种简单的取消策略:客户代码通过调用cancel来请求取消，primeGenerator在每次搜索素数前首先检查是否存在取消请求，如果存在则退出。</p>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>PrimeGenerator中的取消机制最终会使得搜索素数的任务退出，但在退出过程中需要花费一定的时间。<strong>然而，如果使用这种方法的任务调用了一个阻塞方法，例如BlockingQueue.put,那么可能会产生一个更严重的问题——任务可能永远不会检查取消标志，因此永远不会结束。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">生产者线程生成素数，并将它们放入一个阻塞队列。如果生产者的速度超过了消费者的处理速度，队列将被填满，put方法也会阻塞。当生产者在put方法中阻塞时，如果消费者希望取消生产者任务，那么将发生什么情况﹖它可以调用cancel方法来设置cancelled标志，但此时生产者却永远不能检查这个标志，因为它无法从阻塞的put方法中恢复过来（因为消费者此时已经停止从队列中取出素数，所以put方法将一直保持阻塞状态)。*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> B1ockingQueue&lt;BigInteger&gt; queue ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cance1led = <span class="keyword">false</span> ;</span><br><span class="line">	BrokenPrimeProducer (B1ockingQueue&lt;BigInteger&gt; queue)&#123;</span><br><span class="line">		<span class="keyword">this</span>.queue = queue ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span> ( !cancelled)</span><br><span class="line">        		queue.put (p = p.nextProbablePrime()) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException consumed)&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123; cancelled = <span class="keyword">true</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumePrimes</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    BlockingQueue&lt;BigInteger&gt; primes = ...;</span><br><span class="line">    BrokenPrimeProducer producer = <span class="keyword">new</span> BrokenPrimeProducer (primes);</span><br><span class="line">    producer.start ( ) ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="keyword">while</span> (needMorePrimes ())</span><br><span class="line">    		consume (primes.take ());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    	producer.cancel ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程。<strong>每个线程都有一个boolean的中断标志,当中断线程时，这个线程的中断状态将被设置为true。在Thread中包含了中断线程以及查询线程中断状态的方法</strong>，interrupt方法能中断目标线程，而isInterrupted方法能返回目标线程的中断状态。静态的interrupted方法将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。</p>
<p>对中断操作的正确理解是：<strong>它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。</strong>(这些时刻也被称为取消点)。有些方法，例如<strong>wait、sleep和join</strong>等，将严格地处理这种请求，当它们收到中断请求或者在开始执行时发现某个已被设置好的中断状态时，将抛出一个异常。设计良好的方法可以完全忽略这种请求，只要它们能使调用代码对中断请求进行某种处理。设计糟糕的方法可能会屏蔽中断请求，从而导致调用栈中的其他代码无法对中断请求作出响应。<br>在使用静态的interrupted时应该小心，因为它会清除当前线程的中断状态。如果在调用interrupted时返回了true，<strong>那么除非你想屏蔽这个中断，否则必须对它进行处理——可以抛出InterruptedException</strong>，或者通过再次调用interrupt来恢复中断状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用中断而不是boolean标志来取消</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue)&#123;</span><br><span class="line">    	<span class="keyword">this</span>.queue = queue ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	BigInteger p = BigInteger.ONE;</span><br><span class="line">        	<span class="keyword">while</span> (!Thread.currentThread( ).isInterrupted())</span><br><span class="line">        		queue.put (p = p.nextProbablePrime()) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException consumed)&#123;</span><br><span class="line">            <span class="comment">/*允许线程退出*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span> <span class="params">( )</span> </span>&#123; interrupt ( ) ; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h4><p>中断策略规定线程如何解释某个中断请求，当发现中断请求时，应做哪些工作，哪些工作单元对于中断来说是原子操作，以及多快速度来相应中断。</p>
<h4 id="相应中断"><a href="#相应中断" class="headerlink" title="相应中断"></a>相应中断</h4><p>当调用可中断的阻塞函数时，例如<strong>Thread.sleep或BlockingQueue.put</strong>等，有两种实用策略可用于处理InterruptedException;</p>
<ul>
<li>传递异常（可能在执行某个特定于任务的清除操作之后)，从而使你的方法也成为可中断的阻塞方法。</li>
<li>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于一些不支持取消但仍然可以调用可中断阻塞的方法，他们必须在循环中调用这些方法，并在中断后重新尝试，如果过早的设置中断状态，就会引起无线循环因为大多数可中断的阻塞方法都会在入口检查中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span> <span class="params">(BlockingQueue&lt;Taskgt ; queue)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> interrupted = <span class="keyword">false</span> ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="keyword">return</span> queue.take () ;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            	interrupted = <span class="keyword">true</span> ;</span><br><span class="line">                <span class="comment">//重新尝试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (interrupted)</span><br><span class="line">    		Thread.currentThread ( ) .interrupt () ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="示例：计时运行"><a href="#示例：计时运行" class="headerlink" title="示例：计时运行"></a>示例：计时运行</h4><p>许多问题永远无法解决，例如枚举所有的素数。</p>
<p>在执行任务时的另一个方面是，<strong>你希望知道在任务执行过程中是否会抛出异常如果PrimeGenerator在指定时限内抛出了一个未检查的异常，那么这个异常可能会被忽略，因为素数生成器在另一个独立的线程中运行，而这个线程并不会显式地处理异常。</strong><br>在程序清单7-8中给出了在指定时间内运行一个任意的Runnable的示例。它在调用线程中运行任务，并安排了一个取消任务，在运行指定的时间间隔后中断它。这解决了从任务中抛出未检查异常的问题，因为该异常会被timedRun的调用者捕获。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在外部线程中安排中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> scheduledBxecutorservice cancelExec = ...;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span> <span class="params">(Runnable r,<span class="keyword">long</span> timeout,TimeUnit unit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Thread taskThread = Thread.currentThread ( );</span><br><span class="line">	cancelExec.schedule (<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123; taskThread.interrupt ()；&#125;</span><br><span class="line">    &#125;, timeout, unit) ;</span><br><span class="line">	r.run () ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过Future来实现取消"><a href="#通过Future来实现取消" class="headerlink" title="通过Future来实现取消"></a>通过Future来实现取消</h4><p>ExecutorService.submit将返回一个Future来描述任务。Future拥有一个cancel方法，该方法带有一个boolean类型的参数mayInterruptIfRunning，表示取消操作是否成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span> <span class="params">(Runnable r,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">long</span> timeout, TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//将任务提交给ExecutorService</span></span><br><span class="line">	Future&lt;?&gt; task = taskExec.submit(r) ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过定时任务Future.get来获得结果</span></span><br><span class="line">    	task.get (timeout, unit);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">    	<span class="comment">//接下来任务将被取消</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">        <span class="comment">//如果在任务中抛出了异常，那么重新抛出该异常</span></span><br><span class="line">        <span class="keyword">throw</span> launderThrowable(e.getCause ( ));</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    	<span class="comment">//如果任务已经结束，那么执行取消操作也不会带来任何影响</span></span><br><span class="line">    task.cancel (<span class="keyword">true</span>);/如果任务正在运行，那么将被中断</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当Future.get 抛出 <code>InterruptedException</code>或 <code>TimeoutException</code>时,如果你知道不再需要结果,那么就可以调用Future.cancel来取消任务。</p>
<h4 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h4><p>对于那些由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止线程，但要求我们知道线程阻塞的原因：</p>
<ul>
<li><p><strong>Java.io包中的同步Socket l/O。</strong>在服务器应用程序中，最常见的阻塞I/O形式就是对套接字进行读取和写入。虽然InputStream和OutputStream中的read和 write等方法都不会响应中断，但通过关闭底层的套接字，可以使得由于执行read或write等方法而被阻塞的线程抛出一个SocketException。</p>
</li>
<li><p><strong>Java.io包中的同步IO。</strong></p>
</li>
<li><p><strong>Selector的异步IO。</strong>如果一个线程在调用Selector.select方法（在java.nio.channels 中)时阻塞了，那么调用close或wakeup方法会使线程抛出 ClosedSelectorException 并提前返回。</p>
</li>
<li><p><strong>获取某个锁。</strong>如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断，因为线程认为它肯定会获得锁，所以将不会理会中断请求。但是，在Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReaderThread管理了一个套接字连接，它采用同步方式从该套接字中读取数据,并将接收到的数据传递给processBuffer。为了结束某个用户的连接或者关闭服务器，ReaderThread改写了interrupt方法，使其既能处理标准的中断，也能关闭底层的套接字。因此，无论ReaderThread线程是在read方法中阻塞还是在某个可中断的阻塞方法中阻塞，都可以被中断并停止执行当前的工作。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> socket socket ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Inputstream in;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReaderThread</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket ;</span><br><span class="line">        <span class="keyword">this</span>.in = socket.getInputstream ( );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">       	 	socket.close( ) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException ignored)&#123;&#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">        	<span class="keyword">super</span>.interrupt ( );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[]buf = <span class="keyword">new</span> <span class="keyword">byte</span> [BUFSZ];</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> count = in.read ( buf) ;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">0</span> )</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; o)</span><br><span class="line">                    processBuffer (buf,count) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123; <span class="comment">/*允许线程退出*/</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="采用newTaskFor来封装非标准的取消"><a href="#采用newTaskFor来封装非标准的取消" class="headerlink" title="采用newTaskFor来封装非标准的取消"></a>采用newTaskFor来封装非标准的取消</h4><p>当把一个 Callable提交给ExecutorService时,<strong>submit方法会返回一个Future，我们可以通过这个Future来取消任务。newTaskFor是一个工厂方法，它将创建Future来代表任务。</strong>newTaskFor还能返回一个RunnableFuture接口，该接口扩展了Future和 Runnable (并由FutureTask实现)。<br><strong>通过定制表示任务的Future可以改变Future.cancel 的行为。</strong>例如，定制的取消代码可以实现日志记录或者收集取消操作的统计信息，<strong>以及取消一些不响应中断的操作。</strong>通过改写interrupt方法，ReaderThread可以取消基于套接字的线程。同样，通过改写任务的Future.cancel方法也可以实现类似的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个CancellableTask接口，该接口扩展了Callable,并增加了一个cancel方法和一个newTask 工厂方法来构造RunnableFuture。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CancellableTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span> <span class="params">( )</span> </span>;</span><br><span class="line">    <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTask</span> <span class="params">( )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CancellingExecutor扩展了ThreadPoolExecutor，并通过改写newTaskFor使得CancellableTask可以创建自己的Future。</span></span><br><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancellingExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="keyword">protected</span>&lt;T&gt; RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (callable <span class="keyword">instanceof</span> cancellableTask)</span><br><span class="line">			<span class="keyword">return</span> ( (cancellableTask&lt;T&gt;) callable) .newTask ();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.newTaskFor (callable) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SocketUsingTask实现了CancellableTask，并定义了Future.cancel来关闭套接字和调用super.cancel。如果SocketUsingTask通过其自己的 Future来取消，那么底层的套接字将被关闭并且线程将被中断。因此它提高了任务对取消操作的响应性∶不仅能够在调用可中断方法的同时确保响应取消操作，而且还能调用可阻调的套接字IO方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketUsingTask</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="keyword">implements</span> <span class="title">CancellableTask</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> Socket socket ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSocket</span> <span class="params">(Socket s)</span> </span>&#123; socket = s;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cancel</span> <span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">        		socket.close ( ) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored)&#123; &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RunnableFuture&lt;T&gt; <span class="title">newTask</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(<span class="keyword">this</span>) &#123;</span><br><span class="line">    		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span> <span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>&#123;</span><br><span class="line">    			<span class="keyword">try</span> &#123;</span><br><span class="line">    				SocketUsingTask.<span class="keyword">this</span>.cancel( ) ;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.cancel( mayInterruptIfRunning) ;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-停止基于线程的服务"><a href="#7-2-停止基于线程的服务" class="headerlink" title="7.2 停止基于线程的服务"></a>7.2 停止基于线程的服务</h3><p>应用程序通常会创建拥有多个线程的服务，例如线程池，并且这些服务的生命周期通常比创建它们的方法的生命周期更长。如果应用程序准备退出，那么这些服务所拥有的线程也需要结束。由于无法通过抢占式的方法来停止线程，因此它们需要自行结束。<br><strong>正确的封装原则是:除非拥有某个线程，否则不能对该线程进行操控。</strong>例如，中断线程或者修改线程的优先级等。在线程API中，并没有对线程所有权给出正式的定义:线程由Thread对象表示，并且像其他对象一样可以被自由共享。然而，<strong>线程有一个相应的所有者，,即创建该线程的类。因此线程池是其工作者线程的所有者，如果要中断这些线程，那么应该使用线程池。</strong><br>与其他封装对象一样，线程的所有权是不可传递的:<strong>应用程序可以拥有服务，服务也可以拥有工作者线程，但应用程序并不能拥有工作者线程，因此应用程序不能直接停止工作者线程。</strong>相反，服务应该提供生命周期方法(Lifecycle Method)来关闭它自己以及它所拥有的线程。这样，当应用程序关闭该服务时，服务就可以关闭所有的线程了。在ExecutorScevice 中提供了shutdown和 shutdownNow等方法。同样，在其他拥有线程的服务中也应该提供类似的关闭机制。</p>
<h4 id="示例：日志服务"><a href="#示例：日志服务" class="headerlink" title="示例：日志服务"></a>示例：日志服务</h4><p>将调用log方法将日志放入某个队列中，交给其他线程来处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LogWriter中给出了一个简单的日志服务示例，其中日志操作在单独的日志线程中执行。产生日志消息的线程并不会将消息直接写入输出流，而是由LogWrite通过BlockingQueue将消息提交给日志线程，并由日志线程写入。这是一种多生产者单消费者(Multiple-Producer,Single-Consumer）的设计方式:每个调用log 的操作都相当于一个生产者，而后台的日志线程则相当于消费者。如果消费者的处理速度低于生产者的生成速度，那么BlockingQueue将阻塞生产者，直到日志线程有能力处理新的日志消息。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogWriter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;string&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logwriter</span> <span class="params">(Writer writer)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(CAPACITY);</span><br><span class="line">        <span class="keyword">this</span>.logger = <span class="keyword">new</span> LoggerThread(writer);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123; logger.start (); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(string msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    	queue.put (msg) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Printwriter writer;</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            		writer.println (queue.take ( ) ) ;</span><br><span class="line">            &#125;<span class="keyword">catch</span> ( InterruptedException ignored)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writer.close ( ) ;</span><br><span class="line">  		     &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要一种终止日志线程的方法，避免使JVM无法正常关闭。</p>
<p>要停止日志线程是很容易的，因为它会反复调用take，而take能响应中断。<strong>如果将日志线程修改为当捕获到InterruptedException时退出，那么只需中断日志线程就能停止服务。</strong><br>然而，如果只是使日志线程退出，那么还不是一种完备的关闭机制。<strong>这种直接关闭的做法会丢失那些正在等待被写入到日志的信息，不仅如此，其他线程将在调用log时被阻塞，因为日志消息队列是满的，因此这些线程将无法解除阻塞状态。</strong>当取消一个生产者-消费者操作时，需要同时取消生产者和消费者。在中断日志线程时会处理消费者，但在这个示例中，由于生者并<br>另一种关闭LogWriter的方法是<strong>:设置某个“已请求关。在收到关闭请求后，消费者会把队列中的所有消息写入日志,解除所有在调用log时阻塞的生产者。</strong>然而，在这个方法中存在着竞态条件问题，使得该方并不可靠。log 的实现是一种“先判断再运行”的代码序列:生产者发现该服务还没有关闭，此在关闭服务后仍然会将日志消息放入队列，这同样会使得生产者可能在调用log时阻塞并无法解除阻塞状态。可以通过一些技巧来降低这种情况的发生概率</p>
<p>为LogWriter提供可靠关闭操作的方法是解决竞态条件问题<strong>，因而要使日志消息的提交操作成为原子操作。</strong>然而，我们不希望在消息加入队列时去持有一个锁，因为put方法本身就可以阻塞。我们采用的方法是:<strong>通过原子方式来检查关闭请求，并且有条件地递增一个计数器来“保持”提交消息的权利。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logservice</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread loggerThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Printwriter writer ;</span><br><span class="line">    <span class="comment">//是否关闭</span></span><br><span class="line">	<span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> <span class="keyword">boolean</span> isShutdown ;</span><br><span class="line">    <span class="comment">//计数器</span></span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> <span class="keyword">int</span> reservations ;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123; loggerThread.start ( ) ; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span> <span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; isShutdown = <span class="keyword">true</span>; &#125;</span><br><span class="line">        loggerThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(string msg)</span> <span class="keyword">throws</span> InterruptedBxception </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isShutdown)</span><br><span class="line">            	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalstateException (...) ;</span><br><span class="line">            ++reservations ;</span><br><span class="line">        &#125;</span><br><span class="line">        gueue.put (msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//原子方式来检查关闭请求</span></span><br><span class="line">                    	<span class="keyword">synchronized</span> (Logservice.<span class="keyword">this</span>)&#123;</span><br><span class="line">                    		<span class="keyword">if</span> (isshutdown &amp;&amp; reservations ==o)</span><br><span class="line">                   				<span class="keyword">break</span> ;</span><br><span class="line">                    	&#125;</span><br><span class="line">                    	String msg = queue.take () ;</span><br><span class="line">                        <span class="comment">//记录一个就</span></span><br><span class="line">                    	<span class="keyword">synchronized</span> (LogService.<span class="keyword">this</span>) &#123; --reservations;&#125; 								writer.println (msg) ;</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;<span class="comment">/*retry */</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                writer.close ( ) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关闭ExecutorService"><a href="#关闭ExecutorService" class="headerlink" title="关闭ExecutorService"></a>关闭ExecutorService</h4><p>ExecutorService提供了两种关闭方法:<strong>使用shutdown正常关闭,以及使用shutdownNow强行关闭</strong>。在进行强行关闭时，shutdownNow首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单。<br>这两种关闭方式的差别在于各自的安全性和响应性:<strong>强行关闭的速度更快，但风险也更大，因为任务很可能在执行到一半时被结束﹔而正常关闭虽然速度慢，但却更安全，因为ExecutorService 会一直等到队列中的所有任务都执行完成后才关闭。</strong>在其他拥有线程的服务中也应该考虑提供类似的关闭方式以供选择。<br>简单的程序可以直接在main 函数中启动和关闭全局的ExecutorService。而在复杂程序中，通常会将ExecutorService封装在某个更高级别的服务中，并且该服务能提供其自己的生命周期方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它将管理线程的工作委托给一个 ExecutorService，而不是由其自行管理。通过封装ExecutorService，可以将所有权链(Ownership Chain）从应用程序扩展到服务以及线程，所有权链上的各个成员都将管理它所拥有的服务或线程的生命周期。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = <span class="keyword">new</span> SingleThreadExecutor( ) ;:..</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	exec.shutdown ();</span><br><span class="line">        	exec.awaitTermination (TIMEOUr,UNIT);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			writer.close () ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span> <span class="params">(string msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	exec.execute (<span class="keyword">new</span> writeTask (msg) ) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RejectedExecutionException ignored)&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="毒丸对象"><a href="#毒丸对象" class="headerlink" title="毒丸对象"></a>毒丸对象</h4><p>另-种关闭生产者一消费者服务的方式就是使用“毒丸(Poison Pill)”对象:“毒丸”是指<strong>一个放在队列上的对象，其含义是:“当得到这个对象时，立即停止。</strong>”在FIFO（先进先出）队列中，<strong>“毒丸”对象将确保消费者在关闭之前首先完成队列中的所有工作，在提交“毒丸”对象之前提交的所有工作都会被处理，而生产者在提交了“毒丸”对象后，将不会再提交任何工作。</strong></p>
<p>给出一个单生产者-单消费者的桌面搜索示例（来自程序清单5-8)，在这个示例中使用了“毒丸”对象来关闭服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单生产者-单消费者的桌面搜索</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Indexingservice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File POISON = <span class="keyword">new</span> File (<span class="string">&quot;&quot;</span>) ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IndexerThread consumer = <span class="keyword">new</span> IndexerThread( ) ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CrawlerThread producer = <span class="keyword">new</span> CrawlerThread ( ) ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;File&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileFilter fileFilter ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File root ;</span><br><span class="line">    <span class="comment">//生产者线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrawlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                crawl (root);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123; <span class="comment">/*发生异常*/</span>&#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ( <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//重点</span></span><br><span class="line">                        queue.put (POISON);</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> ( InterruptedException e1) &#123;<span class="comment">/*重新尝试*/</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">crawl</span><span class="params">(File root)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//消费者线程    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    File file = queue.take ();</span><br><span class="line">                    <span class="comment">//重点</span></span><br><span class="line">                    <span class="keyword">if</span>(fle == POISON)</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        indexFile(file) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException consumed)&#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		producer.start () ;</span><br><span class="line">        consumer.start () ;</span><br><span class="line">	&#125;</span><br><span class="line">                                       </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span> <span class="params">()</span> </span>&#123; producer.interrupt( ) ; &#125;</span><br><span class="line">                                       </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitTermination</span> <span class="params">( )</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		consumer.join ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只有在生产者和消费者的数量都已知的情况下，才可以使用“毒丸”对象。</strong></p>
<h4 id="示例：只执行一次的服务"><a href="#示例：只执行一次的服务" class="headerlink" title="示例：只执行一次的服务"></a>示例：只执行一次的服务</h4><p><strong>如果某个方法需要处理一批任务，并且当所有任务都处理完成后才返回，那么可以通过一个私有的Executor来简化服务的生命周期管理，其中该Executor 的生命周期是由这个方法来控制的。</strong>(在这种情况下，invokeAll和invokeAny等方法通常会起较大的作用。)</p>
<h4 id="shutdownNow的局限性"><a href="#shutdownNow的局限性" class="headerlink" title="shutdownNow的局限性"></a>shutdownNow的局限性</h4><p>当通过shutdownNow来强行关闭ExecutorService时，<strong>它会尝试取消正在执行的任务，并返回所有已提交但尚未开始的任务，从而将这些任务写入日志或者保存起来以便之后进行处理。</strong><br>要知道哪些任务还没有完成，你不仅需要知道哪些任务还没有开始，而且还需要知道当Executor 关闭时哪些任务正在执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过封装ExecutorService并使得execute（类似地还有submit，在这里没有给出）记录哪些任务是在关闭后取消的，TrackingExecutor可以找出哪些任务已经开始但还没有正常完成。在Executor结束后，getCancelledTasks返回被取消的任务清单。要使这项技术能发挥作用，任务在返回时必须维持线程的中断状态，在所有设计良好的任务中都会实现这个功能。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackingExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executorservice exec ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> set&lt;Runnable&gt; tasksCancelledAtshutdown =</span><br><span class="line">		Collections.synchronizedset (<span class="keyword">new</span> HashSet&lt;Runnable&gt; () ) ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">getCancelledTasks</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !exec.isTerminated ( ))</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalstateException (...) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Runnable&gt; (tasksCancelledAtshutdown) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span> <span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">    	exec.execute (<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">    		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    			<span class="keyword">try</span> &#123;</span><br><span class="line">    				runnable.run ( ) ;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    				<span class="keyword">if</span> ( isshutdown ( )</span><br><span class="line">    					&amp;&amp; Thread.currentThread ( ).isInterrupted ())</span><br><span class="line">                        tasksCancelledAtshutdown.add (runnable) ;</span><br><span class="line">    			&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将Executorservice的其他方法委托给exec</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WebCrawler中给出了TrackingExecutor的用法。网页爬虫程序的工作通常是无穷尽的，因此当爬虫程序必须关闭时，我们通常希望保存它的状态，以便稍后重新房动。CrawlTask提供了一个getPage方法，该方法能找出正在处理的页面。当爬虫程序关闭时无论是还没有开始的任务，还是那些被取消的任务，都将记录它们的URL，因此当爬虫程序重新启动时，就可以将这些URL的页面抓取任务加入到任务队列中。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">webCrawler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> TrackingExecutor exec ;</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> )</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> set&lt;URL&gt; urlsToCrawl = <span class="keyword">new</span> Hashset&lt;URL&gt; ( ) ;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    	exec = <span class="keyword">new</span> TrackingExecutor (Executors.newCachedThreadPool ());</span><br><span class="line">        <span class="comment">//为每一个url提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (URL url : urlsToCrawl) submitcrawlTask (url) ;</span><br><span class="line">        urlsToCrawl.clear () ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//停止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            saveUncrawled ( exec. shutdownNow () ;</span><br><span class="line">            <span class="keyword">if</span> ( exec.awaitTermination (TIMEOUT,UNIT))</span><br><span class="line">            	saveUncrawled (exec.getcancelledTasks ( ));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             exec = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;URL&gt;processPage (URL url) ;</span><br><span class="line">    <span class="comment">//保存没有爬取的页面                       </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveUncrawled</span> <span class="params">(List&lt;Runnable&gt; uncrawled)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Runnable task : uncrawled)</span><br><span class="line">        	urlsToCrawl.add (((crawlTask) task).getPage()) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始爬取                       </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitcrawlTask</span> <span class="params">(URL u)</span></span>&#123;</span><br><span class="line">    	exec.execute (<span class="keyword">new</span> crawlTask(u));</span><br><span class="line">    &#125;</span><br><span class="line">                           </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CrawlTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    	...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (URL link : processPage (url))&#123;</span><br><span class="line">            	<span class="keyword">if</span> (Thread.currentThread().isInterrupted ())</span><br><span class="line">                	<span class="keyword">return</span> ;</span><br><span class="line">                submitCrawlTask (link) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">URLgetPage</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> url ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在TrackingExecutor中存在一个不可避免的竞态条件，从而产生“误报”问题:<strong>一些被认为已取消的任务实际上已经执行完成</strong>。这个问题的原因在于，在任务执行最后一条指令以及线程池将任务记录为“结束”的两个时刻之间，线程池可能被关闭。如果任务是幂等的(Idempotent，即将任务执行两次与执行一次会得到相同的结果)，那么这不会存在问题，在网页爬虫程序中就是这种情况。否则，在应用程序中必须考虑这种风险，并对“误报”问题做好准备。</p>
<h3 id="7-3-处理非正常的线程终止"><a href="#7-3-处理非正常的线程终止" class="headerlink" title="7.3 处理非正常的线程终止"></a>7.3 处理非正常的线程终止</h3><p><strong>如果并发程序中的某个线程发生故障，在控制台中可能会输出栈追踪信息，但没有人会观察控制台。此外，当线程发生故障时，应用程序可能看起来仍然在工作，所以这个失败很可能会被忽略。幸运的是，我们有可以监测并防止在程序中“遗漏”线程的方法。</strong><br>导致线程提前死亡的最主要原因就是<code>RuntimeException</code>。由于这些异常表示出现了某种编程错误或者其他不可修复的错误，因此它们通常不会被捕获。它们不会在调用栈中逐层传递,而是默认地在控制台中输出栈追踪信息，并终止线程。<br>线程非正常退出的后果可能是良性的，也可能是恶性的，这要取决于线程在应用程序中的作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在线程池内部构建一个工作者线程。如果任务抛出了一个未检查异常，那么它将使线程终结，但会首先通知框架该线程已经终结。然后，框架可能会用新的线程来代替这个工作线程，也可能不会，因为线程池正在关闭，或者当前已有足够多的线程能满足需要。ThreadPoolExecutor和 Swing都通过这项技术来确保行为糟糕的任务不会影响到后续任务的执行。当编写一个向线程池提交任务的工作者线程类时，或者调用不可信的外部代码时（例如动态加载的插件)，使用这些方法中的某一种可以避免某个编写得糟糕的任务或插件不会影响调用它的整个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run &#123;</span><br><span class="line">	Throwable thrown = <span class="keyword">null</span> ;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( !isInterrupted ())</span><br><span class="line">        	runTask (getTaskFromworkQueue () ) ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">    	thrown = e ;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    	threadExited (<span class="keyword">this</span>, thrown) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post_share"><div class="social-share" data-image="/./img/photo-1628009193228-076ab63d655a.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86(2)/"><img class="prev-cover" src="/./img/photo-1465188162913-8fb5709d6d57.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java并发编程实战--第二部分 结构化并发应用程序(2)</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/09/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git-%E5%BB%96%E9%9B%AA%E5%B3%B0/"><img class="next-cover" src="/./img/photo-1627819376920-9faac124cf13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Git-廖雪峰</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/01/23/读书笔记/java并发编程实战第三部分/" title="java并发编程实战--第三部分 活跃性、性能与测测"><img class="cover" src="/./img/photo-1465188162913-8fb5709d6d57.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-23</div><div class="title">java并发编程实战--第三部分 活跃性、性能与测测</div></div></a></div><div><a href="/2021/01/22/读书笔记/java并发编程实战第二部分(2)/" title="java并发编程实战--第二部分 结构化并发应用程序(2)"><img class="cover" src="/./img/photo-1465188162913-8fb5709d6d57.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-22</div><div class="title">java并发编程实战--第二部分 结构化并发应用程序(2)</div></div></a></div><div><a href="/2021/01/24/读书笔记/java并发编程实战第四部分(1)/" title="java并发编程实战--第四部分 高级主题"><img class="cover" src="/./img/photo-1626277787644-47d530591292.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-24</div><div class="title">java并发编程实战--第四部分 高级主题</div></div></a></div><div><a href="/2020/08/25/读书笔记/java并发编程实战第一部分/" title="java并发编程实战--第一部分 基础知识"><img class="cover" src="/./img/photo-1626277787644-47d530591292.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-25</div><div class="title">java并发编程实战--第一部分 基础知识</div></div></a></div><div><a href="/2020/07/12/java基础/Java多线程/" title="多线程"><img class="cover" src="/./img/photo-1626277787644-47d530591292.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-12</div><div class="title">多线程</div></div></a></div><div><a href="/2020/07/15/java基础/java多线程(2)/" title="多线程（2）"><img class="cover" src="/./img/photo-1625777719130-0a8e07086117.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-15</div><div class="title">多线程（2）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">1.</span> <span class="toc-text">六、任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%9C%A8%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">6.1 在线程中执行任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">串行的执行任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%9C%B0%E4%B8%BA%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">显示地为任务创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E5%88%B6%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-number">1.1.3.</span> <span class="toc-text">无限制创建线程的不足</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-Executor%E6%A1%86%E6%9E%B6"><span class="toc-number">1.2.</span> <span class="toc-text">6.2 Executor框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9F%BA%E4%BA%8EExecutor%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">示例：基于Executor的Web服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%AD%96%E7%95%A5"><span class="toc-number">1.2.2.</span> <span class="toc-text">执行策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.2.3.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Executor%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">Executor的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.2.5.</span> <span class="toc-text">延迟任务与周期任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%89%BE%E5%87%BA%E5%8F%AF%E5%88%A9%E7%94%A8%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">6.3 找出可利用的并行性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%B8%B2%E8%A1%8C%E7%9A%84%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">示例：串行的页面渲染器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%BA%E5%B8%A6%E7%BB%93%E6%9E%9C%E7%9A%84%E4%BB%BB%E5%8A%A1Callable%E4%B8%8EFuture"><span class="toc-number">1.3.2.</span> <span class="toc-text">携带结果的任务Callable与Future</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-%E4%BD%BF%E7%94%A8Future-%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">示例:使用Future 实现页面渲染器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%BC%82%E6%9E%84%E4%BB%BB%E5%8A%A1%E5%B9%B6%E8%A1%8C%E5%8C%96%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-number">1.3.4.</span> <span class="toc-text">在异构任务并行化中查找的局限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CompletionServiceExecutor%E4%B8%8E-BlockingQueue"><span class="toc-number">1.3.5.</span> <span class="toc-text">CompletionServiceExecutor与 BlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-%E4%BD%BF%E7%94%A8CompletionService%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%99%A8"><span class="toc-number">1.3.6.</span> <span class="toc-text">示例:使用CompletionService实现页面渲染器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%BB%E5%8A%A1%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%99%90"><span class="toc-number">1.3.7.</span> <span class="toc-text">为任务设置时限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%97%85%E8%A1%8C%E9%A2%84%E8%AE%A2%E9%97%A8%E6%88%B7%E7%BD%91%E7%AB%99"><span class="toc-number">1.3.8.</span> <span class="toc-text">示例：旅行预订门户网站</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8F%96%E6%B6%88%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-number">2.</span> <span class="toc-text">七、取消与关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%BB%BB%E5%8A%A1%E5%8F%96%E6%B6%88"><span class="toc-number">2.1.</span> <span class="toc-text">7.1 任务取消</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">2.1.1.</span> <span class="toc-text">中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%AD%96%E7%95%A5"><span class="toc-number">2.1.2.</span> <span class="toc-text">中断策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%BA%94%E4%B8%AD%E6%96%AD"><span class="toc-number">2.1.3.</span> <span class="toc-text">相应中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%AE%A1%E6%97%B6%E8%BF%90%E8%A1%8C"><span class="toc-number">2.1.4.</span> <span class="toc-text">示例：计时运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Future%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%8F%96%E6%B6%88"><span class="toc-number">2.1.5.</span> <span class="toc-text">通过Future来实现取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E7%9A%84%E9%98%BB%E5%A1%9E"><span class="toc-number">2.1.6.</span> <span class="toc-text">处理不可中断的阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E7%94%A8newTaskFor%E6%9D%A5%E5%B0%81%E8%A3%85%E9%9D%9E%E6%A0%87%E5%87%86%E7%9A%84%E5%8F%96%E6%B6%88"><span class="toc-number">2.1.7.</span> <span class="toc-text">采用newTaskFor来封装非标准的取消</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%81%9C%E6%AD%A2%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.2.</span> <span class="toc-text">7.2 停止基于线程的服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text">示例：日志服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%ADExecutorService"><span class="toc-number">2.2.2.</span> <span class="toc-text">关闭ExecutorService</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%92%E4%B8%B8%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.3.</span> <span class="toc-text">毒丸对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.2.4.</span> <span class="toc-text">示例：只执行一次的服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shutdownNow%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">2.2.5.</span> <span class="toc-text">shutdownNow的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%A4%84%E7%90%86%E9%9D%9E%E6%AD%A3%E5%B8%B8%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">2.3.</span> <span class="toc-text">7.3 处理非正常的线程终止</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By naive</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>