<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统-内存管理 | naive的博客</title><meta name="author" content="naive"><meta name="copyright" content="naive"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="内存管理一、内存的连续分配1.1 单一连续分配方式内存在此方式下分为系统区和用户区 系统区仅提供给操作系统使用，通常在低地址部分 用户区是为用户提供的、除系统区之外的内存空间 优点：简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持 缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低 1.2 固定分区分配固定分区分配是最简单的一种多道程序存储管理方式。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-内存管理">
<meta property="og:url" content="http://yoursite.com/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/index.html">
<meta property="og:site_name" content="naive的博客">
<meta property="og:description" content="内存管理一、内存的连续分配1.1 单一连续分配方式内存在此方式下分为系统区和用户区 系统区仅提供给操作系统使用，通常在低地址部分 用户区是为用户提供的、除系统区之外的内存空间 优点：简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持 缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低 1.2 固定分区分配固定分区分配是最简单的一种多道程序存储管理方式。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/img/photo-1442522772768-9032b6d10e3e.jpg">
<meta property="article:published_time" content="2020-08-12T15:38:09.000Z">
<meta property="article:modified_time" content="2020-08-13T03:37:47.063Z">
<meta property="article:author" content="naive">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/photo-1442522772768-9032b6d10e3e.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统-内存管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-08-13 11:37:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="naive的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">150</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/photo-1442522772768-9032b6d10e3e.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">naive的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统-内存管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-12T15:38:09.000Z" title="发表于 2020-08-12 23:38:09">2020-08-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-13T03:37:47.063Z" title="更新于 2020-08-13 11:37:47">2020-08-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统-内存管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="一、内存的连续分配"><a href="#一、内存的连续分配" class="headerlink" title="一、内存的连续分配"></a>一、内存的连续分配</h2><h3 id="1-1-单一连续分配方式"><a href="#1-1-单一连续分配方式" class="headerlink" title="1.1 单一连续分配方式"></a>1.1 单一连续分配方式</h3><p>内存在此方式下分为<strong>系统区</strong>和<strong>用户区</strong></p>
<p><strong>系统区</strong>仅提供给<strong>操作系统</strong>使用，通常在<strong>低地址</strong>部分</p>
<p><strong>用户区</strong>是为<strong>用户</strong>提供的、除系统区之外的内存空间</p>
<p><strong>优点</strong>：简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持</p>
<p><strong>缺点</strong>：只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低</p>
<h3 id="1-2-固定分区分配"><a href="#1-2-固定分区分配" class="headerlink" title="1.2 固定分区分配"></a>1.2 固定分区分配</h3><p>固定分区分配是最简单的一种多道程序存储管理方式。</p>
<p>将用户内存空间划分为若干个<strong>固定大小</strong>的区域，每个分区只装入一道作业。</p>
<p>当有空闲分区时，便可以再从外存的后备作业队列中,选择适当大小的作业装入该分区，如此循环。</p>
<p><strong>划分分区方法</strong>：</p>
<ol>
<li>分区大小相等</li>
<li>分区大小不等</li>
</ol>
<p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA.png" alt="img"></p>
<p><strong>存在的问题</strong>：</p>
<ul>
<li><strong>程序可能太大</strong>而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间</li>
<li><strong>主存利用率低</strong>，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，产生<strong>内部碎片</strong></li>
</ul>
<h3 id="1-3-动态分区分配"><a href="#1-3-动态分区分配" class="headerlink" title="1.3 动态分区分配"></a>1.3 动态分区分配</h3><p>又称为<strong>可变分区分配</strong>，这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小<strong>动态地建立分区</strong>，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。</p>
<p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA.png" alt="img"></p>
<p><strong>动态分区分配算法</strong></p>
<p><strong>首次适应(First Fit)算法</strong>：空闲分区以地址递增的次序链接。分配内存时<strong>顺序查找</strong>，找到大小能满足要求的<strong>第一个空闲分区</strong>。</p>
<p><strong>最佳适应(Best Fit)算法</strong>：空闲分区<strong>按容量递增</strong>形成分区链，找到<strong>第一个</strong>能满足要求的空闲分区。</p>
<p><strong>最坏适应(Worst Fit)算法</strong>：又称<strong>最大适应(Largest Fit)算法</strong>，空闲分区以<strong>容量递减</strong>的次序链接。找到<strong>第一个</strong>能满足要求的空闲分区，也就是挑选出最大的分区。</p>
<p><strong>临近适应算法(Next fit)算法</strong>：从<strong>当前位置</strong>开始，搜索<strong>第一个</strong>能满足进程要求的内存空间</p>
<p><strong>动态分区的缺点</strong></p>
<p>随着时间的推移，内存中会产生越来越多的<strong>外部碎片</strong>，<strong>内存的利用率</strong>随之下降。</p>
<h2 id="二、内存的非连续分配"><a href="#二、内存的非连续分配" class="headerlink" title="二、内存的非连续分配"></a>二、内存的非连续分配</h2><h3 id="2-1-页式存储"><a href="#2-1-页式存储" class="headerlink" title="2.1 页式存储"></a>2.1 页式存储</h3><h4 id="2-1-1-基本概念"><a href="#2-1-1-基本概念" class="headerlink" title="2.1.1 基本概念"></a>2.1.1 基本概念</h4><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/页式存储.png" alt="img" style="zoom:67%;">

<p><strong>基本思想</strong>：用户程序的<strong>地址空间</strong>被划分成若干固定大小的区域，称为“<strong>页</strong>”，相应地，<strong>内存空间</strong>分成若干个<strong>物理块或页帧（</strong>Page Frame<strong>）</strong>，页和块的<strong>大小相等</strong>。可将用户程序的任一页放在内存的任一块中，实现了离散分配：物理块不一定连续。每个页对应一个物理块。</p>
<p><strong>逻辑地址结构</strong>：地址结构包含两部分：前一部分为<strong>页号P</strong>，后一部分为<strong>页内偏移量W。</strong>如果是32位地址，则0<del>11位为页内地址，即每页大小为4KB；12</del>31位为页号，地址空间最多允许有2<sup>20</sup>页</p>
<p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80.png" alt="img"></p>
<p><strong>页表</strong>：因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从<strong>页号到物理块号</strong>的映射</p>
<blockquote>
<p>每个进程也以块为单位进行划分。每一个进程都拥有一个自己的页表，PCB表中有指针指向页表。</p>
<p>分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为<strong>基本分页存储</strong>管理方式和<strong>请求分页存储</strong>管理方式。</p>
</blockquote>
<h4 id="2-1-2-地址变换"><a href="#2-1-2-地址变换" class="headerlink" title="2.1.2 地址变换"></a>2.1.2 地址变换</h4><p>地址变换的任务是将<strong>逻辑地址转换为内存中物理地址</strong>，地址变换是借助于页表实现的</p>
<p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E9%A1%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="img"></p>
<p>当进程执行时，将页表始址和长度存入<strong>页表寄存器</strong></p>
<p>设页大小为<strong>L</strong>（一般为4K），<strong>逻辑地址A</strong>到<strong>物理地址E</strong>的变换过程如下：</p>
<ol>
<li>计算页号P(P=A/L)和页内偏移量W (W=A%L)，这里的P取整</li>
<li>比较页号P和页表长度M，若P &gt;= M，则产生越界中断，否则继续执行</li>
<li>页表中页号P对应的页表项地址 = 页表起始地址F + 页号P * 页表项长度（一般为4B），取出该页表项内容b，即为物理块号</li>
<li>计算E=b*L+W，用得到的物理地址E去访问内存</li>
</ol>
<h4 id="2-1-3-分页管理方式存在的问题"><a href="#2-1-3-分页管理方式存在的问题" class="headerlink" title="2.1.3 分页管理方式存在的问题"></a>2.1.3 分页管理方式存在的问题</h4><ul>
<li>每次访存操作都需要进行逻辑地址到物理地址的转换，<strong>地址转换</strong>过程必须足够快，否则<strong>访存速度</strong>会降低</li>
<li>每个进程引入了<strong>页表</strong>，用于存储映射机制，页表不能太大，否则<strong>内存利用率</strong>会降低</li>
</ul>
<h4 id="2-1-4-具有快表的地址变换机构"><a href="#2-1-4-具有快表的地址变换机构" class="headerlink" title="2.1.4 具有快表的地址变换机构"></a><strong>2.1.4 具有快表的地址变换机构</strong></h4><p>若页表全部放在内存中，则存取一个数据或一条指令至少要<strong>访问两次内存</strong>：</p>
<ol>
<li>从内存中<strong>访问页表</strong>，从中找到指定的物理块号，加上页内偏移<strong>得到实际物理地址</strong></li>
<li>根据第一次得到的物理地址<strong>访问内存取出数据</strong></li>
</ol>
<p>为提高地址变换速度，增设一个具有并行查询能力的特殊<strong>高速缓冲存储器</strong>，称为<strong>“联想存储器</strong>”或“<strong>快表”</strong>，存放当前访问的页表项。与此对应，主存中的页表也常称为慢表。</p>
<p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt="img"></p>
<p>这样由逻辑地址的页号P直接在快表里查找：</p>
<ol>
<li>若查找到，则得到对应的块号，直接转换成物理地址，这样，存取数据<strong>仅一次访问内存</strong>便可实现。</li>
<li>若不存在，则访问主存中的页表，在读出页表项后，应同时将其<strong>存入快表</strong></li>
</ol>
<p>理论依据：<strong>局部性原理</strong></p>
<blockquote>
<p><strong>局部性原理：</strong></p>
<p>时间上的局部性：最近被访问的页在不久的将来还会被访问</p>
<p>空间上的局部性：内存中被访问的页周围的页也很可能被访问</p>
</blockquote>
<h4 id="2-1-5-二级页表"><a href="#2-1-5-二级页表" class="headerlink" title="2.1.5 二级页表"></a><strong>2.1.5 二级页表</strong></h4><p>如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。</p>
<p>为了解决这个问题，可以采用<strong>两级页表或者多级页表</strong>的方法：外层页表一次性调入内存且连续存放，内层页表离散存放。</p>
<p>所以一共需要访问内存<strong>3次</strong>才可以读取一次数据：访问顶级页表-&gt;访问二级页表-&gt;访问内存中的数据</p>
<h3 id="2-2-段式存储"><a href="#2-2-段式存储" class="headerlink" title="2.2 段式存储"></a>2.2 段式存储</h3><p>分页是为了提高内存利用率，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明</p>
<p>而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</p>
<h4 id="2-2-1-基本概念"><a href="#2-2-1-基本概念" class="headerlink" title="2.2.1 基本概念"></a>2.2.1 基本概念</h4><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt="img"></p>
<p><strong>基本思想</strong>：将用户程序地址空间分成若干个大<strong>小不等的段</strong>，<strong>每段</strong>可以定义一组<strong>相对完整的逻辑信息</strong>，每个<strong>段内部从0开始编址</strong>。存储分配时，以段为单位，每个<strong>段内部连续分配</strong>内存，段与段在内存中可以不相邻接，也实现了离散分配。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段。</p>
<p><strong>逻辑地址结构</strong>：<strong>段号S</strong>与<strong>段内偏移量W</strong>两部分组成。如果是32位地址，段号为16位，段内偏移量为16位，则一个作业最多可有2<sup>16</sup>个段，最大段长为65536B即64KB</p>
<p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%81%8F%E7%A7%BB.png" alt="img"></p>
<blockquote>
<p><strong>页式</strong>系统中，<strong>逻辑地址</strong>的页号和页内偏移量对用户是<strong>透明</strong>的，但在<strong>段式</strong>系统中，段号和段内偏移量必须由<strong>用户显示提供</strong>，在髙级程序设计语言中，这个工作由<strong>编译程序</strong>完成</p>
</blockquote>
<p><strong>段表</strong>：每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个<strong>段表项</strong>对应进程的一个段。</p>
<p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E6%AE%B5%E8%A1%A8.png" alt="img"></p>
<p>访问内存的时候根据<strong>段号</strong>和<strong>段表项的长度</strong>计算当前访问段在<strong>段表中的位置</strong>，然后访问段表，得到该<strong>段的物理地址</strong>，根据该物理地址以及<strong>段内偏移量</strong>就可以得到需要访问的内存。</p>
<h4 id="2-2-2-地址变换"><a href="#2-2-2-地址变换" class="headerlink" title="2.2.2 地址变换"></a>2.2.2 地址变换</h4><p>为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了<strong>段表寄存器</strong></p>
<p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E6%AE%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="img"></p>
<p>段表寄存器存了段表始址<strong>F</strong>和段表长度<strong>M，</strong>从<strong>逻辑地址A</strong>到<strong>物理地址E</strong>之间的地址变换过程如下：</p>
<ol>
<li>从逻辑地址A中取出前几位为<strong>段号S</strong>，后几位为<strong>段内偏移量W</strong></li>
<li>比较段号S和段表长度M，若S多M，则产生<strong>越界中断</strong>，否则继续执行</li>
<li>段表中<strong>段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度</strong>，取出该段表项的前几位得到段长C。若段内偏移量&gt;=C，则产生越界中断，否则继续执行</li>
<li>取出段表项中该段的<strong>起始地址b</strong>，计算 <strong>E = b + W</strong>，用得到的物理地址E去访问内存</li>
</ol>
<h4 id="2-2-3-段的共享"><a href="#2-2-3-段的共享" class="headerlink" title="2.2.3 段的共享"></a>2.2.3 段的共享</h4><p>段的共享是通过两个作业的<strong>段表中相应表项指向被共享的段的同一个物理副本</strong>来实现的</p>
<p>不能修改的代码称为<strong>纯代码</strong>或<strong>可重入代码</strong>（它不属于临界资源)，这样的代码和不能修改的数据是<strong>可以共享</strong>的</p>
<p>而<strong>可修改</strong>的代码和数据则<strong>不能共享</strong></p>
<h3 id="2-3-分页与分段的区别"><a href="#2-3-分页与分段的区别" class="headerlink" title="2.3 分页与分段的区别"></a>2.3 分页与分段的区别</h3><p><strong>段式管理</strong></p>
<ul>
<li><strong>优点</strong>：没有内部碎片（因为段大小可变，改变段大小来消除内碎片）。</li>
<li><strong>缺点</strong>：段换入换出时，会产生外部碎片（比如4k的段换5k的段，会产生1k的外碎片）</li>
</ul>
<p><strong>页式管理</strong></p>
<ul>
<li><strong>优点</strong>：没有外部碎片（因为页的大小固定），</li>
<li><strong>缺点</strong>：会产生内部碎片（一个页可能填充不满）</li>
</ul>
<p><strong>分页与分段的区别</strong></p>
<ul>
<li><p><strong>目的不同</strong>：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</p>
</li>
<li><p><strong>大小不同</strong>：页的大小固定且由系统决定（一般为4k），而段的长度却不固定，由其所完成的功能决定；</p>
</li>
<li><p><strong>地址空间不同</strong>： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；一个段在物理空间是连续的内存。</p>
</li>
<li><p><strong>信息共享</strong>：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</p>
</li>
<li><p><strong>内存碎片</strong>：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。<br> 2.4 段页式存储</p>
<p>页式存储管理能有效地提高<strong>内存利用率</strong>，而分段存储管理能反映程序的<strong>逻辑结构并有利于段的共享</strong>。</p>
<p>如果将这两种存储管理方法结合起来，就形成了<strong>段页式存储管理</strong>方式</p>
</li>
</ul>
<h3 id="2-4-段页式存储"><a href="#2-4-段页式存储" class="headerlink" title="2.4 段页式存储"></a>2.4 段页式存储</h3><p>页式存储管理能有效地提高<strong>内存利用率</strong>，而分段存储管理能反映程序的<strong>逻辑结构并有利于段的共享</strong>。</p>
<p>如果将这两种存储管理方法结合起来，就形成了<strong>段页式存储管理</strong>方式</p>
<h3 id="2-4-1-基本概念"><a href="#2-4-1-基本概念" class="headerlink" title="2.4.1 基本概念"></a>2.4.1 基本概念</h3><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/E:%5CBlog%5Csource_posts%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%5C%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt="img"></p>
<p><strong>基本思想</strong>：</p>
<ul>
<li>作业的地址空间首先被分成若干个<strong>逻辑段</strong>，每段都有自己的段号</li>
<li>再将<strong>每一段分成</strong>若干个<strong>大小固定的页</strong></li>
<li>对<strong>内存空间</strong>的管理仍然和分页存储管理一样，将其<strong>分成</strong>若干个和页面大小相同的<strong>块</strong>，对内存的分配以块为单位</li>
</ul>
<p><strong>逻辑地址结构</strong>：段号S、页号P和页内偏移量W。</p>
<p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="img"></p>
<p>每个进程建立<strong>一张段表</strong>，而每个分段有<strong>一张页表</strong></p>
<h3 id="2-4-2-地址变换"><a href="#2-4-2-地址变换" class="headerlink" title="2.4.2 地址变换"></a>2.4.2 地址变换</h3><p>为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了<strong>段表寄存器</strong></p>
<p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="img"></p>
<p>进行一次访问实际需要<strong>三次访问</strong>内存</p>
<ol>
<li>首先利用<strong>段号S</strong>，将它与段表长TL进行比较。若S&lt;TL，表示未越界</li>
<li>根据<strong>段表始址F</strong>和<strong>段号S</strong>来求出该段所对应的<strong>段表项</strong>在段表中的位置，从中得到该段的<strong>页表始址</strong></li>
<li>根据<strong>段内页号P</strong>来获得对应页的<strong>页表项位置</strong>，从中读出该页所在的<strong>物理块号b</strong></li>
<li>利用块号b和页内地址来构成<strong>物理地址</strong></li>
</ol>
<h2 id="三、虚拟内存"><a href="#三、虚拟内存" class="headerlink" title="三、虚拟内存"></a>三、虚拟内存</h2><p>虚拟内存的<strong>基本思想</strong>是：在程序装入时，可以将程序的<strong>一部分装入内存</strong>，而将<strong>其余部分留在外存</strong>，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分<strong>调入内存,</strong>然后继续执行程序。</p>
<p>虚拟内存容量：<strong>内存+外存</strong></p>
<p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt="img"><br>理论依据：<strong>局部性原理</strong></p>
<p>与传统存储器比较虚拟存储器有以下三个<strong>主要特征</strong>：</p>
<ul>
<li>多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多<strong>次调入内存运行</strong>。</li>
<li>对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行<strong>换进和换出</strong>。</li>
<li>虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远<strong>大于实际的内存容量</strong>。</li>
</ul>
<p>虚拟内存的实现有以下两种方式：</p>
<ul>
<li><strong>请求分页存储管理</strong></li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
<h3 id="3-1-请求分页存储管理"><a href="#3-1-请求分页存储管理" class="headerlink" title="3.1 请求分页存储管理"></a>3.1 请求分页存储管理</h3><p>将当前需要的<strong>一部分页面</strong>装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过<strong>调页功能</strong>将其调入，同时还可以通过置换功能将暂时不用的页面<strong>换出到外存</strong>上，以便腾出内存空间</p>
<h4 id="3-1-1-地址变换"><a href="#3-1-1-地址变换" class="headerlink" title="3.1.1 地址变换"></a>3.1.1 地址变换</h4><p>请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的</p>
<p>请求分页系统中，每当所要访问的页面不在内存时，便产生一个<strong>缺页中断</strong>，请求操作系统将所缺的页调入内存</p>
<p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="img"></p>
<p>缺页中断处理中：</p>
<ul>
<li>如果内存中有<strong>空闲块</strong>，则分配一个块，将要调入的<strong>页装入该块</strong></li>
<li>若此时内存中<strong>没有空闲块</strong>，则要<strong>淘汰某页</strong></li>
<li>若被<strong>淘汰页</strong>在内存期间<strong>被修改过</strong>，则要将其<strong>写回外存</strong></li>
</ul>
<h3 id="3-2-页面置换算法"><a href="#3-2-页面置换算法" class="headerlink" title="3.2 页面置换算法"></a>3.2 页面置换算法</h3><p>进程运行时，若其访问的<strong>页面</strong>不在内存而需将其<strong>调入</strong>，但<strong>内存已无空闲</strong>空间时，就需要从<strong>内存中调出一页</strong>程序或数据，送入磁盘的对换区。</p>
<p>选择调出页面的算法就称为<strong>页面置换算法</strong></p>
<ul>
<li><strong>最优页面置换算法</strong></li>
</ul>
<p>最理想的状态下，所选择的被淘汰页面将是<strong>最长时间内不再被访问</strong>的页面，当然，这样的算法<strong>不可能实现</strong>，因为不确定一个页面在何时会被用到。</p>
<ul>
<li><strong>先进先出页面置换算法（FIFO）</strong></li>
</ul>
<p>这种算法的思想和队列是一样的，该算法总是<strong>淘汰最先进入内存的页面</strong>，即选择在内存中驻留时间最久的页面予淘汰。</p>
<p>实现简单，把一个进程已调入内存的页面按先后次序链接成一个队列，并且设置一个指针总是指向最老的页面。</p>
<p><strong>缺点</strong>：对于有些经常被访问的页面如含有全局变量、常用函数、例程等的页面，不能保证这些不被淘汰。</p>
<ul>
<li><strong>最近最久未使用页面置换算法LRU（Least Recently Used）</strong></li>
</ul>
<p>根据页面调入内存后的使用情况做出决策。LRU置换算法是选择<strong>最近最久未使用</strong>的页面进行淘汰。</p>
<p><strong>实现</strong>：</p>
<p>1.为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰</p>
<p>2.利用一个特殊的栈保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。因此，栈顶永远是最新被访问的页面号，栈底是最近最久未被访问的页面号。</p>
<ul>
<li><strong>时钟置换算法(Clock Page Replacement Algorithm)</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190128191216276.png" alt="img"></p>
<p>把所有的页面都保存在一个类似钟面的<strong>环形结构</strong>中</p>
<p>每一个页面增加一个<strong>使用位</strong></p>
<ol>
<li>当某一页<strong>首次装入主存</strong>时，该帧的使用位设<strong>置为1</strong>，当该页随后再<strong>被访问</strong>到时，它的使用位也被<strong>置为1</strong></li>
<li>当需要<strong>替换</strong>一页时，操作系统扫描缓冲区，以<strong>查找使用位被置为0</strong>的一帧，每当遇到一个<strong>使用位为1</strong>的帧时，操作系统就将该位<strong>重新置为0</strong></li>
<li>如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换</li>
<li>如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页</li>
</ol>
<h3 id="3-3-页面抖动（-颠簸）"><a href="#3-3-页面抖动（-颠簸）" class="headerlink" title="3.3 页面抖动（ 颠簸）"></a><strong>3.3</strong> 页面<strong>抖动（</strong> <strong>颠簸）</strong></h3><p>颠簸本质上是指频繁的页面调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，<strong>其他所有的页都在使用</strong>，它置换一个页，但又立刻再次需要这个页。因此，会<strong>不断产生缺页中断</strong>，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）</p>
<p>内存颠簸的<strong>解决策略</strong>包括：</p>
<ul>
<li>如果是因为页面替换策略失误，可以<strong>修改替换算法来</strong>解决这个问题；</li>
<li>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要<strong>降低多道程序的数量</strong>；</li>
<li><strong>终止该进程</strong>或<strong>增加物理内存容量</strong>。</li>
</ul>
<h3 id="3-4-驻留集大小"><a href="#3-4-驻留集大小" class="headerlink" title="3.4 驻留集大小"></a>3.4 驻留集大小</h3><p><strong>驻留集</strong>：对于分页式的虚拟内存，不需要把一个进程的所有页都读取到主存，操作系统必须决定<strong>读取多少页</strong>。也就是说，给特定的进程<strong>分配多大的主存空间</strong>，这就是驻留集。</p>
<p>主要考虑以下几点：</p>
<ul>
<li>分配给一个进程的<strong>存储量越小</strong>，在任何时候驻留在主存中的<strong>进程数就越多</strong>，从而可以提高<strong>处理机的时间利用效率</strong></li>
<li>如果分配给一个进程的<strong>存储量太小</strong>，尽管有局部性原理，<strong>页错误率</strong>仍然会相对较高</li>
<li>如果<strong>存储量太大，</strong>页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响</li>
</ul>
<p>操作系统通常釆用三种策略：</p>
<ul>
<li><strong>固定分配局部置换</strong></li>
</ul>
<p>为每个进程分配<strong>一定数目的物理块</strong>，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面</p>
<ul>
<li><strong>可变分配全局置换</strong></li>
</ul>
<p>为系统中的每个进程分配<strong>一定数目的物理块</strong>,操作系统自身也保持一个<strong>空闲物理块队列</strong>。</p>
<p>当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块<strong>分配</strong>给该进程，并将欲调入的页装入其中。</p>
<ul>
<li><strong>可变分配局部置换</strong></li>
</ul>
<p>为每个进程分配<strong>一定数目的物理块</strong></p>
<p>当某进程发生<strong>缺页</strong>时，只允许从该进程在内存的页面中<strong>选出一页换出</strong>，这样就不会影响其他进程的运行</p>
<p>如果进程在运行中<strong>频繁地缺页</strong>，系统再为该进程<strong>分配若干物理块</strong>，直至该进程缺页率趋于适当程度</p>
<p> 反之，若进程在运行中<strong>缺页率特别低</strong>，则可适当<strong>减少分配</strong>给该进程的物理块</p>
<h3 id="3-5-调入页面的时机"><a href="#3-5-调入页面的时机" class="headerlink" title="3.5 调入页面的时机"></a>3.5 调入页面的时机</h3><p>为确定系统将进程运行时所缺的页面调入内存的时机，可釆取以下两种调页策略</p>
<ul>
<li><strong>预调页策略</strong></li>
</ul>
<p>根据局部性原理，一次调入若干个相邻的页可能会比一次调入一页更高效。但如果调入的一批页面中大多数都未被访问，则又是低效的。所以就需要釆用<strong>以预测为基础的预调</strong>页策略，将<strong>预计在不久之后便会被访问的页面预先调</strong>入内存</p>
<ul>
<li><strong>请求调页策略</strong></li>
</ul>
<p>进程在运行中需要访问的页面不在内存而提出请求，由系统<strong>将所需页面调入</strong>内存。</p>
<p>由这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多釆用此策略。</p>
<p><strong>缺点</strong>在于每次只调入一页，调入调出页面数多时会<strong>花费过多的I/O开销</strong></p>
<h3 id="3-6-从何处调入页面"><a href="#3-6-从何处调入页面" class="headerlink" title="3.6 从何处调入页面"></a>3.6 从何处调入页面</h3><p>请求分页系统中的<strong>外存</strong>分为两部分：</p>
<ol>
<li>用于存放文件的<strong>文件区，</strong>釆用连续分配方式</li>
<li>用于存放对换页面的<strong>对换区，</strong>釆用离散分配方式</li>
</ol>
<p>故对换区的磁盘I/O速度比文件区的更快，这样从何处调入页面有三种情况：</p>
<ul>
<li><strong>系统拥有足够的对换区空间</strong></li>
</ul>
<p>可以<strong>全部从对换区调入所需页面</strong>，以提髙调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区</p>
<ul>
<li><strong>系统缺少足够的对换区空间</strong></li>
</ul>
<p>凡<strong>不会被修改的文件</strong>都直接从<strong>文件区</strong>调入，而当换出这些页面时，由于它们未被修改而不必再将它们换出。</p>
<p>对于那些<strong>可能被修改</strong>的部分，在将它们<strong>换出时须调到对换区</strong>，以后需要时再从对换区调入。</p>
<ul>
<li><strong>UNIX方式</strong></li>
</ul>
<p>与进程有关的文件都放在文件区，故<strong>未运行过的页面</strong>，都应从<strong>文件区</strong>调入</p>
<p>曾经运<strong>行过但又被换出</strong>的页面，由于是被放在<strong>对换区</strong>，因此下次调入时应从对换区调入</p>
<p>进程请求的<strong>共享页面若被其他进程调入内存</strong>，则无需再从对换区调入</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ChaunceyChen/article/details/86672415">https://blog.csdn.net/ChaunceyChen/article/details/86672415</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./img/photo-1442522772768-9032b6d10e3e.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/"><img class="prev-cover" src="/./img/photo-1465156799763-2c087c332922.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统-设备管理</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"><img class="next-cover" src="/./img/photo-1625777719130-0a8e07086117.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统-进程管理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">1.1.</span> <span class="toc-text">一、内存的连续分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 单一连续分配方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 固定分区分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 动态分区分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E7%9A%84%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">1.2.</span> <span class="toc-text">二、内存的非连续分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 页式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">2.1.3 分页管理方式存在的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">2.1.4 具有快表的地址变换机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">2.1.5 二级页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 段式存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3 段的共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 分页与分段的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 段页式存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.4.1 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.4.2 地址变换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.3.</span> <span class="toc-text">三、虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 请求分页存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1 地址变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%A1%B5%E9%9D%A2%E6%8A%96%E5%8A%A8%EF%BC%88-%E9%A2%A0%E7%B0%B8%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 页面抖动（ 颠簸）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%A9%BB%E7%95%99%E9%9B%86%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 驻留集大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 调入页面的时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E4%BB%8E%E4%BD%95%E5%A4%84%E8%B0%83%E5%85%A5%E9%A1%B5%E9%9D%A2"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6 从何处调入页面</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By naive</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>