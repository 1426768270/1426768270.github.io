<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>mysql事务和锁 | naive的博客</title><meta name="keywords" content="mysql"><meta name="author" content="naive"><meta name="copyright" content="naive"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL事务概念事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 MySQL数据库中事务默认自动提交 123456789101112事务提交的两种方式：	自动提交：		mysql就是自动提交的		一条DML(增删改)语句会自动提交一次事务。	手动提交：		Oracle 数据库默认是手动提交事务		需要先开启事务，再提交修改事">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql事务和锁">
<meta property="og:url" content="http://yoursite.com/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/index.html">
<meta property="og:site_name" content="naive的博客">
<meta property="og:description" content="MySQL事务概念事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。 MySQL数据库中事务默认自动提交 123456789101112事务提交的两种方式：	自动提交：		mysql就是自动提交的		一条DML(增删改)语句会自动提交一次事务。	手动提交：		Oracle 数据库默认是手动提交事务		需要先开启事务，再提交修改事">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/img/photo-1465188162913-8fb5709d6d57.jpg">
<meta property="article:published_time" content="2020-08-14T13:25:21.000Z">
<meta property="article:modified_time" content="2021-08-08T08:05:25.317Z">
<meta property="article:author" content="naive">
<meta property="article:tag" content="mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/photo-1465188162913-8fb5709d6d57.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'mysql事务和锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-08 16:05:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="naive的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/photo-1465188162913-8fb5709d6d57.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">naive的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">mysql事务和锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-14T13:25:21.000Z" title="发表于 2020-08-14 21:25:21">2020-08-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-08T08:05:25.317Z" title="更新于 2021-08-08 16:05:25">2021-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="mysql事务和锁"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<p>MySQL数据库中事务默认自动提交</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">事务提交的两种方式：</span><br><span class="line">	自动提交：</span><br><span class="line">		mysql就是自动提交的</span><br><span class="line">		一条DML(增删改)语句会自动提交一次事务。</span><br><span class="line"></span><br><span class="line">	手动提交：</span><br><span class="line">		Oracle 数据库默认是手动提交事务</span><br><span class="line">		需要先开启事务，再提交</span><br><span class="line"></span><br><span class="line">修改事务的默认提交方式：</span><br><span class="line">	查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交 </span><br><span class="line">	修改默认提交方式： set @@autocommit = 0;</span><br></pre></td></tr></table></figure>

<h2 id="事务的四大特征（ACID）"><a href="#事务的四大特征（ACID）" class="headerlink" title="事务的四大特征（ACID）"></a>事务的四大特征（ACID）</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p>
<h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>
<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/ACID关系.png" alt="image-20200815101847222" style="zoom: 80%;">

<h4 id="Mysql怎么保证一致性的？"><a href="#Mysql怎么保证一致性的？" class="headerlink" title="Mysql怎么保证一致性的？"></a>Mysql怎么保证一致性的？</h4><p>​     从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。</p>
<p>​     从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据。</p>
<h4 id="Mysql怎么保证原子性的？"><a href="#Mysql怎么保证原子性的？" class="headerlink" title="Mysql怎么保证原子性的？"></a>Mysql怎么保证原子性的？</h4><p>　　 利用Innodb的<code>undo log</code>。 </p>
<p>　　　<code>undo log</code>名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。</p>
<p>​     例如</p>
<ul>
<li>(1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li>
<li>(2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li>
<li>(3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作</li>
</ul>
<p><code>undo log</code>记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p>
<p>-————————————————————————————————-</p>
<h4 id="Mysql怎么保证持久性的？"><a href="#Mysql怎么保证持久性的？" class="headerlink" title="Mysql怎么保证持久性的？"></a>Mysql怎么保证持久性的？</h4><p> 　利用Innodb的<code>redo log（</code>重做日志）。</p>
<p>　　 正如之前说的，Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。</p>
<p>　　 <em>怎么解决这个问题？</em> </p>
<p>　　简单啊，事务提交前直接把数据写入磁盘就行啊。 </p>
<p>　　<em>这么做有什么问题？</em></p>
<ul>
<li>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。</li>
<li>毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</li>
</ul>
<p>　　采用<code>redo log</code>解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在<code>redo log</code>中记录这次操作。当事务提交的时候，会将<code>redo log</code>日志进行刷盘(<code>redo log</code>一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将<code>redo log</code>中的内容恢复到数据库中，再根据<code>undo log</code>和<code>binlog</code>内容决定回滚数据还是提交数据。</p>
<p>　　<em>采用redo log的好处？</em></p>
<p>　　<code>redo log</code>进行刷盘比对数据页刷盘效率高，具体表现如下</p>
<ul>
<li><ul>
<li><code>redo log</code>体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</li>
<li><code>redo log</code>是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</li>
</ul>
<p>-————————————————————————————————-</p>
</li>
</ul>
<h4 id="Mysql怎么保证隔离性的？"><a href="#Mysql怎么保证隔离性的？" class="headerlink" title="Mysql怎么保证隔离性的？"></a>Mysql怎么保证隔离性的？</h4><p>　　<em>利用的是锁和MVCC机制。</em></p>
<p>　　MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快照数据在<code>undo log</code>中。 如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。 </p>
<h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/丢失修改.png" style="zoom: 80%;">

<h3 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h3><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<p>一个事务，读取到另一个事务中<strong>没有提交</strong>的数据</p>
<p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E8%AF%BB%E8%84%8F%E6%95%B0%E6%8D%AE.png" alt="image-20200815102631015"></p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png" alt="image-20200815102810415"></p>
<h3 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h3><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E5%B9%BB%E5%BD%B1%E8%AF%BB.png" alt="image-20200815102940318"></p>
<p>一个事务<strong>操作(DML)</strong>数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p><strong>未提交读（READ UNCOMMITTED）</strong></p>
<p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<p><strong>提交读（READ COMMITTED）</strong></p>
<p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<p><strong>可重复读（REPEATABLE READ）</strong></p>
<p>保证在同一个事务中多次读取同一数据的结果是一样的。</p>
<p><strong>可串行化（SERIALIZABLE）</strong></p>
<p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>
<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>
<p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png" alt="image-20200815103853857"></p>
<p>幻读临键锁可以解决</p>
<h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，<strong>写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</strong></p>
<p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p>
<p><strong>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</strong></p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><ul>
<li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li>
</ul>
<h3 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h3><p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p>
<p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t(id, x) VALUES(1, &quot;a&quot;);</span><br><span class="line">UPDATE t SET x=&quot;b&quot; WHERE id=1;</span><br><span class="line">UPDATE t SET x=&quot;c&quot; WHERE id=1;</span><br></pre></td></tr></table></figure>

<p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p>
<p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/Undo%E6%97%A5%E5%BF%97.png" alt="image-20200815104813509"></p>
<p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>MVCC 维护了一个 ReadView 结构，主要<strong>包含了当前系统未提交的事务列表</strong> TRX_IDs {TRX_ID_1, TRX_ID_2, …}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。</p>
<p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li>
<li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li>
<li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：<ul>
<li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ul>
<p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p>
<h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><h4 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h4><p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table ...;</span><br></pre></td></tr></table></figure>

<h4 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h4><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT;</span><br><span class="line">UPDATE;</span><br><span class="line">DELETE;</span><br></pre></td></tr></table></figure>

<p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE ? lock in share mode;</span><br><span class="line">SELECT * FROM table WHERE ? for update;</span><br></pre></td></tr></table></figure>

<h1 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h1><ul>
<li><p>表锁</p>
</li>
<li><p>行锁</p>
</li>
<li><p>间隙锁（Gap Locks）</p>
</li>
<li><p>临键锁（Next-key Locks）</p>
</li>
<li><p>共享锁/排他锁（Shared and Exclusive Locks）</p>
</li>
<li><p>意向共享锁/意向排他锁（Intention Shared and Exclusive Locks）</p>
</li>
<li><p>插入意向锁（Insert Intention Locks）</p>
</li>
<li><p>自增锁（Auto-inc Locks）</p>
</li>
</ul>
<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">动增加表锁</span><br><span class="line">lock table 表名字 read(write), 表名字2 read(write), 其他;</span><br><span class="line">查看表上加过的锁</span><br><span class="line">show open tables;</span><br><span class="line">释放表锁</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br><span class="line">线程1 加读锁 lock table 表名字 read;</span><br><span class="line">	线程1不能查询它没有锁定的表，也不能更新这个锁定的表。</span><br><span class="line">	其他线程可以查询该表的数据，也可以查询其他表的数据，但不能这个加锁的表进行修改，会一直等待获得锁。</span><br><span class="line">	</span><br><span class="line">线程1 加写锁 lock table 表名字 write;</span><br><span class="line">	线程1可以对表进行查询、更新、删除等操作</span><br><span class="line">	其他线程对这个表的操作会阻塞。</span><br></pre></td></tr></table></figure>

<p><strong>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。</strong></p>
<p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E8%A1%A8%E9%94%81.png" alt="img"></p>
<p>表锁分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#看看哪些表被加锁了：</span><br><span class="line">show open tables;</span><br><span class="line">#检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定。</span><br><span class="line">show status like ‘table%</span><br><span class="line"></span><br><span class="line">Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1；</span><br><span class="line">Table_locks_waited：出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值加1），此值高则说明存在着较严重的表级锁争用情况。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p>
<h2 id="行锁-记录锁"><a href="#行锁-记录锁" class="headerlink" title="行锁(记录锁)"></a>行锁(记录锁)</h2><ul>
<li><p>偏向Innodb存储引擎，开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li><p>Innodb与MyISAM的最大不同有两点：</p>
</li>
<li><ul>
<li>一是支持事务（TRANSACTION）</li>
<li>而是采用了行级锁</li>
</ul>
</li>
</ul>
<p>行锁就是针对数据表中行记录的锁。比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新</p>
<h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p><strong>一级封锁协议</strong></p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/Blog/source/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.png" alt="image-20200815095233877"></p>
<p><strong>二级封锁协议</strong></p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/Blog/source/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E4%BA%8C%E7%BA%A7%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.png" alt="image-20200815095603609"></p>
<p><strong>三级封锁协议</strong></p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/Blog/source/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E4%B8%89%E7%BA%A7%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.png" alt></p>
<h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/Blog/source/_posts/数据库/mysql事务和锁/两段锁协议.png" alt="在这里插入图片描述" style="zoom:67%;">

<p>加锁和解锁分为两个阶段进行。</p>
<p>事务A持有的两个记录的行锁都是在commit的时候才释放的，事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行</p>
<p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议</strong></p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>

<p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>

<h3 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放**</span><br><span class="line"></span><br><span class="line">假设要实现一个电影票在线交易业务，顾客A要在影院B购买电影票。业务需要涉及到以下操作：</span><br><span class="line"></span><br><span class="line">1.从顾客A账户余额中扣除电影票价</span><br><span class="line"></span><br><span class="line">2.给影院B的账户余额增加这张电影票价</span><br><span class="line"></span><br><span class="line">3.记录一条交易日志</span><br><span class="line"></span><br><span class="line">为了保证交易的原子性，要把这三个操作放在一个事务中。如何安排这三个语句在事务中的顺序呢？</span><br><span class="line"></span><br><span class="line">如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。根据两阶段锁协议，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度</span><br></pre></td></tr></table></figure>

<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK In SHARE MODE;</span><br><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<h3 id="行锁升级表锁"><a href="#行锁升级表锁" class="headerlink" title="行锁升级表锁"></a>行锁升级表锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Session 1</span><br><span class="line">begin;</span><br><span class="line">select * from t1 where name = &#x27;张三&#x27; for update;</span><br><span class="line"></span><br><span class="line">ROLLBACK</span><br><span class="line">COMMIT</span><br><span class="line"></span><br><span class="line">/****************************************************************************/</span><br><span class="line">Session 2</span><br><span class="line">begin;</span><br><span class="line">select * from t1 where id = 3 for update;</span><br><span class="line"></span><br><span class="line">ROLLBACK</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>

<p>session2 因为行锁升级为表锁一直在等待</p>
<p>InnoDB 行级锁是通过<strong>给索引上的索引项加锁</strong>来实现的，InnoDB行级锁只有通过索引条件检索数据，才使用行级锁;否则，InnoDB使用表锁 在不通过索引(主 键)条件查询的时候，InnoDB是表锁而不是行锁。</p>
<p><strong>如果在更新数据的时候出现了强制类型转换导致索引失效</strong>，使得行锁变表锁.</p>
<h2 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h2><p>间隙锁则锁的是若干个索引间的间隙，每个间隙都是两端开放的区间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的Next-Key Locking 算法，请务必牢记：使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;</span><br><span class="line">即所有在（1，10）区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。</span><br><span class="line"></span><br><span class="line">除了手动加锁外，在执行完某些 SQL 后，InnoDB 也会自动加间隙锁。</span><br></pre></td></tr></table></figure>

<p>面试常问：常考如何锁定一行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表 where 某一行的条件 for update;</span><br></pre></td></tr></table></figure>



<h2 id="临键锁（Next-Key-Locks）"><a href="#临键锁（Next-Key-Locks）" class="headerlink" title="临键锁（Next-Key Locks）"></a>临键锁（Next-Key Locks）</h2><p>(间隙锁+行锁)</p>
<p>Next-Key 可以理解为一种特殊的间隙锁，也可以理解为一种特殊的算法。通过临建锁可以解决<code>幻读</code>的问题。 每个数据行上的<code>非唯一索引列</code>上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段<strong>左开右闭</strong>间的数据。需要强调的一点是，<code>InnoDB</code> 中<code>行级锁</code>是基于索引实现的，临键锁只与<code>非唯一索引列</code>有关，在<code>唯一索引列</code>（包括<code>主键列</code>）上不存在临键锁。</p>
<p>假设有如下表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` int(1) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(8) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `test` VALUES (&#x27;1&#x27;, &#x27;小罗&#x27;);</span><br><span class="line">INSERT INTO `test` VALUES (&#x27;5&#x27;, &#x27;小黄&#x27;);</span><br><span class="line">INSERT INTO `test` VALUES (&#x27;7&#x27;, &#x27;小明&#x27;);</span><br><span class="line">INSERT INTO `test` VALUES (&#x27;11&#x27;, &#x27;小红&#x27;);</span><br><span class="line">我们先来看看test表中存在的隐藏间隙：</span><br><span class="line">(-∞, 1]</span><br><span class="line">(1, 5]</span><br><span class="line">(5, 7]</span><br><span class="line">(7, 11]</span><br><span class="line">(11, +∞]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#SessionA</span><br><span class="line">-- 根据非唯一索引列 UPDATE 某条记录</span><br><span class="line">SELECT * FROM `test` WHERE `id` BETWEEN 5 AND 7 FOR UPDATE;</span><br><span class="line"> </span><br><span class="line">#SessionB</span><br><span class="line">/* 插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (3, &#x27;小张1&#x27;); # 正常执行</span><br><span class="line"></span><br><span class="line">/* 插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (4, &#x27;小白&#x27;); # 正常执行</span><br><span class="line"></span><br><span class="line">/* 插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (6, &#x27;小东&#x27;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (8, &#x27;大罗&#x27;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 插入一条 id = 9， name = &#x27;大东&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (9, &#x27;大东&#x27;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 插入一条 id = 11， name = &#x27;李西&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (11, &#x27;李西&#x27;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 插入一条 id = 12， name = &#x27;张三&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (12, &#x27;张三&#x27;); # 正常执行</span><br></pre></td></tr></table></figure>

<p>那最终我们就可以得知，在根据<code>非唯一索引</code> 对记录行进行 <code>UPDATE \ FOR UPDATE \ LOCK IN SHARE MODE</code> 操作时，InnoDB 会获取该记录行的 <code>临键锁</code> ，并同时获取该记录行下一个区间的<code>间隙锁</code>。</p>
<p>即<code>事务 A</code>在执行了上述的 SQL 后，最终被锁住的记录区间为 <code>(5, 11]</code>。</p>
<h2 id="共享锁-排他锁（Shared-and-Exclusive-Locks）"><a href="#共享锁-排他锁（Shared-and-Exclusive-Locks）" class="headerlink" title="共享锁/排他锁（Shared and Exclusive Locks）"></a>共享锁/排他锁（Shared and Exclusive Locks）</h2><h3 id="共享锁-Share-Lock"><a href="#共享锁-Share-Lock" class="headerlink" title="共享锁(Share Lock)"></a>共享锁(Share Lock)</h3><p>共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。</p>
<p>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>

<p>在查询语句后面增加<code>LOCK IN SHARE MODE</code>，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p>
<h3 id="排他锁（eXclusive-Lock）"><a href="#排他锁（eXclusive-Lock）" class="headerlink" title="排他锁（eXclusive Lock）"></a>排他锁（eXclusive Lock）</h3><p>排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</p>
<h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>在查询语句后面增加<code>FOR UPDATE</code>，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。</p>
<h2 id="意向共享锁-意向排他锁（Intention-Shared-and-Exclusive-Locks）"><a href="#意向共享锁-意向排他锁（Intention-Shared-and-Exclusive-Locks）" class="headerlink" title="意向共享锁/意向排他锁（Intention Shared and Exclusive Locks）"></a>意向共享锁/意向排他锁（Intention Shared and Exclusive Locks）</h2><p>意向锁是表级锁，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。</p>
<p>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存InnoDB中的两个表锁：</p>
<p><strong>意向共享锁（IS</strong>）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁</p>
<p><strong>意向排他锁（IX）</strong>：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。</p>
<p>例子：事务A修改user表的记录r，会给记录r上一把行级的排他锁（X），同时会给user表上一把意向排他锁（IX），这时事务B要给user表上一个表级的排他锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。</p>
<p><strong>意向锁是InnoDB自动加的，不需要用户干预。</strong></p>
<h3 id="q1-为什么意向锁是表级锁呢？"><a href="#q1-为什么意向锁是表级锁呢？" class="headerlink" title="q1 为什么意向锁是表级锁呢？"></a>q1 为什么意向锁是表级锁呢？</h3><p>当我们需要加一个排他锁时，需要根据意向锁去判断表中有没有数据行被锁定（行锁）；</p>
<p>（1）如果意向锁是行锁，则需要遍历每一行数据去确认；</p>
<p>（2）如果意向锁是表锁，则只需要判断一次即可知道有没数据行被锁定，提升性能。</p>
<h3 id="q2-意向锁怎么支持表锁和行锁并存？"><a href="#q2-意向锁怎么支持表锁和行锁并存？" class="headerlink" title="q2 意向锁怎么支持表锁和行锁并存？"></a>q2 意向锁怎么支持表锁和行锁并存？</h3><p>（1）首先明确并存的概念是指数据库同时支持表、行锁，而不是任何情况都支持一个表中同时有一个事务A持有行锁、又有一个事务B持有表锁，因为表一旦被上了一个表级的写锁，肯定不能再上一个行级的锁。<br>（2）如果事务A对某一行上锁，其他事务就不可能修改这一行。这与“事务B锁住整个表就能修改表中的任意一行”形成了冲突。所以，没有意向锁的时候，让行锁与表锁共存，就会带来很多问题。于是有了意向锁的出现，如q1的答案中，数据库不需要在检查每一行数据是否有锁，而是直接判断一次意向锁是否存在即可，能提升很多性能。</p>
<h2 id="插入意向锁（Insert-Intention-Locks）"><a href="#插入意向锁（Insert-Intention-Locks）" class="headerlink" title="插入意向锁（Insert Intention Locks）"></a>插入意向锁（Insert Intention Locks）</h2><p>插入意向锁本质上可以看成是一个<code>Gap Lock</code></p>
<ul>
<li>普通的Gap Lock 不允许 在 （上一条记录，本记录） 范围内插入数据</li>
<li>插入意向锁Gap Lock 允许 在 （上一条记录，本记录） 范围内插入数据</li>
</ul>
<p>插入意向锁的作用是为了<strong>提高并发插入的性能</strong>， 多个事务 同时写入 不同数据 至同一索引范围（区间）内，并不需要等待其他事务完成，不会发生锁等待。</p>
<h3 id="插入的过程"><a href="#插入的过程" class="headerlink" title="插入的过程"></a>插入的过程</h3><p>假设现在有记录 10， 30， 50， 70 ；且为主键 ，需要插入记录 25 。</p>
<ol>
<li>找到 小于等于25的记录 ，这里是 10</li>
<li>找到 记录10的下一条记录 ，这里是 30</li>
<li>判断 下一条记录30 上是否有锁<br>3.1 判断 30 上面如果 没有锁 ，则可以插入<br>3.2 判断 30 上面如果有<code>Record Lock</code>，则可以插入<br>3.3 判断 30 上面如果有<code>Gap Lock</code>/<code>Next-Key Lock</code>，则无法插入，因为锁的范围是 (10, 30) /（10, 30] ；在30上增加<code>insert intention lock</code>（ 此时处于waiting状态），当 Gap Lock / Next-Key Lock 释放时，等待的事物（ transaction）将被 唤醒 ，此时 记录30 上才能获得 insert intention lock ，然后再插入 记录25</li>
</ol>
<p>注意：<strong>一个事物 insert 25 且没有提交，另一个事物 delete 25 时，记录25上会有 Record Lock</strong></p>
<p>开启两个会话，两个会话事务的隔离级别都设置为<code>REPEATABLE-READ</code></p>
<table>
<thead>
<tr>
<th align="center">Time</th>
<th align="center">会话A</th>
<th align="center">会话B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">begin</td>
<td align="center">begin</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">select * from a where a&lt;=13 for update</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center">insert into a values (12)  – waiting…… （被阻塞了，在这里等待）</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">此时执行show engine innodb status\G语句会看到以下结果</span><br><span class="line">---TRANSACTION 4424, ACTIVE 7 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)</span><br><span class="line">MySQL thread id 3, OS thread handle 140018685810432, query id 240 localhost root update</span><br><span class="line">--等待插入的SQL</span><br><span class="line">insert into a values(12)</span><br><span class="line">------- TRX HAS BEEN WAITING 7 SEC FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">--插入记录12的事物等待中（被终端会话A中的事物阻塞了），等待获得插入意向锁(lock_mode X locks gap before rec insert intention waiting)</span><br><span class="line">RECORD LOCKS space id 37 page no 3 n bits 72 index PRIMARY of table `test`.`a` trx id 4424 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000d; asc     ;;</span><br><span class="line"> 1: len 6; hex 000000001140; asc      @;;</span><br><span class="line"> 2: len 7; hex b400000128011c; asc     (  ;;</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">TABLE LOCK table `test`.`a` trx id 4424 lock mode IX</span><br><span class="line">RECORD LOCKS space id 37 page no 3 n bits 72 index PRIMARY of table `test`.`a` trx id 4424 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000d; asc     ;;</span><br><span class="line"> 1: len 6; hex 000000001140; asc      @;;</span><br><span class="line"> 2: len 7; hex b400000128011c; asc     (  ;;</span><br><span class="line"></span><br><span class="line">---TRANSACTION 4423, ACTIVE 55 sec</span><br><span class="line">2 lock struct(s), heap size 1136, 4 row lock(s)</span><br><span class="line">MySQL thread id 2, OS thread handle 140018686076672, query id 241 localhost root starting</span><br><span class="line">show engine innodb status</span><br><span class="line">TABLE LOCK table `test`.`a` trx id 4423 lock mode IX</span><br><span class="line">RECORD LOCKS space id 37 page no 3 n bits 72 index PRIMARY of table `test`.`a` trx id 4423 lock_mode X</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000113f; asc      ?;;</span><br><span class="line"> 2: len 7; hex b3000001270110; asc     &#x27;  ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000b; asc     ;;</span><br><span class="line"> 1: len 6; hex 000000001140; asc      @;;</span><br><span class="line"> 2: len 7; hex b4000001280110; asc     (  ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000d; asc     ;;</span><br><span class="line"> 1: len 6; hex 000000001140; asc      @;;</span><br><span class="line"> 2: len 7; hex b400000128011c; asc     (  ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000014; asc     ;;</span><br><span class="line"> 1: len 6; hex 000000001145; asc      E;;</span><br><span class="line"> 2: len 7; hex b70000012b0110; asc     +  ;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">Time</th>
<th align="center">会话A</th>
<th align="center">会话B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">begin</td>
<td align="center">begin</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">select * from a where a&lt;=13 for update</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center">insert into a values (12)  – waiting…… （被阻塞了，在这里等待）</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">commit</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"></td>
<td align="center">输出：Query OK, 1 row affected (17.40 sec) 前提条件是insert操作的锁没有超时</td>
</tr>
</tbody></table>
<p>此时事务B插入成功但是还未commit，再执行<code>show engine innodb status\G</code>语句，会有以下输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---TRANSACTION <span class="number">4425</span>, ACTIVE <span class="number">26</span> sec</span><br><span class="line"><span class="number">2</span> lock <span class="keyword">struct</span>(s), heap size <span class="number">1136</span>, <span class="number">1</span> row lock(s), undo log entries <span class="number">1</span></span><br><span class="line">MySQL thread id <span class="number">3</span>, OS thread handle <span class="number">140018685810432</span>, query id <span class="number">247</span> localhost root</span><br><span class="line">TABLE LOCK table <span class="string">`test`</span>.<span class="string">`a`</span> trx id <span class="number">4425</span> lock mode IX</span><br><span class="line">RECORD LOCKS space id <span class="number">37</span> page no <span class="number">3</span> n bits <span class="number">72</span> index PRIMARY of table <span class="string">`test`</span>.<span class="string">`a`</span> trx id <span class="number">4425</span> lock_mode X locks gap before rec insert intention</span><br><span class="line">Record lock, heap no <span class="number">4</span> PHYSICAL RECORD: n_fields <span class="number">3</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: <span class="built_in">len</span> <span class="number">4</span>; hex <span class="number">8000000</span>d; asc     ;;</span><br><span class="line"> <span class="number">1</span>: <span class="built_in">len</span> <span class="number">6</span>; hex <span class="number">000000001140</span>; asc      @;;</span><br><span class="line"> <span class="number">2</span>: <span class="built_in">len</span> <span class="number">7</span>; hex b400000128011c; asc     (  ;;</span><br></pre></td></tr></table></figure>

<p>从上面的输出可以看到在记录13上面加了一把插入意图锁（<code>lock_mode X locks gap before rec insert intention</code>）。<br> 获得插入意图锁之后，我们就可以在11-13之间并发插入记录，而不需要一个事物等待另一事物，当所有相关的插入的事物都提交后， 13上的插入意向锁 便会释放。</p>
<h2 id="自增锁（Auto-inc-Locks）"><a href="#自增锁（Auto-inc-Locks）" class="headerlink" title="自增锁（Auto-inc Locks）"></a>自增锁（Auto-inc Locks）</h2><p><strong>自增锁,在提交前释放,并发插入高</strong></p>
<p><strong>s,x等锁,在COMMIT扣释放,并发插入需要等待</strong></p>
<p>不能回滚到前面的值</p>
<p>在InnoDB中，每个含有自增列的表都有一个自增长计数器。当对含有自增长计数器的表进行插入时，首先会执行<code>select max(auto_inc_col) from t for update</code>来得到计数器的值，然后再将这个值加1赋予自增长列。我们将这种方式称之为<code>AUTO_INC Lock</code>。</p>
<p><code>AUTO_INC Lock</code>是一种特殊的表锁，它在完成对自增长值插入的SQL语句后立即释放，所以性能会比事务完成后释放锁要高。由于是表级别的锁，所以在并发环境下其依然存在性能问题。</p>
<p>从MySQL 5.1.22开始，InnoDB中提供了一种轻量级互斥量的自增长实现机制，同时InnoDB存储引擎提供了一个参数<code>innodb_autoinc_lock_mode</code>来控制自增长的模式，进而提高自增长值插入的性能。<code>innodb_autoinc_lock_mode</code>和插入类型有关，在介绍它之前，我们先来看看都有哪些插入类型</p>
<ul>
<li><p>“INSERT-like” statements</p>
<p>泛指所有的插入语句, 它包括 “simple-inserts”, “bulk-inserts”, 和 “mixed-mode inserts”.</p>
</li>
<li><p>“Simple inserts”</p>
<p>插入的记录行数是确定的：比如：insert into values，replace<br> 但是不包括： INSERT … ON DUPLICATE KEY UPDATE.</p>
</li>
<li><p>“Bulk inserts”</p>
<p>插入的记录行数不能马上确定的，比如： INSERT … SELECT, REPLACE … SELECT, and LOAD DATA</p>
</li>
<li><p>“Mixed-mode inserts”</p>
<p>这些都是simple-insert，但是部分auto increment值给定或者不给定. 例子如下(where <code>c1</code> is an <code>AUTO_INCREMENT</code> column of table <code>t1</code>):</p>
</li>
</ul>
  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t1 (c1,c2) VALUES (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>), (<span class="literal">NULL</span>,<span class="string">&#x27;b&#x27;</span>), (<span class="number">5</span>,<span class="string">&#x27;c&#x27;</span>), (<span class="literal">NULL</span>,<span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>  另外一种 “mixed-mode insert” 就是 <code>INSERT ... ON DUPLICATE KEY UPDATE</code></p>
<p>介绍完插入类型之后，我们再来看看锁模式，即<code>innodb_autoinc_lock_mode</code>。</p>
<p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/Blog/source/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E8%87%AA%E5%A2%9E%E9%94%81.png" alt="image-20200814235726139"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0：traditonal （每次都会产生表锁）</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">1：consecutive （会产生一个轻量锁，simple insert会获得批量的锁，保证连续插入）</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">2：interleaved （不会锁表，来一个处理一个，并发最高）</span><br></pre></td></tr></table></figure>



<h2 id="事务使用的几点建议"><a href="#事务使用的几点建议" class="headerlink" title="事务使用的几点建议"></a>事务使用的几点建议</h2><ul>
<li>控制事务大小，减少锁定的资源量和锁定时间长度。</li>
<li>所有的数据检索都通过索引来完成，从而避免因为无法通过索引加锁而升级为表锁。</li>
<li>减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的数据。</li>
<li>在业务条件允许下，尽量使用较低隔离级别的事务隔离。减少隔离级别带来的附加成本。</li>
<li>合理使用索引，让innodb在索引上面加锁的时候更加准确。</li>
<li>在应用中尽可能做到访问的顺序执行。</li>
<li>如果容易死锁，就可以考虑使用表锁来减少死锁的概率</li>
</ul>
<h1 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h1><h2 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h2><p>数据结构、数据操作、数据约束</p>
<h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody></table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>属性不可分。</p>
<h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><strong>分解前</strong></p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody></table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><strong>分解后</strong></p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody></table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt; Grade</li>
</ul>
<h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递函数依赖：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
</tr>
</tbody></table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th>Sdept</th>
<th>Mname</th>
</tr>
</thead>
<tbody><tr>
<td>学院-1</td>
<td>院长-1</td>
</tr>
<tr>
<td>学院-2</td>
<td>院长-2</td>
</tr>
</tbody></table>
<h1 id="ER-图"><a href="#ER-图" class="headerlink" title="ER 图"></a>ER 图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h3 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h3><p>包含一对一，一对多，多对多三种。</p>
<ul>
<li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li>
<li>如果是一对一，画两个带箭头的线段；</li>
<li>如果是多对多，画两个不带箭头的线段。</li>
</ul>
<p>下图的 Course 和 Student 是一对多的关系。</p>
<img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/ER图.png" alt="image-20200815114836972" style="zoom: 50%;">

<h2 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。</p>
<p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/多对多.png" alt="image-20200815115129109" style="zoom:50%;">

<h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>
<img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/联系的多向性.png" alt="image-20200815115235884" style="zoom:50%;">

<h2 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>
<img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/表示子类.png" alt="image-20200815115400700" style="zoom:50%;">



<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dca007208a58">https://www.jianshu.com/p/dca007208a58</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010841296/article/details/87909468">https://blog.csdn.net/u010841296/article/details/87909468</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Terry-Wu/p/12219019.html">https://www.cnblogs.com/Terry-Wu/p/12219019.html</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#mysql-%E9%9A%90%E5%BC%8F%E4%B8%8E%E6%98%BE%E7%A4%BA%E9%94%81%E5%AE%9A">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#mysql-%E9%9A%90%E5%BC%8F%E4%B8%8E%E6%98%BE%E7%A4%BA%E9%94%81%E5%AE%9A</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9ff938e3a498">ER图</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43255017/article/details/106442887?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/qq_43255017/article/details/106442887?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/CuiHongYu/p/10845354.html">https://www.cnblogs.com/CuiHongYu/p/10845354.html</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mysql/">mysql</a></div><div class="post_share"><div class="social-share" data-image="/./img/photo-1465188162913-8fb5709d6d57.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/"><img class="prev-cover" src="/./img/photo-1465188162913-8fb5709d6d57.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">mysql高级</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%9A%84in%E5%92%8Cexist%E5%8C%BA%E5%88%AB/"><img class="next-cover" src="/./img/photo-1465188162913-8fb5709d6d57.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">mysql的in和exist区别</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/08/14/数据库/mysql的in和exist区别/" title="mysql的in和exist区别"><img class="cover" src="/./img/photo-1465188162913-8fb5709d6d57.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-14</div><div class="title">mysql的in和exist区别</div></div></a></div><div><a href="/2020/08/15/数据库/mysql高级/" title="mysql高级"><img class="cover" src="/./img/photo-1465188162913-8fb5709d6d57.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-15</div><div class="title">mysql高级</div></div></a></div><div><a href="/2020/08/14/数据库/mysql必知必会/" title="mysql必知必会"><img class="cover" src="/./img/photo-1626811407568-2f41c53fff99.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-14</div><div class="title">mysql必知必会</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.</span> <span class="toc-text">MySQL事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%88ACID%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">事务的四大特征（ACID）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88Atomicity%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 原子性（Atomicity）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%88Consistency%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 一致性（Consistency）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%88Isolation%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 隔离性（Isolation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%88Durability%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">4. 持久性（Durability）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">Mysql怎么保证一致性的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">Mysql怎么保证原子性的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%8C%81%E4%B9%85%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">Mysql怎么保证持久性的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%9A%94%E7%A6%BB%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">Mysql怎么保证隔离性的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">并发一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9"><span class="toc-number">1.3.1.</span> <span class="toc-text">丢失修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%84%8F%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.2.</span> <span class="toc-text">读脏数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">不可重复读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BB%E5%BD%B1%E8%AF%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">幻影读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">多版本并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.5.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number">1.5.2.</span> <span class="toc-text">版本号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Undo-%E6%97%A5%E5%BF%97"><span class="toc-number">1.5.3.</span> <span class="toc-text">Undo 日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadView"><span class="toc-number">1.5.4.</span> <span class="toc-text">ReadView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">1.5.5.</span> <span class="toc-text">快照读与当前读</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">1. 快照读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">2. 当前读</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E7%9A%84%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">MySQL的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">2.1.</span> <span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E9%94%81-%E8%AE%B0%E5%BD%95%E9%94%81"><span class="toc-number">2.2.</span> <span class="toc-text">行锁(记录锁)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.2.1.</span> <span class="toc-text">三级封锁协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.2.2.</span> <span class="toc-text">两段锁协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E9%9A%90%E5%BC%8F%E4%B8%8E%E6%98%BE%E7%A4%BA%E9%94%81%E5%AE%9A"><span class="toc-number">2.2.3.</span> <span class="toc-text">MySQL 隐式与显示锁定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E5%8D%87%E7%BA%A7%E8%A1%A8%E9%94%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">行锁升级表锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Locks%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">间隙锁（Gap Locks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%88Next-Key-Locks%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">临键锁（Next-Key Locks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81-%E6%8E%92%E4%BB%96%E9%94%81%EF%BC%88Shared-and-Exclusive-Locks%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">共享锁&#x2F;排他锁（Shared and Exclusive Locks）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81-Share-Lock"><span class="toc-number">2.5.1.</span> <span class="toc-text">共享锁(Share Lock)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E4%BB%96%E9%94%81%EF%BC%88eXclusive-Lock%EF%BC%89"><span class="toc-number">2.5.2.</span> <span class="toc-text">排他锁（eXclusive Lock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%B3%95-1"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E5%85%B1%E4%BA%AB%E9%94%81-%E6%84%8F%E5%90%91%E6%8E%92%E4%BB%96%E9%94%81%EF%BC%88Intention-Shared-and-Exclusive-Locks%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">意向共享锁&#x2F;意向排他锁（Intention Shared and Exclusive Locks）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#q1-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%84%8F%E5%90%91%E9%94%81%E6%98%AF%E8%A1%A8%E7%BA%A7%E9%94%81%E5%91%A2%EF%BC%9F"><span class="toc-number">2.6.1.</span> <span class="toc-text">q1 为什么意向锁是表级锁呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#q2-%E6%84%8F%E5%90%91%E9%94%81%E6%80%8E%E4%B9%88%E6%94%AF%E6%8C%81%E8%A1%A8%E9%94%81%E5%92%8C%E8%A1%8C%E9%94%81%E5%B9%B6%E5%AD%98%EF%BC%9F"><span class="toc-number">2.6.2.</span> <span class="toc-text">q2 意向锁怎么支持表锁和行锁并存？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88Insert-Intention-Locks%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">插入意向锁（Insert Intention Locks）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.1.</span> <span class="toc-text">插入的过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E9%94%81%EF%BC%88Auto-inc-Locks%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">自增锁（Auto-inc Locks）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E4%BD%BF%E7%94%A8%E7%9A%84%E5%87%A0%E7%82%B9%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.9.</span> <span class="toc-text">事务使用的几点建议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA"><span class="toc-number">3.</span> <span class="toc-text">关系数据库设计理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">关系数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">3.2.</span> <span class="toc-text">函数依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">3.3.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F-1NF"><span class="toc-number">3.4.1.</span> <span class="toc-text">1. 第一范式 (1NF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F-2NF"><span class="toc-number">3.4.2.</span> <span class="toc-text">2. 第二范式 (2NF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F-3NF"><span class="toc-number">3.4.3.</span> <span class="toc-text">3. 第三范式 (3NF)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ER-%E5%9B%BE"><span class="toc-number">4.</span> <span class="toc-text">ER 图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%89%E7%A7%8D%E8%81%94%E7%B3%BB"><span class="toc-number">4.0.1.</span> <span class="toc-text">实体的三种联系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%87%BA%E7%8E%B0%E5%A4%9A%E6%AC%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.1.</span> <span class="toc-text">表示出现多次的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E7%B3%BB%E7%9A%84%E5%A4%9A%E5%90%91%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">联系的多向性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%AD%90%E7%B1%BB"><span class="toc-number">4.3.</span> <span class="toc-text">表示子类</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By naive</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>