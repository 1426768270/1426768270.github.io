<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>计算机网络 | naive的博客</title><meta name="keywords" content="网络"><meta name="author" content="naive"><meta name="copyright" content="naive"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、网络模型OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。TCP&#x2F;IP分层（4层）：网络接口层、 网际层、运输层、 应用层。五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。 物理层：  该层为上层协议提供了一个传输数据的可靠物理媒介  数据的单位称为比特(bit)。  物理层的主要设备:中继器、集线器、适配器。  主要协议：IEEE802.3">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://yoursite.com/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="naive的博客">
<meta property="og:description" content="一、网络模型OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。TCP&#x2F;IP分层（4层）：网络接口层、 网际层、运输层、 应用层。五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。 物理层：  该层为上层协议提供了一个传输数据的可靠物理媒介  数据的单位称为比特(bit)。  物理层的主要设备:中继器、集线器、适配器。  主要协议：IEEE802.3">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/img/photo-1628009193228-076ab63d655a.jpg">
<meta property="article:published_time" content="2020-07-27T09:01:01.000Z">
<meta property="article:modified_time" content="2021-08-08T08:01:18.730Z">
<meta property="article:author" content="naive">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/img/photo-1628009193228-076ab63d655a.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-08 16:01:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="naive的博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">174</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/photo-1628009193228-076ab63d655a.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">naive的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-27T09:01:01.000Z" title="发表于 2020-07-27 17:01:01">2020-07-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-08T08:01:18.730Z" title="更新于 2021-08-08 16:01:18">2021-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计算机网络"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、网络模型"><a href="#一、网络模型" class="headerlink" title="一、网络模型"></a>一、网络模型</h1><p><strong>OSI分层 （7层）：</strong>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br><strong>TCP/IP分层（4层）：</strong>网络接口层、 网际层、运输层、 应用层。<br><strong>五层协议 （5层）：</strong>物理层、数据链路层、网络层、运输层、 应用层。</p>
<p>物理层：</p>
<ul>
<li><p><strong>该层为上层协议提供了一个传输数据的可靠物理媒介</strong></p>
</li>
<li><p>数据的单位称为<strong>比特</strong>(bit)。</p>
</li>
<li><p>物理层的主要设备:中继器、集线器、适配器。</p>
</li>
<li><p>主要协议：IEEE802.3 </p>
</li>
</ul>
<p>数据链路层</p>
<ul>
<li><p><strong>实现两个主机系统之间的数据传输透明</strong></p>
</li>
<li><p>数据的单位称为<strong>帧</strong>(frame)。</p>
</li>
<li><p>数据链路层主要设备:二层交换机、网桥。</p>
</li>
<li><p>主要协议：以太网协议ppp、MAC </p>
</li>
</ul>
<p>网络层</p>
<ul>
<li><strong>实现两个主机系统之间的数据传输透明,路由选择，连接的建立与终止等</strong>，<strong>它提供的服务使传输层不需要了解网络层的数据传输和交换技术</strong></li>
<li><strong>数据包</strong></li>
<li>网络层主要设备:路由器</li>
<li>网络层协议的代表包括:IP、IPX、RIP、ARP、RARP、OSPF等。</li>
</ul>
<p>传输层</p>
<ul>
<li>进程之间的通信。提供端到端的可靠报文传递和错误恢复</li>
<li><strong>TCP的叫段、UDP的叫数据报</strong></li>
<li>TCP/UDP</li>
</ul>
<p>会话层</p>
<ul>
<li>建立、管理和终止会话</li>
<li>会话协议数据单元SPDU</li>
</ul>
<p>表示层</p>
<ul>
<li>对数据进行翻译、加密和压缩</li>
</ul>
<p>应用层</p>
<ul>
<li>允许访问OSI环境的手段</li>
<li>TFTP，HHTP，SMTP,FTP,DN</li>
</ul>
<p>在TCP/IP中会话层和表示层，应用层是应用层</p>
<h1 id="二、TCP和UDP"><a href="#二、TCP和UDP" class="headerlink" title="二、TCP和UDP"></a>二、TCP和UDP</h1><p><strong>传输层协议</strong></p>
<h2 id="TCP和UCP的区别"><a href="#TCP和UCP的区别" class="headerlink" title="TCP和UCP的区别"></a>TCP和UCP的区别</h2><table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>连接</td>
<td>有连接</td>
<td>无连接</td>
</tr>
<tr>
<td>可靠</td>
<td>可靠，使用流量控制和拥塞控制</td>
<td>不可靠，没有使用控制</td>
</tr>
<tr>
<td>有序</td>
<td>有序</td>
<td>无序</td>
</tr>
<tr>
<td>有界</td>
<td>无界</td>
<td>有界</td>
</tr>
<tr>
<td>重传机制</td>
<td>超时重传，快速重传</td>
<td>无</td>
</tr>
<tr>
<td>连接对象</td>
<td>一对一</td>
<td>一对一，一对多，多对多</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向数据流</td>
<td>面向报文</td>
</tr>
<tr>
<td>首部开销</td>
<td>最小20字节，最大60字节</td>
<td>小，仅8字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>可靠的应用传输（文件传输）</td>
<td>实时会议（视频会议，直播）</td>
</tr>
</tbody></table>
<p>是否有界</p>
<ul>
<li><strong>TCP通过字节流传输</strong>TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。 而<strong>UDP传输报文的方式是由应用程序</strong>控制的，<strong>应用层</strong>交给UDP多长的报文，UDP照样发送，<strong>既不拆分，也不合并，而是保留这些报文的边界</strong>，即一次发送一个报文。有界与无界之分是根据接收报文来划分的，对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的,<strong>UDP无缓存服务，信息确认由应用层完成</strong>。</li>
</ul>
<p>TCP黏包问题</p>
<ul>
<li>如果发送的网络数据包太小，<strong>对较小的数据包进行合并</strong>，<strong>服务器在接收到消息（数据流）的时候就无法区分哪些数据包是客户端自己分开发送的，这样产生了粘包</strong>；</li>
</ul>
<p>UDP无连接</p>
<ul>
<li><blockquote>
<p>在发送端，应用层将数据传递给传输层的 UDP 协议，<strong>UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议</strong>，然后就传递给网络层了.在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。</p>
</blockquote>
</li>
</ul>
<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Cecilia3333/article/details/80358201">TCP的各种机制</a></p>
<ul>
<li><p>可靠性</p>
<ul>
<li><strong>确认应答机制</strong>（ACK）</li>
<li><strong>超时重传机制</strong></li>
<li><strong>校验和</strong></li>
</ul>
</li>
<li><p>流量控制</p>
<ul>
<li><p>滑动窗口机制（ARQ)</p>
<blockquote>
<p><strong>建立连接时，各端分配一个缓冲区用来存储接收的数据，并将缓冲区的尺寸发送给另一端。接收方发送的确认消息中包含了自己剩余的缓冲区尺寸。剩余缓冲区空间的数量叫做窗口。</strong>滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>拥塞控制</p>
<ul>
<li><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载</p>
</li>
<li><p>具体实现</p>
<blockquote>
<p><strong>慢启动</strong>（Slow Start）发送方维护拥塞窗口变量cwnd，先用小数据试探网络拥塞，没问题后来断加倍。拥塞窗口的大小取决于网络的拥塞程度，并且动态的变化。<br><strong>拥塞避免</strong>（Congestion voidance）：拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1<br><strong>快速重传</strong>（Fast Retransmit）：快重传要求接收方收到失序报文段后立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br><strong>快速恢复</strong>（Fast Recovery）：当发送方连续收到三个重复确认时，就把慢开始门限ssthresh门限减半。接下来将cwnd设置为ssthresh的大小，然后执行拥塞避免算法</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="这里写图片描述"></p>
<ul>
<li>第一次握手：客户端将标志位SYN置为1，表示请求同步（建立连接）。随机产生一个序号seq=x，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li>
<li>第二次握手：服务器端将标志位SYN置为1表示请求同步，ACK置为1表示收到请求。ack=x+1，用于给客户端和之前传送过来的seq校验。随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li>
<li>第三次握手：客户端收到确认后，检查ACK是否为1，ack是否为x+1，如果正确则将标志位ACK置为1，ack=y+1，seq=传过来的ack=x+1，并将该数据包发送给服务器端，并进入ESTABLISHED状态。服务器端检查ACK是否为1，ack是否为y+1，如果正确则连接建立成功服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。假如第三次握手没有到达服务器端呢？但是这时客户端已进入ESTABLISHED状态。但是其实这种情况下，只要客户端向服务器端写数据，就会收到服务器端的RST（复位）应答，这时客户端就能知道出现问题了。</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><h3 id><a href="#" class="headerlink" title></a><img src="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="这里写图片描述"></h3><p>1）首先客户端想要释放连接，向服务器端发送一段TCP报文，其中：</p>
<ul>
<li><p><strong>标记位为FIN，表示“请求释放连接“；</strong></p>
</li>
<li><p><strong>序号为Seq=U；</strong></p>
</li>
<li><p><strong>随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。</strong></p>
<p>注意：这里不发送的是正常连接时传输的数据(非确认报文)，而不是一切数据，所以客户端仍然能发送ACK确认报文。</p>
</li>
</ul>
<p>（2）服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中：</p>
<ul>
<li><strong>标记位为ACK，表示“接收到客户端发送的释放连接的请求”；</strong></li>
<li><strong>序号为Seq=V；</strong></li>
<li><strong>确认号为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值；</strong></li>
<li><strong>随后服务器端开始准备释放服务器端到客户端方向上的连接。客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段</strong></li>
</ul>
<p>前”两次挥手”既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了</p>
<p>（3）服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中：</p>
<ul>
<li><p><strong>标记位为FIN，ACK，表示“已经准备好释放连接了”。注意：这里的ACK并不是确认收到服务器端报文的确认报文。</strong></p>
</li>
<li><p><strong>序号为Seq=W；</strong></p>
</li>
<li><p><strong>确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。</strong></p>
<p>随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。</p>
</li>
</ul>
<p>（4）客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：</p>
<ul>
<li><p><strong>标记位为ACK，表示“接收到服务器准备好释放连接的信号”。</strong></p>
</li>
<li><p><strong>序号为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。</strong></p>
</li>
<li><p><strong>确认号为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。</strong></p>
<p>随后客户端开始在TIME-WAIT阶段等待2MSL</p>
</li>
</ul>
<h2 id="一个典型TCP客户端（主动建立连接，主动断开连接）会经历的状态序列。"><a href="#一个典型TCP客户端（主动建立连接，主动断开连接）会经历的状态序列。" class="headerlink" title="一个典型TCP客户端（主动建立连接，主动断开连接）会经历的状态序列。"></a>一个典型TCP客户端（主动建立连接，主动断开连接）会经历的状态序列。</h2><p>SYNC_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT</p>
<h2 id="TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为"><a href="#TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为" class="headerlink" title="TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为"></a>TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为</h2><p>客户端：发送X</p>
<p>服务端：发送Y， 确认X+1 </p>
<p>客户端：发送X+1（1000），确认Y+1（2000）</p>
<p>第二次的发送序号为 1999 确认序号为999</p>
<h3 id="为什么TCP连接要建立三次连接？"><a href="#为什么TCP连接要建立三次连接？" class="headerlink" title="为什么TCP连接要建立三次连接？"></a>为什么TCP连接要建立三次连接？</h3><p>为了防止失效的连接请求又传送到主机，因而产生错误。</p>
<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<h3 id="为什么要4次挥手？"><a href="#为什么要4次挥手？" class="headerlink" title="为什么要4次挥手？"></a>为什么要4次挥手？</h3><ul>
<li>当主机A确认发送完数据且知道B已经接受完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给主机B。</li>
<li>主机B收到A发送的FIN，表示收到了，就会发送ACK回复。</li>
<li><strong>但这是B可能还在发送数据，没有想要关闭数据口的意思，所以FIN与ACK不是同时发送的，而是等到B数据发送完了，才会发送FIN给主机A。</strong></li>
<li>A收到B发来的FIN，知道B的数据也发送完了，回复ACK， A等待2MSL以后，没有收到B传来的任何消息，知道B已经收到自己的ACK了，A就关闭链接，B也关闭链接了。</li>
</ul>
<h3 id="为什么TIME-WAIT状态还需要等2-MSL（Max-SegmentLifetime，最大分段生存期）秒之后才能返回到CLOSED状态呢？"><a href="#为什么TIME-WAIT状态还需要等2-MSL（Max-SegmentLifetime，最大分段生存期）秒之后才能返回到CLOSED状态呢？" class="headerlink" title="为什么TIME_WAIT状态还需要等2*MSL（Max SegmentLifetime，最大分段生存期）秒之后才能返回到CLOSED状态呢？"></a>为什么TIME_WAIT状态还需要等2*MSL（Max SegmentLifetime，最大分段生存期）秒之后才能返回到CLOSED状态呢？</h3><p>因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SENT状态到ESTABLISH状态那样），但是我们必须假想网络是不可靠的，你无法保证你最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来<strong>重发可能丢失的ACK报文</strong>。</p>
<h3 id="Time-wait-Close-wait"><a href="#Time-wait-Close-wait" class="headerlink" title="Time_wait,Close_wait"></a>Time_wait,Close_wait</h3><p>在这四次握手状态中，有一个<strong>特别要注意的状态TIME_WAIT</strong>。<strong>这个状态是主动关闭方在收到被关闭方的FIN后会处于并长期**</strong>处于的一个状态<strong>。</strong>也就是大约1-4分钟，然后由操作系统自动回收并将TCP连接设为CLOSED初始状态**。</p>
<ul>
<li>为实现TCP全双工连接的可靠释放</li>
<li>为使旧的数据包在网络因过期而消失</li>
</ul>
<h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<p>TCP头部</p>
<p><img src="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%A4%B4%E9%83%A8.png" alt="TCP首部"></p>
<p>UDP头部20位</p>
<p><img src="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E5%A4%B4%E9%83%A8.png" alt="image-20200727220004371"></p>
<p>一共64位</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ul>
<li>TCP面向连接、UDP是无连接的；</li>
<li>TCP提供可靠的服务、也就是说，通过TCP连接传输的数据是无差错、不丢失、不重复且按序到达；UDP尽最大努力交付，即不保证可靠交付<br>TCP的逻辑通信信息是全双工的可靠信息；UDP则是不可靠信息</li>
<li>每一条TCP连接只能是点对点的；UDP支持一对多、多对一、多对多的交互通信</li>
<li>TCP面向字节流(可能会出现黏包问题)，实际上是TCP白数据看成一连串无结构的字节流；UDP是面向报文的(不会出现黏包问题)</li>
<li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如IP电话，实时视频会议等)</li>
<li>TCP首部开销20字节；UDP的首部开销小，只有8字节</li>
</ul>
<h3 id="为什么UDP有时比TCP更有优势"><a href="#为什么UDP有时比TCP更有优势" class="headerlink" title="为什么UDP有时比TCP更有优势?"></a>为什么UDP有时比TCP更有优势?</h3><p>UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。</p>
<p>（1）<strong>网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。</strong></p>
<p>（2）<strong>TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。</strong></p>
<p>采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDP的协议"><a href="#UDP的协议" class="headerlink" title="UDP的协议"></a>UDP的协议</h3><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/TFTP">TFTP</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/SNMP">SNMP</a>、NFS、DNS 没有SMTP</p>
<h3 id="UDP如何保证可靠性"><a href="#UDP如何保证可靠性" class="headerlink" title="UDP如何保证可靠性?"></a>UDP如何保证可靠性?</h3><p>可靠性由上层应用实现，所以要实现udp可靠性传输，必须通过应用层来实现和控制。</p>
<p>实现确认机制、重传机制、窗口确认机制。</p>
<p> 发送：包的分片、包确认、包的重发</p>
<p>  接收：包的调序、包的序号确认</p>
<h1 id="三、HTTP"><a href="#三、HTTP" class="headerlink" title="三、HTTP"></a>三、HTTP</h1><h2 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<strong>是应用层协议</strong></p>
<h3 id="HTTP-常见的状态码，有哪些？"><a href="#HTTP-常见的状态码，有哪些？" class="headerlink" title="HTTP 常见的状态码，有哪些？"></a>HTTP 常见的状态码，有哪些？</h3><p><em>2xx</em>类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p>
<ul>
<li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li>
<li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li>
<li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li>
</ul>
<p><em>3xx</em>类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>
<ul>
<li><p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p>
</li>
<li><p>「<strong>302 Moved Permanently</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p>
<p> 301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>
</li>
<li><p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</p>
</li>
</ul>
<p><em>4xx</em> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>
<ul>
<li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li>
<li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li>
<li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li>
</ul>
<p><em>5xx</em>类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>
<ul>
<li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li>
<li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li>
<li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li>
<li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</li>
</ul>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/aomize/article/details/78609301">报文格式</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">常见HTTP首部字段</span><br><span class="line">通用首部字段（请求报文与响应报文都会使用的首部字段）</span><br><span class="line">    Date：创建报文时间</span><br><span class="line">    Connection：连接的管理</span><br><span class="line">    Cache-Control：缓存的控制</span><br><span class="line">    Transfer-Encoding：报文主体的传输编码方式</span><br><span class="line">请求首部字段（请求报文会使用的首部字段）</span><br><span class="line">    Host：请求资源所在服务器</span><br><span class="line">    Accept：可处理的媒体类型</span><br><span class="line">    Accept-Charset：可接收的字符集</span><br><span class="line">    Accept-Encoding：可接受的内容编码</span><br><span class="line">    Accept-Language：可接受的自然语言</span><br><span class="line">响应首部字段（响应报文会使用的首部字段）</span><br><span class="line">    Accept-Ranges：可接受的字节范围</span><br><span class="line">    Location：令客户端重新定向到的</span><br><span class="line">    URI Server：HTTP服务器的安装信息</span><br><span class="line">实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</span><br><span class="line">    Allow：资源可支持的HTTP方法</span><br><span class="line">    Content-Type：实体主类的类型</span><br><span class="line">    Content-Encoding：实体主体适用的编码方式</span><br><span class="line">    Content-Language：实体主体的自然语言</span><br><span class="line">    Content-Length：实体主体的的字节数</span><br><span class="line">    Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h2><h3 id="GET-和-POST-的区别？"><a href="#GET-和-POST-的区别？" class="headerlink" title="GET 和 POST 的区别？"></a>GET 和 POST 的区别？</h3><p><code>Get</code> 方法的含义是请求<strong>从服务器获取资源</strong>，这个资源可以是静态的文本、页面、图片视频等。 如，页面的请求</p>
<p>而<code>POST</code> 方法则是相反操作，它向 <code>URI</code> 指定的资源提交数据，数据就放在报文的 body 里。如，表单的提交。</p>
<h3 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h3><ul>
<li><p>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</p>
</li>
<li><p>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p>
<p><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p>
</li>
</ul>
<p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。</p>
<h2 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a>HTTP 特性</h2><p><em>1. 简单</em></p>
<p><em>2. 灵活和易于扩展</em></p>
<p><em>3. 应用广泛和跨平台</em></p>
<p>缺点</p>
<p><em>1. 无状态双刃剑</em></p>
<p>无状态的<strong>好处</strong>，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p>
<p>无状态的<strong>坏处</strong>，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦</p>
<p><strong>Cookie</strong>可以解决这个问题</p>
<p>2.<em>不安全</em></p>
<ul>
<li>通信使用明文（不加密），内容可能会被窃听。比如，<strong>账号信息容易泄漏，那你号没了。</strong></li>
<li>不验证通信方的身份，因此有可能遭遇伪装。比如，<strong>访问假的淘宝、拼多多，那你钱没了。</strong></li>
<li>无法证明报文的完整性，所以有可能已遭篡改。比如，<strong>网页上植入垃圾广告，视觉污染，眼没了。</strong></li>
</ul>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p><strong>请求 - 应答</strong>的通信方式</p>
<p><em>1. 长连接</em></p>
<p>HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。</p>
<p>为了解决上述 TCP 连接问题，HTTP/1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>
<p><em>2. 管道网络传输</em></p>
<p>在同一个 TCP 连接里面，客户端可以发起多个请求，<strong>只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，</strong>可以<strong>减少整体的响应时间。</strong></p>
<p><em>3. 队头阻塞</em></p>
<p>当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」。<strong>好比上班的路上塞车</strong>。</p>
<h3 id="在浏览器中输入url到显示页面的过程"><a href="#在浏览器中输入url到显示页面的过程" class="headerlink" title="在浏览器中输入url到显示页面的过程"></a>在浏览器中输入url到显示页面的过程</h3><ul>
<li><strong>1.输入地址</strong></li>
<li><strong>2.浏览器查找域名的 IP 地址</strong></li>
<li><strong>3.浏览器向 web 服务器发送一个 HTTP 请求</strong><ul>
<li>浏览器会以一个随机端口向服务器的WEB程序（常用的有httpd,nginx等）80端口<strong>发起TCP的连接请求</strong>。</li>
</ul>
</li>
<li><strong>4.服务器的永久重定向响应</strong></li>
<li><strong>5.浏览器跟踪重定向地址</strong></li>
<li><strong>6.服务器处理请求</strong></li>
<li><strong>7.服务器返回一个 HTTP 响应</strong>　</li>
<li><strong>8.浏览器显示 HTML</strong></li>
</ul>
<h3 id="HTTP传输过程"><a href="#HTTP传输过程" class="headerlink" title="HTTP传输过程"></a>HTTP传输过程</h3><ul>
<li>建立TCP连接</li>
<li>web浏览器发送请求 GET/index.jsp HTTP/1.1</li>
<li>web浏览器发送请求头信息，如果为post请求，会提交请求体</li>
<li>web服务器应答， HTTP/1.1 200 OK</li>
<li>web服务器发送应答头信息</li>
<li>web浏览器向服务器发送数据 根据Content-Type中所描述的格式</li>
<li>web服务器关闭TCP连接</li>
</ul>
<h2 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h2><h3 id="HTTP-与-HTTPS-有哪些区别"><a href="#HTTP-与-HTTPS-有哪些区别" class="headerlink" title="HTTP 与 HTTPS 有哪些区别"></a>HTTP 与 HTTPS 有哪些区别</h3><ol>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ol>
<p>HTTPS 解决了，<strong>窃听风险</strong>，<strong>篡改风险</strong>，<strong>冒充风险</strong></p>
<p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议。<strong>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</strong></p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li>
<li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li>
</ul>
<h3 id="HTTPS-是如何解决上面的三个风险的"><a href="#HTTPS-是如何解决上面的三个风险的" class="headerlink" title="HTTPS 是如何解决上面的三个风险的"></a>HTTPS 是如何解决上面的三个风险的</h3><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><ul>
<li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。<ul>
<li><strong>对称加密</strong>和<strong>非对称加密</strong><ul>
<li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li>
</ul>
</li>
<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。<ul>
<li>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><ul>
<li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。<ul>
<li><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</li>
</ul>
</li>
</ul>
<h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><ul>
<li><p>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p>
</li>
<li><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
</li>
</ul>
<h3 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS  是如何建立连接的？其间交互了什么？"></a>HTTPS  是如何建立连接的？其间交互了什么？</h3><p>1、客户端获取主机证书</p>
<p>2、通过主机证书验证服务器的合法性，即是否是客户端想要连接的服务器：</p>
<p>通过证书中包含的签发机构，从根证书链中取得对应公钥，然后对目标域名进行签名，然后对比签名是否和证书中的一致；</p>
<p>如果CA不在证书链中，或者比对有一项不同则主机不被信任（或许是一个虚假主机，或许是不受信任的证书），如果选择信任则继续进行秘钥的磋商</p>
<p>3、传输秘钥的磋商，客户端随机生成传输秘钥，然后通过对证书中的公钥加密后传给服务器，</p>
<p>4、之后的http内容的加密则使用此密文进行加密。</p>
<h2 id="Http的发展"><a href="#Http的发展" class="headerlink" title="Http的发展"></a>Http的发展</h2><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p><em>1. 头部压缩</em></p>
<p>HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的分</strong>。</p>
<p><em>2. 二进制格式</em></p>
<p>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式。</strong></p>
<p>头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧和数据帧</strong>。</p>
<p><em>3. 数据流</em></p>
<p>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>每个请求或回应的所有数据包，称为一个数据流（<code>Stream</code>）。</p>
<p><em>4. 多路复用</em></p>
<p>HTTP/2 是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</p>
<p>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</p>
<p><em>5. 服务器推送</em></p>
<p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。</p>
<h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。</p>
<p>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>
<ul>
<li>HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li>
<li>HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li>
</ul>
<p>这都是基于 TCP 传输层的问题，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong> </p>
<p>基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
<ul>
<li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li>
<li>TL3 升级成了最新的 <code>1.3</code> 版本，头部压缩算法也升级成了 <code>QPack</code>。</li>
<li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 <code>TLS/1.3</code> 的三次握手。QUIC 直接把以往的 TCP 和 <code>TLS/1.3</code> 的 6 次交互<strong>合并成了 3 次，减少了交互次数</strong>。</li>
</ul>
<h1 id="四、IP"><a href="#四、IP" class="headerlink" title="四、IP"></a>四、IP</h1><p><strong>网络层协议</strong></p>
<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<h2 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h2><img src="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP数据报格式.png" alt="img" style="zoom:67%;">

<ul>
<li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li>
<li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>
<li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li>
<li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li>
<li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>
<li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li>
<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>
<li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>
<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>
</ul>
<h2 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h2><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<p><img src="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt="image-20200812155218926"></p>
<ul>
<li><p>广播地址<br>广播地址(Broadcast Address)是专门<strong>用于同时向网络中所有工作站进行发送的一个地址</strong>。</p>
<p>在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。</p>
<ul>
<li>计算广播地址<br>广播地址：网络地址的主机位全部变成1 ，10011111 即159 即：202.112.14.159</li>
</ul>
</li>
<li><p>回环地址<br>127.0.0.1，通常被称为本地回环地址(Loop back address)，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。在windows操作系统中也有相似的定义，所以通常在不安装网卡前就可以ping通这个本地回环地址。<strong>一般都会用来检查本地网络协议、基本数据接口等是否正常的</strong></p>
</li>
</ul>
<h3 id="2-子网划分"><a href="#2-子网划分" class="headerlink" title="2. 子网划分"></a>2. 子网划分</h3><p>为什么进行子网划分</p>
<ul>
<li><strong>减少网络流量</strong></li>
<li><strong>优化网络性能</strong>，这是减少网络流量的结果。</li>
<li><strong>简化管理</strong>，与庞大的网络相比，在一系列相连的小网络中找出并隔离网络问题更容易。</li>
<li><strong>有助于覆盖大型地理区域</strong>，WAN链路比LAN链路的速度慢得多，且更昂贵;单个大跨度的大型网络在前面说的各个方面都可能出现问题（网络流量太大，广播风暴），而将多个小网络连接起来可提高系统的效率。</li>
</ul>
<p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md">HTTP</a><br><a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md">计算机网络</a><br><a target="_blank" rel="noopener" href="https://notecc.ink/posts/50daec4.html">网络</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/iva_brother/article/details/90317645">TCP与UDP的区别与联系</a><br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/amOya0M00LwpL5kCS96Y6w">图解 HTTP 常见的面试题</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011547347/article/details/83186514">https实现原理</a><br><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc">TCP 连接的“ 三次握手 ”与“ 四次挥手 ”</a></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a></div><div class="post_share"><div class="social-share" data-image="/./img/photo-1628009193228-076ab63d655a.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="/./img/photo-1626811407568-2f41c53fff99.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法</div></div></a></div><div class="next-post pull-right"><a href="/2020/07/25/%E9%9D%A2%E8%AF%95/leetcode/leetcode%E6%95%B0%E7%BB%84/"><img class="next-cover" src="/./img/photo-1465156799763-2c087c332922.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">leetcode-数组</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">一、网络模型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81TCP%E5%92%8CUDP"><span class="toc-number">2.</span> <span class="toc-text">二、TCP和UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUCP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.</span> <span class="toc-text">TCP和UCP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.</span> <span class="toc-text">TCP连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.2.3.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%85%B8%E5%9E%8BTCP%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%88%E4%B8%BB%E5%8A%A8%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%B8%BB%E5%8A%A8%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%EF%BC%89%E4%BC%9A%E7%BB%8F%E5%8E%86%E7%9A%84%E7%8A%B6%E6%80%81%E5%BA%8F%E5%88%97%E3%80%82"><span class="toc-number">2.3.</span> <span class="toc-text">一个典型TCP客户端（主动建立连接，主动断开连接）会经历的状态序列。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%87%E7%A8%8B%E9%87%87%E7%94%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%B7%B2%E7%9F%A5%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%8A%A5%E6%96%87%E7%9A%84%E5%8F%91%E9%80%81%E5%BA%8F%E5%88%97%E5%8F%B7%E4%B8%BA1000%EF%BC%8C%E7%A1%AE%E8%AE%A4%E5%BA%8F%E5%88%97%E5%8F%B7%E4%B8%BA2000%EF%BC%8C%E8%AF%B7%E9%97%AE%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%8A%A5%E6%96%87%E7%9A%84%E5%8F%91%E9%80%81%E5%BA%8F%E5%88%97%E5%8F%B7%E5%92%8C%E7%A1%AE%E8%AE%A4%E5%BA%8F%E5%88%97%E5%8F%B7%E5%88%86%E5%88%AB%E4%B8%BA"><span class="toc-number">2.4.</span> <span class="toc-text">TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E8%BF%9E%E6%8E%A5%E8%A6%81%E5%BB%BA%E7%AB%8B%E4%B8%89%E6%AC%A1%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">2.4.1.</span> <span class="toc-text">为什么TCP连接要建立三次连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%814%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">为什么要4次挥手？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TIME-WAIT%E7%8A%B6%E6%80%81%E8%BF%98%E9%9C%80%E8%A6%81%E7%AD%892-MSL%EF%BC%88Max-SegmentLifetime%EF%BC%8C%E6%9C%80%E5%A4%A7%E5%88%86%E6%AE%B5%E7%94%9F%E5%AD%98%E6%9C%9F%EF%BC%89%E7%A7%92%E4%B9%8B%E5%90%8E%E6%89%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E5%88%B0CLOSED%E7%8A%B6%E6%80%81%E5%91%A2%EF%BC%9F"><span class="toc-number">2.4.3.</span> <span class="toc-text">为什么TIME_WAIT状态还需要等2*MSL（Max SegmentLifetime，最大分段生存期）秒之后才能返回到CLOSED状态呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Time-wait-Close-wait"><span class="toc-number">2.4.4.</span> <span class="toc-text">Time_wait,Close_wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">2.4.5.</span> <span class="toc-text">如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.1.</span> <span class="toc-text">TCP与UDP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88UDP%E6%9C%89%E6%97%B6%E6%AF%94TCP%E6%9B%B4%E6%9C%89%E4%BC%98%E5%8A%BF"><span class="toc-number">2.5.2.</span> <span class="toc-text">为什么UDP有时比TCP更有优势?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP"><span class="toc-number">2.6.</span> <span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.6.1.</span> <span class="toc-text">UDP的协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">2.6.2.</span> <span class="toc-text">UDP如何保证可靠性?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81HTTP"><span class="toc-number">3.</span> <span class="toc-text">三、HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E7%89%B9%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">HTTP特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">HTTP 常见的状态码，有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">报文格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET-%E4%B8%8E-POST"><span class="toc-number">3.2.</span> <span class="toc-text">GET 与 POST</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">GET 和 POST 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E5%92%8C-POST-%E6%96%B9%E6%B3%95%E9%83%BD%E6%98%AF%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">3.2.2.</span> <span class="toc-text">GET 和 POST 方法都是安全和幂等的吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E7%89%B9%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text">HTTP 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%88%B0%E6%98%BE%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">在浏览器中输入url到显示页面的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text">HTTP传输过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E4%B8%8E-HTTPS"><span class="toc-number">3.4.</span> <span class="toc-text">HTTP 与 HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E4%B8%8E-HTTPS-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.1.</span> <span class="toc-text">HTTP 与 HTTPS 有哪些区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%B8%89%E4%B8%AA%E9%A3%8E%E9%99%A9%E7%9A%84"><span class="toc-number">3.4.2.</span> <span class="toc-text">HTTPS 是如何解决上面的三个风险的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">完整性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">认证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%9F%E5%85%B6%E9%97%B4%E4%BA%A4%E4%BA%92%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.4.3.</span> <span class="toc-text">HTTPS  是如何建立连接的？其间交互了什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Http%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">3.5.</span> <span class="toc-text">Http的发展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2"><span class="toc-number">3.5.1.</span> <span class="toc-text">HTTP&#x2F;2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-3"><span class="toc-number">3.5.2.</span> <span class="toc-text">HTTP&#x2F;3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81IP"><span class="toc-number">4.</span> <span class="toc-text">四、IP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IP-%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">IP 数据报格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP-%E5%9C%B0%E5%9D%80%E7%BC%96%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">IP 地址编址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.1.</span> <span class="toc-text">1. 分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86"><span class="toc-number">4.2.2.</span> <span class="toc-text">2. 子网划分</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By naive</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>