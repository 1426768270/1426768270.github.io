<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue路由</title>
      <link href="/2021/08/22/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E8%B7%AF%E7%94%B1/"/>
      <url>/2021/08/22/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="vue路由解释"><a href="#vue路由解释" class="headerlink" title="vue路由解释"></a>vue路由解释</h2><p>vue 的一个插件库，专门用来实现 SPA 应用 </p><ol><li>单页 Web 应用（single page web application，SPA）。 </li><li>整个应用<strong>只有一个完整的页面</strong>。 </li><li>点击页面中的导航链接不会刷新页面，只会做页面的<strong>局部更新</strong>。</li><li>数据需要<strong>通过 ajax 请求获取</strong>。</li></ol><p><strong>什么是路由?</strong> </p><ol><li>一个路由就是一组<strong>映射关系</strong>（key - value）</li><li>key 为路径, value 可能是 function 或 component</li></ol><p><strong>路由分类</strong></p><ol><li>后端路由：  <ol><li>理解：value 是 function, 用于处理客户端提交的请求。</li><li>工作过程：服务器接收到一个请求时, <strong>根据请求路径找到匹配的函数 来处理请求, 返回响应数据。</strong> </li></ol></li><li>前端路由：<ol><li>理解：value 是 component，用于<strong>展示页面内容</strong>。</li><li>工作过程：当浏览器的路径改变时, 对应的组件就会显示。</li></ol></li></ol><h2 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol><li>安装vue-router，命令：<code>npm i vue-router</code></li></ol><ol start="2"><li><p>应用插件：<code>Vue.use(VueRouter)</code></p></li><li><p>编写router配置项:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:About</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:Home</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></li><li><p>实现切换（active-class可配置高亮样式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li><li><p>指定展示位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">   &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line"></span><br><span class="line">### 注意点</span><br><span class="line"></span><br><span class="line">1. **路由组件**通常存放在```pages```文件夹，**一般组件**通常存放在```components```文件夹。</span><br><span class="line">2. 通过切换，“隐藏”了的路由组件，默认是**被销毁掉的，需要的时候再去挂载。**</span><br><span class="line">3. 每个组件都有自己的```$route```属性，里面**存储着自己的路由信息**。</span><br><span class="line">4. 整个应用**只有一个router**，可以通过组件的```$router```属性获取到。</span><br><span class="line"></span><br><span class="line">### 多级路由（多级路由）</span><br><span class="line"></span><br><span class="line">1. 配置路由规则，使用children配置项：</span><br><span class="line"></span><br><span class="line">   ```js</span><br><span class="line">   routes:[</span><br><span class="line">   &#123;</span><br><span class="line">   path:&#x27;/about&#x27;,</span><br><span class="line">   component:About,</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">   path:&#x27;/home&#x27;,</span><br><span class="line">   component:Home,</span><br><span class="line">   children:[ //通过children配置子级路由</span><br><span class="line">   &#123;</span><br><span class="line">   path:&#x27;news&#x27;, //此处一定不要写：/news</span><br><span class="line">   component:News</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">   path:&#x27;message&#x27;,//此处一定不要写：/message</span><br><span class="line">   component:Message</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure></li><li><p>跳转（要写完整路径）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="路由的query参数"><a href="#路由的query参数" class="headerlink" title="路由的query参数"></a>路由的query参数</h3><ol><li><p>传递参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;`/home/message/detail?id=$&#123;id&#125;&amp;title=$&#123;title&#125;`&quot;</span>&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> </span></span><br><span class="line"><span class="tag"><span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">path:&#x27;/home/message/detail&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">query:&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">   id:666,</span></span></span><br><span class="line"><span class="string"><span class="tag">            title:&#x27;你好&#x27;</span></span></span><br><span class="line"><span class="string"><span class="tag">&#125;</span></span></span><br><span class="line"><span class="string"><span class="tag">&#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span>跳转<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.query.id</span><br><span class="line">$route.query.title</span><br></pre></td></tr></table></figure></li></ol><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><ol><li><p>作用：可以<strong>简化路由</strong>的跳转。</p></li><li><p>如何使用</p><ol><li><p>给路由命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:Demo,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:Test,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span> <span class="comment">//给路由命名</span></span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:Hello,</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简化跳转：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">name:&#x27;hello&#x27;,</span><br><span class="line">query:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="路由的params参数"><a href="#路由的params参数" class="headerlink" title="路由的params参数"></a>路由的params参数</h3><ol><li><p>配置路由，声明接收params参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:Home,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:News</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">component</span>:Message,</span><br><span class="line"><span class="attr">children</span>:[</span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>, <span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line"><span class="attr">component</span>:Detail</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">:to=&quot;&#123;</span><br><span class="line">name:&#x27;xiangqing&#x27;,</span><br><span class="line">params:&#123;</span><br><span class="line">   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><blockquote><p>特别注意：路由携带params参数时，若使用to的对象写法，则<strong>不能使用path配置项，必须使用name配置！</strong></p></blockquote></li><li><p>接收参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$route.params.id</span><br><span class="line">$route.params.title</span><br></pre></td></tr></table></figure></li></ol><h3 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h3><p>​    作用：让路由组件更方便的收到参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line"><span class="attr">component</span>:Detail,</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line"><span class="comment">// props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line"><span class="comment">// props:true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line"><span class="function"><span class="title">props</span>(<span class="params">route</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">id</span>:route.query.id,</span><br><span class="line"><span class="attr">title</span>:route.query.title</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lt-router-link-gt-的replace属性"><a href="#lt-router-link-gt-的replace属性" class="headerlink" title="&lt;router-link&gt;的replace属性"></a><code>&lt;router-link&gt;</code>的replace属性</h3><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li><li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li></ol><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><ol><li><p>作用：不借助<code>&lt;router-link&gt;</code>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体编码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:xxx,</span><br><span class="line"><span class="attr">title</span>:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$router.replace(&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:xxx,</span><br><span class="line"><span class="attr">title</span>:xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">this</span>.$router.forward() <span class="comment">//前进</span></span><br><span class="line"><span class="built_in">this</span>.$router.back() <span class="comment">//后退</span></span><br><span class="line"><span class="built_in">this</span>.$router.go() <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h3><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="两个新的生命周期钩子"><a href="#两个新的生命周期钩子" class="headerlink" title="两个新的生命周期钩子"></a>两个新的生命周期钩子</h3><ol><li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li><li>具体名字：<ol><li><code>activated</code>路由组件被激活时触发。</li><li><code>deactivated</code>路由组件失活时触发。</li></ol></li></ol><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><ol><li><p>作用：对路由进行权限控制</p></li><li><p>分类：全局守卫、独享守卫、组件内守卫</p></li><li><p>全局守卫:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;beforeEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.meta.isAuth)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line">next() <span class="comment">//放行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">next() <span class="comment">//放行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;afterEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.meta.title)&#123; </span><br><span class="line"><span class="built_in">document</span>.title = to.meta.title <span class="comment">//修改网页的title</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">document</span>.title = <span class="string">&#x27;vue_test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>独享守卫:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line"><span class="keyword">if</span>(to.meta.isAuth)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">next()</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">alert(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line"><span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组件内守卫：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="路由器的两种工作模式"><a href="#路由器的两种工作模式" class="headerlink" title="路由器的两种工作模式"></a>路由器的两种工作模式</h3><ol><li><p>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</p></li><li><p>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</p></li><li><p>hash模式：</p><ol><li>地址中永远带着#号，不美观 。</li><li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li><li>兼容性较好。</li></ol></li><li><p>history模式：</p><ol><li>地址干净，美观 。</li><li>兼容性和hash模式相比略差。</li><li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件</title>
      <link href="/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E7%BB%84%E4%BB%B6/"/>
      <url>/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue组件化编程"><a href="#Vue组件化编程" class="headerlink" title="Vue组件化编程"></a>Vue组件化编程</h1><h2 id="为什么要用组件？"><a href="#为什么要用组件？" class="headerlink" title="为什么要用组件？"></a>为什么要用组件？</h2><p>传统方式编写应用</p><p><img src="/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E7%BB%84%E4%BB%B6/%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E7%BC%96%E5%86%99%E5%BA%94%E7%94%A8.png" alt="传统方式编写应用"></p><p>组件方式编写应用</p><p><img src="/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E7%BB%84%E4%BB%B6/%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F%E7%BC%96%E5%86%99%E5%BA%94%E7%94%A8.png" alt="组件方式编写应用"></p><p><strong>模块</strong>：</p><ul><li>向外提供特定功能的 js 程序, 一般就是一个 js 文件</li><li>作用: 复用 js, 简化 js 的编写, 提高 js 运行效率</li><li>当应用中的js 都以模块来编写的, 那这个应用就是一个<strong>模块化</strong>的应用。 </li></ul><p><strong>组件</strong>：实现应用中<strong>局部</strong>功能<strong>代码</strong>和<strong>资源</strong>的集合</p><ul><li>用来实现局部(特定)功能效果的代码集合(html/css/js/image…..)</li><li>复用编码, 简化项目编码, 提高运行效率 </li><li>当应用中的功能都是多组件的方式来编写的, 那这个应用就是一个组件化的应用,。</li></ul><h2 id="组件的编写"><a href="#组件的编写" class="headerlink" title="组件的编写"></a>组件的编写</h2><h3 id="非单文件组件"><a href="#非单文件组件" class="headerlink" title="非单文件组件"></a>非单文件组件</h3><p>一个文件中包含n个组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello</span>&gt;</span><span class="tag">&lt;/<span class="name">hello</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第三步：编写组件标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">school</span>&gt;</span><span class="tag">&lt;/<span class="name">school</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 第三步：编写组件标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：创建school组件</span></span><br><span class="line"><span class="keyword">const</span> school = Vue.extend(&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">&lt;div class=&quot;demo&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">    <span class="comment">// el:&#x27;#root&#x27;, //组件定义时，一定不要写el配置项，因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器。</span></span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">schoolName</span>:<span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">            <span class="attr">address</span>:<span class="string">&#x27;北京昌平&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>.schoolName)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步：创建student组件</span></span><br><span class="line"><span class="keyword">const</span> student = Vue.extend(&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">studentName</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&#x27;你好啊！&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//第二步：注册组件（局部注册）</span></span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        school,</span><br><span class="line">        student</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：创建hello组件</span></span><br><span class="line"><span class="keyword">const</span> hello = Vue.extend(&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;h2&gt;你好啊！&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;Tom&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//第二步：全局注册组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;hello&#x27;</span>,hello)</span><br></pre></td></tr></table></figure><p>使用组件：定义组件、注册组件、使用组件。</p><p>注意点：</p><ul><li>组件名：<ul><li>一个单词组成<ul><li>第一种写法(首字母小写)：school</li><li>第二种写法(首字母大写)：School</li></ul></li><li>多个单词组成<ul><li>第一种写法(kebab-case命名)：my-school</li><li>第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)</li></ul></li><li>备注<ul><li>组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。</li><li>可以<strong>使用name</strong>配置项指定组件在开发者工具中呈现的名字。</li></ul></li></ul></li><li>关于组件标签<ul><li>第一种写法：<code>&lt;school&gt;&lt;/school&gt;</code></li><li>第二种写法：<code>&lt;school/&gt;</code></li><li>备注：不用使用脚手架时，<code>&lt;school/&gt;</code>会导致后续组件不能渲染。</li></ul></li></ul><p><code>const school = Vue.extend(options)</code> 可简写为：<code>const school = options</code></p><h4 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套"></a>组件的嵌套</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义student组件</span></span><br><span class="line"><span class="keyword">const</span> student = Vue.extend(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;student&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义school组件</span></span><br><span class="line"><span class="keyword">const</span> school = Vue.extend(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;school&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;student&gt;&lt;/student&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">            <span class="attr">address</span>:<span class="string">&#x27;北京&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//注册组件（局部）</span></span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        student</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义hello组件</span></span><br><span class="line"><span class="keyword">const</span> hello = Vue.extend(&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;`</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">msg</span>:<span class="string">&#x27;欢迎来到尚硅谷学习！&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义app组件</span></span><br><span class="line"><span class="keyword">const</span> app = Vue.extend(&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;hello&gt;&lt;/hello&gt;</span></span><br><span class="line"><span class="string">&lt;school&gt;&lt;/school&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        school,</span><br><span class="line">        hello</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&#x27;&lt;app&gt;&lt;/app&gt;&#x27;</span>,</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="comment">//注册组件（局部）</span></span><br><span class="line">    <span class="attr">components</span>:&#123;app&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="VueComponent-重要"><a href="#VueComponent-重要" class="headerlink" title="VueComponent(重要)"></a>VueComponent(重要)</h4><ol><li>school组件本质是一个名为<code>VueComponent</code>的<strong>构造函数</strong>，且不是程序员定义的，是Vue.extend生成的。</li><li>我们只需要写<code>&lt;school/&gt;</code>或<code>&lt;school&gt;&lt;/school&gt;</code>，Vue解析时会<em>帮我们创建</em>school组件的实例对象，即Vue帮我们执行的：<code>new VueComponent(options)</code>。</li><li>注意：每次调用Vue.extend，返回的都是一个<strong>全新的VueComponent</strong>！</li><li>this指向：<ul><li><strong>组件配置</strong>中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。</li><li><strong>new Vue(options)配置</strong>中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。</li></ul></li><li>VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。Vue的实例对象，以后简称vm。（$children）vc不能写el,只有根实例可以写</li></ol><p><strong>一个重要的内置关系</strong>：</p><ul><li>一个重要的<strong>内置关系</strong>：<code>VueComponent.prototype.__proto__ === Vue.prototype</code></li><li>为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</li></ul><img src="/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E7%BB%84%E4%BB%B6/Vue与VueComponent的关系.png" alt="Vue与VueComponent的关系" style="zoom: 80%;"><h3 id="单文件组件："><a href="#单文件组件：" class="headerlink" title="单文件组件："></a>单文件组件：</h3><p>一个文件中只包含1个组件</p><p>代码高亮vetur，单文件组件的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//School.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!-- 结构 --&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    //组件交互相关的代码</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">/* 组件样式 */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;demo&quot;&gt;</span><br><span class="line">&lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line">name:&#x27;School&#x27;,</span><br><span class="line">data()&#123;</span><br><span class="line">return &#123;</span><br><span class="line">name:&#x27;尚硅谷&#x27;,</span><br><span class="line">address:&#x27;北京昌平&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">showName()&#123;</span><br><span class="line">alert(this.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.demo&#123;</span><br><span class="line">background-color: orange;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>汇总所有组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;School&gt;&lt;/School&gt;</span><br><span class="line">&lt;Student&gt;&lt;/Student&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//引入组件</span><br><span class="line">import School from &#x27;./School.vue&#x27;</span><br><span class="line">import Student from &#x27;./Student.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;App&#x27;,</span><br><span class="line">components:&#123;</span><br><span class="line">School,</span><br><span class="line">Student</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line"><span class="attr">template</span>:<span class="string">`&lt;App&gt;&lt;/App&gt;`</span>,</span><br><span class="line"><span class="attr">components</span>:&#123;App&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>练习一下单文件组件的语法<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 准备一个容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>.vue不能直接在浏览器运行，需要<strong>脚手架</strong>。</p><h1 id="Vue脚手架"><a href="#Vue脚手架" class="headerlink" title="Vue脚手架"></a>Vue脚手架</h1><h2 id="初始化脚手架"><a href="#初始化脚手架" class="headerlink" title="初始化脚手架"></a>初始化脚手架</h2><p>Vue 脚手架是 Vue 官方提供的标准化开发工具（开发平台）。vue cli(command line interface)</p><p>官网： <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>全局安装@vue/cli</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>切换到你要创建项目的目录</strong>，然后使用命令创建项目</li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create xxxx</span><br></pre></td></tr></table></figure><ol start="3"><li>启动项目 </li></ol><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure><blockquote><ol><li><p>如出现下载缓慢请配置 npm 淘宝镜像：npm config set registry </p><p><a href="https://registry.npm.taobao.org">https://registry.npm.taobao.org</a></p></li><li><p>Vue 脚手架<strong>隐藏了所有 webpack 相关的配置</strong>，若想查看具体的 webpakc 配置， </p><p>请执行：<code>vue inspect &gt; output.js</code></p></li></ol></blockquote><h3 id="模板项目的结构"><a href="#模板项目的结构" class="headerlink" title="模板项目的结构:"></a>模板项目的结构:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules </span><br><span class="line">├── public </span><br><span class="line">│ ├── favicon.ico: 页签图标 </span><br><span class="line">│ └── index.html: 主页面 </span><br><span class="line">├── src </span><br><span class="line">│ ├── assets: 存放静态资源 </span><br><span class="line">│ │ └── logo.png </span><br><span class="line">│ │── component: 存放组件 </span><br><span class="line">│ │ └── HelloWorld.vue </span><br><span class="line">│ │── App.vue: 汇总所有组件 </span><br><span class="line">│ │── main.js: 入口文件 </span><br><span class="line">├── .gitignore: git 版本管制忽略的配置 </span><br><span class="line">├── babel.config.js: babel 的配置文件 </span><br><span class="line">├── package.json: 应用包配置文件 </span><br><span class="line">├── README.md: 应用描述文件 </span><br><span class="line">├── package-lock.json：包版本控制文件</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">该文件是整个项目的入口文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//引入Vue</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入App组件，它是所有组件的父组件</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">//关闭vue的生产提示</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">关于不同版本的Vue：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.vue.js与vue.runtime.xxx.js的区别：</span></span><br><span class="line"><span class="comment">(1).vue.js是完整版的Vue，包含：核心功能+模板解析器。</span></span><br><span class="line"><span class="comment">(2).vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用</span></span><br><span class="line"><span class="comment">render函数接收到的createElement函数去指定具体内容。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Vue实例对象---vm</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"><span class="comment">//render函数完成了这个功能：将App组件放入容器中</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line"><span class="comment">// render:q=&gt; q(&#x27;h1&#x27;,&#x27;你好啊&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template:`&lt;h1&gt;你好啊&lt;/h1&gt;`,</span></span><br><span class="line"><span class="comment">// components:&#123;App&#125;,</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 针对IE浏览器的一个特殊配置，含义是让IE浏览器以最高的渲染级别渲染页面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启移动端的理想视口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置页签图标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入第三方样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;css/bootstrap.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置网页标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt; <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当浏览器不支持js时noscript中的元素就会被渲染 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="render"><a href="#render" class="headerlink" title="render:"></a>render:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line"><span class="comment">//render函数完成了这个功能：将App组件放入容器中</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line"><span class="comment">// render:q=&gt; q(&#x27;h1&#x27;,&#x27;你好啊&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template:`&lt;h1&gt;你好啊&lt;/h1&gt;`,</span></span><br><span class="line"><span class="comment">// components:&#123;App&#125;,</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 关于不同版本的Vue：</p><ol><li>vue.js与vue.runtime.xxx.js的区别：<ul><li>vue.js是完整版的Vue，包含：<strong>核心功能+模板解析器</strong>。</li><li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；<strong>没有模板解析器</strong>。</li></ul></li><li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要<strong>**使用</strong><pre><code>render函数接收到的createElement函数去指定具体内容**。</code></pre></li></ol><p>打包时已经有了模板引擎，不需要在引入，这里需要一个第3方的。</p><h4 id="修改默认配置"><a href="#修改默认配置" class="headerlink" title="修改默认配置"></a>修改默认配置</h4><p>创建vue.config.js,调整脚手架的配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">pages</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: &#123;</span><br><span class="line">      <span class="comment">//入口</span></span><br><span class="line">      <span class="attr">entry</span>: <span class="string">&#x27;src/main.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">lintOnSave</span>:<span class="literal">false</span>, <span class="comment">//关闭语法检查</span></span><br><span class="line"><span class="comment">//开启代理服务器（方式一）</span></span><br><span class="line"><span class="comment">/* devServer: &#123;</span></span><br><span class="line"><span class="comment">    proxy: &#x27;http://localhost:5000&#x27;</span></span><br><span class="line"><span class="comment">  &#125;, */</span></span><br><span class="line"><span class="comment">//开启代理服务器（方式二）</span></span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/test&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,</span><br><span class="line"><span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/atguigu&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">        <span class="comment">// ws: true, //用于支持websocket</span></span><br><span class="line">        <span class="comment">// changeOrigin: true //用于控制请求头中的host值</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/demo&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,</span><br><span class="line"><span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/demo&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">        <span class="comment">// ws: true, //用于支持websocket</span></span><br><span class="line">        <span class="comment">// changeOrigin: true //用于控制请求头中的host值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些常用属性"><a href="#一些常用属性" class="headerlink" title="一些常用属性"></a>一些常用属性</h3><p><strong>ref属性</strong></p><p><strong>作用：</strong>用于给节点打标识</p><p>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）。</p><p>使用：</p><ul><li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li><li>获取：<code>this.$refs.xxx</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1 v-text=&quot;msg&quot; ref=&quot;title&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&lt;button ref=&quot;btn&quot; @click=&quot;showDOM&quot;&gt;点我输出上方的DOM元素&lt;/button&gt;</span><br><span class="line">&lt;School ref=&quot;sch&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//引入School组件</span><br><span class="line">import School from &#x27;./components/School&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;App&#x27;,</span><br><span class="line">components:&#123;School&#125;,</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">msg:&#x27;欢迎学习Vue！&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">showDOM()&#123;</span><br><span class="line">console.log(this.$refs.title) //真实DOM元素</span><br><span class="line">console.log(this.$refs.btn) //真实DOM元素</span><br><span class="line">console.log(this.$refs.sch) //School组件的实例对象（vc）</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>props配置项</strong></p><ol><li><p>作用：用于父组件给子组件<strong>传递数据</strong> </p></li><li><p><strong>读取方式一</strong>: 只指定名称 <code>props: [&#39;name&#39;, &#39;age&#39;, &#39;setName&#39;]</code></p></li><li><p><strong>读取方式二: 指定名称和类型</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    name: String, </span><br><span class="line">    age: Number, </span><br><span class="line">    setNmae: Function </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>读取方式三: 指定名称/类型/必要性/默认值</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;name: &#123;type: String, required: <span class="literal">true</span>, default:xxx&#125;, &#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>备注：props是<strong>只读</strong>的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请<strong>复制props的内容到data中一份</strong>，然后去修改data中的数据。</p></blockquote><p>app.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;Student name=&quot;李四&quot; sex=&quot;女&quot; :age=&quot;18&quot;/&gt;&lt;!-- 动态绑定 --&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Student from &#x27;./components/Student&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;App&#x27;,</span><br><span class="line">components:&#123;Student&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Student.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;学生年龄：&#123;&#123;myAge+1&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=&quot;updateAge&quot;&gt;尝试修改收到的年龄&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Student&#x27;,</span><br><span class="line">data() &#123;</span><br><span class="line">console.log(this)</span><br><span class="line">return &#123;</span><br><span class="line">msg:&#x27;&#x27;,</span><br><span class="line">myAge:this.age</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">updateAge()&#123;</span><br><span class="line">this.myAge++</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">//简单声明接收</span><br><span class="line">// props:[&#x27;name&#x27;,&#x27;age&#x27;,&#x27;sex&#x27;] </span><br><span class="line"></span><br><span class="line">//接收的同时对数据进行类型限制</span><br><span class="line">/* props:&#123;</span><br><span class="line">name:String,</span><br><span class="line">age:Number,</span><br><span class="line">sex:String</span><br><span class="line">&#125; */</span><br><span class="line"></span><br><span class="line">//接收的同时对数据：进行类型限制+默认值的指定+必要性的限制</span><br><span class="line">props:&#123;</span><br><span class="line">name:&#123;</span><br><span class="line">type:String, //name的类型是字符串</span><br><span class="line">required:true, //name是必要的</span><br><span class="line">&#125;,</span><br><span class="line">age:&#123;</span><br><span class="line">type:Number,</span><br><span class="line">default:99 //默认值</span><br><span class="line">&#125;,</span><br><span class="line">sex:&#123;</span><br><span class="line">type:String,</span><br><span class="line">required:true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>mixin混入</strong></p><ol><li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p></li><li><p>使用方式：<br>第一步定义混合：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    data()&#123;....&#125;,</span><br><span class="line">    methods:&#123;....&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第二步使用混入：</p><p> ​    全局混入：<code>Vue.mixin(xxx)</code><br> ​    局部混入：<code>mixins:[&#39;xxx&#39;]</code></p></li></ol><p>mixin.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hunhe = &#123;</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line"><span class="function"><span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;你好啊！&#x27;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> hunhe2 = &#123;</span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">x</span>:<span class="number">100</span>,</span><br><span class="line"><span class="attr">y</span>:<span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h2 @click=&quot;showName&quot;&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// import &#123;hunhe,hunhe2&#125; from &#x27;../mixin&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Student&#x27;,</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">name:&#x27;张三&#x27;,</span><br><span class="line">sex:&#x27;男&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">// mixins:[hunhe,hunhe2]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ol><li><p>功能：用于<strong>增强Vue</strong></p></li><li><p>本质：包含<strong>install方法</strong>的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p></li><li><p>定义插件：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">对象.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">    Vue.filter(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line">    Vue.directive(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">    Vue.mixin(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line">    Vue.prototype.$myProperty = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用插件：<code>Vue.use()</code></p></li></ol><h4 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h4><ol><li><p>作用：让样式在<strong>局部生效，防止冲突。</strong></p></li><li><p>写法：<code>&lt;style scoped&gt;</code> </p><ul><li><p><code>lang=&quot;less&quot;</code>,可以用不同的语言写，但vue脚手架的不支持，要安装</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i less-loader</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="组件化的流程"><a href="#组件化的流程" class="headerlink" title="组件化的流程"></a>组件化的流程</h1><ol><li><p>组件化编码流程：</p><p> ​    (1).<strong>拆分</strong>静态组件：组件要按照<strong>功能点拆分</strong>，命名不要与html元素冲突。</p><p> ​    (2).实现动态组件：<strong>考虑好数据的存放位置</strong>，数据是一个组件在用，还是一些组件在用：</p><p> ​            1).一个组件在用：放在组件<strong>自身</strong>即可。</p><p> ​            2). 一些组件在用：放在他们<strong>共同的父组件</strong>上（<span style="color:red">状态提升</span>）。</p><p> ​    (3).实现交互：从绑定事件开始。</p></li><li><p>props适用于：</p><p> ​    (1).父组件 ==&gt; 子组件 通信（<strong>逐层传递</strong>）</p><p> ​    (2).子组件 ==&gt; 父组件 通信（要求父先给子一个<strong>函数</strong>）</p></li><li><p>使用v-model时要切记：<strong>v-model绑定的值不能是props传过来的值</strong>，因为props是不可以修改的！</p></li><li><p>props传过来的若是<strong>对象类型的值</strong>，修改对象中的属性时Vue不会报错，但<strong>不推荐这样做</strong>。</p></li></ol><p><strong>uuid的库</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i nanoid</span><br></pre></td></tr></table></figure><p><strong>存储webStorage</strong></p><ol><li><p>存储内容大小一般支持<strong>5MB</strong>左右（不同浏览器可能还不一样）</p></li><li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p></li><li><p>相关API：</p><ol><li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code></p><pre><code>该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</code></pre></li><li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p><p> ​        该方法接受一个键名作为参数，返回键名对应的值。</p></li><li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p><p> ​        该方法接受一个键名作为参数，并把该键名从存储中删除。</p></li><li><p><code>xxxxxStorage.clear()</code></p><p> ​        该方法会清空存储中的所有数据。</p></li></ol></li><li><p>备注：</p><ol><li>SessionStorage存储的内容会<strong>随着浏览器窗口关闭而消失</strong>。</li><li>LocalStorage存储的内容，需要<strong>手动清除</strong>才会消失。</li><li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li><li><code>JSON.parse(null)</code>的结果依然是null。</li></ol></li></ol><p>localStorage.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>localStorage<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>localStorage<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;saveData()&quot;</span>&gt;</span>点我保存一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;readData()&quot;</span>&gt;</span>点我读取一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;deleteData()&quot;</span>&gt;</span>点我删除一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;deleteAllData()&quot;</span>&gt;</span>点我清空一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> &gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> p = &#123;<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">saveData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;msg&#x27;</span>,<span class="string">&#x27;hello!!!&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;msg2&#x27;</span>,<span class="number">666</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;person&#x27;</span>,<span class="built_in">JSON</span>.stringify(p))</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;msg&#x27;</span>))</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;msg2&#x27;</span>))</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> result = <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;person&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(result))</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// console.log(localStorage.getItem(&#x27;msg3&#x27;))</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">deleteData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">localStorage</span>.removeItem(<span class="string">&#x27;msg2&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">deleteAllData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">localStorage</span>.clear()</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>sessionStorage.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>sessionStorage<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>sessionStorage<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;saveData()&quot;</span>&gt;</span>点我保存一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;readData()&quot;</span>&gt;</span>点我读取一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;deleteData()&quot;</span>&gt;</span>点我删除一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;deleteAllData()&quot;</span>&gt;</span>点我清空一个数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> &gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> p = &#123;<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">saveData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">sessionStorage.setItem(<span class="string">&#x27;msg&#x27;</span>,<span class="string">&#x27;hello!!!&#x27;</span>)</span></span><br><span class="line"><span class="javascript">sessionStorage.setItem(<span class="string">&#x27;msg2&#x27;</span>,<span class="number">666</span>)</span></span><br><span class="line"><span class="javascript">sessionStorage.setItem(<span class="string">&#x27;person&#x27;</span>,<span class="built_in">JSON</span>.stringify(p))</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(sessionStorage.getItem(<span class="string">&#x27;msg&#x27;</span>))</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(sessionStorage.getItem(<span class="string">&#x27;msg2&#x27;</span>))</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> result = sessionStorage.getItem(<span class="string">&#x27;person&#x27;</span>)</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(result))</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// console.log(sessionStorage.getItem(&#x27;msg3&#x27;))</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">deleteData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">sessionStorage.removeItem(<span class="string">&#x27;msg2&#x27;</span>)</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">deleteAllData</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">sessionStorage.clear()</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol><li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p></li><li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p></li><li><p>绑定自定义事件：</p><ol><li><p>第一种方式，在父组件中：<code>&lt;Demo @getStudent=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:getStudent=&quot;test&quot;/&gt;</code>  子组件<strong>通过getStudent进行调用</strong>自定义事件，调用父组件的test方法。</p></li><li><p>第二种方式，在父组件中：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Demo ref=<span class="string">&quot;demo&quot;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.$refs.xxx.$on(<span class="string">&#x27;getStudent&#x27;</span>,<span class="built_in">this</span>.test);</span><br><span class="line">   <span class="built_in">this</span>.$refs.xxx.$once(<span class="string">&#x27;getStudent&#x27;</span>,<span class="built_in">this</span>.test)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。<code>&lt;Demo @getStudent.once=&quot;test&quot;/&gt;</code>  或 <code>&lt;Demo v-on:getStudent.once=&quot;test&quot;/&gt;</code>  </p></li></ol></li><li><p>触发自定义事件：<code>this.$emit(&#39;getStudent&#39;,数据)</code>        </p></li><li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code>，只能解绑一个。<code>this.$off([&#39;atguigu&#39;])</code></p></li><li><p>组件上也可以<strong>绑定原生DOM事件</strong>，需要使用<code>native</code>修饰符。<code>&lt;Demo @click.navie=&quot;test&quot;/&gt;</code></p></li><li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！在vue里面谁触发的事件fuction中是this就是那个组件，所以必须写成箭头函数。</p></li></ol><h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>安装全局事件总线： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">Vue.prototype.$bus = <span class="built_in">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">methods</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">demo</span>(<span class="params">data</span>)</span>&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="built_in">this</span>.demo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p></li></ol></li><li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。因为傀儡身上的事件一直存在。</p></li></ol><h2 id="消息订阅和发布"><a href="#消息订阅和发布" class="headerlink" title="消息订阅和发布"></a>消息订阅和发布</h2><ol><li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p></li><li><p>使用步骤：</p><ol><li><p>安装pubsub：<code>npm i pubsub-js</code></p></li><li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p></li><li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">methods</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">demo</span>(<span class="params">data</span>)</span>&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.pid = pubsub.subscribe(<span class="string">&#x27;xxx&#x27;</span>,<span class="built_in">this</span>.demo) <span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p></li><li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p></li></ol></li></ol><p>订阅消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;School&#x27;,</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">name:&#x27;尚硅谷&#x27;,</span><br><span class="line">address:&#x27;北京&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">// console.log(&#x27;School&#x27;,this)</span><br><span class="line">/* this.$bus.$on(&#x27;hello&#x27;,(data)=&gt;&#123;</span><br><span class="line">console.log(&#x27;我是School组件，收到了数据&#x27;,data)</span><br><span class="line">&#125;) */</span><br><span class="line">this.pubId = pubsub.subscribe(&#x27;hello&#x27;,(msgName,data)=&gt;&#123;</span><br><span class="line">console.log(this)</span><br><span class="line">// console.log(&#x27;有人发布了hello消息，hello消息的回调执行了&#x27;,msgName,data)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">// this.$bus.$off(&#x27;hello&#x27;)</span><br><span class="line">pubsub.unsubscribe(this.pubId)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消息发布</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name:&#x27;Student&#x27;,</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                name:&#x27;张三&#x27;,</span><br><span class="line">                sex:&#x27;男&#x27;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            // console.log(&#x27;Student&#x27;,this.x)</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            sendStudentName()&#123;</span><br><span class="line">                // this.$bus.$emit(&#x27;hello&#x27;,this.name)</span><br><span class="line">                pubsub.publish(&#x27;hello&#x27;,666)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol><li>语法：<code>this.$nextTick(回调函数)</code></li><li>作用：在下一次 <strong>DOM 更新结束</strong>后执行其指定的回调。</li><li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;label&gt;</span><br><span class="line">      &lt;input type=&quot;checkbox&quot; :checked=&quot;todo.done&quot; @change=&quot;handleCheck(todo.id)&quot; /&gt;</span><br><span class="line">      &lt;!-- 如下代码也能实现功能，但是不太推荐，因为有点违反原则，因为修改了props --&gt;</span><br><span class="line">      &lt;!-- &lt;input type=&quot;checkbox&quot; v-model=&quot;todo.done&quot;/&gt; --&gt;</span><br><span class="line">      &lt;span v-show=&quot;!todo.isEdit&quot;&gt;&#123;&#123;todo.title&#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;input v-show=&quot;todo.isEdit&quot; type=&quot;text&quot; :value=&quot;todo.title&quot; @blur=&quot;handleBlur(todo.id,$event)&quot;</span><br><span class="line">      ref=&quot;inputTitle&quot; /&gt;</span><br><span class="line">    &lt;/label&gt;</span><br><span class="line">    &lt;button class=&quot;btn btn-danger&quot; @click=&quot;handleDelete(todo.id)&quot;&gt;删除&lt;/button&gt;</span><br><span class="line">    &lt;button v-show=&quot;!todo.isEdit&quot;  class=&quot;btn btn-edit&quot; @click=&quot;handleEdit(todo.id)&quot;&gt;编辑&lt;/button&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import pubsub from &quot;pubsub-js&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;MyItem&quot;,</span><br><span class="line">  props: [&quot;todo&quot;],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    //勾选</span><br><span class="line">    handleCheck(id) &#123;</span><br><span class="line">      //通知App将todo的对象取反</span><br><span class="line">     this.$bus.$emit(&quot;checkTodo&quot;, id);</span><br><span class="line">    &#125;,</span><br><span class="line">    //删除</span><br><span class="line">    handleDelete(id) &#123;</span><br><span class="line">      if (confirm(&quot;确定删除吗？&quot;)) &#123;</span><br><span class="line">        //通知App删除</span><br><span class="line">       this.$bus.$emit(&quot;deleteTodo&quot;, id);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    //编辑</span><br><span class="line">    handleEdit(id) &#123;</span><br><span class="line">      if (this.todo.hasOwnProperty(&quot;isEdit&quot;)) &#123;</span><br><span class="line">        this.todo.isEdit = true;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.$set(this.todo, &quot;isEdit&quot;, true);</span><br><span class="line">      &#125;</span><br><span class="line">      //这里input都没有出现</span><br><span class="line">      this.$nextTick(function()&#123; //下一轮，会在dom解析完执行</span><br><span class="line">        this.$refs.inputTitle.focus()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    //失去焦点，回调修改</span><br><span class="line">    handleBlur(id, e) &#123;</span><br><span class="line">      this.todo.isEdit = false;</span><br><span class="line">      if(!e.target.value.tirm()) return alert(&#x27;输入不能为空&#x27;);</span><br><span class="line">      this.$bus.$emit(&quot;updateTodo&quot;, this.todo.id, e.target.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;root&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;todo-container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;todo-wrap&quot;&gt;</span><br><span class="line">      &lt;MyHeader @addTodo=&quot;addTodo&quot;&gt;&lt;/MyHeader&gt;</span><br><span class="line">      &lt;MyList :todos=&quot;todos&quot; &gt;&lt;/MyList&gt;</span><br><span class="line">      &lt;MyFooter :todos=&quot;todos&quot; @checkAllTodos=&quot;checkAllTodos&quot; @clearAllTodo=&quot;clearAllTodo&quot;&gt;&lt;/MyFooter&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">import MyHeader from &#x27;./components/MyHeader&#x27;</span><br><span class="line">import MyList from &#x27;./components/MyList&#x27;</span><br><span class="line">import MyFooter from &#x27;./components/MyFooter&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyHeader,</span><br><span class="line">    MyList,</span><br><span class="line">    MyFooter</span><br><span class="line">  &#125;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      todos: JSON.parse(localStorage.getItem(&#x27;todos&#x27;)) || []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    //添加一个todo</span><br><span class="line">    addTodo(todoObj)&#123;</span><br><span class="line">      this.todos.unshift(todoObj)</span><br><span class="line">    &#125;,</span><br><span class="line">    //勾选或取消勾选</span><br><span class="line">    checkTodo(id)&#123;</span><br><span class="line">      this.todos.forEach( todo =&gt; &#123;</span><br><span class="line">        if ( todo.id === id ) &#123;</span><br><span class="line">          todo.done = !todo.done;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    //更改</span><br><span class="line">    updateTodo(id, title)&#123;</span><br><span class="line">      this.todos.forEach( todo =&gt; &#123;</span><br><span class="line">        if ( todo.id === id ) &#123;</span><br><span class="line">          todo.title = title;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    //勾选或取消勾选</span><br><span class="line">    deleteTodo(id)&#123;</span><br><span class="line">      this.todos = this.todos.filter( todo =&gt; &#123;</span><br><span class="line">        return todo.id !== id;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    //全选的控制</span><br><span class="line">    checkAllTodos(done)&#123;</span><br><span class="line">      this.todos.forEach( todo =&gt; &#123;</span><br><span class="line">          todo.done = done;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    clearAllTodo()&#123;</span><br><span class="line">      this.todos = this.todos.filter( todo =&gt; &#123;</span><br><span class="line">        return !todo.done;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch:&#123;</span><br><span class="line">    todos:&#123;</span><br><span class="line">      deep:true,</span><br><span class="line">      handler(value)&#123;</span><br><span class="line">         localStorage.setItem(&#x27;todos&#x27;,JSON.stringify(value));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  //挂载事件用于通信</span><br><span class="line">  mounted()&#123;</span><br><span class="line">    this.$bus.$on(&#x27;deleteTodo&#x27;,this.deleteTodo)</span><br><span class="line">    this.$bus.$on(&#x27;checkTodo&#x27;,this.checkTodo)</span><br><span class="line">    this.$bus.$on(&#x27;updateTodo&#x27;,this.updateTodo)</span><br><span class="line">  &#125;,</span><br><span class="line">  //解绑事件</span><br><span class="line">  beforeDestroy()&#123;</span><br><span class="line">    this.$bus.$off(&#x27;checkTodo&#x27;);</span><br><span class="line">    this.$bus.$off(&#x27;deleteTodo&#x27;);</span><br><span class="line">    this.$bus.$off(&#x27;updateTodo&#x27;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol><li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p></li><li><p>图示：</p><img src="/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E7%BB%84%E4%BB%B6/动画.png" alt="动画" style="zoom:80%;"></li><li><p>写法：</p><ol><li><p>准备好样式：</p><ul><li>元素进入的样式：<ol><li>v-enter：进入的起点</li><li>v-enter-active：进入过程中</li><li>v-enter-to：进入的终点</li></ol></li><li>元素离开的样式：<ol><li>v-leave：离开的起点</li><li>v-leave-active：离开过程中</li><li>v-leave-to：离开的终点</li></ol></li></ul></li><li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class="line">&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></li><li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p></li></ol></li></ol><p>动画效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;</span><br><span class="line">&lt;transition name=&quot;hello&quot; appear&gt;</span><br><span class="line">&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Test&#x27;,</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">isShow:true</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">h1&#123;</span><br><span class="line">background-color: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.hello-enter-active&#123;</span><br><span class="line">animation: my-css 0.5s linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.hello-leave-active&#123;</span><br><span class="line">animation: my-css 0.5s linear reverse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes my-css &#123;</span><br><span class="line">from&#123;</span><br><span class="line">transform: translateX(-100%);</span><br><span class="line">&#125;</span><br><span class="line">to&#123;</span><br><span class="line">transform: translateX(0px);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>过渡效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;</span><br><span class="line">&lt;transition-group name=&quot;hello&quot; appear&gt;</span><br><span class="line">&lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Test&#x27;,</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">isShow:true</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">h1&#123;</span><br><span class="line">background-color: orange;</span><br><span class="line">&#125;</span><br><span class="line">/* 进入的起点、离开的终点 */</span><br><span class="line">.hello-enter,.hello-leave-to&#123;</span><br><span class="line">transform: translateX(-100%);</span><br><span class="line">&#125;</span><br><span class="line">.hello-enter-active,.hello-leave-active&#123;</span><br><span class="line">transition: 0.5s linear;</span><br><span class="line">&#125;</span><br><span class="line">/* 进入的终点、离开的起点 */</span><br><span class="line">.hello-enter-to,.hello-leave&#123;</span><br><span class="line">transform: translateX(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>集成第三方</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install animate.css</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;</span><br><span class="line">&lt;transition-group </span><br><span class="line">appear</span><br><span class="line">name=&quot;animate__animated animate__bounce&quot; </span><br><span class="line">enter-active-class=&quot;animate__swing&quot;</span><br><span class="line">leave-active-class=&quot;animate__backOutUp&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#x27;animate.css&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Test&#x27;,</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">isShow:true</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">h1&#123;</span><br><span class="line">background-color: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="Vue中的ajax"><a href="#Vue中的ajax" class="headerlink" title="Vue中的ajax"></a>Vue中的ajax</h1><h2 id="AJAX跨域请求问题"><a href="#AJAX跨域请求问题" class="headerlink" title="AJAX跨域请求问题"></a>AJAX跨域请求问题</h2><p>引入：<code>npm i axios</code></p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​    在vue.config.js中添加如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:<span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li><li>缺点：<strong>不能配置多个代理</strong>，不能灵活的控制请求是否走代理。</li><li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​    编写vue.config.js配置具体代理规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">      <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">ws</span>: <span class="literal">true</span>，  <span class="comment">//支持websocket</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,<span class="comment">//用于控制请求头中的host值</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;<span class="comment">//替换</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li><li>缺点：配置略微繁琐，请求资源时必须加前缀。</li></ol><h3 id="vue-项目中常用的-2-个-Ajax-库"><a href="#vue-项目中常用的-2-个-Ajax-库" class="headerlink" title="vue 项目中常用的 2 个 Ajax 库"></a>vue 项目中常用的 2 个 Ajax 库</h3><ul><li><strong>axios</strong> </li><li><strong>vue-resource</strong> </li></ul><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol><li><p>作用：让父组件可以向子组件指定位置<strong>插入html结构</strong>，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p></li><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ol><li><p>默认插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>具名插槽：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure></li><li><p>作用域插槽：</p><ol><li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p></li><li><p>具体编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category&gt;</span><br><span class="line">&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            export default &#123;</span><br><span class="line">                name:&#x27;Category&#x27;,</span><br><span class="line">                props:[&#x27;title&#x27;],</span><br><span class="line">                //数据在子组件自身</span><br><span class="line">                data() &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div class=&quot;category&quot;&gt;</span><br><span class="line">&lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;</span><br><span class="line">&lt;!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --&gt;</span><br><span class="line">&lt;slot&gt;我是一些默认值，当使用者没有传递具体结构时，我会出现&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Category&quot;,</span><br><span class="line">  props: [&quot;title&quot;]</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;Category title=&quot;美食&quot; &gt;</span><br><span class="line">&lt;img src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category title=&quot;游戏&quot; &gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category title=&quot;电影&quot;&gt;</span><br><span class="line">&lt;video controls src=&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;&gt;&lt;/video&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import  Category  from &quot;./components/Category&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  components:&#123;Category&#125;,</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">foods:[&#x27;火锅&#x27;,&#x27;烧烤&#x27;,&#x27;小龙虾&#x27;,&#x27;牛排&#x27;],</span><br><span class="line">games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;],</span><br><span class="line">films:[&#x27;《教父》&#x27;,&#x27;《拆弹专家》&#x27;,&#x27;《你好，李焕英》&#x27;,&#x27;《尚硅谷》&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;category&quot;&gt;</span><br><span class="line">&lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;</span><br><span class="line">&lt;!-- 定义一个插槽（挖个坑，等着组件的使用者进行填充） --&gt;</span><br><span class="line">&lt;slot name=&quot;center&quot;&gt;我是一些默认值，当使用者没有传递具体结构时，我会出现1&lt;/slot&gt;</span><br><span class="line">&lt;slot name=&quot;footer&quot;&gt;我是一些默认值，当使用者没有传递具体结构时，我会出现2&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Category&#x27;,</span><br><span class="line">props:[&#x27;title&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">&lt;Category title=&quot;美食&quot; &gt;</span><br><span class="line">&lt;img slot=&quot;center&quot; src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;a slot=&quot;footer&quot; href=&quot;http://www.baidu.com&quot;&gt;更多美食&lt;/a&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category title=&quot;游戏&quot; &gt;</span><br><span class="line">&lt;ul slot=&quot;center&quot;&gt;</span><br><span class="line">&lt;li v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;div class=&quot;foot&quot; slot=&quot;footer&quot;&gt;</span><br><span class="line">&lt;a href=&quot;http://www.baidu.com&quot;&gt;单机游戏&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;http://www.baidu.com&quot;&gt;网络游戏&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category title=&quot;电影&quot;&gt;</span><br><span class="line">&lt;video slot=&quot;center&quot; controls src=&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot;&gt;&lt;/video&gt;</span><br><span class="line">&lt;template v-slot:footer&gt;</span><br><span class="line">&lt;div class=&quot;foot&quot;&gt;</span><br><span class="line">&lt;a href=&quot;http://www.baidu.com&quot;&gt;经典&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;http://www.baidu.com&quot;&gt;热门&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;http://www.baidu.com&quot;&gt;推荐&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;h4&gt;欢迎前来观影&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Category from &#x27;./components/Category&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;App&#x27;,</span><br><span class="line">components:&#123;Category&#125;,</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">foods:[&#x27;火锅&#x27;,&#x27;烧烤&#x27;,&#x27;小龙虾&#x27;,&#x27;牛排&#x27;],</span><br><span class="line">games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;],</span><br><span class="line">films:[&#x27;《教父》&#x27;,&#x27;《拆弹专家》&#x27;,&#x27;《你好，李焕英》&#x27;,&#x27;《尚硅谷》&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;category&quot;&gt;</span><br><span class="line">&lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;</span><br><span class="line">        &lt;!-- 给使用者传递数据，类似于组件 --&gt;</span><br><span class="line">&lt;slot :games=&quot;games&quot; msg=&quot;hello&quot;&gt;我是默认的一些内容&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Category&#x27;,</span><br><span class="line">props:[&#x27;title&#x27;],</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;],</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category title=&quot;游戏&quot;&gt;</span><br><span class="line">&lt;template scope=&quot;baidu&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li v-for=&quot;(g,index) in baidu.games&quot; :key=&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category title=&quot;游戏&quot;&gt;</span><br><span class="line">&lt;template scope=&quot;&#123;games&#125;&quot;&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;li style=&quot;color:red&quot; v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category title=&quot;游戏&quot;&gt;</span><br><span class="line">            &lt;!-- --&gt; </span><br><span class="line">&lt;template slot-scope=&quot;&#123;games&#125;&quot;&gt;</span><br><span class="line">&lt;h4 v-for=&quot;(g,index) in games&quot; :key=&quot;index&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Category from &#x27;./components/Category&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;App&#x27;,</span><br><span class="line">components:&#123;Category&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ol><li>概念：专门在 Vue 中实现<strong>集中式状态</strong>（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的<strong>共享状态进行集中式的管理</strong>（读/写），也是一种组件间通信的方式，且适用于<strong>任意组件间通信</strong>。 </li><li>Github 地址: <a href="https://github.com/vuejs/vuex">https://github.com/vuejs/vuex</a></li></ol><img src="/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E7%BB%84%E4%BB%B6/全局组件共享数据.png" alt="全局组件共享数据" style="zoom: 67%;"><img src="/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E7%BB%84%E4%BB%B6/vuex实现组件共享数据.png" alt="vuex实现组件共享数据" style="zoom:67%;"><p>使用时刻：</p><ol><li>多个组件<strong>依赖于同一状态</strong> </li><li>来自不同组件的行为需要<strong>变更同一状态</strong></li></ol><h2 id="Vuex工作原理图（重要）"><a href="#Vuex工作原理图（重要）" class="headerlink" title="Vuex工作原理图（重要）"></a>Vuex工作原理图（重要）</h2><img src="/2021/08/19/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E7%BB%84%E4%BB%B6/vuex.png" alt="vuex" style="zoom: 50%;"><ul><li><p><strong>State</strong>：vuex 管理的状态对象，保存了组件间共享的数据。</p></li><li><p><strong>Action</strong>: 包含多个响应用户动作的回调函数 。通过 commit( )来触发 mutation 中函数的调用, 间接更新 state。<strong>可以包含异步代码（定时器, ajax 等等）</strong>。可以包含多个执行流程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$store.dispatch(<span class="string">&#x27;对应的 action 回调名&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>Mutations</strong>:保存了操作对象，并且在操作里面有着state值和传递过来的值。包含多个直接更新 state 的方法。不能写异步代码、只能单纯的操作 state</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit(<span class="string">&#x27;对应的 mutations 方法名&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><p>这个三个对象需要一个store来管理</p><h2 id="Vuex使用"><a href="#Vuex使用" class="headerlink" title="Vuex使用"></a>Vuex使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol><li><p>安装：<code>npm i vuex</code></p></li><li><p>创建并引入</p><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code>，一般在store文件夹中的index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用Vuex</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">//响应组件中加的动作</span></span><br><span class="line"><span class="function"><span class="title">jia</span>(<span class="params">context,value</span>)</span>&#123;</span><br><span class="line"><span class="comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span></span><br><span class="line">context.commit(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="comment">//执行加</span></span><br><span class="line"><span class="function"><span class="title">JIA</span>(<span class="params">state,value</span>)</span>&#123;</span><br><span class="line"><span class="comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span></span><br><span class="line">state.sum += value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">   <span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">actions,</span><br><span class="line">mutations,</span><br><span class="line">state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在main.js中引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="comment">//vuex</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  store,</span><br><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Vue.prototype.$bus = <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用</p><ul><li><p>定义方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该文件同于常见vuex中最为核心的store</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用vuex插件</span></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于响应组件中的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="function"><span class="title">incrementOdd</span>(<span class="params">context,value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;actions&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (context.state.sum % <span class="number">2</span>)&#123;</span><br><span class="line">            context.commit(<span class="string">&#x27;increment&#x27;</span>,value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">incrementWait</span>(<span class="params">context,value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            context.commit(<span class="string">&#x27;increment&#x27;</span>,value)</span><br><span class="line">          &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于操作数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state, value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;mulations&#x27;</span>);</span><br><span class="line">        state.sum += value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存储数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    <span class="attr">sum</span>:<span class="number">0</span> <span class="comment">//当前的和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并导出store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state</span><br><span class="line">&#125;)使用</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;当前求和为：&#123;&#123;$store.state.sum&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;select v-model.number=&quot;n&quot;&gt;</span><br><span class="line">      &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;</span><br><span class="line">      &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Count&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      n: 1, //用户选择的数字</span><br><span class="line">      sum: 0 //当前的和</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.$store.commit(&quot;increment&quot;, this.n);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement() &#123;</span><br><span class="line">      this.$store.commit(&quot;increment&quot;, -this.n);</span><br><span class="line">    &#125;,</span><br><span class="line">    incrementOdd() &#123;</span><br><span class="line">      this.$store.dispatch(&quot;incrementOdd&quot;, this.n);</span><br><span class="line">    &#125;,</span><br><span class="line">    incrementWait() &#123;</span><br><span class="line">      this.$store.dispatch(&quot;incrementWait&quot;, this.n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p></li><li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p><blockquote><p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p></blockquote></li></ol><h3 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h3><ol><li><p>概念：当state中的数据<strong>需要经过加工后再使用</strong>时，可以使用getters加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line"><span class="function"><span class="title">bigSum</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> state.sum * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">......</span><br><span class="line">getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>组件中读取数据：<code>$store.getters.bigSum</code></p></li></ol><h3 id="四个map方法的使用"><a href="#四个map方法的使用" class="headerlink" title="四个map方法的使用"></a>四个map方法的使用</h3><p>哪里使用哪里引入：import {mapState} from ‘vuex’</p><ol><li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...mapState(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class="line">    ...mapState([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...mapGetters(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class="line">    ...mapGetters([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class="line">    ...mapActions(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class="line">    ...mapActions([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...mapMutations(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...mapMutations([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>备注：mapActions与mapMutations使用时，若<strong>需要传递参数</strong>需要：在模板中<strong>绑定事件时传递好参数</strong>，否则参数是事件对象。</p></blockquote><h2 id="模块化-命名空间"><a href="#模块化-命名空间" class="headerlink" title="模块化+命名空间"></a>模块化+命名空间</h2><ol><li><p>目的：让代码更好维护，让多种<strong>数据分类更加明确</strong>。</p></li><li><p>修改<code>store.js</code>，分别放到2个js文件中，只需要在index.js中引入就可以。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">bigSum</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> state.sum * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取state数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="built_in">this</span>.$store.state.personAbout.list</span><br><span class="line"><span class="comment">//方式二：借助mapState读取：</span></span><br><span class="line">...mapState(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中读取getters数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="built_in">this</span>.$store.getters[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">...mapGetters(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用dispatch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions：</span></span><br><span class="line">...mapActions(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>开启命名空间后，组件中调用commit</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations：</span></span><br><span class="line">...mapMutations(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue基础</title>
      <link href="/2021/08/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/08/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Vue官网： <a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></p><p>动态构建用户界面的<strong>渐进式</strong>JavaScript框架</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>遵循<strong>MVVM</strong>模式</li><li>编码简洁，体积小，运行效率高，适合PC/移动端开发</li><li>只关注UI，可以引入第三方库开发项目</li></ul><h3 id="与其他框架的关联："><a href="#与其他框架的关联：" class="headerlink" title="与其他框架的关联："></a>与其他框架的关联：</h3><ul><li>借鉴Angular的<strong>模板</strong>和<strong>数据绑定</strong>技术</li><li>借鉴React的<strong>组件化</strong>和<strong>虚拟DOM</strong>技术</li></ul><h3 id="周边库："><a href="#周边库：" class="headerlink" title="周边库："></a>周边库：</h3><ul><li>vue-cli:vue脚手架</li><li>vue-resource</li><li>axios</li><li>vue-router:路由</li><li>vuex:状态管理</li><li>…</li></ul><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>初识Vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入Vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 准备好一个容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello，&#123;&#123;name.toUpperCase()&#125;&#125;，&#123;&#123;address&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> &gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">Vue.config.productionTip = <span class="literal">false</span> <span class="comment">//阻止 vue 在启动时生成生产提示。</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">//创建Vue实例</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> x = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>, <span class="comment">//el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。</span></span></span><br><span class="line"><span class="javascript"><span class="attr">data</span>:&#123; <span class="comment">//data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。</span></span></span><br><span class="line"><span class="javascript"><span class="attr">name</span>:<span class="string">&#x27;lq&#x27;</span>,</span></span><br><span class="line"><span class="javascript"><span class="attr">address</span>:<span class="string">&#x27;北京&#x27;</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</li><li>root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；</li><li>root容器里的代码被称为【<strong>Vue模板</strong>】；</li><li>Vue实例和容器是<strong>一一对应</strong>的；</li><li>真实开发中只有一个Vue实例，并且会<strong>配合着组件一起使用</strong>；</li><li>**中的**xxx要写js**表达式**，且xxx可以自动读取到data中的所有属性；</li><li>一旦data中的数据发生改变，那么页面中用到该数据的地方也会<strong>自动更新</strong>；</li></ol><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="模板的理解："><a href="#模板的理解：" class="headerlink" title="模板的理解："></a>模板的理解：</h3><p>html包含了一下js语法代码</p><ul><li><p>插值语法（双大括号表达式）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>指令（以v-开头）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&#x27;&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&#x27;url&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="comment">&lt;!-- 简写 --&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>插值语法</strong></p><ul><li>功能：用于解析标签体<strong>内容</strong></li><li><code>&#123;&#123;xxx&#125;&#125;</code>，xxx是js表达式，且可以直接读取到data中所有属性。</li></ul><p><strong>指令语法</strong></p><ul><li>功能解析标签属性、解析标签体内容、绑定事件</li><li><code>v-bind:href=&#39;xxx&#39;</code>, xxx会当做表达式解析，且可以直接读取到data中所有属性。</li></ul><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p><strong>单向数据绑定</strong></p><ul><li>通过<code>v-bind</code>单向绑定，数据从data流向页面。</li></ul><p><strong>双向数据绑定</strong></p><ul><li>通过<code>v-model</code>双向绑定，数据不仅能从 data 流向页面，还能从页面流向 data。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--单向数据绑定&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt; --&gt;</span></span><br><span class="line">    单向数据绑定<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 双向数据绑定&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt; --&gt;</span></span><br><span class="line">    双向数据绑定<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.productionTip = <span class="literal">false</span> <span class="comment">//阻止 vue 在启动时生成生产提示。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Vue实例</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>, </span><br><span class="line"><span class="attr">data</span>:&#123; </span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;lq&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>不是所有的属性都能使用双向绑定，<code>v-model</code>只能应用在<strong>表单元素</strong>上（输入类元素）。<br>v-model:value简写为v-model.因为默认收集的是value值。</p></blockquote><h2 id="el和data的两中写法"><a href="#el和data的两中写法" class="headerlink" title="el和data的两中写法"></a>el和data的两中写法</h2><p>在Vue实例中，所有<strong>带$的元素都是程序员可以操作</strong>的，其他的是Vue自己在使用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>, </span><br><span class="line"><span class="attr">data</span>:&#123; </span><br><span class="line"><span class="attr">name</span>:<span class="string">&#x27;lq&#x27;</span>,<span class="comment">//对象式写法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//el另一种写法,先创建实例</span></span><br><span class="line">v.$mount(<span class="string">&#x27;#root&#x27;</span>);<span class="comment">//挂载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//data的函数式写法，Vue自动帮忙调用，组件时必须使用函数式</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>, </span><br><span class="line">    <span class="comment">//data:function()&#123;</span></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;<span class="comment">//不要使用箭头函数</span></span><br><span class="line">       <span class="keyword">return</span>&#123;</span><br><span class="line"> <span class="attr">name</span>:<span class="string">&#x27;lq&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>Vue管理的函数一定不要写箭头函数,否则this.就不在是Vue实例了。</p></blockquote><h2 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h2><p>vue没有<strong>完全遵循mvvm模型</strong>，但在一定程度上参考了这个模型，会经常使用<code>vm(ViewModel)</code>来表示Vue实例。</p><ul><li><p><code>M</code>：模型(Model) ：对应 data 中的数据 </p></li><li><p><code>V</code>：视图(View) ：模板 </p></li><li><p><code>VM</code>：视图模型(ViewModel) ： Vue 实例对象，通过<code>DOM Listeners</code>和<code>Data Bindings</code>进行数据双向绑定</p></li></ul><img src="/2021/08/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E5%9F%BA%E7%A1%80/mvvm模型.png" alt="mvvm模型" style="zoom:67%;"><p>可以使用是不仅仅是自己定义的属性，vue的属性也可以直接使用</p><h2 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h2><p><code>Object.defineProperty()</code>,面向对象的修改和读取默认走set和get。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">18</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">&#x27;age&#x27;</span>,&#123;</span><br><span class="line">    <span class="comment">// value:18,</span></span><br><span class="line">    <span class="comment">// enumerable:true, //控制属性是否可以枚举，默认值是false</span></span><br><span class="line">    <span class="comment">// writable:true, //控制属性是否可以被修改，默认值是false</span></span><br><span class="line">    <span class="comment">// configurable:true //控制属性是否可以被删除，默认值是false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值</span></span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;有人读取age属性了&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值</span></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;有人修改了age属性，且值是&#x27;</span>,value);</span><br><span class="line">        number = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person)</span><br></pre></td></tr></table></figure><h3 id="理解数据代理"><a href="#理解数据代理" class="headerlink" title="理解数据代理"></a>理解数据代理</h3><p>数据代理：<strong>通过一个对象代理对另一个对象中属性的操作</strong>（读/写）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>:<span class="number">100</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">y</span>:<span class="number">200</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj2,<span class="string">&#x27;x&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.x</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        obj.x = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Vue中的数据代理"><a href="#Vue中的数据代理" class="headerlink" title="Vue中的数据代理"></a>Vue中的数据代理</h3><ul><li>Vue中的数据代理：通过<strong>vm对象来代理data对象中属性的操作</strong>（读/写）</li><li>Vue中数据代理的好处：更加方便的操作data中的数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm._data = options.data = data//vue内部</span><br><span class="line">vm._data === data //true</span><br></pre></td></tr></table></figure><p>vm把数据都存在了<code>_data</code>，通过<code>vm._data.name</code>获取内部的数据，_data中使用了<strong>数据劫持</strong>。</p><p><strong>为什么用数据劫持</strong>？为了完成在数据更改时修改视图。</p><p><strong>数据驱动视图</strong>，一旦data数据发生变化，页面数据也会发生改变。</p><p>真正数据代理的地方是添加到vm上的数据，通过_data来进行的数据代理。</p><p>基本原理：</p><ul><li>过Object.defineProperty()<strong>把data对象中所有属性添加</strong>到vm上。</li><li>为每一个添加到vm上的属性，<strong>都指定一个getter/setter</strong>。</li><li>在getter/setter<strong>内部去操作</strong>（读/写）data中对应的属性。</li></ul><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="绑定监听"><a href="#绑定监听" class="headerlink" title="绑定监听"></a>绑定监听</h3><ul><li><code>v-on:xxx=function</code>,(xxx是事件名)，简写<code>@:xxx=function(参数)</code>，函数写在<code>methods</code>对象中默认的参数event，隐藏的参数为<code>$event</code>。如果你传递了参数，vue使用<code>$event</code>传递。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;fun(a,$event)&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传递参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>methods的函数，都Vue所管理的函数。this指向都是 <strong>vm</strong> 或 <strong>组件实例对象</strong>。</li><li><strong>函数不做数据代理</strong>。函数不需要进行修改</li></ul><blockquote><p>所有被vue管理的函数都写成普通函数。this不是vm</p></blockquote><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>@keydown、@Keyup，按键按下或抬起</p><table><thead><tr><th align="center">按键别名</th><th align="center">按键</th></tr></thead><tbody><tr><td align="center">enter</td><td align="center">回车</td></tr><tr><td align="center">delete</td><td align="center">删除（删除 和 退格）</td></tr><tr><td align="center">esc</td><td align="center">退出</td></tr><tr><td align="center">space</td><td align="center">空格</td></tr><tr><td align="center">tab</td><td align="center">换行(焦点切换走，会失去焦点使用keydown)</td></tr><tr><td align="center">up</td><td align="center">上</td></tr><tr><td align="center">down</td><td align="center">下</td></tr><tr><td align="center">left</td><td align="center">左</td></tr><tr><td align="center">right</td><td align="center">右</td></tr></tbody></table><p>Vue没有提供别名的按键，使用原始的key值去绑定，注意转换<strong>kebab-case(短横线命名)</strong>,caps-lock；</p><p><strong>系统修饰键</strong>：ctrl、alt、shift、meta(win)</p><ul><li>配合keyup使用：按下修饰键同时、按下其他按键。随后释放其他键、时间才被触发。</li><li>配合keydown使用：正常触发</li></ul><p>自定义键名：Vue.config.keyCodes.自定义键码=键码</p><p><strong>事件修饰符</strong>：</p><ul><li>.stop:停止事件冒泡 event.stopPropagation()</li><li>.prevent:阻止事件的默认行为 event.preventDefault()</li></ul><p><strong>两个按键一起按才能有用</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">keyup.ctrl.y</span>=<span class="string">&quot;function&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="计算属性和监视"><a href="#计算属性和监视" class="headerlink" title="计算属性和监视"></a>计算属性和监视</h2><p>实现输入框的拼接</p><h3 id="插值（不推荐）"><a href="#插值（不推荐）" class="headerlink" title="插值（不推荐）"></a>插值（不推荐）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    姓：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    全名：<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;firstName&#125;&#125;-&#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">firstName</span>:<span class="string">&#x27;张&#x27;</span>,</span><br><span class="line">        <span class="attr">lastName</span>:<span class="string">&#x27;三&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="methods-不推荐"><a href="#methods-不推荐" class="headerlink" title="methods(不推荐)"></a>methods(不推荐)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    姓：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    全名：<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;fullName()&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">firstName</span>:<span class="string">&#x27;张&#x27;</span>,</span><br><span class="line">        <span class="attr">lastName</span>:<span class="string">&#x27;三&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">fullName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;@---fullName&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>()必须写，这里不是插值，是方法。如果模板里面data的值发生改变，会引起整个模板重新解析，函数会重复调用。</p></blockquote><h3 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性-computed"></a>计算属性-computed</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    姓：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    测试：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;x&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    全名：<span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="comment">全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="comment">全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">firstName</span>:<span class="string">&#x27;张&#x27;</span>,</span><br><span class="line">        <span class="attr">lastName</span>:<span class="string">&#x27;三&#x27;</span>,</span><br><span class="line">        <span class="attr">x</span>:<span class="string">&#x27;你好&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">demo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        <span class="attr">fullName</span>:&#123;</span><br><span class="line">            <span class="comment">//get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作fullName的值</span></span><br><span class="line">            <span class="comment">//get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。</span></span><br><span class="line">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;get被调用了&#x27;</span>)</span><br><span class="line">                <span class="comment">// console.log(this) //此处的this是vm</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//set什么时候调用? 当fullName被修改时。</span></span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;set&#x27;</span>,value)</span><br><span class="line">                <span class="keyword">const</span> arr = value.split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                <span class="built_in">this</span>.firstName = arr[<span class="number">0</span>]</span><br><span class="line">                <span class="built_in">this</span>.lastName = arr[<span class="number">1</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>定义</strong>：要用的属性不存在，要<strong>通过已有属性计算得来</strong>。<br><strong>原理</strong>：底层借助了<code>Objcet.defineproperty</code>方法提供的<code>getter</code>和<code>setter</code>。</p><p>get函数什么时候执行？<br>    (1).<strong>初次读取</strong>时会执行一次。<br>    (2).当<strong>依赖的数据发生改变</strong>时会被再次调用。</p><p><strong>优势</strong>：与methods实现相比，<strong>内部有缓存机制（复用）</strong>，效率更高，调试方便。</p><blockquote><p>1.计算属性<strong>最终会出现在vm</strong>上，直接读取使用即可。<br>2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</p></blockquote><p>只展示的数据不需要修改。简写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    <span class="function"><span class="title">fullName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27;-&#x27;</span> +<span class="built_in">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="监视属性watch"><a href="#监视属性watch" class="headerlink" title="监视属性watch"></a>监视属性watch</h3><p>监视属性watch（可以监测<strong>计算属性</strong>）：</p><ul><li>当被监视的<strong>属性变化</strong>时, 回调函数<strong>自动调用</strong>, 进行相关操作    </li><li>监视的属性<strong>必须存在</strong>，才能进行监视！！</li><li>监视的两种写法：<ul><li>new Vue时传入<code>watch</code>配置</li><li>通过<code>vm.$watch</code>监视。</li></ul></li></ul><p>通过按钮切换效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>今天天气很&#123;&#123;info&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeWeather&quot;</span>&gt;</span>切换天气<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">isHot</span>:<span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">info</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.isHot ? <span class="string">&#x27;炎热&#x27;</span> : <span class="string">&#x27;凉爽&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">changeWeather</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.isHot = !<span class="built_in">this</span>.isHot</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/* watch:&#123;</span></span><br><span class="line"><span class="comment">        isHot:&#123;</span></span><br><span class="line"><span class="comment">            immediate:true, //初始化时让handler调用一下</span></span><br><span class="line"><span class="comment">            //handler什么时候调用？当isHot发生改变时。</span></span><br><span class="line"><span class="comment">            handler(newValue,oldValue)&#123;</span></span><br><span class="line"><span class="comment">                console.log(&#x27;isHot被修改了&#x27;,newValue,oldValue)</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    <span class="comment">//简写</span></span><br><span class="line">    watch：&#123;</span><br><span class="line">    <span class="function"><span class="title">isHot</span>(<span class="params">newValue,oldValue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;isHot被修改了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种写法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;isHot&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">immediate</span>:<span class="literal">true</span>, <span class="comment">//初始化时让handler调用一下</span></span><br><span class="line">    <span class="comment">//handler什么时候调用？当isHot发生改变时。</span></span><br><span class="line">    <span class="function"><span class="title">handler</span>(<span class="params">newValue,oldValue</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;isHot被修改了&#x27;</span>,newValue,oldValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="深度监视"><a href="#深度监视" class="headerlink" title="深度监视"></a>深度监视</h4><ul><li>Vue中的watch<strong>默认不监测对象内部值的改变</strong>（一层）。</li><li>.配置deep:true<strong>可以监测对象内部值改变</strong>（多层）。</li></ul><blockquote><p>(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！<br>(2).使用watch时<strong>根据数据的具体结构</strong>，决定是否采用深度监视。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>今天天气很&#123;&#123;info&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeWeather&quot;</span>&gt;</span>切换天气<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>a的值是:&#123;&#123;numbers.a&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;numbers.a++&quot;</span>&gt;</span>点我让a+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>b的值是:&#123;&#123;numbers.b&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;numbers.b++&quot;</span>&gt;</span>点我让b+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;numbers = &#123;a:666,b:888&#125;&quot;</span>&gt;</span>彻底替换掉numbers<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    &#123;&#123;numbers.c.d.e&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">isHot</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">numbers</span>:&#123;</span><br><span class="line">            <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="attr">b</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="attr">c</span>:&#123;</span><br><span class="line">                <span class="attr">d</span>:&#123;</span><br><span class="line">                    <span class="attr">e</span>:<span class="number">100</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="comment">//监视多级结构中某个属性的变化</span></span><br><span class="line">        <span class="comment">/* &#x27;numbers.a&#x27;:&#123;</span></span><br><span class="line"><span class="comment">handler()&#123;</span></span><br><span class="line"><span class="comment">console.log(&#x27;a被改变了&#x27;)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line">        <span class="comment">//监视多级结构中所有属性的变化</span></span><br><span class="line">        <span class="attr">numbers</span>:&#123;</span><br><span class="line">            <span class="attr">deep</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="function"><span class="title">handler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;numbers改变了&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="computed和watch对比（重要）"><a href="#computed和watch对比（重要）" class="headerlink" title="computed和watch对比（重要）"></a>computed和watch对比（重要）</h4><p><strong>区别</strong>：</p><ul><li><p>computed能完成的功能，watch都可以完成。</p></li><li><p>watch能完成的功能，computed不一定能完成，例如：<strong>watch可以进行异步操作</strong>(watch可以执行延迟1s进行操作)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line"><span class="function"><span class="title">fullName</span>(<span class="params"></span>)</span>&#123;<span class="comment">//这里把返回值交给了setTimeout，导致fullName没有返回值，会无法显示</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>watch是靠我们自己写代码修改结果值，而computed是依靠返回值来实现计算。</p><blockquote><p>两个重要的小原则：<br>1.所被Vue管理的函数，<strong>最好写成普通函数</strong>，这样this的指向才是vm 或 组件实例对象。<br>2.所有不被Vue所管理的函数（<strong>定时器的回调函数（指向window）、ajax的回调函数等、Promise的回调函数</strong>），最好写成箭头函数，    这样this的指向才是vm 或 组件实例对象。</p></blockquote><h2 id="绑定class样式"><a href="#绑定class样式" class="headerlink" title="绑定class样式"></a>绑定class样式</h2><p>给标签绑定class</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.basic</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.happy</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">4px</span> solid red;;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0.644</span>);</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">30deg</span>,yellow,pink,orange,yellow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sad</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">4px</span> dashed <span class="built_in">rgb</span>(<span class="number">2</span>, <span class="number">197</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.normal</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.atguigu1</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.atguigu2</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">text-shadow</span>:<span class="number">2px</span> <span class="number">2px</span> <span class="number">10px</span> red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.atguigu3</span>&#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 准备好一个容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;mood&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeMood&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;classArr&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;classObj&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 绑定style样式--对象写法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;styleObj&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 绑定style样式--数组写法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;basic&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;styleArr&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">        <span class="attr">mood</span>:<span class="string">&#x27;normal&#x27;</span>,</span><br><span class="line">        <span class="attr">classArr</span>:[<span class="string">&#x27;atguigu1&#x27;</span>,<span class="string">&#x27;atguigu2&#x27;</span>,<span class="string">&#x27;atguigu3&#x27;</span>],</span><br><span class="line">        <span class="attr">classObj</span>:&#123;</span><br><span class="line">            <span class="attr">atguigu1</span>:<span class="literal">false</span>,</span><br><span class="line">            <span class="attr">atguigu2</span>:<span class="literal">false</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">styleObj</span>:&#123;</span><br><span class="line">            <span class="attr">fontSize</span>: <span class="string">&#x27;40px&#x27;</span>,</span><br><span class="line">            <span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">styleObj2</span>:&#123;</span><br><span class="line">            <span class="attr">backgroundColor</span>:<span class="string">&#x27;orange&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">styleArr</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">fontSize</span>: <span class="string">&#x27;40px&#x27;</span>,</span><br><span class="line">                <span class="attr">color</span>:<span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">backgroundColor</span>:<span class="string">&#x27;gray&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">changeMood</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> arr = [<span class="string">&#x27;happy&#x27;</span>,<span class="string">&#x27;sad&#x27;</span>,<span class="string">&#x27;normal&#x27;</span>]</span><br><span class="line">            <span class="keyword">const</span> index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">3</span>)</span><br><span class="line">            <span class="built_in">this</span>.mood = arr[index]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>class样式<ul><li>写法:class=”xxx” xxx可以是字符串、对象、数组.<ul><li>字符串写法适用于：类名不确定，要动态获取。</li><li>对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</li><li>数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</li></ul></li></ul></li><li>style样式<ul><li>:style=”{fontSize: xxx}”其中xxx是动态值。        </li><li>:style=”[a,b]”其中a、b是样式对象。</li></ul></li></ol><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前的n值是:&#123;&#123;n&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;n++&quot;</span>&gt;</span>点我n+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用v-show做条件渲染 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;h2 v-show=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;h2 v-show=&quot;1 === 1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用v-if做条件渲染 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;h2 v-if=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;h2 v-if=&quot;1 === 1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- v-else和v-else-if --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;div v-if=&quot;n === 1&quot;&gt;Angular&lt;/div&gt;</span></span><br><span class="line"><span class="comment">&lt;div v-else-if=&quot;n === 2&quot;&gt;React&lt;/div&gt;</span></span><br><span class="line"><span class="comment">&lt;div v-else-if=&quot;n === 3&quot;&gt;Vue&lt;/div&gt;</span></span><br><span class="line"><span class="comment">&lt;div v-else&gt;哈哈&lt;/div&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- v-if与template的配合使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;n === 1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>尚硅谷<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">        <span class="attr">n</span>:<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>v-if <ul><li>写法：<ul><li>v-if=”表达式” </li><li>v-else-if=”表达式”</li><li>v-else=”表达式”</li></ul></li><li>适用于：<strong>切换频率较低</strong>的场景。</li><li>特点：不展示的DOM元素<strong>直接被移除</strong>。</li><li>注意：v-if可以和:v-else-if、v-else一起使用，但<strong>要求结构不能被“打断”</strong>。</li></ul></li><li>v-show<ul><li>写法：v-show=”表达式”    </li><li>适用于：<strong>切换频率较高</strong>的场景。</li><li>特点：不展示的DOM元素未被移除，仅仅是使用<strong>样式隐藏掉</strong></li></ul></li></ol><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="列表显示指令"><a href="#列表显示指令" class="headerlink" title="列表显示指令"></a>列表显示指令</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 遍历数组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>人员列表（遍历数组）<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(p,index) of persons&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 遍历对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>汽车信息（遍历对象）<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,k) of car&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;k&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;k&#125;&#125;-&#123;&#123;value&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 遍历字符串 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>测试遍历字符串（用得少）<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(char,index) of str&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;char&#125;&#125;-&#123;&#123;index&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 遍历指定次数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>测试遍历指定次数（用得少）<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(number,index) of 5&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;index&#125;&#125;-&#123;&#123;number&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">persons</span>:[</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;002&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;李四&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;003&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;王五&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">car</span>:&#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;奥迪A8&#x27;</span>,</span><br><span class="line">            <span class="attr">price</span>:<span class="string">&#x27;70万&#x27;</span>,</span><br><span class="line">            <span class="attr">color</span>:<span class="string">&#x27;黑色&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">str</span>:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>v-for用于展示列表数据<br>语法：v-for=”(item, index) in xxx” :key=”yyy” （<strong>如果用到遍历必须给每一个结构都有一个标识</strong><code>：key</code>）<br>可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p><h3 id="key的作用的和原理（重要）"><a href="#key的作用的和原理（重要）" class="headerlink" title="key的作用的和原理（重要）"></a>key的作用的和原理（重要）</h3><p>react、vue中的key有什么作用？（key的内部原理）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 遍历数组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>人员列表（遍历数组）<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;add&quot;</span>&gt;</span>添加一个老刘<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(p,index) of persons&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">persons</span>:[</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;002&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;李四&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;003&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;王五&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> p = &#123;<span class="attr">id</span>:<span class="string">&#x27;004&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;老刘&#x27;</span>,<span class="attr">age</span>:<span class="number">40</span>&#125;</span><br><span class="line">            <span class="built_in">this</span>.persons.unshift(p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>虚拟DOM中key的作用：<ul><li>key是<strong>虚拟DOM对象的标识</strong>，当数据发生变化时，Vue会<strong>根据【新数据】生成【新的虚拟DOM】</strong>, 随后Vue进行<strong>【新虚拟DOM】与【旧虚拟DOM】的差异比较</strong>，比较规则如下：</li></ul></li><li>对比规则：<ol><li>旧虚拟DOM中<strong>找到了</strong>与新虚拟DOM相同的key：<ul><li>若虚拟DOM中<strong>内容没变</strong>, 直接<strong>使用之前的真实DOM</strong>！</li><li>若虚拟DOM中<strong>内容变了</strong>, 则<strong>生成新的真实DOM</strong>，<strong>随后替换</strong>掉页面中之前的真实DOM</li></ul></li><li>旧虚拟DOM中<strong>未找到</strong>与新虚拟DOM相同的key<ul><li><strong>创建新的真实DOM</strong>，随后渲染到到页面。</li></ul></li></ol></li><li>用<strong>index作为key</strong>可能会引发的问题：<ol><li>若对数据进行：<strong>逆序添加、逆序删除</strong>等破坏顺序操作:<ul><li>产生<strong>没有必要的真实DOM更新</strong> ==&gt; 界面效果没问题, 但<strong>效率低</strong>。</li></ul></li><li>如果结构中还<strong>包含输入类</strong>的DOM：<ul><li>会产生<strong>错误DOM更新</strong> ==&gt; 界面有问题。</li></ul></li></ol></li><li>开发中如何选择key?<ol><li>最好<strong>使用每条数据的唯一标识</strong>作为key, 比如id、手机号、身份证号、学号等唯一值。</li><li>如果<strong>不存在对数据的逆序添加、逆序删除等破坏顺序操作</strong>，仅用于渲染列表用于展示，使用index作为key是没有问题的。</li></ol></li></ol><img src="/2021/08/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E5%9F%BA%E7%A1%80/用index作为key.png" alt="用index作为key" style="zoom:67%;"><img src="/2021/08/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E5%9F%BA%E7%A1%80/用id作为key.png" alt="遍历列表时key的作用" style="zoom:67%;"><h3 id="列表过滤"><a href="#列表过滤" class="headerlink" title="列表过滤"></a>列表过滤</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>人员列表<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入名字&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;keyWord&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(p,index) of filPerons&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用watch实现</span></span><br><span class="line"><span class="comment">//#region </span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">keyWord</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">persons</span>:[</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;马冬梅&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;002&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;周冬雨&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;003&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;周杰伦&#x27;</span>,<span class="attr">age</span>:<span class="number">21</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;004&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;温兆伦&#x27;</span>,<span class="attr">age</span>:<span class="number">22</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">filPerons</span>:[]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="attr">keyWord</span>:&#123;</span><br><span class="line">            <span class="attr">immediate</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="function"><span class="title">handler</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.filPerons = <span class="built_in">this</span>.persons.filter(<span class="function">(<span class="params">p</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> p.name.indexOf(val) !== -<span class="number">1</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//#endregion</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用computed实现</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">keyWord</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">persons</span>:[</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;马冬梅&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;002&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;周冬雨&#x27;</span>,<span class="attr">age</span>:<span class="number">20</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;003&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;周杰伦&#x27;</span>,<span class="attr">age</span>:<span class="number">21</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;004&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;温兆伦&#x27;</span>,<span class="attr">age</span>:<span class="number">22</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">filPerons</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.persons.filter(<span class="function">(<span class="params">p</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p.name.indexOf(<span class="built_in">this</span>.keyWord) !== -<span class="number">1</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>功能: 对要显示的数据进行特定格式化后再显示 </p><p>注意: 并没有改变原本的数据, 是产生新的对应的数据 </p><h3 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>人员列表<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入名字&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;keyWord&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sortType = 2&quot;</span>&gt;</span>年龄升序<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sortType = 1&quot;</span>&gt;</span>年龄降序<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sortType = 0&quot;</span>&gt;</span>原顺序<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(p,index) of filPerons&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;p.id&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">keyWord</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">sortType</span>:<span class="number">0</span>, <span class="comment">//0原顺序 1降序 2升序</span></span><br><span class="line">        <span class="attr">persons</span>:[</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;马冬梅&#x27;</span>,<span class="attr">age</span>:<span class="number">30</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;002&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;周冬雨&#x27;</span>,<span class="attr">age</span>:<span class="number">31</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;003&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;周杰伦&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;004&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;温兆伦&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>:&#123;</span><br><span class="line">        <span class="comment">//里面使用的属性发生变化都会重新计算</span></span><br><span class="line">        <span class="function"><span class="title">filPerons</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> arr = <span class="built_in">this</span>.persons.filter(<span class="function">(<span class="params">p</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p.name.indexOf(<span class="built_in">this</span>.keyWord) !== -<span class="number">1</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">//判断一下是否需要排序</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.sortType)&#123;</span><br><span class="line">                arr.sort(<span class="function">(<span class="params">p1,p2</span>)=&gt;</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">this</span>.sortType === <span class="number">1</span> ? p2.age-p1.age : p1.age-p2.age</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><h3 id="更新的问题"><a href="#更新的问题" class="headerlink" title="更新的问题"></a>更新的问题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>人员列表<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;updateMei&quot;</span>&gt;</span>更新马冬梅的信息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(p,index) of persons&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;p.id&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">persons</span>:[</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;马冬梅&#x27;</span>,<span class="attr">age</span>:<span class="number">30</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;002&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;周冬雨&#x27;</span>,<span class="attr">age</span>:<span class="number">31</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;003&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;周杰伦&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">id</span>:<span class="string">&#x27;004&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;温兆伦&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">updateMei</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// this.persons[0].name = &#x27;马老师&#x27; //奏效</span></span><br><span class="line">            <span class="comment">// this.persons[0].age = 50 //奏效</span></span><br><span class="line">            <span class="comment">// this.persons[0].sex = &#x27;男&#x27; //奏效</span></span><br><span class="line">            <span class="comment">// this.persons[0] = &#123;id:&#x27;001&#x27;,name:&#x27;马老师&#x27;,age:50,sex:&#x27;男&#x27;&#125; //不奏效</span></span><br><span class="line">            <span class="built_in">this</span>.persons.splice(<span class="number">0</span>,<span class="number">1</span>,&#123;<span class="attr">id</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;马老师&#x27;</span>,<span class="attr">age</span>:<span class="number">50</span>,<span class="attr">sex</span>:<span class="string">&#x27;男&#x27;</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><p>直接赋值对象是不对的，这里把引用地址也发生了变化，原地址上的数据没有改变。</p><h3 id="Vue监测数据的改变的原理（重要）"><a href="#Vue监测数据的改变的原理（重要）" class="headerlink" title="Vue监测数据的改变的原理（重要）"></a>Vue监测数据的改变的原理（重要）</h3><h4 id="模拟一个数据监测（简单版）"><a href="#模拟一个数据监测（简单版）" class="headerlink" title="模拟一个数据监测（简单版）"></a>模拟一个数据监测（简单版）</h4><p>无法递归处理对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">    <span class="attr">address</span>:<span class="string">&#x27;北京&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个监视的实例对象，用于监视data中属性的变化</span></span><br><span class="line"><span class="keyword">const</span> obs = <span class="keyword">new</span> Observer(data)</span><br><span class="line"><span class="built_in">console</span>.log(obs)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备一个vm实例对象</span></span><br><span class="line"><span class="keyword">let</span> vm = &#123;&#125;</span><br><span class="line">vm._data = data = obs; <span class="comment">//模拟赋值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类似于使用Observer来代理data</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//汇总对象中所有的属性形成一个数组</span></span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    keys.forEach(<span class="function">(<span class="params">k</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//this是Observer实例对象</span></span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>,k,&#123;</span><br><span class="line">            <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> obj[k]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;k&#125;</span>被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了`</span>)</span><br><span class="line">                obj[k] = val</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Vue-set-的使用"><a href="#Vue-set-的使用" class="headerlink" title="Vue.set()的使用"></a>Vue.set()的使用</h4><p>给对象动态添加属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>学校信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>学校名称：&#123;&#123;school.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>学校地址：&#123;&#123;school.address&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>校长是：&#123;&#123;school.leader&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>学生信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addSex&quot;</span>&gt;</span>添加一个性别属性，默认值是男<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>姓名：&#123;&#123;student.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;student.sex&quot;</span>&gt;</span>性别：&#123;&#123;student.sex&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>年龄：真实&#123;&#123;student.age.rAge&#125;&#125;，对外&#123;&#123;student.age.sAge&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>朋友们<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(f,index) in student.friends&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">school</span>:&#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;lq&#x27;</span>,</span><br><span class="line">            <span class="attr">address</span>:<span class="string">&#x27;北京&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">student</span>:&#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>:&#123;</span><br><span class="line">                <span class="attr">rAge</span>:<span class="number">40</span>,</span><br><span class="line">                <span class="attr">sAge</span>:<span class="number">29</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">friends</span>:[</span><br><span class="line">                &#123;<span class="attr">name</span>:<span class="string">&#x27;jerry&#x27;</span>,<span class="attr">age</span>:<span class="number">35</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">name</span>:<span class="string">&#x27;tony&#x27;</span>,<span class="attr">age</span>:<span class="number">36</span>&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">addSex</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// Vue.set(this.student,&#x27;sex&#x27;,&#x27;男&#x27;)</span></span><br><span class="line">            <span class="built_in">this</span>.$set(<span class="built_in">this</span>.student,<span class="string">&#x27;sex&#x27;</span>,<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vue.set()不允许添加一个响应式的数据到身上，<strong>只能给data里面的一个对象上加</strong>，不能给data上加。</p><p>Vue无法为<strong>数组</strong>提供相应更新，没有setter和getter。所以通过索引修改数组的值。只有通过数组的一些方法（push/pop…）才能更新数组。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>vue使用了<strong>数据代理</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm._data.student === <span class="built_in">Array</span>.prototype<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>这个是vue的push,包装了数组的push，添加了数据监听。</p><ol><li><p>vue会监视data中所有层次的数据。</p></li><li><p>如何监测对象中的数据？通过<strong>setter实现监视</strong>，且要在new Vue时就传入要监测的数据。</p><ul><li>对象中后追加的属性，Vue默认不做响应式处理</li><li>如需给后添加的属性做响应式，请使用如下API：<ul><li><code>Vue.set(target，propertyName/index，value)</code> </li><li><code>vm.$set(target，propertyName/index，value)</code></li></ul></li></ul></li><li><p>如何监测数组中的数据？通过<strong>包裹数组更新元素</strong>的方法实现，本质就是做了两件事：</p><ol><li>调用<strong>原生对应的方法</strong>对数组进行更新。</li><li><strong>重新解析模板</strong>，进而更新页面。</li></ol></li><li><p>在Vue修改数组中的某个元素一定要用如下方法：</p><ul><li>.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</li><li>Vue.set() 或 vm.$set()</li></ul></li></ol><blockquote><p>特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的<strong>根数据对象</strong> 添加属性！！！</p></blockquote><h3 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h3><ul><li><code>&lt;input type=&quot;text&quot;/&gt;</code>，则v-model收集的是value值，用户输入的就是value值。</li><li><code>&lt;input type=&quot;radio&quot;/&gt;</code>，则v-model收集的是value值，且要给<strong>标签配置value值</strong>。</li><li><code>&lt;input type=&quot;checkbox&quot;/&gt;</code><ul><li><strong>没有配置input的value属性</strong>，那么收集的就是<strong>checked</strong>（勾选 or 未勾选，是<strong>布尔值</strong>）</li><li>配置input的value属性:<ul><li>v-model的初始值是<strong>非数组</strong>，那么收集的就是<strong>checked</strong>（勾选 or 未勾选，是布尔值）</li><li>v-model的初始值是<strong>数组</strong>，那么收集的的就是<strong>value组成的数组</strong>。</li></ul></li></ul></li></ul><p>备注：v-model的三个修饰符：</p><ul><li><code>lazy</code>：失去焦点再收集数据</li><li><code>number</code>：输入字符串转为有效的数字</li><li><code>trim</code>：输入首尾空格过滤</li></ul><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>对要显示的数据进行特定格式化后再显示 ，并没有改变原本的数据, 是产生新的对应的数据.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入day.js</span></span><br><span class="line">Vue.filter(<span class="string">&#x27;mySlice&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.slice(<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">time</span>:<span class="number">1621561377603</span>, <span class="comment">//时间戳</span></span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&#x27;你好，尚硅谷&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">fmtTime</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dayjs(<span class="built_in">this</span>.time).format(<span class="string">&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">getFmtTime</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dayjs(<span class="built_in">this</span>.time).format(<span class="string">&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//局部过滤器</span></span><br><span class="line">    <span class="attr">filters</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">timeFormater</span>(<span class="params">value,str=<span class="string">&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;</span></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// console.log(&#x27;@&#x27;,value)</span></span><br><span class="line">            <span class="keyword">return</span> dayjs(value).format(str)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用：</p><ul><li>注册过滤器：<code>Vue.filter(name,callback)</code> 或 <code>new Vue&#123;filters:&#123;&#125;&#125;</code></li><li>使用过滤器：<code>&#123;&#123; xxx | 过滤器名&#125;&#125;</code>  或  <code>v-bind:属性 = &quot;xxx | 过滤器名&quot;</code></li></ul><blockquote><p>1.过滤器也可以接收<strong>额外参数</strong>、多个过滤器也可以串联<br>2.并没有改变原本的数据, 是产生新的对应的数据</p></blockquote><h2 id="内置指令与自定义指令"><a href="#内置指令与自定义指令" class="headerlink" title="内置指令与自定义指令"></a>内置指令与自定义指令</h2><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><table><thead><tr><th>指令</th><th>解释</th></tr></thead><tbody><tr><td>v-text</td><td>向其所在的节点中渲染文本内容。(一般都是差值语法)</td></tr><tr><td>v-html</td><td>更新元素的 innerHTML .v-html会替换掉节点中<strong>所有的内容</strong>，则不会。v-html可以识别html结构。<strong>注意</strong>：在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</td></tr><tr><td>v-if</td><td>如果为 true, 当前标签才会输出到页面</td></tr><tr><td>v-else</td><td>如果为 false, 当前标签才会输出到页面</td></tr><tr><td>v-show</td><td>通过控制 display 样式来控制显示/隐藏</td></tr><tr><td>v-for</td><td>遍历数组/对象</td></tr><tr><td>v-on</td><td>绑定事件监听, 一般简写为@</td></tr><tr><td>v-bind</td><td>绑定解析表达式, 可以省略 v-bind</td></tr><tr><td>v-model</td><td>双向数据绑定</td></tr><tr><td>v-cloak(无值)</td><td>Vue实例创建完毕并接管容器后，会删掉v-cloak属性。使用css配合v-cloak可以解决网速慢时页面展示出的问题。</td></tr><tr><td>v-once</td><td>v-once所在节点在初次动态渲染后，就视为<strong>静态内容</strong>了。以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</td></tr><tr><td>v-pre</td><td>跳过其所在节点的编译过程。可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</td></tr></tbody></table><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。</p><p>定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">        <span class="attr">n</span>:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">directives</span>:&#123;</span><br><span class="line">        <span class="comment">//big函数何时会被调用？1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析时。</span></span><br><span class="line">        <span class="comment">/* &#x27;big-number&#x27;(element,binding)&#123;</span></span><br><span class="line"><span class="comment">// console.log(&#x27;big&#x27;)</span></span><br><span class="line"><span class="comment">element.innerText = binding.value * 10</span></span><br><span class="line"><span class="comment">&#125;, */</span></span><br><span class="line">        <span class="function"><span class="title">big</span>(<span class="params">element,binding</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;big&#x27;</span>,<span class="built_in">this</span>) <span class="comment">//注意此处的this是window</span></span><br><span class="line">            <span class="comment">// console.log(&#x27;big&#x27;)</span></span><br><span class="line">            element.innerText = binding.value * <span class="number">10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fbind</span>:&#123;</span><br><span class="line">            <span class="comment">//指令与元素成功绑定时（一上来）</span></span><br><span class="line">            <span class="function"><span class="title">bind</span>(<span class="params">element,binding</span>)</span>&#123;</span><br><span class="line">                element.value = binding.value</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//指令所在元素被插入页面时</span></span><br><span class="line">            <span class="function"><span class="title">inserted</span>(<span class="params">element,binding</span>)</span>&#123;</span><br><span class="line">                element.focus()</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//指令所在的模板被重新解析时</span></span><br><span class="line">            <span class="function"><span class="title">update</span>(<span class="params">element,binding</span>)</span>&#123;</span><br><span class="line">                element.value = binding.value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>定义:</p><ul><li><p>局部指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    directives&#123;指令名:回调函数&#125;</span><br><span class="line">&#125;) </span><br><span class="line">    </span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    &#123;指令名:配置对象&#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>全局指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(指令名,配置对象) 或   Vue.directive(指令名,回调函数)</span><br></pre></td></tr></table></figure></li></ul><p>配置对象中常用的3个回调</p><ul><li>bind：指令与元素成功绑定时调用。</li><li>inserted：指令所在元素被插入页面时调用。</li><li>update：指令所在模板结构被重新解析时调用。</li></ul><blockquote><p>指令定义时不加v-，但使用时要加v-；指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。指令相关的this的都是windows,真实操作DOM的。</p></blockquote><h2 id="Vue实例生命周期-重要"><a href="#Vue实例生命周期-重要" class="headerlink" title="Vue实例生命周期(重要)"></a>Vue实例生命周期(重要)</h2><p>生命周期回调函数、生命周期函数、生命周期钩子。Vue在<strong>关键时刻</strong>帮我们调用的一些特殊名称的函数。生命周期函数的<strong>名字不可更改</strong>，但函数的具体内容是程序员根据需求编写的。生命周期函数中的<strong>this指向是vm 或 组件实例对象</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">opacity</span>:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted</span></span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>,<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.opacity -= <span class="number">0.01</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.opacity &lt;= <span class="number">0</span>) <span class="built_in">this</span>.opacity = <span class="number">1</span></span><br><span class="line">        &#125;,<span class="number">16</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>vue生命周期函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;h2&gt;当前的n值是：&#123;&#123;n&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&lt;button @click=&quot;add&quot;&gt;点我n+1&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">n</span>:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">            <span class="built_in">this</span>.n++</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">bye</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;bye&#x27;</span>)</span><br><span class="line">            <span class="built_in">this</span>.$destroy()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">n</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;n变了&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforeMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforeUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">updated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;updated&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;beforeDestroy&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;destroyed&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>生命周期的图示：</p><p><img src="/2021/08/15/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/vue/vue%E5%9F%BA%E7%A1%80/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="生命周期"></p><p>常用的生命周期钩子：</p><ul><li>mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</li><li>beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</li></ul><p>关于销毁Vue实例</p><ul><li>销毁后借助Vue开发者工具看不到任何信息。</li><li>销毁后<strong>自定义事件会失效</strong>，但<strong>原生DOM事件</strong>依然有效。</li><li>一般<strong>不会在beforeDestroy操作数据</strong>，因为即便操作数据，也<strong>不会再触发更新流程</strong>了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery</title>
      <link href="/2021/08/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JQuery/"/>
      <url>/2021/08/08/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/JQuery/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-认识jQuery"><a href="#第一章-认识jQuery" class="headerlink" title="第一章 认识jQuery"></a>第一章 认识jQuery</h2><h3 id="1-1-什么是jQuery"><a href="#1-1-什么是jQuery" class="headerlink" title="1.1 什么是jQuery"></a>1.1 什么是jQuery</h3><p>是一个组件库，简化JavaScript开发人员遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>轻量级</strong>。采用Packer压缩后只有不到30kb</li><li><strong>强大的选择器</strong>。使用CSS1到CSS3所有的选择器，以及jQueryz独创的高级选择器，还可以加入插件使其支持Xpath选择器，甚至自己的选择器。</li><li><strong>出色的DOM操作封装</strong>。</li><li><strong>可靠的事件处理机制</strong>。预留退路、循序渐进、非侵入式**</li><li><strong>完善的Ajax</strong>。专心处理业务逻辑，无需关系复杂的浏览器兼容性和XMLHttpRequest对象创建和使用。</li><li><strong>不污染的顶级遍历</strong>。只建立一个名为jQuery的对象。不会污染其他对象。可以与其他JavaScript库并存。</li><li><strong>出色的浏览器兼容</strong>。</li><li><strong>链式操作方式</strong>。发生在同一个jQuery对象上的一组动作</li><li><strong>隐式迭代</strong>。当jQuery找到全部元素时，然后隐藏它们，无需循环遍历每一个返回的元素。</li><li><strong>行为层和结构层的分离</strong>。可以直接使用jQuery选中元素，直接添加事件。</li><li><strong>插件支持</strong>。</li><li><strong>完善文档</strong>、</li><li><strong>开源</strong></li></ol><h4 id="库说明"><a href="#库说明" class="headerlink" title="库说明"></a>库说明</h4><table><thead><tr><th>名称</th><th>大学</th><th>说明</th></tr></thead><tbody><tr><td>jquery-1.3.1.js</td><td>113KB</td><td>完整无压缩版本，用于测试、开发、学习</td></tr><tr><td>jquery-1.3.1.min.js</td><td>54KB/18KB</td><td>经过JSMin压缩/服务开启Gzip压缩</td></tr></tbody></table><h5 id="引入"><a href="#引入" class="headerlink" title="引入:"></a>引入:</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jquery-1.3.1.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>$是一个简单的写法</strong></p><p> $.ajax === jQuery.ajax</p><h5 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h5><table><thead><tr><th></th><th>windows.onload</th><th>$(document).ready()</th></tr></thead><tbody><tr><td>执行时机</td><td>必须等网页所有资源加载完毕（包括图片）才能执行</td><td>网页中所有DOM结构绘制完就可以执行。</td></tr><tr><td>编写个数</td><td>不能同时编写多个</td><td>能同时编写多个</td></tr><tr><td>简化写法</td><td>无</td><td>$(funtion(){});</td></tr></tbody></table><h3 id="1-2-jQuery对象和Dom对象"><a href="#1-2-jQuery对象和Dom对象" class="headerlink" title="1.2 jQuery对象和Dom对象"></a>1.2 jQuery对象和Dom对象</h3><ol><li>DOM（文档操作模型）对象，每一份DOM都可以表示一棵树。可以通过JavaScript来获取元素节点。</li><li>jquery对象，是通过jQuery包装DOM对象后产出的对象。是jQuery独有。只有jQuery对象可以使用jQuery的方法。jQuery对象无法使用DOM对象的方法</li></ol><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><h5 id="1-jquery对象转化dom对象-两种方法-index-和get-index"><a href="#1-jquery对象转化dom对象-两种方法-index-和get-index" class="headerlink" title="1.jquery对象转化dom对象,两种方法[index]和get(index)"></a>1.jquery对象转化dom对象,两种方法[index]和get(index)</h5><p>(1) jquery是一个数组对象，可以通过[index]得到相应的DOM对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $cr = $(<span class="string">&quot;cr&quot;</span>);<span class="comment">//jquery对象</span></span><br><span class="line"><span class="keyword">var</span> cr = $cr[<span class="number">0</span>];<span class="comment">//DOM对象</span></span><br></pre></td></tr></table></figure><p>(2) jquery地下本身提供的，get(index)得到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $cr = $(<span class="string">&quot;cr&quot;</span>);<span class="comment">//jquery对象</span></span><br><span class="line"><span class="keyword">var</span> cr = $cr.get(<span class="number">0</span>);<span class="comment">//DOM对象</span></span><br></pre></td></tr></table></figure><h5 id="2-dom对象转化-jquery对象"><a href="#2-dom对象转化-jquery对象" class="headerlink" title="2.dom对象转化.jquery对象"></a>2.dom对象转化.jquery对象</h5><p>只需要用$()把DOM对象包装就可以得到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cr = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;cr&#x27;</span>);<span class="comment">//DOM对象</span></span><br><span class="line"><span class="keyword">var</span> $cr = $(cr);<span class="comment">//jquery对象</span></span><br></pre></td></tr></table></figure><h3 id="1-3-解决库冲突"><a href="#1-3-解决库冲突" class="headerlink" title="1.3 解决库冲突"></a>1.3 解决库冲突</h3><p>jquery的所有插件都被限制在它的命名空间中。不会引起冲突</p><ol><li><p>jquery在其他库之后引入，使用函数将控制权移交给别的库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jQuery.noConflict();</span><br><span class="line">jQuery(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此外，如果想确保不会产生冲突，但又想定义一个快捷方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $j = jQuery.noConflict();<span class="comment">//自定义一个快捷方式</span></span><br><span class="line">$j(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//使用jquery，利用自定义快捷方式</span></span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果在其他库之前引入，就不需要了。</p></li></ol><h2 id="第二章-jQuery选择器"><a href="#第二章-jQuery选择器" class="headerlink" title="第二章 jQuery选择器"></a>第二章 jQuery选择器</h2><h3 id="2-1-jQuery选择器是什么"><a href="#2-1-jQuery选择器是什么" class="headerlink" title="2.1 jQuery选择器是什么"></a>2.1 jQuery选择器是什么</h3><h4 id="1-css选择器"><a href="#1-css选择器" class="headerlink" title="1. css选择器"></a>1. css选择器</h4><p>将网页结构和表现样式完全分离。常用的css选择器：</p><table><thead><tr><th>选择器</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>标签选择器</td><td>E { css }</td><td>选择文档元素</td></tr><tr><td>ID选择器</td><td>#ID { css }</td><td>以文档元素唯一标识符选择</td></tr><tr><td>类选择器</td><td>E.class{ css }</td><td>以class选择</td></tr><tr><td>群组选择器</td><td>E1,E2,E3 { css }</td><td>多个同时应用相同样式</td></tr><tr><td>后代选择器</td><td>E F{ css }</td><td>元素E的任意后代F</td></tr><tr><td>通配选择器</td><td>* { css }</td><td>任意对象</td></tr></tbody></table><h4 id="2-jquery选择器"><a href="#2-jquery选择器" class="headerlink" title="2.  jquery选择器"></a>2.  jquery选择器</h4><p>​    <strong>完全继承CSS风格</strong>。涉及操作css样式非常强大，拥有浏览器兼容性。</p><h3 id="2-2-选择器的优势"><a href="#2-2-选择器的优势" class="headerlink" title="2.2 选择器的优势"></a>2.2 选择器的优势</h3><ol><li><p>简洁写法。</p></li><li><p>支持css1到css3的全部。</p></li><li><p>完善的处理机制。可以避免很多错误。例如：<strong>如果使用dom选择一个没有的元素时会报错。使用jquery就不会</strong>。有了预防措施，即使删除某个网页上使用过的元素，也不用担心。</p><p>但是需要注意：<strong>$()获取的永远是对象</strong>。即使没有，判断这个元素是否存在是就要使用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据获取元素判断</span></span><br><span class="line"><span class="keyword">if</span> ( $(<span class="string">&#x27;#tt&#x27;</span>).length &gt;<span class="number">0</span> )&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换为DOM</span></span><br><span class="line"><span class="keyword">if</span> ( $(<span class="string">&#x27;#tt&#x27;</span>)[<span class="number">0</span>] )&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-jQuery选择器"><a href="#2-3-jQuery选择器" class="headerlink" title="2.3 jQuery选择器"></a>2.3 jQuery选择器</h3><p>基本选择器、层次选择器、过滤选择器、表单选择器。</p><h4 id="1-基本选择器"><a href="#1-基本选择器" class="headerlink" title="1.基本选择器"></a>1.基本选择器</h4><p>通过元素的id、class、标签名来查找Dom</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>#id</td><td>根据id匹配</td><td>单个</td></tr><tr><td>.class</td><td>类名</td><td>集合</td></tr><tr><td>element</td><td>元素名</td><td>集合</td></tr><tr><td>*</td><td>所有</td><td>集合</td></tr><tr><td>selector1，…</td><td>将每个选择器匹配到的所有合并一起返回</td><td>集合</td></tr></tbody></table><h4 id="2-层次选择器"><a href="#2-层次选择器" class="headerlink" title="2.层次选择器"></a>2.层次选择器</h4><p>通过DOM元素之间层次关系来获得特定元素，例如后代、子元素、相邻元素、兄弟元素。</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>$(“ancestor descendant”)</td><td>获取ancestor元素的所有descendant<strong>后代元素</strong></td><td>集合</td></tr><tr><td>$(“parent &gt; child”)</td><td>选取parent元素下所有<strong>子元素</strong>，与上面有区别，上面是后代元素，这个只有子元素</td><td>集合</td></tr><tr><td>$(‘perv + next’)</td><td>选取<strong>紧接</strong>在prev后面的next元素</td><td>集合</td></tr><tr><td>$(‘perv ~ sibling’)</td><td>选择prev元素<strong>之后所有</strong>的sibling元素</td><td>集合</td></tr></tbody></table><p>前2个较为常用。之后2个有代替</p><table><thead><tr><th>选择器</th><th>方法</th></tr></thead><tbody><tr><td>$(‘.one + div’)</td><td>$(‘.one’).next(‘div’)</td></tr><tr><td>$(‘#prev ~ div’)</td><td>$(‘.one’).nextAll(‘div’)</td></tr></tbody></table><p>$(‘#prev ~ div’)只能选择“#prev“之后的同辈<code>&lt;div&gt;</code>,但是<code>siblings()</code>方法与位置无关，只要是同辈就可以。</p><h4 id="3-过滤选择器"><a href="#3-过滤选择器" class="headerlink" title="3.过滤选择器"></a>3.过滤选择器</h4><p>通过特定的过滤规则筛选出所需DOM，选择器以冒号开头</p><h5 id="基本过滤选择器"><a href="#基本过滤选择器" class="headerlink" title="基本过滤选择器"></a>基本过滤选择器</h5><p>注意这里<strong>不加空格</strong> <code>element:first</code></p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>:first</td><td>选取第一个元素</td><td>单个</td></tr><tr><td>:last</td><td>最后一个元素</td><td>单个</td></tr><tr><td>:not(selector)</td><td>去除给定选择器匹配的</td><td>集合</td></tr><tr><td>:even</td><td>选取索引是偶数的、从0开始</td><td>集合</td></tr><tr><td>:odd</td><td>选取索引是奇数的、从0开始</td><td>集合</td></tr><tr><td>eq(index)</td><td>选取索引等于index的元素、从0开始</td><td>单个</td></tr><tr><td>gt(index)</td><td>选取索引大于index的元素、从0开始</td><td>集合</td></tr><tr><td>lt(index)</td><td>选取索引小于index的元素、从0开始</td><td>集合</td></tr><tr><td>:header</td><td>选择所以标题元素,h1、h2等</td><td>集合</td></tr><tr><td>:animated</td><td>选取当前正在执行动画的所有元素</td><td>集合</td></tr></tbody></table><h5 id="内容过滤选择器"><a href="#内容过滤选择器" class="headerlink" title="内容过滤选择器"></a>内容过滤选择器</h5><p>体现在所包含子元素或文本内容上,注意这里<strong>不加空格</strong> </p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>:contains(text)</td><td>选择文本内容含有“text”</td><td>集合</td></tr><tr><td>:empty</td><td>选择不包含子元素或文本内容为空</td><td>集合</td></tr><tr><td>:has(selector)</td><td>含有选择器所匹配的元素的元素</td><td>集合</td></tr><tr><td>:parent</td><td>选择含有子元素或文本的元素</td><td>集合</td></tr></tbody></table><h5 id="可见性过滤选择器"><a href="#可见性过滤选择器" class="headerlink" title="可见性过滤选择器"></a>可见性过滤选择器</h5><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>:hidden</td><td>选择所以不可见的元素</td><td>集合</td></tr><tr><td>:visible</td><td>选择所以可见的元素</td><td>集合</td></tr></tbody></table><p><code>:hidden</code>不仅仅包含样式属性<code>display</code>为“none”的元素，也包含文本隐藏域<code>&lt;input type=&quot;hidden&quot;/&gt;</code>和<code>visible:hidden</code></p><h5 id="属性选择过滤器"><a href="#属性选择过滤器" class="headerlink" title="属性选择过滤器"></a>属性选择过滤器</h5><p>通过元素的属性来获取相应元素。</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>[attribute]</td><td>选择拥有属性的</td><td>集合</td></tr><tr><td>[attribute=value]</td><td>选择属性值为value</td><td>集合</td></tr><tr><td>[attribute!=value]</td><td>选择属性值不等于value的元素</td><td>集合</td></tr><tr><td>[attribute^=value]</td><td>选择属性值以value开头的元素</td><td>集合</td></tr><tr><td>[attribute$=value]</td><td>选择属性值以value结尾的元素</td><td>集合</td></tr><tr><td>[attribute*=value]</td><td>选择属性值含有value结尾的元素</td><td>集合</td></tr><tr><td>[selector1] [selector1]</td><td>属性选择器合并并成一个复合选择器，满足多个条件</td><td>集合</td></tr></tbody></table><h5 id="子元素过滤选择器"><a href="#子元素过滤选择器" class="headerlink" title="子元素过滤选择器"></a>子元素过滤选择器</h5><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>:nth-child(index/even/odd/equation)</td><td>选取父元素下第index个或奇偶（从1开始）</td><td>集合</td></tr><tr><td>:first-child</td><td>选取父元素第1个子元素</td><td>集合</td></tr><tr><td>:last-child</td><td>选取父元素最后1个子元素</td><td>集合</td></tr><tr><td>:only-child</td><td>选择某个元素是它父元素中<strong>唯一的子元素</strong>，如果还有其他不匹配</td><td>集合</td></tr></tbody></table><p><code>:nth-child()</code>是很常用的子元素选择器，详细功能如下：</p><ol><li><code>:nth-child(even)</code>选取父元素下的索引值为偶数的。</li><li><code>:nth-child(odd)</code>选取父元素下的索引值为奇数的。</li><li><code>:nth-child(2)</code>选取父元素下的索引值为2的</li><li><code>:nth-child(3n)</code>选取父元素下的索引值为3的倍数的。（n从0开始）</li><li><code>:nth-child(3n)</code>选取父元素下的索引值为3n+1的。（n从0开始）</li></ol><blockquote><p>注意： <code>eq(index)</code>只匹配一个元素，而<code>:nth-child</code> 将每一个复合条件的父元素匹配子元素。同时应该注意<code>nth-child(index)</code>的index从1开始，而eq(index)从0开始。</p></blockquote><h5 id="表单对象属性过滤选择器"><a href="#表单对象属性过滤选择器" class="headerlink" title="表单对象属性过滤选择器"></a>表单对象属性过滤选择器</h5><p>对表单进行过滤，例如选择被选中下拉框</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>:enable</td><td>选择可用的元素</td><td>集合</td></tr><tr><td>:disabled</td><td>选择不可用的</td><td>集合</td></tr><tr><td>:checked</td><td>选取所有被选中的（单选框、复选框）</td><td>集合</td></tr><tr><td>:selected</td><td>选择所有被选中的选项元素（下拉列表）</td><td>集合</td></tr></tbody></table><h4 id="4-表单选择器"><a href="#4-表单选择器" class="headerlink" title="4.表单选择器"></a>4.表单选择器</h4><p>方便用户灵活操作表单</p><table><thead><tr><th>选择器</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>:input</td><td><code>&lt;input&gt;&lt;textarea&gt;&lt;select&gt;&lt;button&gt;</code></td><td>集合</td></tr><tr><td>:text</td><td>文本</td><td>集合</td></tr><tr><td>:password</td><td>密码</td><td>集合</td></tr><tr><td>:radio</td><td>单选</td><td>集合</td></tr><tr><td>:checkbox</td><td>多选</td><td>集合</td></tr><tr><td>:submit</td><td>提交</td><td>集合</td></tr><tr><td>:image</td><td>图形</td><td>集合</td></tr><tr><td>:reset</td><td>重置</td><td>集合</td></tr><tr><td>:button</td><td>按钮</td><td>集合</td></tr><tr><td>:file</td><td>选择所以上传域</td><td>集合</td></tr><tr><td>:hidden</td><td>选取不可见</td><td>集合</td></tr></tbody></table><h3 id="2-4-注意事项"><a href="#2-4-注意事项" class="headerlink" title="2.4 注意事项"></a>2.4 注意事项</h3><h4 id="1-带有特殊符号"><a href="#1-带有特殊符号" class="headerlink" title="1. 带有特殊符号"></a>1. 带有特殊符号</h4><h5 id="选择器中包含“-”、”-”、“（”、“-”等"><a href="#选择器中包含“-”、”-”、“（”、“-”等" class="headerlink" title="选择器中包含“.”、”#”、“（”、“]”等"></a>选择器中包含“.”、”#”、“（”、“]”等</h5><p>需要通过\来进行转移   <code>\\#</code></p><h5 id="属性选择器引号问题"><a href="#属性选择器引号问题" class="headerlink" title="属性选择器引号问题"></a>属性选择器引号问题</h5><p>@因为版本问题不能加入</p><h4 id="2-选择器中含有空格"><a href="#2-选择器中含有空格" class="headerlink" title="2.选择器中含有空格"></a>2.选择器中含有空格</h4><p>多一个空格会有不同效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $t_a = $(<span class="string">&#x27;.text&#x27;</span> :hidden);<span class="comment">//带空格</span></span><br><span class="line"><span class="comment">//选取class为text中的隐藏元素</span></span><br><span class="line"><span class="keyword">var</span> $t_b = $(<span class="string">&#x27;.text&#x27;</span>:hidden);<span class="comment">//不带</span></span><br><span class="line"><span class="comment">//选取隐藏的class为&quot;text&quot;的元素</span></span><br></pre></td></tr></table></figure><h3 id="2-5-其他选择器"><a href="#2-5-其他选择器" class="headerlink" title="2.5 其他选择器"></a>2.5 其他选择器</h3><h4 id="1-jQuery提供的"><a href="#1-jQuery提供的" class="headerlink" title="1.jQuery提供的"></a>1.jQuery提供的</h4><h5 id="MoreSelectors-for-jquery"><a href="#MoreSelectors-for-jquery" class="headerlink" title="MoreSelectors for jquery"></a>MoreSelectors for jquery</h5><p>增加更多的选择器</p><h5 id="Basic-XPath"><a href="#Basic-XPath" class="headerlink" title="Basic XPath"></a>Basic XPath</h5><p>可以使用最基本的XPath</p><h4 id="2-其他使用css的方法"><a href="#2-其他使用css的方法" class="headerlink" title="2.其他使用css的方法"></a>2.其他使用css的方法</h4><ul><li>document.getElementsBySelector() 通过选择器获取文档</li><li>cssQuery()</li><li>querySelectorAll()</li></ul><h2 id="第三章、jQuery中DOM的操作"><a href="#第三章、jQuery中DOM的操作" class="headerlink" title="第三章、jQuery中DOM的操作"></a>第三章、jQuery中DOM的操作</h2><p>DOM是一种与<strong>浏览器、平台、语言</strong>无关的接口，使用该接口可以轻松的访问页面中所有的标准组件。</p><h3 id="3-1-DOM操作的分类"><a href="#3-1-DOM操作的分类" class="headerlink" title="3.1 DOM操作的分类"></a>3.1 DOM操作的分类</h3><h4 id="1-DOM-Core"><a href="#1-DOM-Core" class="headerlink" title="1. DOM Core"></a>1. DOM Core</h4><p>任何支持DOM的程序都能使用，并非仅限于处理网页，处理任何一种标记语言写的文档，例如<code>XML</code>。</p><p><code>JavaScript</code>中的<code>getElementById()</code>、<code>getElementByTagName()</code>、<code>getAttribute()</code>等等都是<code>DOM Core</code>的方法。</p><h4 id="2-HTML-DOM"><a href="#2-HTML-DOM" class="headerlink" title="2. HTML_DOM"></a>2. HTML_DOM</h4><p>使用<code>JavaScript</code>和<code>DOM</code>为<code>HTML</code>编写脚本，有许多专属<code>HTML-DOM</code>的属性。例如:<code>document.forms</code>提供一个<code>forms</code>对象。只能用来处理Web文档。</p><h4 id="3-CSS-DOM"><a href="#3-CSS-DOM" class="headerlink" title="3. CSS_DOM"></a>3. CSS_DOM</h4><p>针对<code>CSS</code>的操作，主要用于获取和设置style的各种属性。例如：<code>element.style.color=&quot;red&quot;</code>;</p><h3 id="3-2-jQuery中的Dom操作"><a href="#3-2-jQuery中的Dom操作" class="headerlink" title="3.2 jQuery中的Dom操作"></a>3.2 jQuery中的Dom操作</h3><p>每一张网页都能用<code>DOM</code>表示出来，每一份<code>DOM</code>都可以看做一颗<code>DOM</code>树。</p><h4 id="1-查找节点"><a href="#1-查找节点" class="headerlink" title="1. 查找节点"></a>1. 查找节点</h4><h5 id="查找元素节点"><a href="#查找元素节点" class="headerlink" title="查找元素节点"></a>查找元素节点</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $li = $(<span class="string">&#x27;ul li:eq(1)&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> $li_txt = $li.text();<span class="comment">//获取文本属性</span></span><br></pre></td></tr></table></figure><h5 id="查找属性节点"><a href="#查找属性节点" class="headerlink" title="查找属性节点"></a>查找属性节点</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $para = $(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> $p_txt = $para.attr(<span class="string">&quot;title&quot;</span>);<span class="comment">//获取p节点属性title</span></span><br></pre></td></tr></table></figure><h4 id="2-创建节点"><a href="#2-创建节点" class="headerlink" title="2.创建节点"></a>2.创建节点</h4><h5 id="创建元素节点"><a href="#创建元素节点" class="headerlink" title="创建元素节点"></a>创建元素节点</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(html);<span class="comment">//根据传入的HTML创建一个DOM对象</span></span><br></pre></td></tr></table></figure><p>创建<code>&lt;li&gt;</code>节点作为ul的子节点加入DOM中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $li = $(<span class="string">&#x27;&lt;li&gt;&lt;/li&gt;&#x27;</span>);<span class="comment">//创建节点</span></span><br><span class="line">$(<span class="string">&#x27;ul&#x27;</span>).append($li);<span class="comment">//添加 可以采用链式写法添加多个</span></span><br></pre></td></tr></table></figure><h5 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $li = $(<span class="string">&#x27;&lt;li&gt;xxx&lt;/li&gt;&#x27;</span>);<span class="comment">//创建节点</span></span><br><span class="line">$(<span class="string">&#x27;ul&#x27;</span>).append($li);<span class="comment">//添加 可以采用链式写法添加多个</span></span><br></pre></td></tr></table></figure><p>无论html多复杂都使用相同的方式来创建。</p><h5 id="创建属性节点"><a href="#创建属性节点" class="headerlink" title="创建属性节点"></a>创建属性节点</h5><p>创建节点时一起创建：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $li = $(<span class="string">&#x27;&lt;li title=&quot;x&quot;&gt;xxx&lt;/li&gt;&#x27;</span>);<span class="comment">//创建节点</span></span><br><span class="line">$(<span class="string">&#x27;ul&#x27;</span>).append($li);<span class="comment">//添加 可以采用链式写法添加多个</span></span><br></pre></td></tr></table></figure><h4 id="3-插入节点"><a href="#3-插入节点" class="headerlink" title="3.插入节点"></a>3.插入节点</h4><p>动态创建HTML元素没有用，需要将创建元素加入文档。下面是插入的方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>append()</td><td>向每个匹配的元素追加内容,把B添加到A中</td></tr><tr><td>appendTo()</td><td>将所有匹配的匀速追加到指定元素中，把A添加到B中</td></tr><tr><td>prepend()</td><td>向每个匹配的元素内部前置内容</td></tr><tr><td>prependTo()</td><td>与上面颠倒</td></tr><tr><td>after()</td><td>在每个匹配的元素之后加入内容</td></tr><tr><td>insertAfter()</td><td>将所有匹配的元素插入到指定元素后面</td></tr><tr><td>before()</td><td>在每个匹配的元素之前插入内容</td></tr><tr><td>insetBefore()</td><td>将每个匹配的元素插入到指定元素前面</td></tr></tbody></table><p>不仅仅可以将新创建的元素插入文档，也可以对原有的DOM元素进行移动。</p><h4 id="4-删除节点"><a href="#4-删除节点" class="headerlink" title="4.删除节点"></a>4.删除节点</h4><h5 id="remove"><a href="#remove" class="headerlink" title="remove()"></a><code>remove()</code></h5><p>该方法会将所有后代节点同时删除。方法的返回值是指向被伤处元素的引用，可以在之后再使用这些元素。</p><p><code>remove()</code>中也可以选择性的删除元素。</p><h5 id="empty"><a href="#empty" class="headerlink" title="empty()"></a><code>empty()</code></h5><p>这个方法是<strong>清空节点</strong>，将元素所有后代节点清空。</p><h4 id="5-复制节点"><a href="#5-复制节点" class="headerlink" title="5.复制节点"></a>5.复制节点</h4><p>例如购物网站中，用户不仅仅可以通过单击商品下方选择购买相应产品，也可以通过鼠标拖到来放入购物车，这就是复制节点，将用户选择的商品所处的节点元素复制一份，并跟随鼠标一起移动。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul il&#x27;</span>).click(<span class="function"><span class="title">funciton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="built_in">this</span>).clone().appendTo(<span class="string">&#x27;ul&#x27;</span>);<span class="comment">//复制当今节点并添加到ul中</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>被复制的元素不具有任何行为。如果需要新元素也具有复制功能，可加入参数<code>true</code>,<code>clone(true)</code></p><h4 id="6-替换节点"><a href="#6-替换节点" class="headerlink" title="6.替换节点"></a>6.替换节点</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>replaceWith()</td><td>将所有匹配的元素都替换成指定的HTML或DOM元素</td></tr><tr><td>replaceAll()</td><td>将匹配元素放入指定的HTML</td></tr></tbody></table><p>如果在替换之前，已经为元素绑定事件，替换后原先绑定的事件将会与被替换的元素一起消失。</p><h4 id="7-包裹节点"><a href="#7-包裹节点" class="headerlink" title="7.包裹节点"></a>7.包裹节点</h4><p>将某个节点用其他节点包裹起来</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>wrap()</td><td>将选择的节点用其他的标记包裹</td></tr><tr><td>wrapAll()</td><td>将所有匹配的元素用<strong>一个元素</strong>包裹起来，不同于wrap()，wrap()是将所有元素单独包装</td></tr><tr><td>wrapInner()</td><td>将每一个匹配的元素<strong>子内容</strong>用其他结构化标记包裹</td></tr></tbody></table><h4 id="8-属性操作"><a href="#8-属性操作" class="headerlink" title="8.属性操作"></a>8.属性操作</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>attr()</td><td>获取和设置属性，传递一个参数，根据参数获取，传递2个参数设置属性，也可以用object对象来设置属性</td></tr><tr><td>removeAttr()</td><td>删除属性</td></tr></tbody></table><p>jQuery中很多多少用一个函数来实现获取和设置。例如<code>html()</code>、<code>text()</code> 、<code>height()</code> 、<code>widht()</code>、<code>val()</code>、css()。</p><h4 id="9-样式操作"><a href="#9-样式操作" class="headerlink" title="9.样式操作"></a>9.样式操作</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>attr()</td><td>设置样式</td></tr><tr><td>addClass()</td><td>给元素追加类</td></tr><tr><td>removeClass()</td><td>移除样式</td></tr><tr><td>toggle(function(){}, function(){})</td><td>切换样式 ，通过2个函数重复切换</td></tr><tr><td>toggleClass()</td><td>控制样式重复切换</td></tr><tr><td>hasClass()</td><td>判断是否含有某个元素，这个方法是为了可读性，<strong>内部使用了is()判断</strong></td></tr></tbody></table><h4 id="10-设置和获取HTML、文本和值"><a href="#10-设置和获取HTML、文本和值" class="headerlink" title="10.设置和获取HTML、文本和值"></a>10.设置和获取HTML、文本和值</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>html()</td><td>类似于<code>innerHTML</code>设置某个元素中HTML值，不穿参数，就获取值，也可以用于XHTML，XML。</td></tr><tr><td>text()</td><td>类似于<code>innerText</code>设置文本内容，不传参数，就获取值。对XHTML和XML都有效。</td></tr><tr><td>val()</td><td>类似于<code>value</code>属性，可以设置和获取元素的值，无论是文本框还是下拉框，如果是多选就放回一个值的数组。defaultValue属性可以获得默认属性，同时可以将下拉框和多选框和单选框的值被选中。<strong>是从最后一个往前读取，如果选项的value或者text有一项就会被选中</strong>。</td></tr></tbody></table><h4 id="11-遍历节点"><a href="#11-遍历节点" class="headerlink" title="11.遍历节点"></a>11.遍历节点</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>children()</td><td>取得匹配元素的子元素结合。</td></tr><tr><td>next()</td><td>取得匹配元素之后的同辈元素。</td></tr><tr><td>prev()</td><td>取得匹配元素前面的同辈元素。</td></tr><tr><td>siblings()</td><td>取得元素前后的同辈元素。</td></tr><tr><td>closest()</td><td>取得最近的匹配元素，首先检查当前元素是否匹配，如果匹配直接返回本身，如果不匹配向上查找，如果没有找到就返回一个空的jQuery对象</td></tr></tbody></table><p>除此之外还有<code>find()</code>、<code>filter()</code>、<code>nextAll()</code>、<code>prevAll()</code>、<code>parent()</code>、<code>parents()</code></p><h4 id="12-CSS-DOM操作"><a href="#12-CSS-DOM操作" class="headerlink" title="12.CSS-DOM操作"></a>12.CSS-DOM操作</h4><p>读取和设置style的各种属性</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>css()</td><td>获取属性，只有一个值；设置属性，通过两个参数，或者对象的方式。如果是数字，自动转换为像素。</td></tr><tr><td>height()</td><td>获取或设置高度。</td></tr><tr><td>offset()</td><td>获得当前元素在视窗的偏移，<strong>返回的结果包括top和left两个属性</strong></td></tr><tr><td>position()</td><td>获取元素相对最近一个position样式属性设置为relative或absolute的祖父节点的相对偏移，包括top和left。</td></tr><tr><td>scrollTop()</td><td>获取元素滚动条距离顶端的距离。可以设定参数让元素滚动到指定位置。</td></tr><tr><td>scrollLeft()</td><td>左端元素滚动条距离顶端的距离。可以设定参数让元素滚动到指定位置。</td></tr></tbody></table><h2 id="第四章、jQuery中的事件和动画"><a href="#第四章、jQuery中的事件和动画" class="headerlink" title="第四章、jQuery中的事件和动画"></a>第四章、jQuery中的事件和动画</h2><p>当文档或某些元素发生变化或操作时，浏览器会生成一个事件。</p><h3 id="4-1-jQuery中的事件"><a href="#4-1-jQuery中的事件" class="headerlink" title="4.1 jQuery中的事件"></a>4.1 jQuery中的事件</h3><h4 id="加载DOM"><a href="#加载DOM" class="headerlink" title="加载DOM"></a>加载DOM</h4><p>以浏览器加载文档为例，文档加载完毕，浏览器会通过JavaScript为DOM添加事件，通常用<code>window.onload</code>,而在jQuery中使用<code>$(document).ready()</code>，可以提高web查询的响应速度。</p><p>2这不同之处查看第一章</p><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>文档装载完毕后，为元素绑定事件，使用<code>bind()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bing( type [, data] , fn);</span><br></pre></td></tr></table></figure><p>第一个参数为事件类型，包括blur、focus、load、resize、scroll、unload、click、dblclick、mousedown、mouseup、mousemove、mouseover、mouseout、mouseenter 、mouseleave、change、select、submit、keydown、keypress、keyup和 error等，当然也可以是自定义名称。</p><p>第二个参数是可选，作为<code>event.data</code>属性传给事件对象。</p><p>第三个参数是处理函数。</p><p>jQuery的事件绑定比JavaScript少了“on”</p><p>在回调函数中可以使用<code>$(this)</code>将dom对象转换为jQuery对象</p><h4 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h4><p>有2个合成事件。</p><h5 id="hover-fun1-fun2"><a href="#hover-fun1-fun2" class="headerlink" title="hover(fun1, fun2)"></a>hover(fun1, fun2)</h5><p>模拟鼠标光标悬停事件。当光标移到元素上时，会触发指定的第一哥函数；当光标移除这个元素时，会触发第二个函数。</p><blockquote><p>（1）css中有伪类选择符，例如”:hover”,当用户悬停在元素上时，会改变元素的外观。</p><p>（2）hover()方法是代替<code>bind(&quot;mouseenter&quot;)</code>和<code>bind(&quot;mouseleave&quot;)</code>的，而不是bind(“mouseover”)和<code>bind(&quot;mouseout&quot;)</code>，因此需要触发第2 个函数时，需要用<code>trigger(&quot;mouseleave&quot;)</code>触发，而不是<code>trigger(&quot;mouseout&quot;)</code>。</p></blockquote><h5 id="toggle-fn1-…-fnN"><a href="#toggle-fn1-…-fnN" class="headerlink" title="toggle(fn1, …, fnN)"></a>toggle(fn1, …, fnN)</h5><p>用于模拟鼠标连续点击事件，第一次点击触发第一个，第二次点击触发第二个，直到最后一个。随后的点击都是对这几个事件轮番调用。</p><p><code>toggle()</code>方法还可以<strong>切换元素的可见状态</strong>。</p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>页面上可以有多个事件，也可以多个元素响应同一个事件。如果网页上有2个元素，一个元素嵌套另一个元素，同时绑定click事件，内部的点击事件也会触发外部的点击事件。事件会从内而外冒泡。</p><h5 id="引发的问题"><a href="#引发的问题" class="headerlink" title="引发的问题"></a>引发的问题</h5><p>使用事件对象，需要内部的click事件需要为函数加一个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;element&#x27;</span>).bind(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当点击元素时，事件对象就被创建了。这个事件对象只有事件处理函数才能访问，执行完毕后，事件对象就被销毁。</p><p>可以<strong>停止事件冒泡</strong>在阻止其他对象的事件处理函数执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.stopPropagation()<span class="comment">//阻止事件冒泡</span></span><br></pre></td></tr></table></figure><p>可以阻止默认的行为。例如当点击超链接后会发生跳转、点击提交按钮表单会提交。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">event.preventDefault()<span class="comment">//阻止元素的默认行为</span></span><br></pre></td></tr></table></figure><p>如果想同时对事件对象停止冒泡和默认行为，可以<strong>在事件处理函数中返回false</strong>,这是这2中方法的一种简写模式。</p><p>jQuery<strong>不支持事件捕获</strong>。</p><h4 id="事件对象的属性"><a href="#事件对象的属性" class="headerlink" title="事件对象的属性"></a>事件对象的属性</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>type()</td><td>获取类型的类型，click…</td></tr><tr><td>preventDefault()</td><td>阻止默认的事件行为</td></tr><tr><td>stopPropagation()</td><td>阻止事件的冒泡</td></tr><tr><td>target()</td><td>获取触发事件的元素</td></tr><tr><td>pageX()/pageY()</td><td>获取光标相对于页面的x,y坐标</td></tr><tr><td>which()</td><td>鼠标点击事件中获取鼠标的左中右键1、2、3</td></tr><tr><td>metaKey()</td><td>ctrl按键</td></tr><tr><td>originalEvent()</td><td>指向原始的事件对象</td></tr></tbody></table><h4 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unbind([type][,data])</span><br></pre></td></tr></table></figure><p>第一个是事件类型，第二个是将要移除的函数。</p><p>只触发一次随后就立即解除绑定的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one(type,[data],fn)</span><br></pre></td></tr></table></figure><h4 id="模拟操作"><a href="#模拟操作" class="headerlink" title="模拟操作"></a>模拟操作</h4><p>通过模拟用户操作来到达点击的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#btn&#x27;</span>).trigger(<span class="string">&#x27;click&#x27;</span>);</span><br></pre></td></tr></table></figure><p>触发自定义事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#btn&#x27;</span>).bind(<span class="string">&#x27;myClick&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">&#x27;#btn&#x27;</span>).trigger(<span class="string">&#x27;myClick&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="4-2-jQuery中的动画"><a href="#4-2-jQuery中的动画" class="headerlink" title="4.2 jQuery中的动画"></a>4.2 jQuery中的动画</h3><h4 id="show-和hide"><a href="#show-和hide" class="headerlink" title="show()和hide()"></a>show()和hide()</h4><p>修改display为none,<code>hide()</code>将内容的属性值设置为none,会记住之前的display属性值，当调用show时，会根据之前记住的方法来显示元素。</p><p>可以传递参数时间来控制隐藏和显示的速度。</p><h4 id="fadeIn-和fadeOut"><a href="#fadeIn-和fadeOut" class="headerlink" title="fadeIn()和fadeOut()"></a>fadeIn()和fadeOut()</h4><p>只改变元素的不透明度。</p><h4 id="slideUp-和slideDown"><a href="#slideUp-和slideDown" class="headerlink" title="slideUp()和slideDown()"></a>slideUp()和slideDown()</h4><p>只会改变元素的高度。如果一个元素的display属性值为<code>none</code>,<code>slideDown()</code>会让这个元素会由上至下延伸展示。</p><h4 id="自定义动画animate"><a href="#自定义动画animate" class="headerlink" title="自定义动画animate()"></a>自定义动画animate()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animate(params. speed, callback)</span><br><span class="line"><span class="comment">//param:属性值的映射 &#123;property1:&quot;value&quot;,property2:&quot;value2&quot;...&#125;</span></span><br><span class="line"><span class="comment">//speed:速度，可选</span></span><br><span class="line"><span class="comment">//callback:动画执行完成时调用的函数，可选</span></span><br></pre></td></tr></table></figure><h4 id="停止元素的动画和判断是否处于动画"><a href="#停止元素的动画和判断是否处于动画" class="headerlink" title="停止元素的动画和判断是否处于动画"></a>停止元素的动画和判断是否处于动画</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop([clearQueue] [,gotoEnd])</span><br></pre></td></tr></table></figure><p>都是可选的参数没Boolean值，clear表示是否要清空未执行完的动画队列，goEnd表示是否直接跳转到末状态。</p><h4 id="其他动画方法"><a href="#其他动画方法" class="headerlink" title="其他动画方法"></a>其他动画方法</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>toggle()</td><td>切换可见状态</td></tr><tr><td>slideToggle()</td><td>通过高度变化来切换匹配元素的可见性</td></tr><tr><td>fadeTo()</td><td>通过不透明度来渐进</td></tr></tbody></table><h2 id="第五章、jQuery与Ajax应用"><a href="#第五章、jQuery与Ajax应用" class="headerlink" title="第五章、jQuery与Ajax应用"></a>第五章、jQuery与Ajax应用</h2><p>Ajax全程“<code>Asynchronous JavaScript and XML</code>” (异步与XML)，是有机的利用了一系列交互式网页应用相关的技术形成的结合体</p><h3 id="5-1-优势与不足"><a href="#5-1-优势与不足" class="headerlink" title="5.1 优势与不足"></a>5.1 优势与不足</h3><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>不需要插件支持</strong></li><li><strong>优秀的用户体验</strong>：不刷新整个页面前提下更新数据。</li><li><strong>提供web程序的性能</strong>，ajax在性能上最大的区别在于传输数据的模式，在传统模式中，数据提交通过表单来实现，数据获取靠全页面刷新来获取。</li><li><strong>减去服务器和带宽的负担</strong>，相当于在用户和服务器之间加了一个中间层，使用户操作与服务器相应异步化。在客户端创建Ajax引擎，把传统方式下的一些服务器负担工作移到客户端。</li></ol><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ol><li>浏览器对于XMLHttpRequest对象支持不高，现在都支持了</li><li><strong>破坏浏览器前进后退按键的正常功能</strong>。程序员不愿意在复杂的逻辑中去处理这个问题，但是用户习惯性的点击后退按键，这样就会发生不愿意看到是事情。</li><li>对搜索引擎支持不足，搜索引擎通过爬虫来对数据进行整理和交户</li><li>开发和调试工具缺乏。</li></ol><h3 id="5-2-Ajax和XMLHttpRequest对象"><a href="#5-2-Ajax和XMLHttpRequest对象" class="headerlink" title="5.2 Ajax和XMLHttpRequest对象"></a>5.2 Ajax和XMLHttpRequest对象</h3><p>Ajax的核心是<code>XMLHttpRequest</code>对象，它是 Ajax实现的关键——<strong>发送异步请求、接收响应及执行回调</strong>都是通过它来完成的。XMLHttpRequest对象最早是在 Microsoft InternetExplorer 5.0 ActiveX组件中被引入的，之后各大浏览器厂商都以JavaScript内置对象的方式来实现XMLHttpRequest对象。</p><h3 id="5-3-jQuery中的Ajax"><a href="#5-3-jQuery中的Ajax" class="headerlink" title="5.3 jQuery中的Ajax"></a>5.3 jQuery中的Ajax</h3><p>对jquery进行了封装</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>load(url [,data] [,callback])</td><td>载入远程HTML代码并插入DOM,更改url可以很好的得到页面每个模块。传递方式是根据参数决定，无参get,有参post</td></tr><tr><td>$.get(url [,data] [,callback] [,type])</td><td>通过get方式进行异步请求，多了一个类型是服务器返回内容的格式</td></tr><tr><td>$.post()</td><td>post请求和get请求使用上一样</td></tr><tr><td>$.getScript()</td><td>在页面初次加载就取得全部的js是没有必要的</td></tr><tr><td>$.getJSON()</td><td>用于加载json</td></tr><tr><td>$.ajax(options)</td><td>下面细讲</td></tr></tbody></table><h4 id="浏览器返回的数据格式"><a href="#浏览器返回的数据格式" class="headerlink" title="浏览器返回的数据格式"></a>浏览器返回的数据格式</h4><ul><li>HTML:HTML可以直接插入到页面中</li><li>XML：这个就需要进行数据处理，但是XML的可移植性很高，但是解析和操作速度慢</li><li>JSON：因为XML文档的体积到难以解析，就诞生了json,轻量级</li></ul><h4 id="get和post请求的区别"><a href="#get和post请求的区别" class="headerlink" title="get和post请求的区别"></a>get和post请求的区别</h4><ul><li>GET请求会将<strong>参数跟在URL后</strong>进行传递，而POST请求则是<strong>作为HTTP消息的实体内容</strong>发送给Web服务器。</li><li>GET 方式对传输的<strong>数据有大小限制</strong>（通常不能大于2KB)，而使用 POST方式传递的<strong>数据量要比GET方式大得多(理论上不受限制)。</strong></li><li>GET 方式请求的数据<strong>会被浏览器缓存起来</strong>，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET方式会带来严重的安全性问题，而POST方式相对来说就可以避免这些问题。</li><li>GET方式和 POST 方式传递的数据<strong>在服务器端的获取也不相同</strong>。在 PHP中，GET方式的数据可以用$S_GET[]获取，而POST方式可以用$_POST[]获取。两种方式都可以用$_REQUEST[]来获取。</li></ul><h4 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax()"></a>$.ajax()</h4><p>是最底层的Ajax实现，常用参数如下</p><table><thead><tr><th>参数名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>url</td><td>String</td><td>发送请求地址</td></tr><tr><td>type</td><td>String</td><td>请求类型(get/post)默认get,其他HTTP请求方法也支持例如put/delete</td></tr><tr><td>timeout</td><td>Number</td><td>请求超时时间</td></tr><tr><td>data</td><td>Object或String</td><td>发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。GET 请求中将附加在URL后。防止这种自动转换，可以查看processData选项。对象必须为key/value格式,例如{foo1 :”bar1”,foo2 :”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，jQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”}转换为&amp;foo=bar1&amp;foo=bar2</td></tr><tr><td>dataType</td><td>String</td><td>预期服务器返回的数据类型。如果不指定，jQuery将自动根据HTTP包 MIME信息返回responseXML 或responseText，并作为回调函数参数传递。<br>可用的类型如下。<br><strong>xml</strong>:返回 XML文档，可用jQuery 处理。<br><strong>html</strong>:返回纯文本HTML信息;包含的script标签会在插入 DOM时执行。<br><strong>script</strong>:返回纯文本 JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时(不在同一个域下），所有POST请求都将转为GET请求。<br><strong>json</strong>:返回JSON数据。<br><strong>jsonp</strong>: JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，jQuery 将自动替换后一个“?”为正确的函数名，以执行回调函数。<br><strong>text</strong>:返回纯文本字符串</td></tr><tr><td>beforeSend</td><td>Function</td><td>发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在 beforeSend中如果返回false可以取消本次Ajax 请求。XMLHttpRequest对象是惟一的参数。<br>function (XMLHttpRequest){<br>this;//调用本次Ajax请求时传递的options参数}</td></tr><tr><td>complete</td><td>Function</td><td>请求完成后调用的回调函数（请求成功或失败时均调用）。<br>参数:XMLHttpRequest对象和一个描述成功请求类型的字符串。function (XMLHttpRequest, textStatus){<br>this;//调用本次Ajax请求时传递的options参数</td></tr><tr><td>success</td><td>Function</td><td>请求成功后调用的回调函数，有两个参数。<br>(1）由服务器返回，并根据dataType参数进行处理后的数据。(2）描述状态的字符串。<br>function (data, textStatus){<br>// data可能是xmlDoc、jsonObj、html、text等等<br>this; //调用本次Ajax请求时传递的options参数}</td></tr><tr><td>error</td><td>Function</td><td>请求失败时被调用的函数。该函数有3个参数，即<br>XMLHttpRequest对象、错误信息、捕获的错误对象(可选）。Ajax事件函数如下。<br>function (XMLHttpRequest, textStatus, errorThrown){<br>//通常情况下textStatus和 errorThown只有其中一个包含信息this; //调用本次Ajax请求时传递的options参数</td></tr><tr><td>global</td><td>Boolean</td><td>默认为true.表示是否触发全局Ajax时间。设置为false不会茶法Ajax事件，AjaxStart或AjaxStop可用于控制各中Ajax事件。</td></tr></tbody></table><h3 id="5-4-序列化元素"><a href="#5-4-序列化元素" class="headerlink" title="5.4 序列化元素"></a>5.4 序列化元素</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>serialize()</td><td>表单必不可少，经常用来提交数据。通过这个方法可以把数据序列化成字符串，用于Ajax请求</td></tr><tr><td>serializeArray()</td><td>将DOM元素序列化后返回JSON数据</td></tr><tr><td>param()</td><td>用来对一个数组或对象按照key/value进行序列化</td></tr></tbody></table><h3 id="5-5-Ajax全局事件"><a href="#5-5-Ajax全局事件" class="headerlink" title="5.5 Ajax全局事件"></a>5.5 Ajax全局事件</h3><p>jQuery简化 Ajax操作不仅体现在调用Ajax方法和处理响应方面，而且还体现<strong>在对调用Ajax方法的过程中的HTTP请求的控制</strong>。通过jQuery提供了一些自定义全局函数，能够为各种与Ajax相关的事件注册回调函数。例如当Ajax请求开始时，会触发<code>ajaxStart()</code>方法的回调函数;当Ajax 请求结束时，会触发<code>ajaxStop()</code>方法的回调函数。这些方法都是全局的方法，因此无论创建它们的代码位于何处，只要有Ajax 请求发生时，就会触发它们。在前面例子中，远程读取网站的图片速度可能会比较慢，如果在加载的过程中，不给用户提供一些提示和反馈信息，很容易让用户误认为按钮单击无用，使用户对网站失去信心。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>ajaxComplete(callback)</td><td>Ajax请求完成时执行的函数</td></tr><tr><td>ajaxError(callback)</td><td>Ajax 请求发生错误时执行的函数，捕捉到的错误可以作为最后一个参数传递</td></tr><tr><td>ajaxSend(callback)</td><td>Ajax请求发送前执行的函数</td></tr><tr><td>ajaxSuccess(callback)</td><td>Ajax请求成功时执行的函数</td></tr></tbody></table><h2 id="第六章、插件的使用和写法"><a href="#第六章、插件的使用和写法" class="headerlink" title="第六章、插件的使用和写法"></a>第六章、插件的使用和写法</h2><p>jQuery的易扩展性,吸引了来自全球的开发者来共同编写jQuery的插件。最新最全的插件可以从jQuery官方网站的插件板块中获取，网站地址为: <code>http:/plugins.jquery.com/</code>。</p><h3 id="6-1-表单验证插件-Validation"><a href="#6-1-表单验证插件-Validation" class="headerlink" title="6.1 表单验证插件-Validation"></a>6.1 表单验证插件-Validation</h3><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>有如下特点：</p><ul><li><strong>内置验证规则</strong>:拥有必填、数字、E-Mail、URL 和信用卡号码等19类内置验证规则。</li><li><strong>自定义验证规则</strong>:可以很方便地自定义验证规则。</li><li><strong>简单强大的验证信息提示</strong>:默认了验证信息提示，并提供自定义覆盖默认提示信息的功能。</li><li><strong>实时验证</strong>:可以通过keyup或blur事件触发验证，而不仅仅在表单提交的时候验证。</li></ul><p>下载地址：<code>http://plugins.jquery.com/project/validate</code></p><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;#id&#x27;).validate()</span><br></pre></td></tr></table></figure><p>针对不同字段进行规则编码，</p><ul><li>class=”required”必须填写、minlength=”2”最小长度为2</li><li>class=”required email”必须填写并且符合规范 </li></ul><h4 id="不同写法"><a href="#不同写法" class="headerlink" title="不同写法"></a>不同写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入一个新插件</span></span><br><span class="line">&lt;script src=<span class="string">&quot;lib/jquery.metadata.js&quot;</span> type=<span class="string">&quot;text/javascript&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">$(<span class="string">&#x27;#id&#x27;</span>).validate(&#123;<span class="attr">meta</span>: <span class="string">&#x27;validate&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如,为表单添加验证规则</span></span><br><span class="line">$(<span class="string">&#x27;#form&#x27;</span>).validate(&#123;</span><br><span class="line">    <span class="attr">rules</span>: &#123;</span><br><span class="line">        <span class="attr">username</span>: &#123;</span><br><span class="line">            <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">minlength</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">email</span>: &#123;</span><br><span class="line">            <span class="attr">required</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">email</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;url&quot;</span>,</span><br><span class="line">        <span class="attr">comment</span>: <span class="string">&quot;required&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="自定义验证规则"><a href="#自定义验证规则" class="headerlink" title="自定义验证规则"></a>自定义验证规则</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$.validator.addMethod(</span><br><span class="line"><span class="string">&quot;formula&quot;</span>,<span class="comment">//验证方法名称</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value, element, param</span>)</span>&#123; <span class="comment">//验证规则</span></span><br><span class="line">        <span class="keyword">return</span> value == <span class="built_in">eval</span>(param)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;请正确输入熟悉公式计算后的结果&#x27;</span><span class="comment">//验证提示信息</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">$(<span class="string">&#x27;#form&#x27;</span>).validate(&#123;</span><br><span class="line">    <span class="attr">rules</span>: &#123;</span><br><span class="line">        <span class="attr">username</span>: &#123;</span><br><span class="line">            <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">minlength</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">email</span>: &#123;</span><br><span class="line">            <span class="attr">required</span>:<span class="literal">true</span>,</span><br><span class="line">            <span class="attr">email</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&quot;url&quot;</span>,</span><br><span class="line">        <span class="attr">comment</span>: <span class="string">&quot;required&quot;</span></span><br><span class="line">        <span class="attr">valcode</span>: &#123;<span class="attr">formula</span>: <span class="string">&#x27;7+9&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="6-2-编写jquery插件"><a href="#6-2-编写jquery插件" class="headerlink" title="6.2 编写jquery插件"></a>6.2 编写jquery插件</h3><p>给已经有的一系列方法或函数进行一个封装，以便在其他地方重复使用。</p><h4 id="6-2-1-插件的种类"><a href="#6-2-1-插件的种类" class="headerlink" title="6.2.1 插件的种类"></a>6.2.1 插件的种类</h4><h5 id="1-封装对象方法的插件"><a href="#1-封装对象方法的插件" class="headerlink" title="1. 封装对象方法的插件"></a>1. 封装对象方法的插件</h5><p>将对象封装起来，用于对通过选择器获取的jQuery对象进行操作。</p><h5 id="2-封装全局函数的插件"><a href="#2-封装全局函数的插件" class="headerlink" title="2.封装全局函数的插件"></a>2.封装全局函数的插件</h5><p>将独立的函数加到jQuery的命名空间下。</p><h5 id="3-选择器插件"><a href="#3-选择器插件" class="headerlink" title="3.选择器插件"></a>3.选择器插件</h5><p>个别情况下，会用到选择器插件。</p><h4 id="6-2-2-插件的基本要点"><a href="#6-2-2-插件的基本要点" class="headerlink" title="6.2.2 插件的基本要点"></a>6.2.2 插件的基本要点</h4><ul><li><p>jQuery 插件的文件名推荐命名为jquery.[插件名].js,以免和其他JavaScript库插件混绢。例如命名为jquery.color.js。</p></li><li><p>所有的<strong>对象方法都应当附加到 jQuery.fn对象</strong>上，而所有的<strong>全局函数都应当附加到jQuery对象</strong>本身上。</p></li><li><p>在插件内部，<strong>this指向的是当前通过选择器获取的jQuery对象</strong>，而不像一般的方法那样，例如 click()方法，内部的 this 指向的是DOM元素。</p></li><li><p>可以通过<strong>this.each来遍历所有元素。</strong></p></li><li><p>所有的方法或函数插件，都应当<strong>以分号结尾</strong>，否则压缩的时候可能出现问题。为了更稳妥些,甚至<strong>可以在插件头部先加上一个分号</strong>，以免他人的不规范代码给插件带来影响。具体方法可以参考后面的代码。</p></li><li><p>插件应该<strong>返回一个jQuery对象</strong>，以<strong>保证插件的可链式操作</strong>。除非插件需要返回的是一些需要获取的量，例如字符串或者数组等。</p></li><li><p>避免在插件内部使用$作为jQuery对象的别名，而应使用完整的jQuery来表示。这样可以避免冲突。当然，也可以<strong>利用闭包这种技巧来回避这个问题</strong>，使插件内部继续使用$作为 jQuery 的别名。</p></li></ul><h4 id="6-2-3-插件中的闭包"><a href="#6-2-3-插件中的闭包" class="headerlink" title="6.2.3 插件中的闭包"></a>6.2.3 插件中的闭包</h4><p>允许使用内部函数（即<strong>函数定义的函数表达式位于另一个函数的函数体内</strong>），而且，这些内部函数可以访问他们所在的外部函数中声明的<strong>所有局部变量、参数和声明的内部函数</strong>，当其中一个这样的内部函数在包含他们的外部函数被调用时，就会形成<strong>闭包</strong>。内部函数会在外部函数返回后执行，它仍然必须访问其外部函数的局部变量、参数以及其他内部函数。这些局部变量、参数和函数声明（最初时）的值是外部函数返回的值，但也会受到内部函数的影响。</p><p>利用闭包的特性，既可以避免内部临时变量影响全局空间，又可以在插件内部使用$作为别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)();<span class="comment">//通过（）这个运算符来执行</span></span><br></pre></td></tr></table></figure><p>可以传递参数进去供内部函数使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了兼容器加;</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;<span class="comment">//$作为形参</span></span><br><span class="line">    <span class="comment">//这里编写插件的代码，可以使用$作为jQuery的别名</span></span><br><span class="line">    <span class="comment">//foo外部无法访问，仅内部可以访问</span></span><br><span class="line">    <span class="keyword">var</span> foo;</span><br><span class="line">   <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//在匿名函数内部的函数都可以访问foo,即使在匿名函数外部调用bar()的时候，也可以在bar()的内部访问到foo,但在匿名函数外部直接访问foo是做不到的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//让匿名函数内部的bar()逃逸到全局可访问的范围内，这样就可以同$.bar()来访问内部定义的函数bar(),并且内部函数bar()也能访问匿名函数的变量foo</span></span><br><span class="line">    $.bar = bar</span><br><span class="line">&#125;)(jQuery)<span class="comment">//将jQuery作为参数传递给匿名函数</span></span><br></pre></td></tr></table></figure><h4 id="6-2-4-jQuery的机制"><a href="#6-2-4-jQuery的机制" class="headerlink" title="6.2.4 jQuery的机制"></a>6.2.4 jQuery的机制</h4><p>提供了2个用于扩展jQuery的方法，<code>jQuery.fn.extend()</code>方法和<code>jQuery.extend()</code>,前者用于扩展第一种类型，后者用于扩展后两种插件。这两个方法都接收一个参数，类型为Object。</p><p><code>jQuery.extend()</code>方法除了可以用于扩展jQuery对象外，还有一个强大的功能，就是扩展已有的Object对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(target,obj,...[objN])</span><br></pre></td></tr></table></figure><p><code>extend()</code>方法常用于设置插件方法的一系列默认参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">options = jQuery.extend(&#123;</span><br><span class="line"><span class="attr">name</span> : <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">        <span class="attr">length</span> : <span class="number">5</span>,</span><br><span class="line">        <span class="attr">dataType</span>: xml<span class="comment">//默认参数</span></span><br><span class="line">&#125;, options)<span class="comment">//传递的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过jQuery.extend()方法，可以很方便的用传入的参数来覆盖默认值。此时，对方调用的方法依旧保持一致，只不过传入的是一个映射而不是一个参数列表。这种机制比传统的每个参数都去检测的方式不仅灵活而且简介。此外使用命名参数意味着添加新选项也不会影响过去编写的代码。</p><h4 id="6-2-5-编写jQuery插件"><a href="#6-2-5-编写jQuery插件" class="headerlink" title="6.2.5 编写jQuery插件"></a>6.2.5 编写jQuery插件</h4><h5 id="1-封装jQuery对象方法的插件"><a href="#1-封装jQuery对象方法的插件" class="headerlink" title="1.封装jQuery对象方法的插件"></a>1.封装jQuery对象方法的插件</h5><p>第一个编写设置和获取颜色的插件，插件有2个功能</p><ul><li>设置匹配元素的值</li><li>获取匹配的元素的颜色</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">$.fn.extend(&#123;</span><br><span class="line">        <span class="comment">//这里给这个方法提供一个参数value，如果调用方法的时候传递了value这个参数，那么就是用这个值来设置字体颜色;否则就是获取匹配元素的字体颜色的值。</span></span><br><span class="line">        <span class="string">&quot;color&quot;</span> : <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//插件如果不需要返回字符串，应当使其具有可链接性。直接返回这个this对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.css(<span class="string">&quot;color&quot;</span>,value);<span class="comment">//通过css来实现,css已经有判断value是否为undefined的机制，所以可以根据参数的不同而返回不同的值。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)(jQuery);<span class="comment">//通过（）这个运算符来执行</span></span><br></pre></td></tr></table></figure><p>第二个编写隔行变色的工具</p><p>工具如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;tbody&gt;tr:odd&#x27;</span>).addClass(<span class="string">&#x27;odd&#x27;</span>);</span><br><span class="line">$(<span class="string">&#x27;tbody&gt;tr:even&#x27;</span>).addClass(<span class="string">&#x27;even&#x27;</span>);</span><br><span class="line">$(<span class="string">&#x27;tdody&gt;tr&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断当前是否被选择</span></span><br><span class="line">    <span class="keyword">var</span> hasSelected = $(<span class="built_in">this</span>).hasClass(<span class="string">&#x27;selected&#x27;</span>);</span><br><span class="line">    <span class="comment">//如果选中则移除selected类，否则加上selected类</span></span><br><span class="line">    $(<span class="built_in">this</span>)[hasSelected?<span class="string">&quot;removeClass&quot;</span>:<span class="string">&quot;addClass&quot;</span>](<span class="string">&#x27;selected&#x27;</span>)</span><br><span class="line">    <span class="comment">//查找内部的checkbox，设置对应的值</span></span><br><span class="line">    .find(<span class="string">&#x27;:checkbox&#x27;</span>).attr(<span class="string">&#x27;checked&#x27;</span>,!hasSelected);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//如果复选框默认情况下是选择的，则高色</span></span><br><span class="line">$(<span class="string">&#x27;tbody&gt;tr:has(:checked)&#x27;</span>).addClass(<span class="string">&#x27;selected&#x27;</span>);</span><br></pre></td></tr></table></figure><p>插件实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">$.fn.extend(&#123;</span><br><span class="line"><span class="string">&quot;alterBgColor&quot;</span>:<span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//设置默认参数</span></span><br><span class="line">            options=$.extend(&#123;</span><br><span class="line">                <span class="attr">odd</span>:<span class="string">&#x27;odd&#x27;</span>,</span><br><span class="line">                <span class="attr">even</span>:<span class="string">&#x27;even&#x27;</span>,</span><br><span class="line">                <span class="attr">selected</span>:<span class="string">&#x27;selected&#x27;</span></span><br><span class="line">            &#125;,options);</span><br><span class="line">            <span class="comment">//不能使用tbody&gt;tr，会使所有的页面都变色，需要改写$(&#x27;tbody&gt;tr&#x27;, this),表示在匹配元素内（当前表格内查找）</span></span><br><span class="line">            $(<span class="string">&#x27;tbody&gt;tr:odd&#x27;</span>).addClass(options.odd);</span><br><span class="line">$(<span class="string">&#x27;tbody&gt;tr:even&#x27;</span>).addClass(options.even);</span><br><span class="line">$(<span class="string">&#x27;tdody&gt;tr&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">//判断当前是否被选择</span></span><br><span class="line">            <span class="keyword">var</span> hasSelected = $(<span class="built_in">this</span>).hasClass(options.selected);</span><br><span class="line">            <span class="comment">//如果选中则移除selected类，否则加上selected类</span></span><br><span class="line">            $(<span class="built_in">this</span>)[hasSelected?<span class="string">&quot;removeClass&quot;</span>:<span class="string">&quot;addClass&quot;</span>](options.selected)</span><br><span class="line">                <span class="comment">//查找内部的checkbox，设置对应的值</span></span><br><span class="line">                .find(<span class="string">&#x27;:checkbox&#x27;</span>).attr(<span class="string">&#x27;checked&#x27;</span>,!hasSelected);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//如果复选框默认情况下是选择的，则高色</span></span><br><span class="line">        $(<span class="string">&#x27;tbody&gt;tr:has(:checked)&#x27;</span>).addClass(options.selected);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">//方法可链</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure><p>需要注意，jQuery选择符可能会匹配多个元素，因此在内部使用each()来遍历元素，然后执行相应方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">$.fn.extend(&#123;</span><br><span class="line"><span class="string">&#x27;somePlugin&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">              <span class="comment">//插件代码  </span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure><h5 id="2-封装全局函数的插件-1"><a href="#2-封装全局函数的插件-1" class="headerlink" title="2.封装全局函数的插件"></a>2.封装全局函数的插件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="number">4</span></span>)</span>&#123;</span><br><span class="line">$.extend(&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="function"><span class="title">funtion</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//方法</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)(jQuery);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">$.name(options);</span><br></pre></td></tr></table></figure><h5 id="3-自定义选择器"><a href="#3-自定义选择器" class="headerlink" title="3.自定义选择器"></a>3.自定义选择器</h5><p>jQuery 的选择符解析器首先会<strong>使用一组正则表达式来解析选择器</strong>，然后针<strong>对解析出的每个选择符执行一个函数，称为选择器函数</strong>。最后根据这个选择器函数的返回值为true还是false来决定是否保留这个元素。这样就可以找到匹配的元素节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div:gt(1)&quot;)</span><br></pre></td></tr></table></figure><p>该选择器首先会获取所有的<code>&lt;div&gt;</code>元素，然后隐式遍历这些<code>&lt;div&gt;</code>元素，并逐个将这些<code>&lt;div&gt;</code>元素作为参数，连同括号里的“1”等一些参数(具体见下文)一起传递给gt对应的选择器函数进行判断。如果这个函数返回 true，则这个<code>&lt;div&gt;</code>元素保留，如果返回 false，则不保留这个<code>&lt;div&gt;</code>元素。这样得到的结果就是一个符合要求的<code>&lt;div&gt;</code>元素的集合。<br>:gt()选择器在jQuery源文件中的代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gt: <span class="function"><span class="keyword">function</span> (<span class="params">a,i,m</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> i&gt;m[<span class="number">3</span>] -<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中,选择器的函数一共接受3个参数,代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"> a , i , m</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第1个参数为a，指向的是<strong>当前遍历到的DOM</strong>元素。<br>第2个参数为i，指的是<strong>当前遍历到的DOM元素的索引值</strong>，从0开始。<br>第3个参数m最为特别，它是由jQuery 正则解析引擎进一步解析后的产物(用match 匹配出来的)，是一个数组。</p><ul><li>m[0]，以上面的$(“div:gt(1)”)这个例子来讲，是:gt(1)这部分。它是 jQuery 选择器进一步将要匹配的内容。</li><li>m[1]，这里是选择器的引导符，匹配例子中的“:”，即冒号。并非只能使用”:”后面跟上选择器,用户还可以自定义其他的选择器引导符。</li><li>m[2]，即例子中的gt，确定究竟是调用哪个选择器函数。</li><li>m[3]，即例子中括号里的数字“1”，它非常有用，是编写选择器函数最重要的一个参数。</li><li>m[4]，上面的例子中没有体现出来，这个比较罕见。例如”div:K(ss(dd))”这样一个选择器中，m[4]就指向了(dd）这部分，注意是带括号的（dd)，而不只是 dd。同时要注意,此时的m[3]的值是ss(dd)而非ss。</li></ul><p>选择器插件中的函数属于运算密集型函数，对执行效率要求很高，读者在编写此类插件的时候，一定要秉承优化再优化的原则，千万不要随便写一个能实现功能的函数就草草了事。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码整洁之道</title>
      <link href="/2021/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
      <url>/2021/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    细节决定成败。</p><p>​    习艺之要有二：知和行，学而用。整洁代码，需要自行实践，体验自己的失败。观测他人的实践与失败。阅读代码–大量代码。代码好在什么地方，坏在什么地方。</p><h2 id="第一章、整洁代码"><a href="#第一章、整洁代码" class="headerlink" title="第一章、整洁代码"></a>第一章、整洁代码</h2><p>​    2个原因：第一，你是个程序员；第二，你想成为更好的程序员。</p><h3 id="1-1-要有代码"><a href="#1-1-要有代码" class="headerlink" title="1.1 要有代码"></a>1.1 要有代码</h3><p>​    代码呈现了需求的细节。细节无法被忽略或抽象。代码确然是我们最终用来表达需求的那种语言。我们可以创造帮助把需求解析和汇整为正式结构的各种工具。但是我们无法抛弃必要的精确性，所以代码用存。</p><h3 id="1-2-糟糕的代码"><a href="#1-2-糟糕的代码" class="headerlink" title="1.2 糟糕的代码"></a>1.2 糟糕的代码</h3><p>​    沼泽（wading）。我们趟过代码的水域，我们穿过灌木密布、瀑布暗藏的沼泽地。我们拼命的想寻找出路，期望有什么线索能启发我们到底发生了什么事：但目光所及，只是越来越多死气沉沉的代码。</p><p>​    勒布朗法则：<strong>稍后等于永不</strong>（Later equals never）。</p><h3 id="1-3-混乱的代价"><a href="#1-3-混乱的代价" class="headerlink" title="1.3 混乱的代价"></a>1.3 混乱的代价</h3><p>​    对代码的每次修改都影响到其他两到三处代码，修改无小事。</p><h4 id="1-3-1-新设计"><a href="#1-3-1-新设计" class="headerlink" title="1.3.1 新设计"></a>1.3.1 新设计</h4><p>​    当旧系统无法在开发时。就会开发全新的设计。会诞生两两个团队，新团队开发一套新系统，必须实现旧系统的所有功能，另外，还得跟上对旧系统的持续改动。在新系统的功能可以抗衡旧系统时管理层是不会换掉旧系统的。</p><h4 id="1-3-2-态度"><a href="#1-3-2-态度" class="headerlink" title="1.3.2 态度"></a>1.3.2 态度</h4><p>​    用户指望我们验证需求是否都在系统中实现。项目经理指望我们遵守进度。我们与项目的规划脱不了干系，对失败有极大责任；医生对病人做手术之前都会洗手。程序员遵从了不了解混乱风险的经理的意愿，是不专业的做法。</p><h4 id="1-3-3-谜题"><a href="#1-3-3-谜题" class="headerlink" title="1.3.3 谜题"></a>1.3.3 谜题</h4><p>​    谜题：开发者背负期限的压力，只好制造混乱。但是这个谜题说错了，制造混乱<strong>无助于</strong>赶上期限，只会立刻拖慢你。赶上期限的唯一方法，<strong>始终尽可能保持代码清洁</strong>。</p><h4 id="1-3-4-整洁代码的艺术"><a href="#1-3-4-整洁代码的艺术" class="headerlink" title="1.3.4 整洁代码的艺术"></a>1.3.4 整洁代码的艺术</h4><p>​    代码就像绘画。多数人知道一幅画是好还是坏，但不代表会会绘画。整洁代码，需要遵循大量的小技巧，贯彻刻苦习得的“整洁感”。</p><p>​    缺乏“代码感”的程序员，看混乱是混乱，无处着手。有“代码感”的程序员能从混乱中看出其他的可能与变化。“代码感”帮助程序员选出最好的方案，并指导程序员制订修改行动计划，按图索骥。</p><h4 id="1-3-5-什么是整洁代码"><a href="#1-3-5-什么是整洁代码" class="headerlink" title="1.3.5 什么是整洁代码"></a>1.3.5 什么是整洁代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我喜欢优雅和高效的代码。代码逻辑应当直截了当，叫缺陷难以隐藏;尽量减少依赖关系，使之便于维护;依据某种分层战略完善错误处理代码;性能调至最优，省得引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。Bjarne</span><br></pre></td></tr></table></figure><p>​    C++语言的发明者Bjarne认为整洁代码读起来令人愉悦。</p><p>​    破窗理论：窗户破损了的建筑让人觉得似乎无人照管。于是别人也不在关心。放任窗户继续破损。最终自己也参加破坏活动。</p><p>​    Bjarne:整洁的代码只做好一件事。每个函数、每个类和每个模块都全神贯注于一事。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">整洁的代码简单直接。整洁的代码如同优美的散文。整洁的代码从不隐藏设计者的意图，充满了干净利落的抽象和直截了当的控制语句。Grady（面向对象分析与设计作者）</span><br></pre></td></tr></table></figure><p>​    Grady，整洁的代码如同优美的散文。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">近年来，我开始研究贝克的简单代码规则，差不多也都琢磨透了。简单代码，依其重要顺序:</span><br><span class="line">能通过所有测试;</span><br><span class="line">没有重复代码;</span><br><span class="line">体现系统中的全部设计理念;</span><br><span class="line">包括尽量少的实体，比如类、方法、函数等。</span><br><span class="line">在以上诸项中，我最在意代码重复。如果同一段代码反复出现，就表示某种想法未在代码中得到良好的体现。我尽力去找出到底那是什么，然后再尽力更清晰地表达出来。</span><br><span class="line">在我看来，有意义的命名是体现表达力的一种方式，我往往会修改好几次才会定下名字来。借助Eclipse这样的现代编码工具，重命名代价极低，所以我无所顾忌。然而，表达力还不只体现在命名上。我也会检查对象或方法是否想做的事太多。如果对象功能太多，最好是切分为两个或多个对象。如果方法功能太多，我总是使用抽取手段（Extract Method)重构之，从而得到一个能较为清晰地说明自身功能的方法，以及另外数个说明如何实现这些功能的方法。</span><br><span class="line">消除重复和提高表达力让我在整洁代码方面获益良多，只要铭记这两点，改进脏代码时就会大有不同。不过，我时常关注的另一规则就不太好解释了。</span><br><span class="line">这么多年下来，我发现所有程序都由极为相似的元素构成。例如“在集合中查找某物”。不管是雇员记录数据库还是名-值对哈希表，或者某类条目的数组，我们都会发现自己想要从集合中找到某一特定条目。一旦出现这种情况，我通常会把实现手段封装到更抽象的方法或类中。这样做好处多多。</span><br><span class="line">可以先用某种简单的手段，比如哈希表来实现这一功能，由于对搜索功能的引用指向了我那个小小的抽象，就能随需应变，修改实现手段。这样就既能快速前进，又能为未来的修改预留余地。</span><br><span class="line">另外，该集合抽象常常提醒我留意“真正”在发生的事，避免随意实现集合行为，因为我真正需要的不过是某种简单的查找手段。</span><br><span class="line">减少重复代码，提高表达力，提早构建简单抽象。这就是我写整洁代码的方法。Ron（极限编程实施）</span><br></pre></td></tr></table></figure><p>​    Ron：不要重复代码，只做一件事，表达力，小规模抽象，该有的都有了。</p><h3 id="1-4-思想流派"><a href="#1-4-思想流派" class="headerlink" title="1.4 思想流派"></a>1.4 思想流派</h3><p>​    武术家从不认同所谓的最好武术。别认为我们是”正确的“。</p><h3 id="1-5-我们是作者"><a href="#1-5-我们是作者" class="headerlink" title="1.5 我们是作者"></a>1.5 我们是作者</h3><p>​    我们写代码时，我们是作者，要为评判我工作的读者写代码。写新代码时，我们一直在读旧代码。编写代码的难度，取决于读周边代码的难度，要想干的快，要想早点做完，要想轻松写代码，先让代码易读吧。</p><h3 id="1-6-童子军军规"><a href="#1-6-童子军军规" class="headerlink" title="1.6 童子军军规"></a>1.6 童子军军规</h3><p>​    把代码写好还不够。必须时时<strong>保持代码整洁</strong>。童子军军规：让营地比你来时干净。</p><h3 id="1-7-前传与原则"><a href="#1-7-前传与原则" class="headerlink" title="1.7 前传与原则"></a>1.7 前传与原则</h3><p>​    本书中会发现对不同设计原则的引用，包括单一权责、开放闭合原则和依赖倒置原则等。</p><h3 id="1-8-小结"><a href="#1-8-小结" class="headerlink" title="1.8 小结"></a>1.8 小结</h3><p>​    艺术家并不能保证你读过之后能成为艺术家，只能告诉你其他艺术家用过的工具、技术和思维过程。本书只能展示好程序员的思维过程，还有他们使用的技巧、技术和工具。</p><p>​    和艺术书一样，本书充满了细节。你会看到启发、规条和技巧的列表。最终的结果取决于你。</p><h2 id="第二章、有意义的命名"><a href="#第二章、有意义的命名" class="headerlink" title="第二章、有意义的命名"></a>第二章、有意义的命名</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>​    软件中随处可见命名。有如此多的命名要做，不妨做好它。</p><h3 id="2-2-名副其实"><a href="#2-2-名副其实" class="headerlink" title="2.2 名副其实"></a>2.2 名副其实</h3><p>​    遍历函数或类的名称已经答复了所有问题。如果名称需要注释，就不是名副其实。</p><h3 id="2-3-避免误导"><a href="#2-3-避免误导" class="headerlink" title="2.3 避免误导"></a>2.3 避免误导</h3><p>​    避免使用与本意相悖的词。accountList 除非真的是list，否则accountGroup</p><h3 id="2-4-做有意义的区分"><a href="#2-4-做有意义的区分" class="headerlink" title="2.4 做有意义的区分"></a>2.4 做有意义的区分</h3><p>​    如果知识为满足编译期或解释器的需要写代码，就会制造麻烦。例如，同一作用域内的2样东西不能重名，你可能会随手改掉其中一个名称。（a1,a2,a3）</p><h3 id="2-5-使用能读得出来的名称"><a href="#2-5-使用能读得出来的名称" class="headerlink" title="2.5 使用能读得出来的名称"></a>2.5 使用能读得出来的名称</h3><h3 id="2-6-使用可搜索的名称"><a href="#2-6-使用可搜索的名称" class="headerlink" title="2.6 使用可搜索的名称"></a>2.6 使用可搜索的名称</h3><p>​    单字母名称和数字常量，很难在一大篇文字中找出。搜的到的名称胜于自造编码的名称。名称的长短应与其作用域大学相对应。若变量或常量可能在多处使用，则应赋予便于搜索的名称。</p><h3 id="2-7-避免使用编码"><a href="#2-7-避免使用编码" class="headerlink" title="2.7 避免使用编码"></a>2.7 避免使用编码</h3><h4 id="2-7-1-匈牙利语标记法"><a href="#2-7-1-匈牙利语标记法" class="headerlink" title="2.7.1 匈牙利语标记法"></a>2.7.1 匈牙利语标记法</h4><h4 id="2-7-2-成员前缀"><a href="#2-7-2-成员前缀" class="headerlink" title="2.7.2 成员前缀"></a>2.7.2 成员前缀</h4><p>​    不必用m_前缀来表明成员变量，应该吧类和函数做的足够小，消除对成员前缀的需要。</p><h4 id="2-7-3-接口和实现"><a href="#2-7-3-接口和实现" class="headerlink" title="2.7.3 接口和实现"></a>2.7.3 接口和实现</h4><p>​    怎么命名接口和实现？不加修饰的接口，然后对实现类加Imp</p><h3 id="2-8-避免思维映射"><a href="#2-8-避免思维映射" class="headerlink" title="2.8 避免思维映射"></a>2.8 避免思维映射</h3><p>​    不要让读者在脑中把你的名称翻译为他们熟知的名称。单变量作用域就是这个问题。在作用域较小、也没有名称冲突时，计数器可能为i、j、k，这不是个好选择，读者必须把它映射为真实概念。</p><h3 id="2-9-类名"><a href="#2-9-类名" class="headerlink" title="2.9 类名"></a>2.9 类名</h3><p>​    类名和对象名应该是名词或名词短语。</p><h3 id="2-10-方法名"><a href="#2-10-方法名" class="headerlink" title="2.10 方法名"></a>2.10 方法名</h3><p>​    方法名应该是动词或动词短语。get、set、is。</p><h3 id="2-11-别扮可爱"><a href="#2-11-别扮可爱" class="headerlink" title="2.11 别扮可爱"></a>2.11 别扮可爱</h3><p>​    如果名称太可爱，只有可作者一样的人才能记住。</p><h3 id="2-12-每个概念对应一个词"><a href="#2-12-每个概念对应一个词" class="headerlink" title="2.12 每个概念对应一个词"></a>2.12 每个概念对应一个词</h3><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Html</title>
      <link href="/2021/07/12/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Html/"/>
      <url>/2021/07/12/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Html/</url>
      
        <content type="html"><![CDATA[<h2 id="一、了解"><a href="#一、了解" class="headerlink" title="一、了解"></a>一、了解</h2><p>超文本标记语言</p><p>W3C 万维网联盟（<a href="http://www.w3.org）">http://www.w3.org）</a></p><ul><li>结构化标准（HTML、XML）</li><li>表现标准语言（CSS）</li><li>行为标准（DOM、ECMAScript）js</li></ul><h2 id="二、网页基本信息"><a href="#二、网页基本信息" class="headerlink" title="二、网页基本信息"></a>二、网页基本信息</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 告诉浏览器，我们要使用什么规范 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DCOTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 网页头部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 描述性标签， 描述网站的一些信息--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 一般用来做SEO--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;练习&quot;</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;这个地方用来练习&quot;</span>&gt;</span> </span><br><span class="line">       <span class="comment">&lt;!-- 标题 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 主体部分 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常用标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 标题标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 段落标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 换行标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 水平线标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 粗体、斜体标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>粗体<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 特殊符号 --&gt;</span></span><br><span class="line">空<span class="symbol">&amp;nbsp;</span>格</span><br><span class="line"><span class="symbol">&amp;gt;</span> 大于号</span><br><span class="line"><span class="symbol">&amp;lt;</span> 小于</span><br><span class="line"><span class="symbol">&amp;copy;</span>版权</span><br></pre></td></tr></table></figure><p>图像标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;text&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;&quot;</span> <span class="attr">hight</span>=<span class="string">&quot;&quot;</span>/&gt;</span>地址、图像的代替位置、鼠标悬停提示文字,宽，高</span><br></pre></td></tr></table></figure><p>链接标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;path&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口位置&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>链接路径(必填)、链接在哪个窗口打开（_self、_blank新标签）</span><br><span class="line">图片超链接</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">img</span>/&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">锚链接</span><br><span class="line">1.需要一个锚标记</span><br><span class="line">2.跳转到标记</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;top&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> 标记</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">herf</span>=<span class="string">&quot;#top&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">功能性链接</span><br><span class="line">邮件链接：mailto</span><br><span class="line">QQ链接</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:1426768270@qq.com&quot;</span>&gt;</span>点击练习我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>行内元素和块元素</p><p>列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">有序列表 有序号的</span><br><span class="line">应用：试卷，问答</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">无序列表</span><br><span class="line">应用：导航，侧边栏</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">自定义列表</span><br><span class="line">公司网站底部</span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span> 标签</span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span><span class="tag">&lt;/<span class="name">dt</span>&gt;</span> 列表名称</span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span> 列表内容</span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span><span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>表格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">行 tr</span><br><span class="line">列 td</span><br><span class="line">colspan 跨列</span><br><span class="line">rowspan 跨行</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>视频和音频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="页面结构分析"><a href="#页面结构分析" class="headerlink" title="页面结构分析"></a>页面结构分析</h2><ul><li>header 标记头部区域的内容</li><li>footer: 脚部区域</li><li>section web页面中一块独立区域</li><li>article 独立的文章内容</li><li>aside:相关内容或应用，侧边栏</li><li>nav:导航类辅助内容</li></ul><h3 id="iframe内联框架"><a href="#iframe内联框架" class="headerlink" title="iframe内联框架"></a>iframe内联框架</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;引用的地址&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;框架标识名&quot;</span></span></span><br><span class="line"><span class="tag">        &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表单语法"><a href="#表单语法" class="headerlink" title="表单语法"></a>表单语法</h3><!--action : 表单提交的位置，可以是网站，也可以是请求处理地址method :提交的方式 post get--><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;result.html&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        名字<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--单选框的name必须一样，这样才能成为一个组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;boy&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">button: 普通按钮</span></span><br><span class="line"><span class="comment">image: 图像按钮</span></span><br><span class="line"><span class="comment">submit:提交按钮</span></span><br><span class="line"><span class="comment">reset:重置</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;btm1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击变长&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;地址&quot;</span>&gt;</span> 图片按钮自动提交的</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--下拉框--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;列表名称&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;选项的值&quot;</span> <span class="attr">selected</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--文本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;textarea&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;10&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--文件域--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;files&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--验证--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;url&quot;</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;num&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">step</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--滑块--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">name</span>=<span class="string">&quot;volume&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">step</span>=<span class="string">&quot;1&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--增强鼠标可用性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lable</span> <span class="attr">for</span>=<span class="string">&quot;mark&quot;</span>&gt;</span>你点我试试<span class="tag">&lt;/<span class="name">lable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mark&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--表单初级验证</span></span><br><span class="line"><span class="comment">placeholder:提示</span></span><br><span class="line"><span class="comment">required:必填</span></span><br><span class="line"><span class="comment">pattern:正则表达式</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;diymail&quot;</span> <span class="attr">pattren</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-组合模式</title>
      <link href="/2021/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>编写程序展示一个学校院系结构:需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系。</p><h4 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h4><p>将学院看做是学校的子类，系是学院的子类，这样实际上是站在组织大小来进行分层次的<br><strong>实际上我们的要求是</strong>：在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系，因此这种方案，<strong>不能很好实现的管理的操作</strong>，比如对学院、系的添加，删除，遍历等<br>解决方案:<strong>把学校、院、系都看做是组织结构</strong>，他们之间没有继承的关系，而是一个树形结构,可以更好的实现管理操作。=&gt;组合模式</p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li><p>组合模式(Composite Pattern)，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“<strong>整体-部分</strong>”的层次关系。</p></li><li><p>组合模式依<strong>据树形结构来组合对象</strong>，用来表示部分以及整体层次。</p></li><li><p>这种类型的设计模式属于结构型模式。</p></li><li><p>组合模式使得<strong>用户对单个对象和组合对象的访问具有一致性</strong>，即:组合能让客户以一致的方式处理个别对象以及组合对象</p><p><img src="/2021/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20210306204811423.png" alt="image-20210306204811423"></p></li></ul><p><strong>Component</strong> :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component子部件, Component可以是抽象类或者接口<br><strong>Leaf</strong> :在组合中表示叶子节点，叶子节点没有子节点<br><strong>Composite</strong> :非叶子节点，<strong>用于存储子部件</strong>，在Component接口中实现子部件的相关操作,比如增加(add),删除。</p><p>组合模式解决，当要处理的对象可以生成一颗树形的结果，我们要对树上的节点和叶子进行操作时，他能提供一致的方法</p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2.示例"></a>2.示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">private</span> String des;<span class="comment">//说明</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span></span>&#123;</span><br><span class="line">        <span class="comment">//默认实现</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span></span>&#123;</span><br><span class="line">        <span class="comment">//默认实现</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//做成抽象的,下面的子类都需要实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就是Composite，组合器，管理College</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">University</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">University</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写add方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">        organizationComponents.add(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写remove方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">        organizationComponents.remove(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//就是输出，包含学院</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------&quot;</span>+getName()+<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent organizationComponent:organizationComponents)&#123;</span><br><span class="line">            organizationComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">College</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放</span></span><br><span class="line">    List&lt;OrganizationComponent&gt; organizationComponents = <span class="keyword">new</span> ArrayList&lt;OrganizationComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">College</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写add方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实际业务中，添加方法不一定完全相同</span></span><br><span class="line">        organizationComponents.add(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写remove方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(OrganizationComponent organizationComponent)</span> </span>&#123;</span><br><span class="line">        organizationComponents.remove(organizationComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//就是输出，包含专业</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------&quot;</span>+getName()+<span class="string">&quot;-------&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (OrganizationComponent organizationComponent:organizationComponents)&#123;</span><br><span class="line">            organizationComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">OrganizationComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(String name, String des)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, des);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//add,remove不用写了，因为他是叶子节点</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从大到小创建对象,学校</span></span><br><span class="line">        University university = <span class="keyword">new</span> University(<span class="string">&quot;清华大学&quot;</span>, <span class="string">&quot;中国顶级大学&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//学院</span></span><br><span class="line">        College college = <span class="keyword">new</span> College(<span class="string">&quot;计算机学院&quot;</span>, <span class="string">&quot;计算机学院&quot;</span>);</span><br><span class="line">        College college1 = <span class="keyword">new</span> College(<span class="string">&quot;信息工程学院&quot;</span>, <span class="string">&quot;信息工程学院&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建各个专业</span></span><br><span class="line">        college.add(<span class="keyword">new</span> Department(<span class="string">&quot;软件工程&quot;</span>,<span class="string">&quot;软件工程&quot;</span>));</span><br><span class="line">        college.add(<span class="keyword">new</span> Department(<span class="string">&quot;网络工程&quot;</span>,<span class="string">&quot;网络工程&quot;</span>));</span><br><span class="line"></span><br><span class="line">        college1.add(<span class="keyword">new</span> Department(<span class="string">&quot;通信工程&quot;</span>,<span class="string">&quot;通信工程&quot;</span>));</span><br><span class="line">        college1.add(<span class="keyword">new</span> Department(<span class="string">&quot;信息工程&quot;</span>,<span class="string">&quot;信息工程&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将2个学院加入学校</span></span><br><span class="line">        university.add(college);</span><br><span class="line">        university.add(college1);</span><br><span class="line"></span><br><span class="line">        university.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">-------清华大学-------</span></span><br><span class="line"><span class="comment">-------计算机学院-------</span></span><br><span class="line"><span class="comment">软件工程</span></span><br><span class="line"><span class="comment">网络工程</span></span><br><span class="line"><span class="comment">-------信息工程学院-------</span></span><br><span class="line"><span class="comment">通信工程</span></span><br><span class="line"><span class="comment">信息工程</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3-在JDK中的使用"><a href="#3-在JDK中的使用" class="headerlink" title="3.在JDK中的使用"></a>3.在JDK中的使用</h3><h4 id="Java集合HashMap就使用了组合模式"><a href="#Java集合HashMap就使用了组合模式" class="headerlink" title="Java集合HashMap就使用了组合模式"></a>Java集合HashMap就使用了组合模式</h4><p><code>HashMap</code> 提供 <code>putAll</code> 的方法，可以将另一个 <code>Map</code> 对象放入自己的存储空间中，如果有相同的 key 值则会覆盖之前的 key 值所对应的 value 值</p><p>putAll 接收的参数为父类 Map 类型，所以 HashMap 是一个容器类，Map 的子类为叶子类，当然如果 Map 的其他子类也实现了 putAll 方法，那么它们都既是容器类，又都是叶子类</p><p>同理，ArrayList 中的 addAll(Collection&lt;? extends E&gt; c) 方法也是一个组合模式的应用，在此不做探讨</p><img src="/2021/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/image-20210306213839803.png" alt="image-20210306213839803" style="zoom:67%;"><h4 id="Mybatis-SqlNode中的组合模式"><a href="#Mybatis-SqlNode中的组合模式" class="headerlink" title="Mybatis SqlNode中的组合模式"></a>Mybatis SqlNode中的组合模式</h4><p>MyBatis 的强大特性之一便是它的动态SQL，其通过 <code>if</code>, <code>choose</code>, <code>when</code>, <code>otherwise</code>, <code>trim</code>, <code>where</code>, <code>set</code>, <code>foreach</code> 标签，可组合成非常灵活的SQL语句，从而提高开发人员的效率。</p><p>Mybatis在处理动态SQL节点时，应用到了组合设计模式，Mybatis会将映射配置文件中定义的动态SQL节点、文本节点等解析成对应的 SqlNode 实现，并形成树形结构。</p><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h3><ul><li>简化客户端操作。客户端只需要面对一致的对象而<strong>不用考虑整体部分或者节点叶子的问题。</strong></li><li>具有较强的扩展性。当我们要更改组合对象时，我们<strong>只需要调整内部的层次关系，客户端不用做出任何改动.</strong></li><li>方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，<strong>容易添加节点或者叶子从而创建出复杂的树形结构</strong></li><li>需要遍历组织机构，或者处理的<strong>对象具有树形结构</strong>时，非常适合使用组合模式.</li><li>要求较高的抽象性，<strong>如果节点和叶子有很多差异性的话</strong>，比如很多方法和属性都不一样<strong>，不适合使用组合模式</strong></li></ul><p>组合模式的<strong>主要缺点</strong>如下：</p><ul><li>使得设计更加复杂，客户端需要花更多时间理清类之间的层次关系。</li><li>在增加新构件时很难对容器中的构件类型进行限制。</li></ul><p><strong>适用场景</strong>：</p><ul><li>在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。</li><li>在一个使用面向对象语言开发的系统中需要处理一个树形结构。</li><li>在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-装饰者模式</title>
      <link href="/2021/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><p>咖啡种类/单品咖啡:Espresso(意大利浓咖啡)、ShortBlack、LongBlack(美式咖啡)、Decaf(无因咖啡)<br>调料: Milk、Soy(豆浆)、Chocolate<br>要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便<br>使用OO的来计算不同种类咖啡的费用:客户可以点单品咖啡，也可以单品咖啡+调料组合。</p><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><img src="/2021/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20210306171648392.png" alt="image-20210306171648392" style="zoom: 50%;"><p>Drink是一个抽象类，表示饮料<br>des 就是对咖啡的描述，比如咖啡的名字<br>cost()方法就是计算费用，Drink类中做成一个抽象方法.<br>Decaf 就是单品咖啡，继承 Drink，并实现cost<br>Espress &amp;&amp; Milk就是单品咖啡+调料，这个组合很多</p><p>问题:<strong>这样设计，会有很多类，当我们增加一个单品咖啡，或者一个新的调料，类的数量就会倍增，就会出现类爆炸</strong></p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>将调料内置Drink中</p><p>方案2-解决星巴克咖啡订单问题分析</p><blockquote><p>1)方案2可以控制类的数量，不至于造成很多的类<br>2)在增加或者删除调料种类时，代码的维护量很大<br>3)考虑到用户可以添加多份调料时，可以将 hasMilk返回一个对应int4)考虑使用装饰者模式</p></blockquote><h4 id="装饰者模式定义"><a href="#装饰者模式定义" class="headerlink" title="装饰者模式定义"></a>装饰者模式定义</h4><ul><li><p>装饰者模式<strong>:动态的将新功能附加到对象</strong>上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)</p></li><li><p>这里提到的<strong>动态的将新功能附加到对象和ocp原则</strong>，在后面的应用实例上会以代码的形式体现。</p></li></ul><h4 id="装饰者模式原理"><a href="#装饰者模式原理" class="headerlink" title="装饰者模式原理"></a>装饰者模式原理</h4><p>装饰者模式就像<strong>打包一个快递</strong></p><ul><li>主体:比如:陶瓷、衣服(Component)//被装饰者<br>包装:比如:报纸填充、塑料泡沫、纸板、木板(Decorator)</li><li>Component主体:比如类似前面的Drink</li><li>ConcreteComponent和 Decorator<br>ConcreteComponent:具体的主体，比如前面的各个单品咖啡<br>Decorator:装饰者，比如各调料.</li><li>在Component与ConcreteComponent之间，如果ConcreteComponent类很多,还可以设计一个缓冲层，将共有的部分提取出来，抽象层一个类。</li></ul><h3 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a>2.案例</h3><img src="/2021/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20210306185944592.png" alt="image-20210306185944592" style="zoom:67%;"><p><img src="/2021/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20210306193201890.png" alt="image-20210306193201890"></p><p>Drink类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String des;    <span class="comment">//描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="comment">//计算费用的抽象方法</span></span><br><span class="line">    <span class="comment">//子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Coffee类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">Drink</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种单品咖啡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Espresso extends Coffee&#123;</span><br><span class="line">    public Espresso()&#123;</span><br><span class="line">        setDes(&quot;意大利咖啡&quot;);</span><br><span class="line">        setPrice(6.0f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongBlack</span> <span class="keyword">extends</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LongBlack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        setDes(<span class="string">&quot;longback&quot;</span>);</span><br><span class="line">        setPrice(<span class="number">5.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drink obj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//getPrice得到自己的价格的价格</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + obj.cost();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//装饰者描述+装饰者的价格+被装饰者的描述</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.des + <span class="string">&quot; &quot;</span> + <span class="keyword">super</span>.getPrice() + <span class="string">&quot;&amp;&amp;&quot;</span> + obj.getDes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体装饰器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体的Decorator调味品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chocolate</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chocolate</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(obj);</span><br><span class="line">        setDes(<span class="string">&quot;巧克力&quot;</span>);</span><br><span class="line">        setPrice(<span class="number">3.0f</span>);   <span class="comment">//调味品的价格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(obj);</span><br><span class="line">        setDes(<span class="string">&quot;牛奶&quot;</span>);</span><br><span class="line">        setPrice(<span class="number">2.0f</span>);   <span class="comment">//调味品的价格</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeBar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//订单：2分巧克力+一份牛奶+LongBlack</span></span><br><span class="line">        <span class="comment">//1.点一份LongBlack</span></span><br><span class="line">        Drink order = <span class="keyword">new</span> LongBlack();</span><br><span class="line">        System.out.println(<span class="string">&quot;费用：&quot;</span>+order.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;描述：&quot;</span>+order.getDes());</span><br><span class="line">        <span class="comment">//2.加入一份牛奶</span></span><br><span class="line">        order = <span class="keyword">new</span> Milk(order);</span><br><span class="line">        System.out.println(<span class="string">&quot;费用：&quot;</span>+order.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;描述：&quot;</span>+order.getDes());</span><br><span class="line">        <span class="comment">//3.加入一份巧克力</span></span><br><span class="line">        order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">        System.out.println(<span class="string">&quot;费用：&quot;</span>+order.cost());</span><br><span class="line">        System.out.println(<span class="string">&quot;描述：&quot;</span>+order.getDes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">费用：5.0</span></span><br><span class="line"><span class="comment">描述：longback</span></span><br><span class="line"><span class="comment">费用：7.0</span></span><br><span class="line"><span class="comment">描述：牛奶 2.0 &amp;&amp; longback</span></span><br><span class="line"><span class="comment">费用：10.0</span></span><br><span class="line"><span class="comment">描述：巧克力 3.0 &amp;&amp; 牛奶 2.0 &amp;&amp; longback</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="3-在JDK中的使用"><a href="#3-在JDK中的使用" class="headerlink" title="3.在JDK中的使用"></a>3.在JDK中的使用</h3><p>Java中IO结果FilterputStream是一个装饰者者</p><img src="/2021/03/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20210306194248301.png" alt="image-20210306194248301" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1 . InputStream是抽象类，类似我们前面讲的Drink</span></span><br><span class="line">    <span class="comment">//2.FileInputStream是 ImputStream子类，类似我们前面的DeCaf, LongBlack</span></span><br><span class="line">    <span class="comment">//3.FilterInputStream是 InputStream子类:类似我们前面的Decorator修饰者</span></span><br><span class="line">    <span class="comment">//4. DataInputStream是 FilterInputStream子类，具体的修饰者，类似前面的Milk, Soy      </span></span><br><span class="line">    <span class="comment">//5.FilterInputStream类有protected volatile InputStream in;即含被装饰者</span></span><br><span class="line">    <span class="comment">//6.分析得出在jdk 的io体系中，就是使用装饰者模式</span></span><br><span class="line">    DataInputStream dis =<span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot; d:llabc.txt&quot;</span>));System.out.println(dis.read());</span><br><span class="line">    dis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-桥接模式</title>
      <link href="/2021/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等)，</p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><ul><li><p>扩展性问题(类爆炸)，如果我们再增加手机的样式(旋转式)，就需要增加各个品牌手机的类，同样如果我们增加一个手机品牌，也要在各个手机样式类下增加。</p></li><li><p>违反了单一职责原则，当我们增加手机样式时，要同时增加所有品牌的手机，这样增加了代码维护成本.</p></li><li><p>解决方案-使用桥接模式</p></li></ul><p>桥接模式(Bridge)-基本介绍基本介绍</p><blockquote><p>桥接模式(Bridge模式)是指:<strong>将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</strong><br>是一种结构型设计模式<br><strong>Bridge模式基于类的最小设计原则</strong>，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把<strong>抽象(Abstraction)与行为实现(Implementation)</strong>分离开来,从而可以保持各部分的独立性以及应对他们的功能扩展</p></blockquote><p><img src="/2021/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20210305221204784.png" alt="image-20210305221204784"></p><ul><li>Client类:桥接模式的调用者</li><li>抽象类(Abstraction) :维护了lmplementor/即它的实现类ConcretelmplementorA…二者是聚合关系, Abstraction充当桥接类</li><li>RefinedAbstraction :是Abstraction抽象类的子类</li><li>lmplementor:行为实现类的接口</li><li>ConcreteImplementorA/B :行为的具体实现类</li><li>从UML图:这里的抽象类和接口是聚合的关系，其实调用和被调用关系</li></ul><h3 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a>2.案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMi</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vivo</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vivo手机开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vivo手机关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Vivo手机打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Brand brand;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoldPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FoldPhone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.open();</span><br><span class="line">        System.out.println(<span class="string">&quot;折叠样式的手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;折叠样式的手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.call();</span><br><span class="line">        System.out.println(<span class="string">&quot;折叠样式的手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取折叠式手机（样式+品牌）</span></span><br><span class="line">        FoldPhone phone = <span class="keyword">new</span> FoldPhone(<span class="keyword">new</span> XiaoMi());</span><br><span class="line">        phone.open();</span><br><span class="line">        phone.call();</span><br><span class="line">        phone.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">小米手机开机</span></span><br><span class="line"><span class="comment">折叠样式的手机</span></span><br><span class="line"><span class="comment">小米手机打电话</span></span><br><span class="line"><span class="comment">折叠样式的手机</span></span><br><span class="line"><span class="comment">小米手机关机</span></span><br><span class="line"><span class="comment">折叠样式的手机</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Phone充当了桥的功能 让具体的手机类型去掉用品牌 实际上实现的功能</strong></p><p>减少拓展时需要增加的类</p><p>类似数据库的多对多</p><h3 id="3-桥接模式在JDBC的源码剖析桥接模式在"><a href="#3-桥接模式在JDBC的源码剖析桥接模式在" class="headerlink" title="3,.桥接模式在JDBC的源码剖析桥接模式在"></a>3,.桥接模式在JDBC的源码剖析桥接模式在</h3><p>JDBC的源码剖析</p><p>Jdbc的 Driver接口，如果从桥接模式来看，Driver就是一个接口，下面可以有MySQL的Driver，Oracle的Driver，这些就可以当做实现接口类<br>代码分析+Debug源码</p><img src="/2021/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/image-20210305223924937.png" alt="image-20210305223924937" style="zoom:67%;"><p>可以看到需要返回的是Connection对象。在Java中通过Connection提供给各个数据库一样的操作接口，这里的Connection可以看作抽象类。可以说我们用来操作不同数据库的方法都是相同的，不过MySQL有自己的ConnectionImpl类，同样Oracle也有对应的实现类。这里Driver和Connection之间是通过DriverManager类进行桥接的，不是像我们上面说的那样用组合关系来进行桥接。</p><h3 id="3、桥接模式优缺点"><a href="#3、桥接模式优缺点" class="headerlink" title="3、桥接模式优缺点"></a>3、桥接模式优缺点</h3><p>3.1 优点</p><pre><code>抽象和实现的分离。优秀的扩展能力。实现细节对客户透明。经常遇到一些可以通过两个或多个维度划分的事物，第一种解决方式就是多层继承，但是复用性比较差，同时类的个数也会很多，桥接模式是改进其的更好办法桥接模式增强了系统的扩展性，在两个维度中扩展任意一个维度都不需要修改原有代码，符合开闭原则</code></pre><p>3.2 缺点</p><pre><code>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。桥接模式增加了系统的理解与设计难度：因为聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度</code></pre><p>3.3 使用场景</p><pre><code>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</code></pre><p>3.4 注意事项</p><pre><code>注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。</code></pre><h3 id="4、桥接模式与适配器模式"><a href="#4、桥接模式与适配器模式" class="headerlink" title="4、桥接模式与适配器模式"></a>4、桥接模式与适配器模式</h3><h4 id="适配器模式与桥接模式的区别和联系"><a href="#适配器模式与桥接模式的区别和联系" class="headerlink" title="适配器模式与桥接模式的区别和联系"></a>适配器模式与桥接模式的区别和联系</h4><p>适配器模式和桥接模式<strong>都是间接引用对象</strong>，因此可以使系统更灵活，在实现上都涉及从自身以外的一个接口向被引用的对象发出请求。</p><p>两种模式的区别在于<strong>使用场合的不同，适配器模式主要解决两个已经有接口间的匹配问题</strong>，这种情况下被适配的接口的实现往往是一个黑匣子。我们不想，也不能修改这个接口及其实现。同时也不可能控制其演化，只要相关的对象能与系统定义的接口协同工作即可。适配器模式经常被用在与第三方产品的功能集成上，采用该模式适应新类型的增加的方式是开发针对这个类型的适配器，如下图所示：</p><p><img src="/2021/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/cdf191868176df03d4ac5fa4e6f87b9c.png" alt="img"></p><p>桥接模式则不同，<strong>参与桥接的接口是稳定的，用户可以扩展和修改桥接中的类</strong>，但是不能改变接口。桥接模式通过接口继承实现或者类继承实现功能扩展。如下图所示：</p><p><img src="/2021/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/bee1c6acc468bd6391dd93acf324611b.png" alt="img"></p><p>桥接模式和适配器模式用于设计的不同阶段，<strong>桥接模式用于设计的前期，即在设计类时将类规划为逻辑和实现两个大类，是他们可以分别精心演化；而适配器模式用于设计完成之后，当发现设计完成的类无法协同工作时，可以采用适配器模式。</strong>然而很多情况下在设计初期就要考虑适配器模式的使用，如涉及到大量第三方应用接口的情况。</p><h3 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h3><p>JDBC 驱动程序</p><p>银行转账系统<br>转账分类:网上转账，柜台转账，AMT转账<br>转账用户类型:普通用户，银卡用户，金卡用户..</p><p>消息管理<br>消息类型:即时消息，延时消息<br>消息分类:手机短信，邮件消息，QQ消息…</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式--适配器模式</title>
      <link href="/2021/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性,因<strong>接口不匹配不能一起工作的两个类可以协同工作。</strong>其别名为包装器(Wrapper)<br>适配器模式属于结构型模式<br>主要分为三类:<strong>类适配器模式、对象适配器模式、接口适配器模式</strong></p><p>工作原理</p><ul><li>适配器模式:将一个类的接口转换成另一种接口.<strong>让原本接口不兼容的类可以兼容</strong></li><li>从用户的角度看不到被适配者，是解耦的</li><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li><li>用户收到反馈结果，感觉只是和目标接口交互</li></ul><h3 id="2-类适配器模式"><a href="#2-类适配器模式" class="headerlink" title="2.类适配器模式"></a>2.类适配器模式</h3><p>基本介绍: Adapter类，通过继承src类，实现dst类接口，完成src-&gt;dst的适配。</p><h4 id="类适配器模式应用实例"><a href="#类适配器模式应用实例" class="headerlink" title="类适配器模式应用实例"></a>类适配器模式应用实例</h4><p>以生活中充电器的例子来讲解适配器，充电器本身相当于Adapter，220V交流电相当于src(即被适配者)的目dst(即目标)是5V直流电</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被适配的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出220V电压</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;电压=&quot;</span>+src+<span class="string">&quot;V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = output220V();</span><br><span class="line">        <span class="keyword">int</span> dstV = src /<span class="number">44</span>;</span><br><span class="line">        <span class="keyword">return</span> dstV;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//充电</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(IVoltage5V iVoltage5V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (iVoltage5V.output5V() == <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电压为5V，可以充电~~&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (iVoltage5V.output5V() &gt; <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;电压大于5V，不可以充电~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//电压=220V</span></span><br><span class="line"><span class="comment">//电压为5V，可以充电~~</span></span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>Java是单继承机制，所以类适配器需要<strong>继承src类这一点算是一个缺点</strong>,因为这要求dst必须是接口，有限性;</li><li>src类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。</li><li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。</li></ul><h3 id="3-对象适配器"><a href="#3-对象适配器" class="headerlink" title="3.对象适配器"></a>3.对象适配器</h3><ul><li>基本思路和类的适配器模式相同，<strong>只是将Adapter类作修改，不是继承src类</strong>，而是持有src类的实例.兼容性的问题。即:持有src类，实现 dst类接口，完成src-&gt;dst 的适配</li><li>根据“合成复用原则”，在系统中尽量使用关联关系（聚合）来替代继承关系。</li><li><strong>对象适配器模式是适配器模式常用的一种</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title">IVoltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage220V;<span class="comment">//关联关系的聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造器传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dst = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != voltage220V)&#123;</span><br><span class="line">            <span class="keyword">int</span> src = voltage220V.output220V();</span><br><span class="line">            System.out.println(<span class="string">&quot;使用对象适配器进行转换&quot;</span>);</span><br><span class="line">            dst = src / <span class="number">44</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;处理完成，输出电压为=&quot;</span>+dst);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">电压=220V</span></span><br><span class="line"><span class="comment">使用对象适配器进行转换</span></span><br><span class="line"><span class="comment">处理完成，输出电压为=5</span></span><br><span class="line"><span class="comment">电压为5V，可以充电~~</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。<br><strong>根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src 的局限性问题，也不再要求dst必须是接口。</strong></p></li><li><p>使用成本更低，更灵活。</p></li></ul><h3 id="4-接口适配器模式"><a href="#4-接口适配器模式" class="headerlink" title="4.接口适配器模式"></a>4.接口适配器模式</h3><ul><li>一些书籍称为:适配器模式(Default Adapter Pattern)或<strong>缺省</strong>适配器模式。</li><li>核心思路:<strong>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求</strong></li><li>适用于一个接口不想使用其所有的方法的情况。<br>接口适配器模式应用实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在AbsAdapter中，我们将Interface进行默认实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsAdapter</span> <span class="keyword">implements</span> <span class="title">Interface4</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m4</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbsAdapter absAdapter = <span class="keyword">new</span> AbsAdapter() &#123;</span><br><span class="line">            <span class="comment">//只需要去覆盖我们需要使用的接口方法</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;使用了m1的方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        absAdapter.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-适配器在SpringMVC中的使用"><a href="#5-适配器在SpringMVC中的使用" class="headerlink" title="5.适配器在SpringMVC中的使用"></a>5.适配器在SpringMVC中的使用</h3><ul><li>SpringMvc中的HandlerAdapter，就使用了适配器模式</li><li>SpringMVC处理请求的流程回顾</li><li>使用HandlerAdapter的原因分析:<br>可以看到处理器的类型不同，有<strong>多重实现方式，那么调用方式就不是确定的，</strong>如果需要直接调用Controller方法，需要调用的时候就得不断是使用if else来进行判断是哪一种子类然后执行。那么如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则。<br>4)代码分析+Debug源码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpController</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHttpHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;http...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSimpleHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;simple...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationController</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnnotationHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;annotation...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个Adapter接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Object handler)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多种适配器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> SimpleController;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        ((SimpleController)handler).doSimpleHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> HttpController;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        ((HttpController)handler).doHttpHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> AnnotationController;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">        ((AnnotationController)handler).doAnnotationHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;HandlerAdapter&gt; handlerAdapters = <span class="keyword">new</span> ArrayList&lt;HandlerAdapter&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DispatchServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        handlerAdapters.add(<span class="keyword">new</span> AnnotationHandlerAdapter());</span><br><span class="line">        handlerAdapters.add(<span class="keyword">new</span> HttpHandlerAdapter());</span><br><span class="line">        handlerAdapters.add(<span class="keyword">new</span> SimpleHandlerAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//此处模拟SpringMVC从request取handler的对象</span></span><br><span class="line">        <span class="comment">// 适配器可以获取到希望的Controller</span></span><br><span class="line">        <span class="comment">// HttpController controller = new HttpController();</span></span><br><span class="line">        AnnotationController controller = <span class="keyword">new</span> AnnotationController();</span><br><span class="line">        <span class="comment">//得到对应的适配器</span></span><br><span class="line">        HandlerAdapter adapter = getHandler(controller);</span><br><span class="line">        <span class="comment">//通过适配器执行对应的controller方法</span></span><br><span class="line">        adapter.handler(controller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HandlerAdapter <span class="title">getHandler</span><span class="params">(Controller controller)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据controller得到对应适配器</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters)&#123;</span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(controller))&#123;</span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DispatchServlet().doDispatch();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类适配器代替controller执行相应的方法<br><strong>扩展Controller时，只需要增加一个适配器类就完成了SpringMvC的扩展了，这就是设计模式的力量</strong></p><h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6.注意事项"></a>6.注意事项</h3><ul><li>三种命名方式，是根据 <strong>src是以怎样的形式给到Adapter</strong>(在 Adapter 里的形式）来命名的。</li><li>类适配器:以类给到，在Adapter 里，就是将<strong>src当做类，继承</strong><br>对象适配器:以对象给到，在 Adapter里，将<strong>src作为一个对象，持有</strong><br>接口适配器:以接口给到，在Adapter里，将<strong>src作为一个接口，实现</strong></li><li>Adapter模式最大的作用还是将<strong>原本不兼容的接口融合在一起工作</strong>。</li><li>实际开发中，实现起来不拘泥于我们讲解的三种经典形式</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式--建造者模式</title>
      <link href="/2021/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h3><p>需要建房子:这一过程为打桩、砌墙、封顶<br>房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不要相同的.</p><p>传统模式</p><p>设计的程序结构，过于简单，没有设计缓存层对象，程序的扩展和维护不好.也就是说，这种设计方案，把产品(即:房子)和创建产品的过程(即:建房子流程)封装在一起，耦合性增强了。</p><p>解决方案:将产品和产品建造过程解耦→建造者模式.</p><h3 id="2-建造者模式基本介绍"><a href="#2-建造者模式基本介绍" class="headerlink" title="2.建造者模式基本介绍"></a>2.建造者模式基本介绍</h3><p><strong>建造者模式(Builder Pattern）</strong>又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。<br>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们,用户不需要知道内部的具体构建细节。</p><h4 id="四个角色"><a href="#四个角色" class="headerlink" title="四个角色"></a>四个角色</h4><p><strong>Product(产品角色)</strong>:一个具体的产品对象。<br><strong>Builder(抽象建造者)</strong>:创建一个Product对象的各个部件指定的接口/抽象类。<br><strong>ConcreteBuilder(具体建造者)</strong>:实现接口，构建和装配各个部件。<br><strong>Director〈指挥者)</strong>:构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是:隔离了客户与对象的生产过程，二是:负责控制产品对象的生产过程。</p><p><img src="/2021/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/image-20210304170344883.png" alt="image-20210304170344883"></p><p>Product</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String basis;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String roofed;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Builder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象的建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> House house = <span class="keyword">new</span> House();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将建造流程写好</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造房子</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">buildHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setBasis(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setWall(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        house.setRoofed(<span class="string">&quot;普通&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>director</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指挥者，这里动态去指定制作流程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HouseBuilder houseBuilder = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过构造器传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过setter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何处理建造房子流程，交给指挥者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">constructHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();;</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//盖普通房子</span></span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">        <span class="comment">//准备创建房子的指挥者</span></span><br><span class="line">        HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector(commonHouse);</span><br><span class="line">        <span class="comment">//返回产品</span></span><br><span class="line">        House house = houseDirector.constructHouse();</span><br><span class="line">        System.out.println(house);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//House(basis=5, wall=10, roofed=普通)</span></span><br></pre></td></tr></table></figure><h3 id="3-建造者的应用"><a href="#3-建造者的应用" class="headerlink" title="3.建造者的应用"></a>3.建造者的应用</h3><p>springBuilder</p><ul><li>Appendable接口定义了多个append方法(抽象方法)，即Appendable为抽象建造者,定义了抽象方法</li><li>AbstractStringBuilder实现了Appendable接口方法，这里的 AbstractStringBuilder已经是建造者，只是不能实例化</li><li>StringBuilder即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由AbstractStringBuilder完成，而StringBuilder继承了AbstractStringBuilder</li></ul><h3 id="4-注意事项和细节"><a href="#4-注意事项和细节" class="headerlink" title="4.注意事项和细节"></a>4.注意事项和细节</h3><ul><li>客户端(使用程序)<strong>不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</strong></li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，<strong>用户使用不同的具体建造者即可得到不同的产品对象</strong></li><li><strong>可以更加精细地控制产品的创建过程。</strong>将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰,也更方便使用程序来控制创建过程</li><li><strong>增加新的具体建造者无须修改原有类库的代码</strong>，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”</li><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，<strong>如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</strong></li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.</li><li><strong>抽象工厂模式VS建造者模式</strong><br>抽象工厂模式实现<strong>对产品家族的创建，一个产品家族是这样的一系列产品:具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程</strong>，只关心什么产品由什么工厂生产即可。而建造者模式则是<strong>要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-原型模式</title>
      <link href="/2021/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>现在有一只羊，姓名为：tom,年龄为：1,颜色为：白色，请创建和tom羊属性完全相同的10只羊。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传统的方式的优缺点:</p><ul><li><p>优点是比较好理解，简单易操作。</p></li><li><p>在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低</p></li><li><p>总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活</p></li><li><p>改进的思路分析</p><blockquote><p><strong>思路</strong>: Java 中 Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份,但是需要实现clone的Java类必须要实现一个接口Cloneable,该接口表示该类能够复制且具有复制的能力→原型模式</p></blockquote></li></ul><h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><ul><li>原型模式(Prototype模式)是指:用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li><li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li><li><strong>工作原理是</strong>:通过将一个原型对象传给那个要发动创建的对象,这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone(）<img src="/2021/03/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/image-20210303180637148.png" alt="image-20210303180637148" style="zoom:67%;">1)Prototype:原型类，声明一个克隆自己的接口2) ConcretePrototype:具体的原型类，实现一个克隆自己的操作3)Client:让一个原型对象克隆自己，从而创建一个新的对象(属性一样)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//克隆该示例，使用默认的clone方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sheep = (Sheep) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;tom&quot;</span>,<span class="number">1</span>,<span class="string">&quot;白色&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Sheep sheep1 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep sheep2 = (Sheep) sheep.clone();</span><br><span class="line">        System.out.println(sheep1);</span><br><span class="line">        System.out.println(sheep2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-原型模式在Spring中的使用"><a href="#2-原型模式在Spring中的使用" class="headerlink" title="2.原型模式在Spring中的使用"></a>2.原型模式在Spring中的使用</h3><p>spring创建bean的时候使用prototype参数来创建一个bean</p><h3 id="3-深入讨论-浅拷贝和深拷贝"><a href="#3-深入讨论-浅拷贝和深拷贝" class="headerlink" title="3.深入讨论-浅拷贝和深拷贝"></a>3.深入讨论-浅拷贝和深拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>当羊属性中有一个对象的时候，会发什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">private</span> Sheep friend;  <span class="comment">//对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//克隆该示例，使用默认的clone方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sheep = (Sheep) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;tom&quot;</span>,<span class="number">1</span>,<span class="string">&quot;白色&quot;</span>);</span><br><span class="line">    sheep.setFriend(<span class="keyword">new</span> Sheep(<span class="string">&quot;jack&quot;</span>,<span class="number">2</span>,<span class="string">&quot;黑色&quot;</span>));</span><br><span class="line"></span><br><span class="line">    Sheep sheep1 = (Sheep) sheep.clone();</span><br><span class="line">    Sheep sheep2 = (Sheep) sheep.clone();</span><br><span class="line">    System.out.println(sheep1);</span><br><span class="line">    System.out.println(sheep2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于数据类型是<strong>基本数据类型</strong>的成员变量,<strong>浅拷贝会直接进行值传递</strong>，也就是将该属性值复制一份给新的对象。</li><li>对于数据类型是<strong>引用数据类型</strong>的成员变量，比如说成员变量是<strong>某个数组、某个类的对象</strong>等，那么浅拷贝会<strong>进行引用传递</strong>，也就是<strong>只是将该成员变量的引用值（内存地址）复制一份给新的对象。</strong>因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li><li>前面我们克隆羊就是浅拷贝</li><li>浅拷贝是使用默认的clone()方法来实现<br>sheep = (Sheep) super.clone();</li></ul><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul><li>复制对象的所有基本数据类型的成员变量值</li><li>为所有引用数据类型的成员变量申请存储空间，<strong>并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝</strong></li><li>深拷贝实现方式1:重写clone方法来实现深拷贝</li><li>深拷贝实现方式2:通过对象序列化实现深拷贝(推荐)</li></ul><p>clone方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepCloneableTarget</span> <span class="keyword">implements</span> <span class="title">Serializable</span>,<span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String cloneName;</span><br><span class="line">    <span class="keyword">private</span> String cloneClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeepCloneableTarget</span><span class="params">(String cloneName, String cloneClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cloneName = cloneName;</span><br><span class="line">        <span class="keyword">this</span>.cloneClass = cloneClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget; <span class="comment">//引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成深拷贝实现 - 方式1 使用clone方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Object deep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//完成对基本数据类型的克隆，包括字符串</span></span><br><span class="line">        deep = <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//对引用类型的属性，进行单独处理</span></span><br><span class="line">        DeepProtoType deepProtoType = (DeepProtoType)deep;</span><br><span class="line">        deepProtoType.deepCloneableTarget = (DeepCloneableTarget) deepCloneableTarget.clone();</span><br><span class="line">        <span class="keyword">return</span> deepProtoType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DeepProtoType d = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">        d.name = <span class="string">&quot;宋江&quot;</span>;</span><br><span class="line">        d.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">&quot;大牛&quot;</span>,<span class="string">&quot;大牛的类&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一 完成深拷贝</span></span><br><span class="line">        DeepProtoType d2 = (DeepProtoType) d.clone();</span><br><span class="line">        System.out.println(d.deepCloneableTarget.hashCode());</span><br><span class="line">        System.out.println(d2.deepCloneableTarget.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2133927002</span></span><br><span class="line"><span class="comment">1836019240</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>通过序列号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepProtoType</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DeepCloneableTarget deepCloneableTarget; <span class="comment">//引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2 通过对象的序列号实现（推荐）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建流对象</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//序列号</span></span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>); <span class="comment">//当前这个对象以对象流的方式输出</span></span><br><span class="line">            <span class="comment">//反序列化</span></span><br><span class="line">            bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            DeepProtoType copyObject = (DeepProtoType) ois.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> copyObject;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">                bis.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        DeepProtoType d = <span class="keyword">new</span> DeepProtoType();</span><br><span class="line">        d.name = <span class="string">&quot;宋江&quot;</span>;</span><br><span class="line">        d.deepCloneableTarget = <span class="keyword">new</span> DeepCloneableTarget(<span class="string">&quot;大牛&quot;</span>,<span class="string">&quot;大牛的类&quot;</span>);</span><br><span class="line">        <span class="comment">//方式2 完成深拷贝</span></span><br><span class="line">        DeepProtoType d2 = (DeepProtoType) d.deepClone();</span><br><span class="line">        System.out.println(d.name+<span class="string">&quot;********&quot;</span>+d.deepCloneableTarget.hashCode());</span><br><span class="line">        System.out.println(d.name+<span class="string">&quot;********&quot;</span>+d2.deepCloneableTarget.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ul><li>创建新的对象比较复杂时，可以利用<strong>原型模式简化对象的创建过程</strong>，同时也能够提高效率</li><li><strong>不用重新初始化对象，而是动态地获得对象运行时的状态</strong></li><li>如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码</li><li>在实现深克隆的时候可能需要比较复杂的代码</li><li>缺点:需要<strong>为每一个类配备一个克隆方法</strong>，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则，这点请注意.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop</title>
      <link href="/2021/03/02/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/"/>
      <url>/2021/03/02/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Hadoop入门"><a href="#一、Hadoop入门" class="headerlink" title="一、Hadoop入门"></a>一、Hadoop入门</h2><h3 id="1-1-Hadoop-是什么"><a href="#1-1-Hadoop-是什么" class="headerlink" title="1.1 Hadoop 是什么"></a>1.1 Hadoop 是什么</h3><ul><li>Hadoop是一个由Apache基金会所开发的<strong>分布式</strong>系统基础架构。</li><li>主要解决，海量数据的<strong>存储</strong>和海量数据的<strong>分析计算</strong>问题。</li><li>广义上来说，Hadoop通常是指一个更广泛的概念——<strong>Hadoop生态圈</strong>。</li></ul><h3 id="1-2-Hadoop-三大发行版本"><a href="#1-2-Hadoop-三大发行版本" class="headerlink" title="1.2 Hadoop 三大发行版本"></a>1.2 Hadoop 三大发行版本</h3><p>Hadoop 三大发行版本：Apache、Cloudera、Hortonworks。</p><p><strong>Apache</strong> 版本最原始（最基础）的版本，对于入门学习最好。2006</p><p>Cloudera 内部集成了很多大数据框架，对应产品 <strong>CDH</strong>。2008</p><p>Hortonworks 文档较好，对应产品 <strong>HDP</strong>。2011</p><p>Hortonworks 现在已经被 Cloudera 公司收购，推出新的品牌 <strong>CDP</strong>。 </p><h4 id="Apache-Hadoop"><a href="#Apache-Hadoop" class="headerlink" title="Apache Hadoop"></a>Apache Hadoop</h4><p>官网地址：<a href="http://hadoop.apache.org">http://hadoop.apache.org</a></p><p>下载地址：<a href="https://hadoop.apache.org/releases.html">https://hadoop.apache.org/releases.html</a></p><h4 id="Cloudera-Hadoop"><a href="#Cloudera-Hadoop" class="headerlink" title="Cloudera Hadoop"></a>Cloudera Hadoop</h4><p>官网地址：<a href="https://www.cloudera.com/downloads/cdh">https://www.cloudera.com/downloads/cdh</a></p><p>下载地址：<a href="https://docs.cloudera.com/documentation/enterprise/6/release-notes/topics/rg_cdh_6_download.html">https://docs.cloudera.com/documentation/enterprise/6/release-notes/topics/rg_cdh_6_download.html</a></p><h4 id="Hortonworks-Hadoop"><a href="#Hortonworks-Hadoop" class="headerlink" title="Hortonworks Hadoop"></a>Hortonworks Hadoop</h4><p>官网地址：<a href="https://hortonworks.com/products/data-center/hdp/">https://hortonworks.com/products/data-center/hdp/</a></p><p>下载地址：<a href="https://hortonworks.com/downloads/#data-pl">https://hortonworks.com/downloads/#data-pl</a></p><h3 id="1-3-Hadoop-优势"><a href="#1-3-Hadoop-优势" class="headerlink" title="1.3 Hadoop 优势"></a>1.3 Hadoop 优势</h3><p>1）高可靠性：Hadoop底层维护多个数据副本，所以即使Hadoop某个计算元素或存储出现故障，也不会导致数据的丢失。 </p><p>2）高扩展性：在集群间分配任务数据，可方便的扩展数以千计的节点。</p><p>3）高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理速度。</p><p>4）高容错性：能够自动将失败的任务重新分配。</p><h3 id="1-4-Hadoop-组成"><a href="#1-4-Hadoop-组成" class="headerlink" title="1.4 Hadoop 组成"></a>1.4 Hadoop 组成</h3><p>Hadoop1.x、2.x、3.x区别</p><p>在 Hadoop1.x 时 代 ，Hadoop中 的MapReduce同时处理业务逻辑运算和资源的调度，耦合性较大。 <strong>在Hadoop2.x时 代，增加 了Yarn。Yarn只负责资 源 的 调 度 ，MapReduce 只负责运算。Hadoop3.x在组成上没有变化。</strong></p><p><img src="/2021/03/02/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/image-20210302184307303.png" alt="image-20210302184307303"></p><h3 id="1-4-1-HDFS-架构概述"><a href="#1-4-1-HDFS-架构概述" class="headerlink" title="1.4.1 HDFS 架构概述"></a>1.4.1 HDFS 架构概述</h3><p>Hadoop Distributed File System，简称 HDFS，是一个分布式文件系统。</p><ul><li><p>NameNode（nn）：存储文件的<strong>元数据</strong>，如<strong>文件名，文件目录结构，文件属性</strong>（生成时间、副本数、文件权限），以及每个文件的<strong>块列表</strong>和<strong>块所在的DataNode</strong>等。</p></li><li><p>DataNode(dn)：在本地文件系统存储文件<strong>块数据</strong>，以及块<strong>数据的校验和</strong>。</p></li><li><p>Secondary NameNode(2nn)：<strong>每隔一段时间对NameNode元数据备份</strong></p></li></ul><h3 id="1-4-2-YARN-架构概述"><a href="#1-4-2-YARN-架构概述" class="headerlink" title="1.4.2 YARN 架构概述"></a>1.4.2 YARN 架构概述</h3><p>Yet Another Resource Negotiator 简称 YARN ，另一种资源协调者，是 Hadoop 的资源管理器</p><blockquote><p>1）ResourceManager（RM）：整个集群资源（内存、CPU等）的老大<br>3）ApplicationMaster（AM）：单个任务运行的老大<br>2）NodeManager（N M）：单个节点服务器资源老大<br>4）Container：容器，相当一台独立的服务器，里面封装了任务运行所需要的资源，如<strong>内存、CPU、磁盘、网络</strong>等。<br>说明1：客户端可以有多个<br>说明2：集群上可以运行多个ApplicationMaster<br>说明3：每个NodeManager上可以有多个Container</p></blockquote><h3 id="1-4-3-MapReduce-架构概述"><a href="#1-4-3-MapReduce-架构概述" class="headerlink" title="1.4.3 MapReduce 架构概述"></a>1.4.3 MapReduce 架构概述</h3><blockquote><p>MapReduce 将计算过程分为两个阶段：Map 和 Reduce<br>1）Map 阶段并行处理输入数据<br>2）Reduce 阶段对 Map 结果进行汇总</p></blockquote><h3 id="1-4-4-HDFS、YARN、MapReduce-三者关系"><a href="#1-4-4-HDFS、YARN、MapReduce-三者关系" class="headerlink" title="1.4.4 HDFS、YARN、MapReduce 三者关系"></a>1.4.4 HDFS、YARN、MapReduce 三者关系</h3><p><img src="/2021/03/02/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/image-20210302192706325.png" alt="image-20210302193038549"></p><h3 id="1-5-大数据技术生态体系"><a href="#1-5-大数据技术生态体系" class="headerlink" title="1.5 大数据技术生态体系"></a>1.5 大数据技术生态体系</h3><p><img src="/2021/03/02/%E5%A4%A7%E6%95%B0%E6%8D%AE/hadoop/image-20210302193153598.png" alt="image-20210302193153598"></p><p>1）Sqoop：Sqoop 是一款开源的工具，主要用于在 Hadoop、Hive 与传统的数据库（MySQL）<br>间进行数据的传递，可以将一个关系型数据库（例如 ：MySQL，Oracle 等）中的数据导进<br>到 Hadoop 的 HDFS 中，也可以将 HDFS 的数据导进到关系型数据库中。<br>2）Flume：Flume 是一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，<br>Flume 支持在日志系统中定制各类数据发送方，用于收集数据；<br>3）Kafka：Kafka 是一种高吞吐量的分布式发布订阅消息系统；<br>4）Spark：Spark 是当前最流行的开源大数据内存计算框架。可以基于 Hadoop 上存储的大数<br>据进行计算。<br>5）Flink：Flink 是当前最流行的开源大数据内存计算框架。用于实时计算的场景较多。<br>6）Oozie：Oozie 是一个管理 Hadoop 作业（job）的工作流程调度管理系统。<br>7）Hbase：HBase 是一个分布式的、面向列的开源数据库。HBase 不同于一般的关系数据库，<br>它是一个适合于非结构化数据存储的数据库。<br>8）Hive：Hive 是基于 Hadoop 的一个数据仓库工具，可以将结构化的数据文件映射为一张<br>数据库表，并提供简单的 SQL 查询功能，可以将 SQL 语句转换为 MapReduce 任务进行运<br>行。其优点是学习成本低，可以通过类 SQL 语句快速实现简单的 MapReduce 统计，不必开<br>发专门的 MapReduce 应用，十分适合数据仓库的统计分析。<br>9）ZooKeeper：它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、<br>名字服务、分布式同步、组服务等。</p><h2 id="二、-Hadoop-运行环境搭建"><a href="#二、-Hadoop-运行环境搭建" class="headerlink" title="二、 Hadoop 运行环境搭建"></a>二、 Hadoop 运行环境搭建</h2><h3 id="2-1-模板虚拟机环境准备"><a href="#2-1-模板虚拟机环境准备" class="headerlink" title="2.1 模板虚拟机环境准备"></a>2.1 模板虚拟机环境准备</h3><p>0）安装模板虚拟机，IP 地址 192.168.10.100、主机名称 hadoop100、内存 4G、硬盘 50G</p><p>1）hadoop100 虚拟机配置要求如下（本文 Linux 系统全部以 CentOS-7.5-x86-1804 为例） </p><blockquote><p>（1）使用 yum 安装需要虚拟机可以正常上网，yum 安装前可以先测试下虚拟机联网情<br>况</p><p>（2）安装 epel-release</p><p>注：Extra Packages for Enterprise Linux 是为“红帽系”的操作系统提供额外的软件包，</p><p>适用于 RHEL、CentOS 和 Scientific Linux。相当于是一个软件仓库，大多数 rpm 包在官方</p><p>repository 中是找不到的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# yum install -y epel-release</span><br></pre></td></tr></table></figure><p>（3）注意：如果 Linux 安装的是最小系统版，还需要安装如下工具；如果安装的是 Linux<br>桌面标准版，不需要执行如下操作</p><p>net-tool：工具包集合，包含 ifconfig 等命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# yum install -y net-tools </span><br></pre></td></tr></table></figure><p> vim：编辑器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# yum install -y vim</span><br></pre></td></tr></table></figure></blockquote><p>2）关闭防火墙，关闭防火墙开机自启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# systemctl stop firewalld</span><br><span class="line">[root@hadoop100 ~]# systemctl disable firewalld.service</span><br></pre></td></tr></table></figure><p>3）创建 atguigu 用户，并修改 atguigu 用户的密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# useradd atguigu</span><br><span class="line">[root@hadoop100 ~]# passwd atguigu</span><br></pre></td></tr></table></figure><p>4）配置 atguigu 用户具有 root 权限，方便后期加 sudo 执行 root 权限的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# vim /etc/sudoers</span><br></pre></td></tr></table></figure><p>修改/etc/sudoers 文件，在%wheel 这行下面添加一行，如下所示：</p><p>修改/etc/sudoers 文件，在%wheel 这行下面添加一行，如下所示：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## Allow root <span class="keyword">to</span> run any commands anywhere</span><br><span class="line">root ALL=(ALL) ALL</span><br><span class="line"></span><br><span class="line">## Allows people in group wheel <span class="keyword">to</span> run <span class="keyword">all</span> commands</span><br><span class="line">%wheel ALL=(ALL) ALL</span><br><span class="line"></span><br><span class="line">atguigu ALL=(ALL) NOPASSWD:ALL</span><br><span class="line">注意：atguigu 这一行不要直接放到 root 行下面，因为所有用户都属于 wheel 组，你先</span><br><span class="line">配置了 atguigu 具有免密功能，但是程序执行到%wheel 行时，该功能又被覆盖回需要</span><br><span class="line">密码。所以 atguigu 要放到%wheel 这行下面。</span><br></pre></td></tr></table></figure><p>5）在/opt 目录下创建文件夹，并修改所属主和所属组</p><blockquote><p>（1）在/opt 目录下创建 module、software 文件夹<br>[root@hadoop100 ~]# mkdir /opt/module<br>[root@hadoop100 ~]# mkdir /opt/software<br>（2）修改 module、software 文件夹的所有者和所属组均为 atguigu 用户<br>[root@hadoop100 ~]# chown atguigu:atguigu /opt/module<br>[root@hadoop100 ~]# chown atguigu:atguigu /opt/software<br>（3）查看 module、software 文件夹的所有者和所属组<br>[root@hadoop100 ~]# cd /opt/<br>[root@hadoop100 opt]# ll<br>总用量 12<br>drwxr-xr-x. 2 atguigu atguigu 4096 5 月 28 17:18 module<br>drwxr-xr-x. 2 root root 4096 9 月 7 2017 rh<br>drwxr-xr-x. 2 atguigu atguigu 4096 5 月 28 17:18 software</p></blockquote><p>6）卸载虚拟机自带的 JDK</p><p>注意：如果你的虚拟机是最小化安装不需要执行这一步。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# rpm -qa | grep -i java | xargs -n1 rpm -e </span><br><span class="line"></span><br><span class="line">--nodeps</span><br><span class="line">➢ rpm -qa：查询所安装的所有 rpm 软件包</span><br><span class="line">➢ grep -i：忽略大小写</span><br><span class="line">➢ xargs -n1：表示每次只传递一个参数</span><br><span class="line">➢ rpm -e –nodeps：强制卸载软件</span><br></pre></td></tr></table></figure><p>7）重启虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@hadoop100 ~]# reboot</span><br></pre></td></tr></table></figure><h3 id="2-2-克隆虚拟机"><a href="#2-2-克隆虚拟机" class="headerlink" title="2.2 克隆虚拟机"></a>2.2 克隆虚拟机</h3><blockquote><p>1）利用模板机 hadoop100，克隆三台虚拟机：hadoop102 hadoop103 hadoop104<br>注意：克隆时，要先关闭 hadoop100<br>2）修改克隆机 IP，以下以 hadoop102 举例说明<br>（1）修改克隆虚拟机的静态 IP<br>[root@hadoop100 ~]# vim /etc/sysconfig/network-scripts/ifcfgens33<br>改成<br>DEVICE=ens33<br>TYPE=Ethernet</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ONBOOT=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">IPADDR=192.168.10.102</span><br><span class="line">PREFIX=24</span><br><span class="line">GATEWAY=192.168.10.2</span><br><span class="line">DNS1=192.168.10.2</span><br></pre></td></tr></table></figure><h3 id="2-3-在-hadoop102-安装-JDK"><a href="#2-3-在-hadoop102-安装-JDK" class="headerlink" title="2.3 在 hadoop102 安装 JDK"></a>2.3 在 hadoop102 安装 JDK</h3><p>1）卸载现有 JDK<br>注意：安装 JDK 前，一定确保提前删除了虚拟机自带的 JDK。详细步骤见问文档 3.1 节<br>中卸载 JDK 步骤。<br>2）用 XShell 传输工具将 JDK 导入到 opt 目录下面的 software 文件夹下面</p><p>3）在 Linux 系统下的 opt 目录中查看软件包是否导入成功<br>[atguigu@hadoop102 ~]$ ls /opt/software/<br>看到如下结果：<br>jdk-8u212-linux-x64.tar.gz<br>4）解压 JDK 到/opt/module 目录下<br>[atguigu@hadoop102 software]$ tar -zxvf jdk-8u212-linuxx64.tar.gz -C /opt/module/<br>5）配置 JDK 环境变量</p><blockquote><p>（1）新建/etc/profile.d/my_env.sh 文件<br>[atguigu@hadoop102 ~]$ sudo vim /etc/profile.d/my_env.sh<br>添加如下内容<br>#JAVA_HOME<br>export JAVA_HOME=/opt/module/jdk1.8.0_212<br>export PATH=$PATH:$JAVA_HOME/bin</p><p>（2）保存后退出<br>:wq<br>（3）source 一下/etc/profile 文件，让新的环境变量 PATH 生效<br>[atguigu@hadoop102 ~]$ source /etc/profile</p></blockquote><p>6）测试 JDK 是否安装成功<br>[atguigu@hadoop102 ~]$ java -version<br>如果能看到以下结果，则代表 Java 安装成功。<br>java version “1.8.0_212”</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>component注解与Configuration的理解</title>
      <link href="/2021/02/28/%E6%A1%86%E6%9E%B6/Springboot%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/02/28/%E6%A1%86%E6%9E%B6/Springboot%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/baidu_41634343/article/details/95176401">https://blog.csdn.net/baidu_41634343/article/details/95176401</a></p><h2 id="configuration和component之间的区别"><a href="#configuration和component之间的区别" class="headerlink" title="configuration和component之间的区别"></a>configuration和component之间的区别</h2><p>@Component注解的范围最广，所有类都可以注解，但是@Configuration注解一般注解在这样的类上：<strong>这个类里面有@Value注解的成员变量和@Bean注解的方法，就是一个配置类。</strong></p><p>从定义来看，@Configuration 注解本质上还是@Component，因此context:component-scan/ 或者 @ComponentScan都能处理@Configuration注解的类。</p><p>@Configuration标记的类必须符合下面的要求：</p><p>配置类必须以类的形式提供（不能是工厂方法返回的实例），允许通过生成子类在运行时增强（cglib 动态代理）。<br> 配置类不能是 final 类（没法动态代理）。<br> 配置注解通常为了通过 @Bean 注解生成 Spring 容器管理的类，<br> 配置类必须是非本地的（即不能在方法中声明，不能是 private）。<br> 任何嵌套配置类都必须声明为static。<br> @Bean 方法可能不会反过来创建进一步的配置类（也就是返回的 bean 如果带有 @Configuration，也不会被特殊处理，只会作为普通的 bean）。<br> 加载过程</p><p>Spring  容器在启动时，会加载默认的一些PostPRocessor，其中就有ConfigurationClassPostProcessor，这个后置处理程序专门处理带有@Configuration注解的类，这个程序会在bean 定义加载完成后，在bean初始化前进行处理。主要处理的过程就是使用cglib动态代理增强类，而且是对其中带有@Bean注解的方法进行处理。</p><p>基于Java的配置我们通常使用@Configuration注解来声明Spring Bean<br> 除此之外我们还能使用@Component声明Spring Bean</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ</title>
      <link href="/2021/02/23/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/ActiveMQ/"/>
      <url>/2021/02/23/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/ActiveMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="一-初步安装使用"><a href="#一-初步安装使用" class="headerlink" title="一.   初步安装使用"></a>一.   初步安装使用</h2><p> ActiveMQ 的官网  ： <a href="http://activemq.apache.org">http://activemq.apache.org</a></p><p>ActiveMQ   </p><blockquote><p>API 接受发送<br>MQ 的高可用MQ 的集群容错配置<br>MQ 的持久化<br>延时发送/定时投递<br>签收机制<br>Spring/SpringBoot 整合 </p></blockquote><h3 id="1-为什么要使用-MQ-？"><a href="#1-为什么要使用-MQ-？" class="headerlink" title="1.为什么要使用 MQ ？"></a>1.为什么要使用 MQ ？</h3><p>微服务架构后<br>链式调用是我们在写程序时候的一般流程,为了完成一个整体功能会将其拆分成多个函数(或子模块)，比如模块A调用模块B,模块B调用模块C,模块C调用模块D。但在大型分布式应用中，系统间的RPC交互繁杂，一个功能背后要调用上百个接口并非不可能，从单机架构过渡到分布式微服务架构的通例，</p><p>系统之间接口耦合比较严重</p><blockquote><p>每新增一个下游功能，都要对上游的相关接口进行改造；<br>举个例子：如果系统A要发送数据给系统B和系统C，发送给每个系统的数据可能有差异，因此系统A对要发送给每个系统的数据进行了组装，然后逐一发送；<br>当代码上线后又新增了一个需求：<br>把数据也发送给D，新上了一个D系统也要接受A系统的数据，此时就需要修改A系统，让他感知到D系统的存在，同时把数据处理好再给D。在这个过程你会看到，每接入一个下游系统，都要对系统A进行代码改造，开发联调的效率很低。面对大流量并发时，容易被冲垮</p></blockquote><p>面对大流量并发时，容易被冲垮</p><blockquote><p>每个接口模块的吞吐能力是有限的，这个上限能力如果是堤坝，当大流量（洪水）来临时，容易被冲垮。<br>举个例子秒杀业务：<br>上游系统发起下单购买操作，我就是下单一个操作<br>下游系统完成秒杀业务逻辑<br>（读取订单，库存检查，库存冻结，余额检查，余额冻结，订单生产，余额扣减，库存减少，生成流水，余额解冻，库存解冻）</p></blockquote><p>等待同步存在性能问题</p><blockquote><p>RPC接口上基本都是同步调用，整体的服务性能遵循“木桶理论”，即整体系统的耗时取决于链路中最慢的那个接口。<br>比如A调用B/C/D都是50ms，但此时B又调用了B1，花费2000ms，那么直接就拖累了整个服务性能。</p></blockquote><h3 id="2-是什么"><a href="#2-是什么" class="headerlink" title="2.是什么"></a>2.是什么</h3><blockquote><p>1，要做到系统解耦，当新的模块接进来时，可以做到代码改动最小；能够<strong>解耦</strong><br>2，设置流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲垮；能<strong>削峰</strong><br>3，强弱依赖梳理能将非关键调用链路的操作异步化并提升整体系统的吞吐能力；能够<strong>异步</strong></p></blockquote><p><strong>面向消息的中间件（message-oriented middleware）MOM</strong>能够很好的解决以上问题，是指利用高效可靠的消息传递机制与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。<br>通过提供<strong>消息传递</strong>和<strong>消息排队</strong>模型在分布式环境下提供应用解耦，弹性伸缩，冗余存储、流量削峰，异步通信，数据同步等功能。<br>大致的过程是这样的：<br>发送者把消息发送给消息服务器，消息服务器将消息存放在若干<strong>队列/主题</strong>中，在合适的时候，消息服务器回将消息转发给接受者。在这个过程中，<strong>发送和接收是异步的</strong>，也就是发送无需等待，而且发送者和接受者的生命周期也没有必然的关系；<br>尤其在发布pub/订阅sub模式下，也可以完成一对多的通信，即让一个消息有多个接受者。</p><p>消息发送者可以发送一个消息而无须等待响应。消息发送者将消息发送到一条虚拟的通道（主题或者队列）上；<br>消息接收者则订阅或者监听该爱通道。一条消息可能最终转发给一个或者多个消息接收者，这些消息接收者都无需对消息发送者做出同步回应。整个过程都是异步的。</p><p>应用系统之间解耦合</p><ul><li>发送者和接受者不必了解对方，只需要确认消息</li><li>发送者和接受者不必同时在线</li></ul><img src="/2021/02/23/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/ActiveMQ/image-20210224154503073.png" alt="image-20210224154503073" style="zoom: 25%;"><p>实现高可用，高性能，可伸缩，易用和安全的企业级面向消息服务的系统</p><ul><li>异步消息的消费和处理</li><li>控制消息的消费顺序</li><li>可以和Spring或者SpringBoot整合简化代码</li><li>配置集群容错的MQ集群</li></ul><h3 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h3><p>1.下载  <a href="http://activemq.apache.org">http://activemq.apache.org</a></p><p>2.上传到/opt下</p><p>3.解压缩apache-activemq-5.16.1-bin.tar.gz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf  apache-activemq-5.16.1-bin.tar.gz</span><br></pre></td></tr></table></figure><p>4.拷贝到根目录myactiveMQ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r apache-activemq-5.16.1 /myactiveMq/</span><br></pre></td></tr></table></figure><p>5.启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd bin</span><br><span class="line">./activemq start</span><br></pre></td></tr></table></figure><p>6.activemq默认端口是61616</p><p>查看端口号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep activemq | grep -v grep  //屏蔽grep进程</span><br><span class="line">netstat -anp|grep 61616 查看端口是否被占用</span><br></pre></td></tr></table></figure><p>7.关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./activemq stop</span><br></pre></td></tr></table></figure><p>8.日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./activemq start &gt; /myactiveMQ/run_active.log</span><br></pre></td></tr></table></figure><h3 id="4-ActiveMQ控制台"><a href="#4-ActiveMQ控制台" class="headerlink" title="4.ActiveMQ控制台"></a>4.ActiveMQ控制台</h3><p><a href="http://127.0.0.1:8161/admin">http://127.0.0.1:8161/admin</a></p><p>默认的用户名和密码是admin/admin</p><p>访问不了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service //关闭防火墙</span><br><span class="line">systemctl status firewalld.service //查看状态</span><br></pre></td></tr></table></figure><p>服务器安装activemq，在本地浏览器无法访问8161端口，这是因为activemq默认是本地回环监听127.0.0.1，修改conf/jetty.xml文件，把127.0.0.1修改成0.0.0.0就可以了</p><p>vim ./conf/activemq.xml storeUsage 1gb 500mb</p><p>ActiveMQ采用61616端口提供JMS服务</p><p>ActiveMQ采用8161端口提供管理控制台服务</p><h2 id="二、Java编码实现ActiveMQ通讯"><a href="#二、Java编码实现ActiveMQ通讯" class="headerlink" title="二、Java编码实现ActiveMQ通讯"></a>二、Java编码实现ActiveMQ通讯</h2><h3 id="1-依赖"><a href="#1-依赖" class="headerlink" title="1.依赖"></a>1.依赖</h3><p>创建maven项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--activemq锁需要的jar包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.16.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.xbean<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xbean-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通用配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-JMS"><a href="#2-JMS" class="headerlink" title="2.JMS"></a>2.JMS</h3><p><strong>JMS</strong> :  Java  消息中间件的服务接口规范，activemq 之上是 mq  ， 而 mq 之上是JMS 定义的消息规范 。 activemq 是mq 技术的一种理论实现（与之相类似的实现还有 Kafka  RabbitMQ  RockitMQ  ），而 JMS 是更上一级的规范。</p><img src="/2021/02/23/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/ActiveMQ/image-20210224154503074.png" alt="image-20210224154503074" style="zoom:67%;"><p>在点对点的消息传递时，目的地称为 队列   queue   </p><p>在发布订阅消息传递中，目的地称为 主题   topic </p><p>JDBC连接数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一步:注册驱动(仅仅只做一次)   Class.forName(&quot;com.mysql.jdbc.com&quot;);</span><br><span class="line">第二步:建立连接(Connection)DriverManager.getConnection(url,user,password);</span><br><span class="line">第三步:创建运行SQL语句(Statement)   connection.createStatement();</span><br><span class="line">第四步:运行语句rs.executeQuery(sql);</span><br><span class="line">第五步:处理结果集(ResultSet)</span><br><span class="line">第六步:释放资源</span><br></pre></td></tr></table></figure><h3 id="3-点对点"><a href="#3-点对点" class="headerlink" title="3.点对点"></a>3.点对点</h3><h4 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMSProduce</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVEMQ_URL = <span class="string">&quot;tcp://192.168.5.128:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂,按照给定的url地址，采用默认用户名密码</span></span><br><span class="line">        ActiveMQConnectionFactory activeMQConnectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">        <span class="comment">//2.通过连接工厂，获得连接Connection +并启动访问</span></span><br><span class="line">        Connection connection = activeMQConnectionFactory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 创建会话Session</span></span><br><span class="line">        <span class="comment">//两个参数，第一个参数事务，第二个叫签收</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//4.创建目的地（队列还是主题topic）</span></span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME); <span class="comment">//接口</span></span><br><span class="line">        <span class="comment">//5.创建消息的生产者</span></span><br><span class="line">        MessageProducer producer = session.createProducer(queue);</span><br><span class="line">        <span class="comment">//6.通过消息生产者生成3天消息发送MQ队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//7.创建消息</span></span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;msg----&quot;</span> + i);<span class="comment">//字符串</span></span><br><span class="line">            <span class="comment">//8. 通过消息生产者发送mq</span></span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9.关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;********消息发布到MQ成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Number Of Pending Messages=等待消费的消息，这个是未出队列的数量，公式=总接收数-总出队列数。<br>Number Of Consumers=消费者数量，消费者端的消费者数量。<br>Messages Enqueued=进队消息数，进队列的总消息量，包括出队列的。这个数只增不减。<br>Messages Dequeued=出队消息数，可以理解为是消费者消费掉的数量。<br>总结：<br>当有一个消息进入这个队列时，等待消费的消息是1，进入队列的消息是1。<br>当消息消费后，等待消费的消息是0，进入队列的消息是1，出队列的消息是1。<br>当再来一条消息时，等待消费的消息是1，进入队列的消息就是2。</p><h4 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMSConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVEMQ_URL = <span class="string">&quot;tcp://192.168.5.128:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂,按照给定的url地址，采用默认用户名密码</span></span><br><span class="line">        ActiveMQConnectionFactory activeMQConnectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">        <span class="comment">//2.通过连接工厂，获得连接Connection +并启动访问</span></span><br><span class="line">        Connection connection = activeMQConnectionFactory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 创建会话Session</span></span><br><span class="line">        <span class="comment">//两个参数，第一个参数事务，第二个叫签收</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//4.创建目的地（队列还是主题topic）</span></span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME); <span class="comment">//接口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.创建消息的生产者</span></span><br><span class="line">        MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line">        <span class="comment">//6.同步阻塞方式(receive)</span></span><br><span class="line">        <span class="comment">//订阅者或接收者抵用MessageConsumer的receive()方法来接收消息，receive方法在能接收到消息之前（或超时之前）将一直阻塞。</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">             <span class="comment">//TextMessage textMessage = (TextMessage)consumer.receive();</span></span><br><span class="line">            TextMessage textMessage = (TextMessage)consumer.receive(<span class="number">4000L</span>);<span class="comment">//有时间限制的</span></span><br><span class="line">            <span class="keyword">if</span> ( <span class="keyword">null</span> != textMessage)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;****消费者接收到消息：&quot;</span>+textMessage.getText());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.关闭资源</span></span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;********接收到MQ成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMSConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVEMQ_URL = <span class="string">&quot;tcp://192.168.5.128:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;queue01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂,按照给定的url地址，采用默认用户名密码</span></span><br><span class="line">        ActiveMQConnectionFactory activeMQConnectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">        <span class="comment">//2.通过连接工厂，获得连接Connection +并启动访问</span></span><br><span class="line">        Connection connection = activeMQConnectionFactory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 创建会话Session</span></span><br><span class="line">        <span class="comment">//两个参数，第一个参数事务，第二个叫签收</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//4.创建目的地（队列还是主题topic）</span></span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME); <span class="comment">//接口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.创建消息的生产者</span></span><br><span class="line">        MessageConsumer consumer = session.createConsumer(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过监听的方式消费</span></span><br><span class="line">        <span class="comment">//异步非阻塞方式（监听器onMessage()）</span></span><br><span class="line">        <span class="comment">//订阅者或接收者通过MessageConsumer的setMessageListener(MessageListener listener)注册一个消息监听器，</span></span><br><span class="line"><span class="comment">//当消息到达之后，系统会自动调用监听器MessageListener的onMessage(Message message)方法。</span></span><br><span class="line">        consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> ( <span class="keyword">null</span> != message &amp;&amp; message <span class="keyword">instanceof</span> TextMessage)&#123;</span><br><span class="line">                    TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;****消费者接收到消息：&quot;</span>+textMessage.getText());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//保证控制台不灭</span></span><br><span class="line">        System.in.read();</span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里的一点经验： activemq 好像自带负载均衡，当先启动两个队列（Queue）的消费者时，在启动生产者发出消息，<strong>此时的消息平均的被两个消费者消费</strong>。 并且消费者不会消费已经被消费的消息（即为已经出队的消息）</p><p>但是当有多个主题（Topic）订阅者时，发布者发布的消息，每个订阅者都会接收所有的消息。topic 更像是被广播的消息，但是缺点是不能接受已经发送过的消息。</p><p> JMS开发的基本步骤</p><blockquote><p>1：创建一个connection factory<br>2：通过connection factory来创建JMS connection<br>3：启动JMS connection<br>4：通过JMS connection创建JMS session<br>5：创建JMS destination（目的地 队列/主题）<br>6：创建JMS producer或者创建JMS consume并设置destination<br>7：创建JMS consumer或者注册一个JMS message listener<br>8：发送(send)或者接收(receive)JMS message<br>9：关闭所有JMS资源 JMS开发的基本步骤</p></blockquote><h3 id="4-一对多"><a href="#4-一对多" class="headerlink" title="4.一对多"></a>4.一对多</h3><p>发布/订阅消息传递域的特点如下：<br>（1）生产者将消息发布到topic中，每个消息可以有多个消费者，属于1：N的关系；<br>（2）生产者和消费者之间有时间上的相关性。订阅某一个主题的消费者只能消费自<strong>它订阅之后发布的消息。</strong><br>（3）生产者生产时，topic不保存消息它是无状态的不落地，假如无人订阅就去生产，那就是一条废消息，所以，一般<strong>先启动消费者再启动生产者。</strong></p><p>JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。一句话，好比我们的微信公众号订阅</p><p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMSProduce_Topic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVEMQ_URL = <span class="string">&quot;tcp://192.168.5.128:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_NAME = <span class="string">&quot;topic01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂,按照给定的url地址，采用默认用户名密码</span></span><br><span class="line">        ActiveMQConnectionFactory activeMQConnectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">        <span class="comment">//2.通过连接工厂，获得连接Connection +并启动访问</span></span><br><span class="line">        Connection connection = activeMQConnectionFactory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 创建会话Session</span></span><br><span class="line">        <span class="comment">//两个参数，第一个参数事务，第二个叫签收</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//4.创建目的地（队列还是主题topic）</span></span><br><span class="line">        Topic topic = session.createTopic(TOPIC_NAME); <span class="comment">//接口</span></span><br><span class="line">        <span class="comment">//5.创建消息的生产者</span></span><br><span class="line">        MessageProducer producer = session.createProducer(topic);</span><br><span class="line">        <span class="comment">//6.通过消息生产者生成3天消息发送MQ队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//7.创建消息</span></span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;msg----&quot;</span> + i);<span class="comment">//字符串</span></span><br><span class="line">            <span class="comment">//8. 通过消息生产者发送mq</span></span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9.关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;********TOPIC_NAME消息发布到MQ成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMSConsumer_Topic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVEMQ_URL = <span class="string">&quot;tcp://192.168.5.128:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_NAME = <span class="string">&quot;topic01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂,按照给定的url地址，采用默认用户名密码</span></span><br><span class="line">        ActiveMQConnectionFactory activeMQConnectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">        <span class="comment">//2.通过连接工厂，获得连接Connection +并启动访问</span></span><br><span class="line">        Connection connection = activeMQConnectionFactory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 创建会话Session</span></span><br><span class="line">        <span class="comment">//两个参数，第一个参数事务，第二个叫签收</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//4.创建目的地（队列还是主题topic）</span></span><br><span class="line">        Topic topic = session.createTopic(TOPIC_NAME); <span class="comment">//接口</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.创建消息的生产者</span></span><br><span class="line">        MessageConsumer consumer = session.createConsumer(topic);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过监听的方式消费</span></span><br><span class="line">        consumer.setMessageListener((message) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="keyword">null</span> != message &amp;&amp; message <span class="keyword">instanceof</span> TextMessage)&#123;</span><br><span class="line">                TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;****消费者接收到消息：&quot;</span>+textMessage.getText());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保证控制台不灭</span></span><br><span class="line">        System.in.read();</span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动订阅者再启动生产者,不然发送的消息是废消息</p><h3 id="5-两个模式比较"><a href="#5-两个模式比较" class="headerlink" title="5. 两个模式比较"></a>5. 两个模式比较</h3><table><thead><tr><th>比较项目目</th><th>Topic模式队列</th><th>Queue模式队列</th></tr></thead><tbody><tr><td>工作模式</td><td>“订阅-发布”模式，如果当前没有订阅者，消息将会被去弃。如果有多个订阅者，那么这些订阅者都会收到消息</td><td>“负载均衡”模式，如果当前没有消费者。消息也不会丢弃;如果有多个消费者，那么—条消息也只会发送给其中一个消费者，并且要求消费者ack信息。</td></tr><tr><td>有无状态</td><td>无状态</td><td>Queue数掘默认会在mq服务器上以文件形式保存，比如Active MQ—般保存在$AMQ_HOME\data\kr-store\data下面。也可以配置成DB存储。</td></tr><tr><td>传递完整性</td><td>如果没有订阅者,消息会被丢弃</td><td>消息不会丢弃</td></tr><tr><td>处理效郭</td><td>由于消息要按服订阅者的数量进行复制,所以处理性能会随着订阅吉的增加而明显降低,并且还要结合不同消息协议自身的性能差异</td><td>由于一条消息只发送给一个消费者。所以就算消费者再多，性能也不会有明显降低。当然不同消息协议的具体性能也是有差异的</td></tr></tbody></table><h2 id="三、JMS"><a href="#三、JMS" class="headerlink" title="三、JMS"></a>三、JMS</h2><h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1. 是什么"></a>1. 是什么</h3><p>JavaEE是一套使用Java进行企业级应用开发的大家一致遵循的13个核心规范工业标准。JavaEE平台提供了一个基于组件的方法来加快设计，开发。装配及部署企业应用程序。</p><blockquote><p>1，JDBC（Java Databease）数据库连接<br>2，JNDI（Java Naming and Directory Interfaces）Java的命令和目录接口<br>3，EJB（Enterprise JavaBean）<br>4，RMI（Remote Method Invoke）远程方法调用<br>5，Java IDL（Interface Description Language）/CORBA（Common Object Broker Architecture）接口定义语言/共用对象请求代理程序体系结构<br>6，JSP（Java Server Page）<br>7，Servlet<br>8，XML（Extensible Markup Language）可标记白标记语言<br>9，JMS（Java Message Service）Java消息服务<br>10，JTA（Java Transaction API）Java事务API<br>11，JTS（Java Transaction Service）Java事务服务<br>12，JavaMail<br>13，JAF（JavaBean Activation Framework）</p></blockquote><p>什么是Java消息服务？</p><blockquote><p>Java消息服务指的是<strong>两个应用程序之间进行异步通信的API</strong>，它为标准协议和消息服务提供了一组通用接口，包括创建、发送、读取消息等，用于支持Java应用程序开发。在JavaEE中，当两个应用程序使用JMS进行通信时，它们之间不是直接相连的，而是通过一个共同的消息收发服务组件关联起来以达到解耦/异步削峰的效果。</p></blockquote><h3 id="2-四大消息中间件的对比"><a href="#2-四大消息中间件的对比" class="headerlink" title="2.四大消息中间件的对比"></a>2.四大消息中间件的对比</h3><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>PRODUCER-CUMSUMER</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>PUBLISH-SUBSCRIBE</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>REQUEST-REPLY</td><td>支持</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>API完备性</td><td>高</td><td>高</td><td>高</td><td>低(静态配置)</td></tr><tr><td>多语言支持</td><td>支持,Java优先</td><td>语言无关</td><td>支持,Java优先</td><td>支持</td></tr><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>十万级</td><td>单机万级</td></tr><tr><td>消息延迟</td><td></td><td>微秒级</td><td>毫秒级</td><td></td></tr><tr><td>可用性</td><td>高(主从)</td><td>高(主从)</td><td>非常高(分布式)</td><td>高</td></tr><tr><td>消息丢失</td><td>极低</td><td>低</td><td>理论上不会</td><td></td></tr><tr><td>消息重复</td><td></td><td>可控制</td><td>理论上会有重复</td><td></td></tr><tr><td>文档的完备性</td><td>高</td><td>高</td><td>高</td><td>中</td></tr><tr><td>提供快速入门</td><td>有</td><td>有</td><td>有</td><td>无</td></tr><tr><td>首次部署难度</td><td></td><td>低</td><td>中</td><td>高</td></tr></tbody></table><h3 id="3-JMS的组成结构和特点"><a href="#3-JMS的组成结构和特点" class="headerlink" title="3.JMS的组成结构和特点"></a>3.JMS的组成结构和特点</h3><table><thead><tr><th>JMS 部件</th><th>JMS provider</th><th>JMS producer</th><th>JMS consumer</th><th>JMS message</th></tr></thead><tbody><tr><td>含义</td><td>实现JMS 的消息中间件，也就是MQ服务器</td><td>消息生产者，创建和发送消息的客户端</td><td>消息消费者，接收和处理消息的客户端</td><td>JMS 消息，分为消息头、消息属性、消息体</td></tr></tbody></table><h4 id="5-个主要的消息头"><a href="#5-个主要的消息头" class="headerlink" title="5 个主要的消息头"></a>5 个主要的消息头</h4><table><thead><tr><th>消息头</th><th>JMSDestination</th><th>JMSDeliveryMode</th><th>JMSExpiration</th><th>JMSPriority</th><th>JMSMessageId</th></tr></thead><tbody><tr><td>含义</td><td>消息发送的目的地，主要是指Queue和Topic</td><td>是持久还是非持久</td><td>过期时间，默认永久</td><td>优先级，默认是4有0~9 ，5-9 是紧急的，0-4 是普通的</td><td>唯一标识每个消息的标识由MQ产生。</td></tr></tbody></table><p>一条持久性的消息：应该被传送“一次仅仅一次”，这就意味着如果JMS提供者出现故障，该消息并不会丢失，它会在服务器恢复之后再次传递。</p><p>一条非持久的消息：最多会传递一次，这意味着服务器出现故障，该消息将会永远丢失。</p><h4 id="5-种消息体格式："><a href="#5-种消息体格式：" class="headerlink" title="5 种消息体格式："></a>5 种消息体格式：</h4><table><thead><tr><th>5种消息体</th><th>TextMessage</th><th>Mapmessage</th><th>BytesMessage</th><th>StreamMessage</th><th>ObjectMessage</th></tr></thead><tbody><tr><td>含义</td><td>普通字符串消息，包含一个String</td><td>Map 类型的消息， k-&gt; String v -&gt; Java 基本类型</td><td>二进制数组消息，包含一个byte[]</td><td>Java 数据流消息，用标准流操作来顺序的填充读取</td><td>对象消息，包含一个可序列化的Java 对象</td></tr></tbody></table><p>消息属性：识别、去重、重点标注</p><h3 id="4-JMS的可靠性"><a href="#4-JMS的可靠性" class="headerlink" title="4.JMS的可靠性"></a>4.JMS的可靠性</h3><p>  JMS 可靠性：Persistent   持久性  、 事务 、 Acknowledge  签收</p><h4 id="PERSISTENT：持久性"><a href="#PERSISTENT：持久性" class="headerlink" title="PERSISTENT：持久性"></a>PERSISTENT：持久性</h4><p>队列queue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在队列为目的地的时候持久化消息</span></span><br><span class="line">messageProducer.setDeliveryMode(DeliveryMode.PERSISTENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列为目的地的非持久化消息</span></span><br><span class="line">messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</span><br></pre></td></tr></table></figure><p> 持久化的消息，服务器宕机后消息依旧存在，只是没有入队，当服务器再次启动，消息仍就会被消费。</p><p>但是非持久化的消息，服务器宕机后消息<strong>永远丢失</strong>。 而当你没有注明是否是持久化还是非持久化时，默认是持久化的消息。</p><p>对于目的地为主题（topic）来说，默认就是非持久化的，让主题的订阅支持化的意义在于：对于订阅了公众号的人来说，当用户手机关机，在开机后任就可以接受到关注公众号之前发送的消息。</p><p>代码实现：持久化topic 的消费者</p><p>主题topic</p><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">……    </span><br><span class="line">    connection.setClientID(<span class="string">&quot;z4&quot;</span>);</span><br><span class="line">    <span class="comment">// 前面代码相同，不复制了      </span></span><br><span class="line">      Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">      TopicSubscriber topicSubscriber = session.createDurableSubscriber(topic,<span class="string">&quot;remark...&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 5 发布订阅</span></span><br><span class="line">      connection.start();</span><br><span class="line"></span><br><span class="line">      Message message = topicSubscriber.receive();<span class="comment">// 一直等</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">null</span> != message)&#123;</span><br><span class="line">           TextMessage textMessage = (TextMessage)message;</span><br><span class="line">           System.out.println(<span class="string">&quot; 收到的持久化 topic ：&quot;</span>+textMessage.getText());</span><br><span class="line">           message = topicSubscriber.receive(<span class="number">3000L</span>);    <span class="comment">// 等1秒后meesage 为空，跳出循环，控制台关闭</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>发布者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MessageProducer messageProducer = session.createProducer(topic);</span><br><span class="line">     <span class="comment">// 6 通过messageProducer 生产 3 条 消息发送到消息队列中</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 设置持久化topic 在启动</span></span><br><span class="line">     messageProducer.setDeliveryMode(DeliveryMode.PERSISTENT); </span><br><span class="line">     connection.start();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span> ; i++) &#123;</span><br><span class="line">         <span class="comment">// 7  创建字消息</span></span><br><span class="line">         TextMessage textMessage = session.createTextMessage(<span class="string">&quot;topic_name--&quot;</span> + i);</span><br><span class="line">         <span class="comment">// 8  通过messageProducer发布消息</span></span><br><span class="line">         messageProducer.send(textMessage);</span><br><span class="line"></span><br><span class="line">         MapMessage mapMessage = session.createMapMessage();</span><br><span class="line">         <span class="comment">//    mapMessage.setString(&quot;k1&quot;,&quot;v1&quot;);</span></span><br><span class="line">         <span class="comment">//     messageProducer.send(mapMessage);</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 9 关闭资源</span></span><br><span class="line">   …… </span><br></pre></td></tr></table></figure><p>先注册，离线后再启动，消息被消费。</p><h4 id="Transaction：事务"><a href="#Transaction：事务" class="headerlink" title="Transaction：事务"></a>Transaction：事务</h4><p>createSession的第一个参数为true 为开启事务，开启事务之后必须在将消息提交，才可以在队列中看到消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Session session = connection.createSession(<span class="keyword">true</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//提交</span></span><br><span class="line">session.commit();</span><br></pre></td></tr></table></figure><p>事务偏生产者/签收偏消费者</p><p>事务开启的意义在于，如果对于多条必须同批次传输的消息，可以使用事务，如果一条传输失败，可以将事务回滚，再次传输，<strong>保证数据的完整性</strong>。</p><p> 对于消息<strong>消费者</strong>来说，开启事务的话，<strong>可以避免消息被多次消费，以及后台和服务器数据的不一致性。</strong>举个栗子：</p><p>如果消息消费的  createSession  设置为 ture  ，但是没有 commit ，此时就会造成非常严重的后果，那就是在后台看来消息已经被消费，但是对于服务器来说并没有接收到消息被消费，此时就有可能被多次消费。</p><h4 id="Acknowledge：签收"><a href="#Acknowledge：签收" class="headerlink" title="Acknowledge：签收"></a>Acknowledge：签收</h4><p>非事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Session.AUTO_ACKNOWLEDGE      自动签收，默认</span><br><span class="line"></span><br><span class="line">Session.CLIENT_ACKNOWLEDGE     手动签收</span><br><span class="line"><span class="comment">//手动签收需要acknowledge   ,不签收，就会被重复消费</span></span><br><span class="line">textMessage.acknowledge();</span><br></pre></td></tr></table></figure><p>而对于开启事务时，设置<strong>手动签收和自动签收</strong>没有多大的意义，都默认自动签收，也就是说事务的优先级更高一些。</p><p>开启事务，但不commit,就算签收也没有用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Session session = connection.createSession(<span class="keyword">true</span>,Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"><span class="comment">//Session session = connection.createSession(true,Session.CLIENT_ACKNOWLEDGE);   //  也是自动签收   </span></span><br><span class="line">  ……</span><br><span class="line">session.commit();  </span><br></pre></td></tr></table></figure><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><p>点对点模型是基于队列的，生产者发送消息到队列，消费者从队列接收消息，队列的存在使得消息的<strong>异步传输</strong>成为可能。和我们平时给朋友发送短信类似。</p><blockquote><p>1：如果在Session关闭时有部分消息被收到但还没有被签收（acknowledge），那当消费者下次连接到相同的队列时，这些消息还会被再次接收</p><p>2：队列可以长久的保存消息直到消费者收到消息。消费者不需要因为担心消息会丢失而时刻和队列保持激活的链接状态，充分体现了异步传输模式的优势</p></blockquote><p>Pub/Sub 模型定义了如何向一个内容节点发布和订阅消息，这些节点被称作topic<br>主题可以被认为是消息的传输中介，发布者（publisher）发布消息到主题，订阅者（subscribe）从主题订阅消息。<br>主题使得消息订阅者和消息发布者保持互相独立不需要解除即可保证消息的传送</p><blockquote><p>非持久订阅只有当客户端处于激活状态，也就是和MQ保持连接状态才能收发到某个主题的消息。<br>如果消费者处于离线状态，生产者发送的主题消息将会丢失作废，消费者永远不会收到。一句话：<strong>先订阅注册才能接受到发布，只给订阅者发布消息。</strong></p><p>客户端首先向MQ注册一个自己的身份ID识别号，当这个客户端处于离线时，生产者会为这个ID保存所有发送到主题的消息，当客户再次连接到MQ的时候，会根据消费者的ID得到所有当自己处于离线时发送到主题的消息<br>当持久订阅状态下，不能恢复或重新派送一个未签收的消息。持久订阅才能恢复或重新派送一个未签收的消息。</p><p><strong>当所有的消息必须被接收，则用持久订阅。当消息丢失能够被容忍，则用非持久订阅</strong></p></blockquote><h2 id="四、Broker"><a href="#四、Broker" class="headerlink" title="四、Broker"></a>四、Broker</h2><p>相当于一个ActiveMQ服务器实例</p><p>说白了，Broker其实就是实现了用代码的形式启动ActiveMQ将MQ嵌入到Java代码中，以便随时用随时启动，<br>在用的时候再去启动这样能节省了资源，也保证了可用性。</p><p>类似Redis，不同config配置文件来模拟不同的实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./activemq start xbean:file:/myactivemq/conf/activemq02.xml</span><br></pre></td></tr></table></figure><h4 id="嵌入式Broker"><a href="#嵌入式Broker" class="headerlink" title="嵌入式Broker"></a>嵌入式Broker</h4><p>用ActiveMQ Broker作为独立的消息服务器来构建Java应用。<br>ActiveMQ也支持在vm中通信基于嵌入的broker，能够无缝的集成其他java应用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--activemq锁需要的jar包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.16.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--嵌入式broker--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.xbean<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xbean-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbedBroker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//ActiveMQ也支持在vm中通信基于嵌入的broker</span></span><br><span class="line">        BrokerService brokerService = <span class="keyword">new</span> BrokerService();</span><br><span class="line">        brokerService.setPopulateJMSXUserID(<span class="keyword">true</span>);</span><br><span class="line">        brokerService.addConnector(<span class="string">&quot;tcp://127.0.0.1:61616&quot;</span>);</span><br><span class="line">        brokerService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、SpringBoot整合MQ"><a href="#五、SpringBoot整合MQ" class="headerlink" title="五、SpringBoot整合MQ"></a>五、SpringBoot整合MQ</h2><p>创建父工程pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>boot_mq_produce<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--统一管理jar包版本--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.spring.boot.version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">mybatis.spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--子模块继承之后，提供作用：锁定版本+子module不用谢groupId和version--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring boot 2.2.2--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring cloud Hoxton.SR1--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--spring cloud 阿里巴巴--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- druid--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--log4j--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列生产者pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>boot_mq_produce<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7777</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">activemq:</span></span><br><span class="line">    <span class="attr">broker-url:</span> <span class="string">tcp://192.168.5.128:61616</span> <span class="comment">#my服务器地址</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">jms:</span></span><br><span class="line">    <span class="attr">pub-sub-domain:</span> <span class="literal">false</span>   <span class="comment">#false = Queue   true = Topic</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#自己定义队列名称</span></span><br><span class="line"><span class="attr">myqueue:</span> <span class="string">boot-activemq-queue</span></span><br></pre></td></tr></table></figure><p>注入bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableJms</span>    <span class="comment">//重点，开启jms适配注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myqueue&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String myQueue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQQueue(myQueue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue_Produce</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(queue,<span class="string">&quot;*****:&quot;</span>+ UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(classes = Main_Produce.class)</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActiveMq</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Queue_Produce queue_produce;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        queue_produce.produceMsg();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定时投放"><a href="#定时投放" class="headerlink" title="定时投放"></a>定时投放</h4><p>业务类加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedDelay = 3000)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceMsgScheduled</span><span class="params">()</span></span>&#123;</span><br><span class="line">    jmsMessagingTemplate.convertAndSend(queue,<span class="string">&quot;*****:Scheduled&quot;</span>+ UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主启类加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span></span><br></pre></td></tr></table></figure><p>消费者</p><p>建maven工程</p><p>导入依赖</p><p>yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">activemq:</span></span><br><span class="line">    <span class="attr">broker-url:</span> <span class="string">tcp://192.168.5.128:61616</span> <span class="comment">#my服务器地址</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">jms:</span></span><br><span class="line">    <span class="attr">pub-sub-domain:</span> <span class="literal">false</span>   <span class="comment">#false = Queue   true = Topic</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#自己定义队列名称</span></span><br><span class="line"><span class="attr">myqueue:</span> <span class="string">boot-activemq-queue</span></span><br></pre></td></tr></table></figure><p>业务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue_Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;$&#123;myqueue&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(TextMessage textMessage)</span> <span class="keyword">throws</span> JMSException</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*********消费者收到消息&quot;</span>+textMessage.getText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7777</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">activemq:</span></span><br><span class="line">    <span class="attr">broker-url:</span> <span class="string">tcp://192.168.5.128:61616</span> <span class="comment">#my服务器地址</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">jms:</span></span><br><span class="line">    <span class="attr">pub-sub-domain:</span> <span class="literal">true</span>   <span class="comment">#false = Queue   true = Topic</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#自己定义队列名称</span></span><br><span class="line"><span class="attr">myqueue:</span> <span class="string">boot-activemq-queue</span></span><br><span class="line"><span class="attr">myTopic:</span> <span class="string">boot-activemq-topic</span></span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableJms</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myTopic&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String topicName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Topic <span class="title">topic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQTopic(topicName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Topic_Produce</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Topic topic;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = 3000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceTopic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jmsMessagingTemplate.convertAndSend(topic,<span class="string">&quot;主题消息：&quot;</span>+ UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者</p><p>yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">activemq:</span></span><br><span class="line">    <span class="attr">broker-url:</span> <span class="string">tcp://192.168.5.128:61616</span> <span class="comment">#my服务器地址</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">jms:</span></span><br><span class="line">    <span class="attr">pub-sub-domain:</span> <span class="literal">true</span>   <span class="comment">#false = Queue   true = Topic</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#自己定义队列名称</span></span><br><span class="line"><span class="attr">myqueue:</span> <span class="string">boot-activemq-queue</span></span><br><span class="line"><span class="attr">myTopic:</span> <span class="string">boot-activemq-topic</span></span><br></pre></td></tr></table></figure><p>业务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Topic_Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;$&#123;myTopic&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(TextMessage textMessage)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*********消费者收到消息&quot;</span>+textMessage.getText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、activeMQ的传输协议"><a href="#六、activeMQ的传输协议" class="headerlink" title="六、activeMQ的传输协议"></a>六、activeMQ的传输协议</h2><p>61616如何改端口？</p><p>你生产上的连接协议如何配置的？使用tcp吗？</p><p><a href="http://activemq.apache.org/configuring-version-5-transports.html">http://activemq.apache.org/configuring-version-5-transports.html</a></p><p>ActiveMQ支持的client-broker通讯协议有：TVP、NIO、UDP、SSL、Http(s)、VM。<br>其中配置Transport Connector的文件在ActiveMQ安装目录的conf/activemq.xml中的<transportConnectors>标签之内。</transportConnectors></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DOS protection, limit concurrent connections to 1000 and frame size to 100MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;openwire&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;tcp://0.0.0.0:61616?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;amqp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;amqp://0.0.0.0:5672?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;stomp&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;stomp://0.0.0.0:61613?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;mqtt&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;mqtt://0.0.0.0:1883?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;ws&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;ws://0.0.0.0:61614?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上文给出的配置信息中，<br>URI描述信息的头部都是采用协议名称：例如<br>描述amqp协议的监听端口时，采用的URI描述格式为“amqp://······”；<br>描述Stomp协议的监听端口时，采用URI描述格式为“stomp://······”；<br>唯独在进行openwire协议描述时，URI头却采用的“tcp://······”。这是因为ActiveMQ中默认的消息协议就是openwire</p><h3 id="传输协议有哪些"><a href="#传输协议有哪些" class="headerlink" title="传输协议有哪些"></a>传输协议有哪些</h3><h4 id="1-Transmission-Control-Protocol-TCP-默认"><a href="#1-Transmission-Control-Protocol-TCP-默认" class="headerlink" title="1.Transmission Control Protocol(TCP)默认"></a>1.Transmission Control Protocol(TCP)默认</h4><pre><code>1.这是默认的Broker配置，TCP的Client监听端口616162.在网络传输数据前，必须要先序列化数据，消息是通过一个叫wire protocol的来序列化成字节流。3.TCP连接的URI形式如：tcp://HostName:port?key=value&amp;key=value，后面的参数是可选的。4.TCP传输的的优点：       (4.1)TCP协议传输可靠性高，稳定性强       (4.2)高效率：字节流方式传递，效率很高       (4.3)有效性、可用性：应用广泛，支持任何平台5.关于Transport协议的可选配置参数可以参考官网http://activemq.apache.org/configuring-version-5-transports.html</code></pre><h4 id="2-New-I-O-API-Protocol-NIO"><a href="#2-New-I-O-API-Protocol-NIO" class="headerlink" title="2.New I/O API Protocol(NIO)"></a>2.New I/O API Protocol(NIO)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.NIO协议和TCP协议类似，但NIO更侧重于底层的访问操作。它允许开发人员对同一资源可有更多的client调用和服务器端有更多的负载。</span><br><span class="line">2.适合使用NIO协议的场景：</span><br><span class="line">(2.1)可能有大量的Client去连接到Broker上，一般情况下，大量的Client去连接Broker是被操作系统的线程所限制的。因此，NIO的实现比TCP需要更少的线程去运行，所以建议使用NIO协议。</span><br><span class="line">(2.2)可能对于Broker有一个很迟钝的网络传输，NIO比TCP提供更好的性能。</span><br><span class="line">3.NIO连接的URI形式：nio://hostname:port?key=value&amp;key=value</span><br><span class="line">4.关于Transport协议的可选配置参数可以参考官网http://activemq.apache.org/configuring-version-5-transports.html</span><br></pre></td></tr></table></figure><h3 id="nio案例演示"><a href="#nio案例演示" class="headerlink" title="nio案例演示"></a>nio案例演示</h3><p><a href="http://activemq.apache.org/configuring-version-5-transports.html">http://activemq.apache.org/configuring-version-5-transports.html</a></p><p>修改activemq.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;nio&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;nio://0.0.0.0:61618?trace=true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transportConnectors</span>&gt;</span></span><br><span class="line">如果你不特别指定ActiveMQ的网络监听端口，那么这些端口都讲使用BIO网络IO模型</span><br><span class="line">所以为了首先提高单节点的网络吞吐性能，我们需要明确指定ActiveMQ网络IO模型。</span><br><span class="line">如下所示：URI格式头以“nio”开头，表示这个端口使用以TCP协议为基础的NIO网络IO模型。</span><br></pre></td></tr></table></figure><p>修改普通代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVEMQ_URL = <span class="string">&quot;nio://192.168.5.128:61618&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;transport&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="nio增强"><a href="#nio增强" class="headerlink" title="nio增强"></a>nio增强</h3><p>URI格式以”nio”开头，代表这个端口使用TCP协议为基础的NIO网络模型。<br>但是这样的设置方式，只能使这个端口支持Openwire协议。</p><p>我们怎么能够让这个端口既支持NIO网络模型，又让他支持多个协议呢？</p><p><a href="http://activemq.apache.org/auto">http://activemq.apache.org/auto</a></p><p>使用”+”符号来为端口设置多种特性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">&quot;auto+nio&quot;</span> <span class="attr">uri</span>=<span class="string">&quot;auto+nio://localhost:5671&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="七、ActiveMQ的消息存储和持久化"><a href="#七、ActiveMQ的消息存储和持久化" class="headerlink" title="七、ActiveMQ的消息存储和持久化"></a>七、ActiveMQ的消息存储和持久化</h2><p><a href="http://activemq.apache.org/persistence">http://activemq.apache.org/persistence</a></p><h3 id="1-是什么-1"><a href="#1-是什么-1" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>为了避免意外宕机以后丢失信息，需要做到重启后可以恢复消息队列，消息系统一半都会采用持久化机制。<br>ActiveMQ的消息持久化机制有JDBC，AMQ，KahaDB和LevelDB，无论使用哪种持久化方式，消息的存储逻辑都是一致的。</p><p>就是在发送者将消息发送出去后，消息中心首先将消息存储到本地数据文件、内存数据库或者远程数据库等。再试图将消息发给接收者，成功则将消息<strong>从存储中删除</strong>，失败则继续尝试尝试发送。</p><p>消息中心启动以后，要先检查指定的存储位置是否有未成功发送的消息，如果有，则会先把存储位置中的消息发出去。</p><h3 id="2-有哪些"><a href="#2-有哪些" class="headerlink" title="2.有哪些"></a>2.有哪些</h3><h4 id="AMQ-Mesage-Store-了解）"><a href="#AMQ-Mesage-Store-了解）" class="headerlink" title="AMQ Mesage Store(了解）"></a>AMQ Mesage Store(了解）</h4><p>基于文件的存储方式，是以前的默认消息存储，现在不用了</p><h4 id="KahaDB消息存储-默认"><a href="#KahaDB消息存储-默认" class="headerlink" title="KahaDB消息存储(默认)"></a>KahaDB消息存储(默认)</h4><p>基于日志文件，从ActiveMQ5.4开始默认的持久化插件</p><p><a href="http://activemq.aache.org/kahadb">http://activemq.aache.org/kahadb</a></p><blockquote><p>KahaDB是目前默认的存储方式，可用于任何场景，提高了性能和恢复能力。<br><strong>消息存储使用一个事务日志和仅仅用一个索引文件来存储它所有的地址。</strong><br>KahaDB是一个专门针对消息持久化的解决方案，它对典型的消息使用模型进行了优化。<br>数据被追加到data logs中。当不再需要log文件中的数据的时候，log文件会被丢弃。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">KahaDB在消息保存的目录中有4类文件和一个lock，跟ActiveMQ的其他几种文件存储引擎相比，这就非常简洁了。</span><br><span class="line"></span><br><span class="line">1，db-number.log</span><br><span class="line">    KahaDB存储消息到预定大小的数据纪录文件中，文件名为db-number.log。当数据文件已满时，一个新的文件会随之创建，number数值也会随之递增，它随着消息数量的增多，如没32M一个文件，文件名按照数字进行编号，如db-1.log，db-2.log······。当不再有引用到数据文件中的任何消息时，文件会被删除或者归档。</span><br><span class="line"></span><br><span class="line">2，db.data</span><br><span class="line">    该文件包含了持久化的BTree索引，索引了消息数据记录中的消息，它是消息的索引文件，本质上是B-Tree（B树），使用B-Tree作为索引指向db-number。log里面存储消息。</span><br><span class="line"></span><br><span class="line">3，db.free</span><br><span class="line">    当问当前db.data文件里面哪些页面是空闲的，文件具体内容是所有空闲页的ID</span><br><span class="line"></span><br><span class="line">4，db.redo</span><br><span class="line">    用来进行消息恢复，如果KahaDB消息存储再强制退出后启动，用于恢复BTree索引。</span><br><span class="line"></span><br><span class="line">5，lock</span><br><span class="line">    文件锁，表示当前kahadb独写权限的broker。</span><br></pre></td></tr></table></figure><h4 id="JDBC消息存储-重点"><a href="#JDBC消息存储-重点" class="headerlink" title="JDBC消息存储(重点)"></a>JDBC消息存储(重点)</h4><h4 id="LevelDB消息存储-了解"><a href="#LevelDB消息存储-了解" class="headerlink" title="LevelDB消息存储(了解)"></a>LevelDB消息存储(了解)</h4><p>这种文件系统是从ActiveMQ5.8之后引进的，它和KahaDB非常相似，也是基于文件的本地数据库存储形式，但是它提供比KahaDB更快的持久性。<br>但它不使用自定义B-Tree实现来索引独写日志，而是使用基于LevelDB的索引</p><p>默认配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">levelDB</span> <span class="attr">directory</span>=<span class="string">&quot;activemq-data&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="JDBC-Message-Store-with-ActiveMQ-Journal"><a href="#JDBC-Message-Store-with-ActiveMQ-Journal" class="headerlink" title="JDBC Message Store with ActiveMQ Journal"></a>JDBC Message Store with ActiveMQ Journal</h4><h3 id="3-JDBC存储消息"><a href="#3-JDBC存储消息" class="headerlink" title="3.JDBC存储消息"></a>3.JDBC存储消息</h3><p>MQ+MySQL</p><h4 id="1-添加mysql数据库的驱动包到lib文件夹"><a href="#1-添加mysql数据库的驱动包到lib文件夹" class="headerlink" title="1.添加mysql数据库的驱动包到lib文件夹"></a>1.添加mysql数据库的驱动包到lib文件夹</h4><p><a href="https://downloads.mysql.com/archives/c-j/">https://downloads.mysql.com/archives/c-j/</a></p><h4 id="2-jdbcPersistenceAdapter配置"><a href="#2-jdbcPersistenceAdapter配置" class="headerlink" title="2.jdbcPersistenceAdapter配置"></a>2.jdbcPersistenceAdapter配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">修改activemq.xml配置文件</span><br><span class="line">修改前的KahaDB修改后的jdbcPersisteceAdapter</span><br><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;<span class="name">kahaDB</span> <span class="attr">directory</span>=<span class="string">&quot;$&#123;activemq.data&#125;/kahadb&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span>              </span><br><span class="line"><span class="tag">&lt;<span class="name">jdbcPersistenceAdapter</span> <span class="attr">dataSource</span>=<span class="string">&quot;#mysql-ds&quot;</span>/&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">dataSource是指定将要引用的持久化数据库的bean名称。</span><br><span class="line">createTableOnStartup是否在启动的时候创建数据库表，默认是true，这样每次启动都会去创建表了，一般是第一次启动的时候设置为true，然后再去改成false。</span><br></pre></td></tr></table></figure><h4 id="3-数据库连接池配置"><a href="#3-数据库连接池配置" class="headerlink" title="3.数据库连接池配置"></a>3.数据库连接池配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mysql-ds&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp2.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://192.168.1.239:3306/activemq?relaxAutoCommit=true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;poolPreparedStatements&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>&lt;</span><br></pre></td></tr></table></figure><h4 id="4-建库SQL和创表说明"><a href="#4-建库SQL和创表说明" class="headerlink" title="4.建库SQL和创表说明"></a>4.建库SQL和创表说明</h4><p>建一个名为activemq的数据库</p><p>三张表的说明</p><p>ACTIVEMQ_MSGS</p><blockquote><p>ID：自增的数据库主键<br>CONTAINER：消息的Destination<br>MSGID_PROD：消息发送者的主键<br>MSG_SEQ：是发送消息的顺序，MSGID_PROD+MSG_SEQ可以组成JMS的MessageID<br>EXPIRATION：消息的过期时间，存储的是从1970-01-01到现在的毫秒数<br>MSG：消息本体的Java序列化对象的二进制数据<br>PRIORITY：优先级，从0-9，数值越大优先级越高</p></blockquote><p>ACTIVEMQ_ACKS</p><blockquote><p>用于存储订阅关系，如果持久化Topic,订阅者和服务器的订阅关系在这个表保存</p></blockquote><p>ACTIVEMQ_LOCK</p><blockquote><p>表ACTIVEMQ_LOCK在集群环境下才有用，只有一个Broker可以获取消息，称为Master Broker，其他的只能作为备份等待Master Broker不可用，才可能成为下一个Master Broker。这个表用于记录哪个Broker是当前的Master Broker</p></blockquote><p>如果新建数据库ok，上述配置ok，代码运行ok，3张表会自动生成</p><p>如果表没生成，可能需要自己创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">-- auto-generated definition</span><br><span class="line">create table ACTIVEMQ_ACKS</span><br><span class="line">(</span><br><span class="line">    CONTAINER     varchar(250)     not null comment &#x27;消息的Destination&#x27;,</span><br><span class="line">    SUB_DEST      varchar(250)     null comment &#x27;如果使用的是Static集群，这个字段会有集群其他系统的信息&#x27;,</span><br><span class="line">    CLIENT_ID     varchar(250)     not null comment &#x27;每个订阅者都必须有一个唯一的客户端ID用以区分&#x27;,</span><br><span class="line">    SUB_NAME      varchar(250)     not null comment &#x27;订阅者名称&#x27;,</span><br><span class="line">    SELECTOR      varchar(250)     null comment &#x27;选择器，可以选择只消费满足条件的消息，条件可以用自定义属性实现，可支持多属性AND和OR操作&#x27;,</span><br><span class="line">    LAST_ACKED_ID bigint           null comment &#x27;记录消费过消息的ID&#x27;,</span><br><span class="line">    PRIORITY      bigint default 5 not null comment &#x27;优先级，默认5&#x27;,</span><br><span class="line">    XID           varchar(250)     null,</span><br><span class="line">    primary key (CONTAINER, CLIENT_ID, SUB_NAME, PRIORITY)</span><br><span class="line">)</span><br><span class="line">    comment &#x27;用于存储订阅关系。如果是持久化Topic，订阅者和服务器的订阅关系在这个表保存&#x27;;</span><br><span class="line"></span><br><span class="line">create index ACTIVEMQ_ACKS_XIDX</span><br><span class="line">    on ACTIVEMQ_ACKS (XID);</span><br><span class="line"></span><br><span class="line">-- auto-generated definition</span><br><span class="line">create table ACTIVEMQ_LOCK</span><br><span class="line">(</span><br><span class="line">    ID          bigint       not null</span><br><span class="line">        primary key,</span><br><span class="line">    TIME        bigint       null,</span><br><span class="line">    BROKER_NAME varchar(250) null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- auto-generated definition</span><br><span class="line">create table ACTIVEMQ_MSGS</span><br><span class="line">(</span><br><span class="line">    ID         bigint       not null</span><br><span class="line">        primary key,</span><br><span class="line">    CONTAINER  varchar(250) not null,</span><br><span class="line">    MSGID_PROD varchar(250) null,</span><br><span class="line">    MSGID_SEQ  bigint       null,</span><br><span class="line">    EXPIRATION bigint       null,</span><br><span class="line">    MSG        blob         null,</span><br><span class="line">    PRIORITY   bigint       null,</span><br><span class="line">    XID        varchar(250) null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create index ACTIVEMQ_MSGS_CIDX</span><br><span class="line">    on ACTIVEMQ_MSGS (CONTAINER);</span><br><span class="line"></span><br><span class="line">create index ACTIVEMQ_MSGS_EIDX</span><br><span class="line">    on ACTIVEMQ_MSGS (EXPIRATION);</span><br><span class="line"></span><br><span class="line">create index ACTIVEMQ_MSGS_MIDX</span><br><span class="line">    on ACTIVEMQ_MSGS (MSGID_PROD, MSGID_SEQ);</span><br><span class="line"></span><br><span class="line">create index ACTIVEMQ_MSGS_PIDX</span><br><span class="line">    on ACTIVEMQ_MSGS (PRIORITY);</span><br><span class="line"></span><br><span class="line">create index ACTIVEMQ_MSGS_XIDX</span><br><span class="line">    on ACTIVEMQ_MSGS (XID);</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/jia970426/article/details/104516383">https://blog.csdn.net/jia970426/article/details/104516383</a></p><p>数据库授权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; grant all privileges on db_name.* to usr_name@&#x27;%&#x27; identified by &#x27;pwd&#x27;;</span><br><span class="line"></span><br><span class="line">其中，db_name 是数据库名， usr_name 用户名， pwd 密码。&#x27;%&#x27; 为通配符。</span><br><span class="line"></span><br><span class="line">mysql &gt; flush privileges ;</span><br></pre></td></tr></table></figure><h4 id="5-代码运行验证"><a href="#5-代码运行验证" class="headerlink" title="5.代码运行验证"></a>5.代码运行验证</h4><p>一定要开启持久化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageProducer.setDeliveryMode(DeliveryMode.PERSISTENT);</span><br></pre></td></tr></table></figure><h4 id="6-数据库情况"><a href="#6-数据库情况" class="headerlink" title="6.数据库情况"></a>6.数据库情况</h4><p>在点对点类型中</p><blockquote><p>当DeliveryMode设置为NON_PERSISTENCE时，消息被保存在内存中<br>当DeliveryMode设置为PERSISTENCE时，消息保存在broker的相应的文件或者数据库中。</p><p>而且点对点类型中消息一旦被Consumer消费，就从数据中删除 </p><p>消费前的消息,会被存放到数据库</p><p> 上面的消息被消费后被MQ自动删除</p></blockquote><p>设置了持久订阅数据库里面会保存订阅者的信息</p><p>ACTIVEMQ_ACKS表中的LAST_ACKED_ID记录了CLIENT_ID最后签收的一条消息</p><p>而LAST_ACKED_ID和ACTIVEMQ_MSGS的ID字段是外键关联关系，这样就可以实现，Topic的消息保存到ACTIVEMQ_MSGS表内，还能根据ACTIVEMQ_ACKS表中的持久订阅者查到该订阅者上次收到的最后一条消息是什么</p><p>值得注意的是，Topic内的消息是不会被删除的，而Queue的消息在被删除后，会在数据库中被删除，如果需要保存Queue，应该使用其他方案解决</p><h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h4><p>如果是queue<br>在没有消费者消费的情况下会将消息保存到activemq_msgs表中，只要有任意一个消费者消费了，就会删除消费过的消息</p><p>如果是topic，<br>一般是先启动消费订阅者然后再生产的情况下会将持久订阅者永久保存到qctivemq_acks，而消息则永久保存在activemq_msgs，<br>在acks表中的订阅者有一个last_ack_id对应了activemq_msgs中的id字段，这样就知道订阅者最后收到的消息是哪一条。</p><h4 id="8-开发"><a href="#8-开发" class="headerlink" title="8.开发"></a>8.开发</h4><p>在配置关系型数据库作为ActiveMQ的持久化存储方案时，有坑</p><p><strong>数据库jar包</strong><br>注意把对应版本的数据库jar或者你自己使用的非自带的数据库连接池jar包</p><p><strong>createTablesOnStartup属性</strong><br>默认为true，每次启动activemq都会自动创建表，在第一次启动后，应改为false，避免不必要的损失。</p><p><strong>java.lang.IllegalStateException: LifecycleProcessor not initialized</strong><br>确认计算机主机名名称没有下划线</p><h4 id="4-JDBC-Message-store-with-ActiveMQ-Journal"><a href="#4-JDBC-Message-store-with-ActiveMQ-Journal" class="headerlink" title="4.JDBC Message store with ActiveMQ Journal"></a>4.JDBC Message store with ActiveMQ Journal</h4><p>这种方式克服了JDBC Store的不足，JDBC每次消息过来，都需要去写库读库。<br>ActiveMQ Journal，使用高速缓存写入技术，大大提高了性能。</p><p>当消费者的速度能够及时跟上生产者消息的生产速度时，journal文件能够大大减少需要写入到DB中的消息。<br>举个例子：<br>生产者生产了1000条消息，这1000条消息会保存到journal文件，如果消费者的消费速度很快的情况下，在journal文件还没有同步到DB之前，消费者已经消费了90%的以上消息，那么这个时候只需要同步剩余的10%的消息到DB。如果消费者的速度很慢，这个时候journal文件可以使消息以批量方式写到DB。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">修改配置前</span><br><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="name">jdbcPersistenceAdapter</span> <span class="attr">dataSource</span>=<span class="string">&quot;#mysql-ds&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persistenceFactory</span>&gt;</span>                      <span class="tag">&lt;<span class="name">journalPersistenceAdapterFactory</span>                                    <span class="attr">journalLogFiles</span>=<span class="string">&quot;5&quot;</span>                                    <span class="attr">journalLogFileSize</span>=<span class="string">&quot;32768&quot;</span>                                    <span class="attr">useJournal</span>=<span class="string">&quot;true&quot;</span>                                    <span class="attr">useQuickJournal</span>=<span class="string">&quot;true&quot;</span>                                    </span></span><br><span class="line"><span class="tag"><span class="attr">dataSource</span>=<span class="string">&quot;#mysql-ds&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">dataDirectory</span>=<span class="string">&quot;../activemq-data&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">persistenceFactory</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以前是实时写入mysql，在使用了journal后，数据会被journal处理，如果在一定时间内journal处理（消费）完了，就不写入mysql，如果没消费完，就写入mysql，起到一个缓存的作用</p><h3 id="5-持久化总结"><a href="#5-持久化总结" class="headerlink" title="5.持久化总结"></a>5.持久化总结</h3><p><strong>持久化消息主要指的是：</strong><br>MQ所在服务器宕机了消息不会丢试的机制。</p><p><strong>持久化机制演变的过程：</strong><br>从最初的AMQ Message Store方案到ActiveMQ V4版本退出的High Performance Journal（高性能事务支持）附件，并且同步推出了关于关系型数据库的存储方案。ActiveMQ5.3版本又推出了对KahaDB的支持（5.4版本后被作为默认的持久化方案），后来ActiveMQ 5.8版本开始支持LevelDB，到现在5.9提供了标准的Zookeeper+LevelDB集群化方案。</p><p><strong>ActiveMQ消息持久化机制有：</strong><br>AMQ              基于日志文件<br>KahaDB          基于日志文件，从ActiveMQ5.4开始默认使用<br>JDBC              基于第三方数据库<br>Replicated LevelDB Store 从5.9开始提供了LevelDB和Zookeeper的数据复制方法，用于Master-slave方式的首选数据复制方案。</p><h2 id="七-ActiveMQ的多节点集群"><a href="#七-ActiveMQ的多节点集群" class="headerlink" title="七.ActiveMQ的多节点集群"></a>七.ActiveMQ的多节点集群</h2><p>引入消息中间件后如何保证其高可用？</p><p>基于zookeeper和LevelDB搭建ActiveMQ集群。集群仅提供主备方式的高可用集群功能，避免单点故障。</p><h3 id="zookeeper-replicated-leveldb-store的主从集群"><a href="#zookeeper-replicated-leveldb-store的主从集群" class="headerlink" title="zookeeper+replicated-leveldb-store的主从集群"></a>zookeeper+replicated-leveldb-store的主从集群</h3><h4 id="三种集群"><a href="#三种集群" class="headerlink" title="三种集群"></a>三种集群</h4><p>基于shareFileSystem共享文件系统（KahaDB）</p><p>基于JDBC</p><p>基于可复制的LevelDB</p><p><a href="http://activemq.apache.org/replicated-leveldb-store">http://activemq.apache.org/replicated-leveldb-store</a></p><h4 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h4><p><a href="http://activemq.apache.org/replicated-leveldb-store">http://activemq.apache.org/replicated-leveldb-store</a></p><blockquote><p>使用Zookeeper集群注册所有的ActiveMQ Broker但只有其中一个Broker可以提供服务，它将被视为Master,其他的Broker处于待机状态被视为Slave。<br>如果Master因故障而不能提供服务，Zookeeper会从Slave中选举出一个Broker充当Master。Slave连接Master并同步他们的存储状态，Slave不接受客户端连接。所有的存储操作都将被复制到连接至Maste的Slaves。<br>如果Master宕机得到了最新更新的Slave会变成Master。故障节点在恢复后会重新加入到集群中并连接Master进入Slave模式。</p><p>所有需要同步的消息操作都将等待存储状态被复制到其他法定节点的操作完成才能完成。<br>所以，如给你配置了replicas=3，name法定大小是（3/2）+1 = 2。Master将会存储更新然后等待（2-1）=1个Slave存储和更新完成，才汇报success，至于为什么是2-1，zookeeper讲解过自行复习。<br>有一个ode要作为观察者存在。当一个新的Master被选中，你需要至少保障一个法定mode在线以能够找到拥有最新状态的ode，这个ode才可以成为新的Master。</p><p>因此，推荐运行至少3个replica nodes以防止一个node失败后服务中断。</p></blockquote><p>配置集群步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1,创建我们自己的文件夹存放Zookeeper</span><br><span class="line">mkdir /my_zookeeper</span><br><span class="line"> </span><br><span class="line">2,下载Zookeeper</span><br><span class="line">wget -P /my_zookeeper/ https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.5.6/apache-zookeeper-3.5.6-bin.tar.gz</span><br><span class="line"> </span><br><span class="line">3,解压</span><br><span class="line">tar -zxvf apache-zookeeper-3.5.6-bin.tar.g</span><br><span class="line"> </span><br><span class="line">4,修改配置文件</span><br><span class="line">文件名必须叫这个zoo.cfg</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br><span class="line">设置一下自定义的数据文件夹(注意要手动创建这个目录,后面会用到),,注意最后一定要有/结尾,没有/会报错这是坑</span><br><span class="line">dataDir=/my_zookeeper/apache-zookeeper-3.5.6-bin/data/</span><br><span class="line">在zoo.cfg件最后面追加集群服务器</span><br><span class="line">server.1=192.168.10.130:2888:3888</span><br><span class="line">server.2=192.168.10.132:2888:3888</span><br><span class="line">server.3=192.168.10.133:2888:3888</span><br><span class="line"> </span><br><span class="line">server.1=leantaot-zk-01:2888:3888</span><br><span class="line">1是一个数字，标识这个是第几号服务器</span><br><span class="line">leantaot-zk-01是这个服务器的IP地址（或者是与IP地址做了映射的主机名）</span><br><span class="line">2888第一个端口用来集群成员的信息交换，标识这个服务器与集群中的leader服务器交换信息的端口</span><br><span class="line">3888是在leader挂掉时专门用来进行选举leader所用的端口</span><br><span class="line"> </span><br><span class="line">6.把刚刚配置好的Zookeeper整个文件夹远程推送到其他服务器的/my_zookeeper文件夹内</span><br><span class="line">scp -r /my_zookeeper/ root@192.168.10.132:/</span><br><span class="line">scp -r /my_zookeeper/ root@192.168.10.133:/ </span><br><span class="line"> </span><br><span class="line">7.创建myid文件， id 与 zoo.cfg 中的序号对应</span><br><span class="line">在192.168.10.130机器上执行</span><br><span class="line">echo 1 &gt; /my_zookeeper/apache-zookeeper-3.5.6-bin/data/zookeeper_server.pid</span><br><span class="line">echo 1 &gt; /my_zookeeper/apache-zookeeper-3.5.6-bin/data/myid</span><br><span class="line">在192.168.10.132机器上执行</span><br><span class="line">echo 2 &gt; /my_zookeeper/apache-zookeeper-3.5.6-bin/data/zookeeper_server.pid</span><br><span class="line">echo 2 &gt; /my_zookeeper/apache-zookeeper-3.5.6-bin/data/myid</span><br><span class="line">在192.168.10.133机器上执行</span><br><span class="line">echo 3 &gt; /my_zookeeper/apache-zookeeper-3.5.6-bin/data/zookeeper_server.pid</span><br><span class="line">echo 3 &gt; /my_zookeeper/apache-zookeeper-3.5.6-bin/data/myid</span><br><span class="line"> </span><br><span class="line">8.bin目录下启动Zookeeper做测试</span><br><span class="line"> ./zkServer.sh start</span><br><span class="line">输出</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /my_zookeeper/apache-zookeeper-3.5.6-bin/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... already running as process 1.</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>5.创建3台集群目录</strong></p><p>就是一台电脑复制三份ActiveMQ</p><p><strong>6.修改管理控制台端口</strong></p><p>就是ActiveMQ后台管理页面的访问端口</p><p>node1不改</p><p>jetty.xml port</p><p><strong>7.hostname名字映射(如果不映射只需要吧mq配置文件的hostname改成当前主机ip)</strong></p><p><strong>8.ActiveMQ集群配置</strong></p><p>配置文件里面的BrokerName要全部一致</p><p>持久化配置(必须)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistenceAdapter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">replicatedLevelDB</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">directory</span>=<span class="string">&quot;$&#123;activemq.data&#125;/leveldb&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">replicas</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">bind</span>=<span class="string">&quot;tcp://0.0.0.0:62621&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">zkAddress</span>=<span class="string">&quot;192.168.10.130:2181,192.168.10.132:2181,192.168.10.133:2181&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">hostname</span>=<span class="string">&quot;192.168.10.130&quot;</span></span></span><br><span class="line"><span class="tag">                      <span class="attr">zkPath</span>=<span class="string">&quot;/activemq/leveldb-stores&quot;</span></span></span><br><span class="line"><span class="tag">                        /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">persistenceAdapter</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>9.修改各个节点的消息端口</strong></p><p>61616/61617/61618</p><p><strong>10.按顺序启动3个ActiveMQ节点,到这步前提是zk集群已经成功启动运行</strong></p><p>使用zkCli.sh连接一台Zookeeper<br>/my_zookeeper/apache-zookeeper-3.5.6-bin/bin/zkCli.sh -server 192.168.10.130:2181</p><h2 id="八、消息中间件高级特性"><a href="#八、消息中间件高级特性" class="headerlink" title="八、消息中间件高级特性"></a>八、消息中间件高级特性</h2><h3 id="1-异步投递"><a href="#1-异步投递" class="headerlink" title="1.异步投递"></a>1.异步投递</h3><p><a href="http://activemq.apache.org/async-sends">http://activemq.apache.org/async-sends</a></p><p>对于一个Slow Consumer,使用同步发送消息可能出现Producer堵塞的情况,慢消费者适合使用异步发送</p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>ActiveMQ支持同步，异步两种发送的模式将消息发送到broker，模式的选择对发送延时有巨大的影响。producer能达到怎么样的产出率（产出率=发送数据总量/时间）主要受发送延时的影响，使用异步发送可以显著提高发送的性能。<br><strong>ActiveMQ默认使用异步发送的模式</strong>：除非明确指定使用同步发送的方式或者在未使用事务的前提下发送持久化的消息，这两种情况都是同步发送的。<br>如果你<strong>没有使用事务且发送的是持久化的消息</strong>，每一次发送都是同步发送的且会阻塞producer知道broker返回一个确认，表示消息已经被安全的持久化到磁盘。确认机制提供了消息安全的保障，但同时会阻塞客户端带来了很大的延时。<br>很多高性能的应用，<strong>允许在失败的情况下有少量的数据丢失。</strong>如果你的应用满足这个特点，你可以使用异步发送来提高生产率，即使发送的是持久化的消息。</p><p><strong>异步发送</strong><br>它可以最大化producer端的发送效率。我们<strong>通常在发送消息量比较密集的情况下使用异步发送</strong>，它可以很大的提升Producer性能；不过这也带来了额外的问题，<br>就是需要消耗更多的Client端内存同时也会<strong>导致broker端性能消耗增加</strong>；<br>此外它<strong>不能有效的确保消息的发送成功。</strong>在userAsyncSend=true的情况下客户端需要容忍消息丢失的可能。</p><p>开启</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.setUseAsyncSend(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h4 id="异步消息如何确定发送成功"><a href="#异步消息如何确定发送成功" class="headerlink" title="异步消息如何确定发送成功?"></a>异步消息如何确定发送成功?</h4><p>异步发送丢失消息的场景是：生产者设置userAsyncSend=true，使用producer.send(msg)持续发送消息。<br>如果消息不阻塞，<strong>生产者会认为所有send的消息均被成功发送至MQ。</strong><br>如果MQ突然宕机，此时生产者端内存中尚未被发送至MQ的消息都会丢失。</p><p>所以，正确的异步发送方法是<strong>需要接收回调的。</strong></p><p>同步发送和异步发送的区别就在此，<br>同步发送等send不阻塞了就表示一定发送成功了，<br>异步发送需要客户端回执并由客户端再判断一次是否发送成功</p><p>JmsProduce_AsyncSend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lq.activemq.async;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQMessageProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.AsyncCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsProduce_AsyncSend</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVEMQ_URL = <span class="string">&quot;tcp://192.168.5.128:61616&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;async01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建连接工厂,按照给定的url地址，采用默认用户名密码</span></span><br><span class="line">        ActiveMQConnectionFactory activeMQConnectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">        activeMQConnectionFactory.setUseAsyncSend(<span class="keyword">true</span>); <span class="comment">//异步发送</span></span><br><span class="line">        <span class="comment">//2.通过连接工厂，获得连接Connection +并启动访问</span></span><br><span class="line">        Connection connection = activeMQConnectionFactory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 创建会话Session</span></span><br><span class="line">        <span class="comment">//两个参数，第一个参数事务，第二个叫签收</span></span><br><span class="line">        Session session = connection.createSession(<span class="keyword">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//4.创建目的地（队列还是主题topic）</span></span><br><span class="line">        Queue queue = session.createQueue(QUEUE_NAME); <span class="comment">//接口</span></span><br><span class="line">        <span class="comment">//5.创建消息的生产者</span></span><br><span class="line">        ActiveMQMessageProducer activeMQMessageProducer = (ActiveMQMessageProducer)session.createProducer(queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.通过消息生产者生成3天消息发送MQ队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//7.创建消息</span></span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">&quot;async msg----&quot;</span> + i);<span class="comment">//字符串</span></span><br><span class="line">            textMessage.setJMSMessageID(UUID.randomUUID().toString()+<span class="string">&quot;---orderLQ&quot;</span>);</span><br><span class="line">            String msgID = textMessage.getJMSMessageID();</span><br><span class="line">            <span class="comment">//8. 通过消息生产者发送mq,异步回调</span></span><br><span class="line">            activeMQMessageProducer.send(textMessage, <span class="keyword">new</span> AsyncCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(msgID+<span class="string">&quot;has been ok send&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(JMSException e)</span> </span>&#123;</span><br><span class="line">                    System.out.println(msgID+<span class="string">&quot;fail to send mq&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//9.关闭资源</span></span><br><span class="line">        activeMQMessageProducer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;********消息发布到MQ成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-延迟投递和定时投递"><a href="#2-延迟投递和定时投递" class="headerlink" title="2.延迟投递和定时投递"></a>2.延迟投递和定时投递</h3><p><a href="http://activemq.apache.org/delay-and-schedule-message-delivery.html">http://activemq.apache.org/delay-and-schedule-message-delivery.html</a></p><table><thead><tr><th>属性</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>AMQ_SCHEDULED_DELAY</td><td>long</td><td>延迟投递时间</td></tr><tr><td>AMQ_SCHEDULED_PERIOD</td><td>long</td><td>重复投递时间</td></tr><tr><td>AMQ_SCHEDULED_REPEAT</td><td>int</td><td>重复投递次数</td></tr><tr><td>AMQ_SCHEDULED_CRON</td><td>string</td><td>Cron表达式</td></tr></tbody></table><p>要在activemq.xml中配置schedulerSupport属性为true</p><p>Java代码里面封装的辅助消息类型：ScheduledMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> delay = <span class="number">3</span> * <span class="number">1000</span>;      <span class="comment">//延迟投递的时间</span></span><br><span class="line"><span class="keyword">long</span> period = <span class="number">4</span> * <span class="number">1000</span>;     <span class="comment">//每次投递的时间间隔</span></span><br><span class="line"><span class="keyword">int</span> repeat = <span class="number">5</span>;             <span class="comment">//投递的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    TextMessage textMessage = session.createTextMessage(<span class="string">&quot;message-延时投递&quot;</span> + i);</span><br><span class="line">    <span class="comment">//给消息设置属性以便MQ服务器读取到这些信息,好做对应的处理</span></span><br><span class="line">    textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, delay);</span><br><span class="line">    textMessage.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_PERIOD, period);</span><br><span class="line">    textMessage.setIntProperty(ScheduledMessage.AMQ_SCHEDULED_REPEAT, repeat);</span><br><span class="line">    messageProducer.send(textMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ActiveMQ消息重试机制"><a href="#3-ActiveMQ消息重试机制" class="headerlink" title="3.ActiveMQ消息重试机制"></a>3.ActiveMQ消息重试机制</h3><p>具体哪些情况会引发消息重发？</p><blockquote><p>1：Client用了transactions且再session中调用了rollback<br>2：Client用了transactions且再调用commit之前关闭或者没有commit<br>3：Client再CLIENT_ACKNOWLEDGE的传递模式下，session中调用了recover</p></blockquote><p>请说说消息重发时间间隔和重发次数？</p><blockquote><p>间隔：1<br>次数：6<br> 每秒发6次</p></blockquote><p>有毒消息Poison ACK</p><blockquote><p>一个消息被redelivedred超过默认的最大重发次数（默认6次）时，消费的回个MQ发一个“poison ack”表示<strong>这个消息有毒，告诉broker不要再发了</strong>。这个时候broker会把这个消息放到DLQ（私信队列）。</p></blockquote><p><a href="http://activemq.apache.org/redelivery-policy">http://activemq.apache.org/redelivery-policy</a></p><h3 id="4-死信队列"><a href="#4-死信队列" class="headerlink" title="4.死信队列"></a>4.死信队列</h3><p>ActiveMQ中引入了“死倍队列”(Dead Letter Queue)的概念。即一条消息再被重发了多次后（默认为重发6次redeliveryCounter==6)，将会被ActiveMQ移入“死信队列”。开发人员可以在这个Queue中查看处理出错的消息，进行人工干预。</p><p><em>一般生产环境中在使用MQ的时候设计两个队列:*</em>一个是核心业务队列，一个是死信队列。**<br><em>核心业务队列，就是比如上图专门用来让订单系统发送订单消息的，然后另外一个死信队列就是用来处理异常情况的。<br><em>假如第三方物流系统故障了此时无法请求，那么仓储系统每次消费到一条订单消息，尝试通知发货和配送都会遇到对方的接口报错。此时仓储系统就可以把这条消息拒绝访问或者标志位处理失败。</em></em>一旦标志这条消息处理失败了之后，MQ就会把这条消息转入提前设置好的一个死信队列中**。然后你会看到的就是，在第三方物流系统故障期间，所有订单消息全部处理失败，全部会转入死信队列。然后你的仓储系统得专门有一个后台线程，监控第三方物流系统是否正常，能否请求的，不停的监视。一旦发现对方恢复正常，这个后台线程就从死信队列消费出来处理失败的订单，</p><h3 id="5-防止重复调用"><a href="#5-防止重复调用" class="headerlink" title="5.防止重复调用"></a>5.防止重复调用</h3><p>网络延迟传输中，会造成进行MQ重试中，在重试过程中，可能会造成重复消费。<br>如果消息是做数据库的插入操作，<strong>给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</strong><br>如果上面两种情况还不行，准备一个<strong>第三服务方来做消费记录</strong>。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2021/02/20/%E6%A1%86%E6%9E%B6/springCloud/"/>
      <url>/2021/02/20/%E6%A1%86%E6%9E%B6/springCloud/</url>
      
        <content type="html"><![CDATA[<h2 id="一、SpringCloud简介"><a href="#一、SpringCloud简介" class="headerlink" title="一、SpringCloud简介"></a>一、SpringCloud简介</h2><p>SpringCloud 是微服务一站式服务解决方案，微服务全家桶。它是微服务开发的主流技术栈。它采用了名称，而非数字版本号。</p><p>springCloud 和 springCloud Alibaba 目前是最主流的微服务框架组合。</p><p><img src="/2021/02/20/%E6%A1%86%E6%9E%B6/springCloud/1597213385700.png" alt="1597213385700"></p><h3 id="1-1-版本选择"><a href="#1-1-版本选择" class="headerlink" title="1.1 版本选择"></a>1.1 版本选择</h3><h4 id="springboot版本选择"><a href="#springboot版本选择" class="headerlink" title="springboot版本选择"></a>springboot版本选择</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git源码地址</span><br><span class="line">https://github.com/spring-projects/spring-boot/releases/</span><br></pre></td></tr></table></figure><p>强烈建议升级2.x</p><h4 id="springcloud版本选择"><a href="#springcloud版本选择" class="headerlink" title="springcloud版本选择"></a>springcloud版本选择</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git源码地址</span><br><span class="line">https://github.com/spring-projects/spring-cloud</span><br><span class="line">https://spring.io/projects/spring-cloud</span><br><span class="line">更详细的选择</span><br><span class="line">https://start.spring.io/actuator/info</span><br></pre></td></tr></table></figure><h3 id="本次使用"><a href="#本次使用" class="headerlink" title="本次使用"></a>本次使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cloud Hoxton.SR1</span><br><span class="line">boot 2.2.2.RELEASE</span><br><span class="line">cloud alibaba 2.1.0.RELEASE</span><br><span class="line">java java8</span><br><span class="line">Maven 3.5以上</span><br><span class="line">Mysql 5.7及以上</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2-Cloud各种组件的停更-升级-替换"><a href="#1-2-Cloud各种组件的停更-升级-替换" class="headerlink" title="1.2 Cloud各种组件的停更/升级/替换"></a>1.2 Cloud各种组件的停更/升级/替换</h3><p>停更不停用</p><p><img src="/2021/02/20/%E6%A1%86%E6%9E%B6/springCloud/1597213783265.png" alt="1597213783265"></p><h2 id="二、工程创建"><a href="#二、工程创建" class="headerlink" title="二、工程创建"></a>二、工程创建</h2><h3 id="2-1-创建父工程"><a href="#2-1-创建父工程" class="headerlink" title="2.1 创建父工程"></a>2.1 创建父工程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.new project</span><br><span class="line">2.聚合总父工程名字</span><br><span class="line">3.maven选版本</span><br><span class="line">4.工程名字</span><br><span class="line">5.字符编码utf-8</span><br><span class="line">6.注解生效</span><br><span class="line">7.java编译版本选8</span><br></pre></td></tr></table></figure><h3 id="2-2-父工程依赖"><a href="#2-2-父工程依赖" class="headerlink" title="2.2 父工程依赖"></a>2.2 父工程依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2021<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--统一管理jar包版本--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.spring.boot.version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">mybatis.spring.boot.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--子模块继承之后，提供作用：锁定版本+子module不用谢groupId和version--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--spring boot 2.2.2--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--spring cloud Hoxton.SR1--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--spring cloud 阿里巴巴--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- druid--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--log4j--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面配置的解释：</p><blockquote><p>首先要加  <packaging>pom</packaging>  这个。</p><p>聚合版本依赖，dependencyManagement <strong>只声明依赖，并不实现引入</strong>，所以子项目还需要写要引入的依赖。</p><p><strong>如果不在子项目中声明依赖，是不会从父项目中继承下来的;只有在子项目中写了该依赖项，并且没有指定具体版本,才会从父项目中继承该项，并且version和scope都读取自父pom;</strong></p><p>如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</p></blockquote><p><code>dependencyManagement</code><br>Maven使用dependencyManagement元素来提供了一种管理依赖版本号的方式。<strong>通常会在一个组织或者项目的最顶层的父POM中看到dependencyManagement元素。</strong><br>使用pom.xml 中的dependencyManagement元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。Maven 会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用这个dependencyManagement元素中指定的版本号。</p><p>这样做的好处就是:如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号，这样当想升级或切换到另一个版本</p><p>跳过单元测试 闪电</p><h3 id="2-3-第一个微服务架构"><a href="#2-3-第一个微服务架构" class="headerlink" title="2.3 第一个微服务架构"></a>2.3 第一个微服务架构</h3><img src="/2021/02/20/%E6%A1%86%E6%9E%B6/springCloud/1597225177689.png" alt="1597225177689" style="zoom: 50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">微服务模块</span><br><span class="line">1. 建模块 module</span><br><span class="line">2. 改 pom</span><br><span class="line">3. 写yml</span><br><span class="line">4. 主启动</span><br><span class="line">5. 业务类</span><br></pre></td></tr></table></figure><h4 id="建cloud-provider-payment8001"><a href="#建cloud-provider-payment8001" class="headerlink" title="建cloud-provider-payment8001"></a>建cloud-provider-payment8001</h4><h4 id="改pom"><a href="#改pom" class="headerlink" title="改pom"></a>改pom</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2021<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-provider-payment8001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 引入自己定义的api通用包，可以使用Payment支付Entity --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mysql-connector-java--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--jdbc--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="cloud-provider-payment8001-子工程的yml文件"><a href="#cloud-provider-payment8001-子工程的yml文件" class="headerlink" title="cloud-provider-payment8001 子工程的yml文件"></a>cloud-provider-payment8001 子工程的yml文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-payment8001</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/cloud2021?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.lq.springcloud.entities</span>  <span class="comment"># 所有Entity 别名类所在包</span></span><br></pre></td></tr></table></figure><h4 id="主启动"><a href="#主启动" class="headerlink" title="主启动"></a>主启动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentMain8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类"><a href="#业务类" class="headerlink" title="业务类"></a>业务类</h4><p>1.sql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `payment`(</span><br><span class="line">`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;ID&#x27;,</span><br><span class="line">`serial` varchar(200) DEFAULT &#x27;&#x27;,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGING=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure><p>2.实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主实体类 Payment</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String serial;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Json封装体CommentResult,传给前端，判断编码是否成功，成功才显示</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;  <span class="comment">//泛型：如果装的payment 返回payment,装的order 返回order</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonResult</span><span class="params">(Integer code, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(code, message, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.dao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mybatis推荐</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(Payment payment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Payment <span class="title">getPaymentById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lq.springcloud.dao.PaymentDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;create&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Payment&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        insert into payment(serial) values(#&#123;serial&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.lq.springcloud.entities.Payment&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;BIGINT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;serial&quot;</span> <span class="attr">property</span>=<span class="string">&quot;serial&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getPaymentById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">        select * from payment where id=#&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">create</span><span class="params">(Payment payment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Payment <span class="title">getPaymentById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentServiceImpl</span> <span class="keyword">implements</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentDao paymentDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentDao.create(payment);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Payment <span class="title">getPaymentById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentDao.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只传给前端CommonResult，不需要前端了解其他的组件</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/payment/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = paymentService.create(payment);</span><br><span class="line">        log.info(<span class="string">&quot;*****插入结果：&quot;</span>+result);</span><br><span class="line">        <span class="keyword">if</span>(result &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;插入数据成功&quot;</span>,result);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,<span class="string">&quot;插入数据失败&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        Payment payment = paymentService.getPaymentById(id);</span><br><span class="line">        log.info(<span class="string">&quot;*****插入结果：&quot;</span>+payment);</span><br><span class="line">        <span class="keyword">if</span>(payment != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">200</span>,<span class="string">&quot;查询成功&quot;</span>,payment);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CommonResult(<span class="number">444</span>,<span class="string">&quot;没有对应记录,查询ID：&quot;</span>+id,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>使用postman进行测试</p><h3 id="2-4-热部署Devtool"><a href="#2-4-热部署Devtool" class="headerlink" title="2.4 热部署Devtool"></a>2.4 热部署Devtool</h3><p><strong>1.Adding devtools to your project</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.Adding plugin to your pom.xml</strong></p><p>父类总工程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3.Enabling automatic build</strong> </p><p>settings-&gt;build-&gt;complier  ADBC打勾</p><p><strong>4.Update the value of</strong></p><p>shift + ctrl + alt + / 四个按键一块按，选择Reg项</p><img src="/2021/02/20/%E6%A1%86%E6%9E%B6/springCloud/1597222341651.png" alt="1597222341651" style="zoom:67%;"><p><strong>5.重启IDEA</strong></p><h3 id="2-5-消费者订单模块"><a href="#2-5-消费者订单模块" class="headerlink" title="2.5 消费者订单模块"></a>2.5 消费者订单模块</h3><h4 id="1-创建微服务消费者订单Module模块"><a href="#1-创建微服务消费者订单Module模块" class="headerlink" title="1.创建微服务消费者订单Module模块"></a>1.创建微服务消费者订单Module模块</h4><h4 id="2-pom"><a href="#2-pom" class="headerlink" title="2.pom"></a>2.pom</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2021<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-consumer-order80<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-主启动类"><a href="#3-主启动类" class="headerlink" title="3.主启动类"></a>3.主启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderMain.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-业务类"><a href="#4-业务类" class="headerlink" title="4.业务类"></a>4.业务类</h4><p>订单也需要Payment、CommonResult实体类，但是不需要操作数据库，没有Service、Dao，只需添加Controller即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String serial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CommonResult</span></span><br><span class="line"><span class="keyword">package</span> com.atguigu.springcloud.entities;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;  <span class="comment">//泛型：如果装的payment 返回payment,装的order 返回order</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonResult</span><span class="params">(Integer code,String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(code,message,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>首说RestTemplate：</strong> RestTemplate提供了多种便捷访问远程Http服务的方法，是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的<strong>客户端模板工具集</strong>，实现80到8001的远程调用。<br> 官网地址：<br> <a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html</a><br> 使用：<br> 使用restTemplate访问restful接口非常的简单粗暴，（url、requestMap、ResponseBean.class）这三个参数分别代表REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。</p><p>将RestTemplate对象注册到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL=<span class="string">&quot;http://localhost:8001&quot;</span>;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL+<span class="string">&quot;/payment/create&quot;</span>,payment, CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">&quot;/payment/get/&quot;</span>+id,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8001/payment/get/31</span><br><span class="line">http://localhost/consumer/payment/get/31</span><br></pre></td></tr></table></figure><p>添加：</p><p>可以看到数据库只插入主键，并没有插入内容，要在8001的PaymentController加</p><p>@RequestBody注解</p><h3 id="2-6-工程重构"><a href="#2-6-工程重构" class="headerlink" title="2.6 工程重构"></a>2.6 工程重构</h3><p>项目中存在相同的代码（entities包下的Payment.class和CommonResult.class）,造成代码冗余，可以进行重构。<br> 通过Maven聚合父工程，把相同重复的代码移到公开公用的工程里面，还可以放第三方接口、工具类，统一调配使用。</p><h4 id="建立公共module-导入依赖"><a href="#建立公共module-导入依赖" class="headerlink" title="建立公共module 导入依赖"></a>建立公共module 导入依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloud-api-commons</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2021<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="将entities包复制到cloud-api-commons"><a href="#将entities包复制到cloud-api-commons" class="headerlink" title="将entities包复制到cloud-api-commons"></a>将entities包复制到cloud-api-commons</h4><h4 id="使用Maven打包发布上传到公用本地库里"><a href="#使用Maven打包发布上传到公用本地库里" class="headerlink" title="使用Maven打包发布上传到公用本地库里"></a>使用Maven打包发布上传到公用本地库里</h4><p>打开Maven窗口，执行clean测试一下，无误后出现BUILD SUCCESS，然后执行install</p><h4 id="删除重复entities，引入maven-install的jar包坐标即可使用。"><a href="#删除重复entities，引入maven-install的jar包坐标即可使用。" class="headerlink" title="删除重复entities，引入maven install的jar包坐标即可使用。"></a>删除重复entities，引入maven install的jar包坐标即可使用。</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入自己定义的api通用包，可以使用Payment支付Entity--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、Eureka服务注册与发现"><a href="#三、Eureka服务注册与发现" class="headerlink" title="三、Eureka服务注册与发现"></a>三、Eureka服务注册与发现</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>Eureka采用了CS的设计架构，Eureka Server作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka的客户销连接到lfurela Sevef并维持心跳连接。这样系统的维护人员就可以通过Eureka Server 来监控系统中各个微服务是否正常运行。<br>这点和zookeeper很相似<br>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方(消费者服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想:在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址)</p><p>Eureka包含两个组件: <code>Eureka Server</code>和<code>Eureka Client</code><br><strong>Eureka Server</strong>提供服务注册服务<br>各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p><p><strong>EurekaClient</strong>通过注册中心进行访问<br>是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒)</p><h3 id="3-服务器端安装"><a href="#3-服务器端安装" class="headerlink" title="3.服务器端安装"></a>3.服务器端安装</h3><p>创建项目cloud-eureka-server7001</p><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2021<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-eureka-server7001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka server--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入自己定义的api通用包，可以使用payment支付Entity--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--boot web actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一般通用配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZ4 one:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>主启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaMain7001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaMain7001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个服务注册中心，主要干的活就是服务注册，不需要写业务类。<br> 但是注意：Eureka有两个组件，一定要标清楚哪个是Server，哪个是Client。@EnableEurekaServer代表服务注册中心</p><h5 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:7001/</span><br></pre></td></tr></table></figure><p>出现图标，表示Eureka 服务端安装成功。No instances available表示当前没有服务注册进来</p><h3 id="4-单机Eureka构建：支付微服务8001入驻进eurekaServer"><a href="#4-单机Eureka构建：支付微服务8001入驻进eurekaServer" class="headerlink" title="4. 单机Eureka构建：支付微服务8001入驻进eurekaServer"></a>4. 单机Eureka构建：支付微服务8001入驻进eurekaServer</h3><p>将 Eureka-client 依赖引入，便于使用注解@EnableEurekaClient标注这是个Eureka Client端</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><p>主启动类添加注解@EnableEurekaClient</p><p>测试</p><img src="/2021/02/20/%E6%A1%86%E6%9E%B6/springCloud/image-20210221131426332.png" alt="image-20210221131426332" style="zoom:67%;"><p>这样就注册进来了，入住进Eureka服务器的名称就是8001yml中配置的spring.application.name。红色警告是Eureka的自我保护机制，后面会详细说。</p><h3 id="5-单机Eureka构建：订单微服务入驻进eurekaServer"><a href="#5-单机Eureka构建：订单微服务入驻进eurekaServer" class="headerlink" title="5. 单机Eureka构建：订单微服务入驻进eurekaServer"></a>5. 单机Eureka构建：订单微服务入驻进eurekaServer</h3><p>同理</p><p>pom</p><p>yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-order-server</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><p>添加注解@EnableEurekaClient</p><p>测试</p><h3 id="6-EurekaServer集群环境构建"><a href="#6-EurekaServer集群环境构建" class="headerlink" title="6.EurekaServer集群环境构建"></a>6.EurekaServer集群环境构建</h3><p>微服务RPC远程服务调用最核心的是什么？</p><p>高可用，如果注册中心只有一个，出故障没了。注册中心集群</p><p>创建 cloud-eureka-server7002</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2021<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-eureka-server7002<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka-server--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入自定义的api通用包，可以使用Payment支付Entity--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--boot web actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一般通用配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写yml之前修改映射文件</p><p>C:\Windows\System32\drivers\etc路径下的hosts文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 eureka7001.com</span><br><span class="line">127.0.0.1 eureka7002.com</span><br></pre></td></tr></table></figure><p>x修改yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">    <span class="comment">#设置Server交互地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002:7002/eureka/</span> <span class="comment">#互相注册</span></span><br></pre></td></tr></table></figure><p>8001和8002也都访问正常，那如果我们用80访问呢？发现怎么刷新都是8001，这是因为我们的源程序地址是写死的：</p><p>修改为动态的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//private static final String PAYMENT_URL=&quot;http://localhost:8001&quot;;</span></span><br><span class="line">    <span class="comment">//通过在eureka上注册过的微服务名称调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL = <span class="string">&quot;http://CLOUD-PROVIDER-SERVICE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/create&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">create</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL+<span class="string">&quot;/payment/create&quot;</span>,payment,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">&quot;/payment/get/&quot;</span>+id,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现报错了，现在对外暴露的不再是地址和端口，只认微服务名称了，可是微服务并不知道下面有几个，找不到这个主机名称，需要使用#LoadBalanced注解开启RestTemplate负载均衡功能。<br> 提前说一下：这个就是后面要介绍的Ribbon负载均衡功能。</p><p><strong>@LoadBalanced注解让RestTemplate负载均衡</strong></p><h3 id="7-服务发现Discovery"><a href="#7-服务发现Discovery" class="headerlink" title="7.服务发现Discovery"></a>7.服务发现Discovery</h3><p>对于注册进Eureka里面的微服务，可以通过服务发现来获得该服务的信息</p><ul><li>修改controller</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">GetMapping(value = <span class="string">&quot;/payment/discovery&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> object <span class="title">discovery</span><span class="params">()</span></span>&#123;</span><br><span class="line">List&lt;String&gt; services = discoveryClicnt.getServices();<span class="comment">//得到所有的微服务</span></span><br><span class="line">    <span class="keyword">for</span> (String element : services) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;element : &quot;</span>+element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">list&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;CLOUD-PROVIOER-SERVICE&quot;</span>);<span class="comment">//得到一个县体微服务的所有实例</span></span><br><span class="line">    <span class="keyword">for</span> (ServiceInstance instance : instances)&#123;</span><br><span class="line"> log.info(instance.getServiceId()+<span class="string">&quot;\t&quot;</span>+instance.getHost()+<span class="string">&quot;\t&quot;</span>+instance.getPort()+<span class="string">&quot;\t&quot;</span>+instance.getUri());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.discoveryClient;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主启动类加@EnableDiscoveryClient注解</p><h3 id="8-Eureka自我保护"><a href="#8-Eureka自我保护" class="headerlink" title="8.Eureka自我保护"></a>8.Eureka自我保护</h3><p>某时刻某一个微服务不可用了，Eureka不会立刻清理，依然会对该服务的信息进行保存</p><p>默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90秒)。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，<strong>此时本不应该注销这个微服务</strong>。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障)，那么这个节点就会进入自我保护模式。</p><p>服务端</p><p>eureka.server.enable-self-preservation = false可以禁用自我保护模式</p><p>eviction-interval-timer-in-ms: 2000 客户端向服务端发送心跳的时间间隔</p><p>客户端</p><p>eureka.instance.lease-renewal-interval-in-seconds=30 客户端向服务端发送心跳的时间间隔，默认30s</p><p>eureka.instance.lease-expiration-duration-in-seconds=90服务端在最后收到一次心跳的等待上限，超时剔除服务</p><h2 id="四、Zookeeper服务注册与发现"><a href="#四、Zookeeper服务注册与发现" class="headerlink" title="四、Zookeeper服务注册与发现"></a>四、Zookeeper服务注册与发现</h2><p>老项目还可以继续使用Eureka，新项目可以使用其他技术：</p><ul><li>Zookeeper</li><li>Consul</li><li>Nacos</li></ul><h2 id="五、-Consul"><a href="#五、-Consul" class="headerlink" title="五、 Consul"></a>五、 Consul</h2><p>三个注册中心异同点</p><p><strong>CAP</strong>  CAP理论关注粒度是数据，而不是整体系统设计的策略</p><ul><li>C:Consistency(强一致性)</li><li>A:Availability(可用性)</li><li>P:Partition tolerance(分区容错)</li></ul><img src="/2021/02/20/%E6%A1%86%E6%9E%B6/springCloud/1597384290665.png" alt="image-20210221173509924" style="zoom:67%;"><p><img src="/2021/02/20/%E6%A1%86%E6%9E%B6/springCloud/image-20210221173539642.png" alt="image-20210221173539642"></p><p><strong>最多只能同时较好的满足两个</strong>。<br>CAP理论的核心是:<strong>一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求</strong>，因此，根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类:CA-单点集群，满足─致性，可用性的系统，通常在可扩展性上不太强大。<br>CP-满足一致性，分区容忍必的系统，通常性能不是特别高。<br>AP-满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</p><h2 id="六、Ribbon-负载规则替换"><a href="#六、Ribbon-负载规则替换" class="headerlink" title="六、Ribbon 负载规则替换"></a>六、Ribbon 负载规则替换</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套<strong>客户端负载均衡的工具</strong>。<br>简单的说，Ribbon是Netflx发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer(简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p><p>LB负载均衡(Load Balance)是什么？<br>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的<strong>HA(高可用)</strong>。常见的负载均衡有软件Nginx，LVS，硬件F5等。</p><p>Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别？<br><strong>Nginx是服务器负载均衡</strong>，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。<br><strong>Ribbon本地负载均衡</strong>，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到VM本地，从而在本地实现RPC远程服务调用技术。</p><p>负载均衡+RestTemplate调用</p><p>总结：Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和eureka结合只是其中的一个实例。</p><p>没有引入ribbon,eureka已经做了整合</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupld</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactld</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactld</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-RestTemplate的使用"><a href="#2-RestTemplate的使用" class="headerlink" title="2.RestTemplate的使用"></a>2.RestTemplate的使用</h3><p><a href="https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html</a></p><p>getForObject方法：json对象</p><p>getForEntity方法 ：返回对象为ResponseEntit对象，包含响应中的一些重要信息，比如响应头，响应状态码，响应体</p><p>postForObject/postForEntity</p><h3 id="3-Ribbon核心组件IRule"><a href="#3-Ribbon核心组件IRule" class="headerlink" title="3.Ribbon核心组件IRule"></a>3.Ribbon核心组件IRule</h3><p>IRule:根据特定算法从服务列表中选取一个要访问的服务</p><p>替换：</p><ul><li>com.netflix.loadbalancer.RoundRobinRule 轮询</li><li>com.netflix.loadbalancer.RandomRule 随机</li><li>com.netflix.loadbalancer.RetryRule 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试</li><li>WeightedResponseTimeRule  对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择</li><li>BestAvailableRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</li><li>AvailabilityFilteringRule 先过滤掉故障实例，再选择并发较小的实例</li><li>ZoneAvoidanceRule 默认规则，复合判断server所在区域的性能和server的可用性选择服务器</li></ul><p>修改order80</p><p>自定义配置类不能放在ComponentScan所扫描的包及子包下</p><p>不能和启动类在一个包下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类 加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RibbonClient(name=&quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = MySelfRule.class)</span><br></pre></td></tr></table></figure><h3 id="4-负载均衡算法"><a href="#4-负载均衡算法" class="headerlink" title="4.负载均衡算法"></a>4.负载均衡算法</h3><p>负载均衡算法: rest接口第几次请求数%服务器集群总数量=实际调用服务器位置下标，每次服务重启动后rest接口计数从1开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);</span><br><span class="line"><span class="comment">//如:</span></span><br><span class="line">List [<span class="number">0</span>] instances = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8002</span></span><br><span class="line">List [<span class="number">1</span>] instances = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8001</span></span><br></pre></td></tr></table></figure><p>手写</p><p>去掉@LoadBalanced</p><p>LoadBalanced接口</p><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/lb&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPaymentLB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> serverPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServiceInstance <span class="title">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MLB</span> <span class="keyword">implements</span> <span class="title">LoadBalance</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">        <span class="keyword">int</span> next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            current = <span class="keyword">this</span>.atomicInteger.get();</span><br><span class="line">            next = current &gt;= <span class="number">2147483647</span> ? <span class="number">0</span> : current + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">while</span> (!<span class="keyword">this</span>.atomicInteger.compareAndSet(current,next));</span><br><span class="line">        System.out.println(<span class="string">&quot;*******next:&quot;</span>+next);</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = getAndIncrement() % serviceInstances.size();</span><br><span class="line">        <span class="keyword">return</span> serviceInstances.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> LoadBalance loadBalance;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/consumer/payment/lb&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPaymentLB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;CLOUD-PROVIDER-SERVICE&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == instances || instances.size() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ServiceInstance serviceInstance = loadBalance.instances(instances);</span><br><span class="line">    URI uri = serviceInstance.getUri();</span><br><span class="line">    <span class="keyword">return</span>  restTemplate.getForObject(uri+<span class="string">&quot;/payment/lb&quot;</span>,String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、OpenFeign服务接口调用"><a href="#七、OpenFeign服务接口调用" class="headerlink" title="七、OpenFeign服务接口调用"></a>七、OpenFeign服务接口调用</h2><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h3><p><a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign">https://cloud.spring.io/spring-cloud-static/Hoxton.SR1/reference/htmlsingle/#spring-cloud-openfeign</a><br>Feign是一个<strong>声明式WebService客户端</strong>。使用Feign能让编写Web Service客户端更加简单。<br>它的使用方法是<strong>定义一个服务接口然后在上面添加注解。</strong>Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡</p><p><a href="https://github.com/spring-cloud/spring-cloud-openfeign">https://github.com/spring-cloud/spring-cloud-openfeign</a></p><p>Feign能干什么<br>Feign旨在使编写Java Http客户端变得更容易。<br>前面在使用<strong>Ribbon+RestTemplate</strong>时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，<strong>往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。</strong>所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，<strong>我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)</strong>，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。<br>Feign集成了Ribbon<br>利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，<strong>通过feign只需要定义服务绑定接口且以声明式的方法</strong>，优雅而简单的实现了服务调用</p><p>OpenFeign是Spring Cloud在Feign的基础上支持了SpringMVC的注解，如@RequesMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.使用</p><p>@FeignClient</p><p>新建cloud-consumer-feign-order80</p><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2021<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-consumer-feign-order80<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入自己定义的api通用包，可以使用Payment支付Entity--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignMain80</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderFeignMain80.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentFeignService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt;  <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(value = &quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentFeignService paymentFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/payment/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult&lt;Payment&gt; <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认Feign客户端只等待一秒钟，但是服务端处理需要超过1秒钟，导致Feign客户端不想等待了，直接返回报错。为了避免这样的情况，有时候我们需要设置Feign客户端的超时控制。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#没置feign客广端超时时间( openFeign 默认支持ribbon)</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="comment">#指的是建立连接后从服务器读取到可用资源所用的时问</span></span><br><span class="line"><span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line"><span class="comment">#指的是建立连接用的时间，适用于网络状况正常的情况下,两端连接所用的时问</span></span><br><span class="line"><span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="string">com.atguigu.springcloud.service.PaymentFeignService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h2 id="八、Hystrix断路器"><a href="#八、Hystrix断路器" class="headerlink" title="八、Hystrix断路器"></a>八、Hystrix断路器</h2><h3 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1.概述"></a>1.概述</h3><h4 id="服务雪崩"><a href="#服务雪崩" class="headerlink" title="服务雪崩"></a>服务雪崩</h4><p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“<strong>扇出</strong>”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.<br>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>Hystrix是一个用于处理分布式系统的<strong>延迟和容错的开源库</strong>，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。<br>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝)，向<strong>调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常</strong>，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p><ul><li>服务降级</li><li>服务熔断</li><li>接近实时的监控</li></ul><p>停更</p><p><a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">https://github.com/Netflix/Hystrix/wiki/How-To-Use</a></p><h3 id="2-Hystrix重要概念"><a href="#2-Hystrix重要概念" class="headerlink" title="2.Hystrix重要概念"></a>2.Hystrix重要概念</h3><h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>服务器忙，请稍候再试，不让客户端等待并立刻返回一个友好提示，fallback</p><p>哪些情况会触发降级</p><ul><li>程序运行异常</li><li>超时</li><li>服务熔断触发服务降级</li><li>线程池/信号量打满也会导致服务降级</li></ul><h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><p>类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示</p><p>就是保险丝</p><p>服务的降级-&gt;进而熔断-&gt;恢复调用链路</p><h4 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h4><p>秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行</p><h3 id="3-案例"><a href="#3-案例" class="headerlink" title="3.案例"></a>3.案例</h3><p>新建cloud-provider-hystrix-payment8001</p><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2021<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-provider-hystrix-payment8001<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--hystrix--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入自己定义的api通用包，可以使用Payment支付Entity--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-hystrix-payment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><p>主启动类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">public class PaymentHystrixMain8001 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(PaymentHystrixMain8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常访问</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_Ok</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  paymentInfo_Ok,id:&quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;O(∩_∩)O哈哈~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> timeNumber = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  paymentInfo_TimeOut,id:&quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;O(∩_∩)O哈哈~&quot;</span>+<span class="string">&quot; 耗时&quot;</span>+timeNumber+<span class="string">&quot;s&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_Ok</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfo_Ok(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        String result = paymentService.paymentInfo_TimeOut(id);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><p>以上述为根基平台，从正确-&gt;错误-&gt;降级熔断-&gt;恢复</p><p>上述在非高并发情形下，还能勉强满足   but…..</p><p>开启Jmeter，来20000个并发压死8001，20000个请求都去访问paymentInfo_TimeOut服务</p><p>上面还是服务提供者8001自己测试，假如此时外部的消费者80也来访问，那消费者只能干等，最终导致消费端80不满意，服务端8001直接被拖死</p><p>创建cloud-consumer-feign-hystrix-order80 同理</p><p><strong>原因</strong></p><p>8001同一层次的其他接口服务被困死，因为tomcat线程里面的工作线程已经被挤占完毕</p><p>80此时调用8001，客户端访问响应缓慢，转圈圈</p><p>如何解决？解决的要求</p><ul><li>超时导致服务器变慢（转圈）超时不再等待</li><li>出错（宕机或程序运行出错）出错要有兜底</li></ul><p>解决</p><ul><li>对方服务（8001）超时了，调用者（80）不能一直卡死等待，必须有服务降级</li><li>对方服务（8001）down机了，调用者（80）不能一直卡死等待，必须有服务降级</li><li>对方服务（8001）OK，调用者（80）自己出故障或有自我要求（自己的等待时间小于服务提供者），自己处理降级</li></ul><h4 id="服务降级-1"><a href="#服务降级-1" class="headerlink" title="服务降级"></a>服务降级</h4><p>@HystrixCommand</p><p>8001先从自身找问题</p><ul><li>设置自身调用超时时间的峰值，峰值内可以正常运行，超过了需要有兜底的方法处理，作服务降级fallback</li></ul><p>@HystrixCommand报异常后如何处理 service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentInfo_TimeOutHandler&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;3000&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> timeNumber = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//int a = 10/0;</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  paymentInfo_TimeOut,id:&quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;O(∩_∩)O哈哈~&quot;</span>+<span class="string">&quot; 耗时&quot;</span>+timeNumber+<span class="string">&quot;s&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOutHandler</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;  paymentInfo_TimeOut,id:&quot;</span>+id+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;o(╥﹏╥)o&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主启动类添加新注解<code>@EnableCircuitBreaker</code></p><p>@HystrixCommand报异常后如何处理</p><ul><li>一旦调用服务方法失败并抛出了错误信息后，会自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法</li></ul><p>总结</p><ul><li>超时 或 服务异常 都做服务降级</li></ul><p>80fallback 一般降级都是在客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure><p>主启动类加@EnableHystrix</p><p>controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/consumer/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentTimeOutFallbackMethod&quot;, commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;1500&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">    String result = paymentHystrixService.paymentInfo_TimeOut(id);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeOutFallbackMethod</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;我是消费者80，对付支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,(┬＿┬)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个业务方法对应一个兜底的方法，代码膨胀</p><p>统一和自定义的分开</p><p>@DefaultProperties(defaultFallback = “”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局fallback</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">payment_Global_FallbackMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Global异常处理信息，请稍后再试,(┬＿┬)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类上加</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;payment_Global_FallbackMethod&quot;)</span><span class="comment">//全局的</span></span><br><span class="line"><span class="comment">//方法加上</span></span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br></pre></td></tr></table></figure><p><strong>服务降级，客户端去调用服务端，碰上服务端宕机或关闭</strong></p><p>本次案例服务降级处理是在客户端80实现完成的，与服务端8001没有关系，只需要为Feign客户端定义的接口添加一个服务降级处理的实现类即可实现解耦</p><ul><li>运行</li><li>超时</li><li>宕机</li></ul><p>修改cloud-consumer-feign-hystrix-order80</p><p>根据cloud-consumer-feign-hystrix-order80已经有的PaymentHystrixService接口，重新新建一个类（PaymentFallbackService）实现该接口，统一为接口里面的方法进行异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback = PaymentFallbackService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentHystrixService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_Ok</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/hystrix/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentInfo_TimeOut</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="string">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>此时服务端provider已经down了，但是我们做了服务降级处理，让客户端在服务端不可用时也会获得提示信息而不会挂起耗死服务器</p><h4 id="服务熔断-1"><a href="#服务熔断-1" class="headerlink" title="服务熔断"></a>服务熔断</h4><p>论文<a href="https://martinfowler.com/bliki/CircuitBreaker.html">https://martinfowler.com/bliki/CircuitBreaker.html</a></p><p>熔断机制概述<br>熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。<br><strong>当检测到该节点微服务调用响应正常后，恢复调用链路。</strong><br>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务熔断</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,commandProperties = &#123;//10s内10次请求失败6次</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.enabled&quot;,value = &quot;true&quot;), //是否开启断路器</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;,value=&quot;10&quot;),//请求次数</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;,value=&quot;10000&quot;),//时间范围</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;,value=&quot;60&quot;),//失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">            &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( id &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;*****id 不能负数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String serialNumber=IdUtil.simpleUUID();</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;调用成功,流水号：&quot;</span>+serialNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker_fallback</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id 不能负数，请稍候再试,(┬＿┬)/~~     id: &quot;</span> +id;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务熔断</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/payment/circuit/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">    String result = paymentService.paymentCircuitBreaker(id);</span><br><span class="line">    log.info(<span class="string">&quot;*****result:&quot;</span>+result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次错误,然后慢慢正确，发现刚开始不满足条件，就算是正确的访问地址也不能进行访问，需要慢慢的恢复链路</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>熔断类型</p><ul><li>熔断打开：请求不再进行调用当前服务，内部设置时钟一般为MTTR(平均故障处理时间)，当打开时长达到所设时钟则进入熔断状态</li><li>熔断关闭：熔断关闭不会对服务进行熔断</li><li>熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断</li></ul><p>涉及到断路器的三个重要参数:<strong>快照时间窗、请求总数阀值、错误百分比阀值。</strong></p><ul><li>快照时间窗:断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。</li><li>请求总数阀值:在快照时间窗内，必须满足请求总数阀值才有资格熔断。默认为20，意味着在10秒内，如果该hystrx命令的调用次数不足20次,即使所有的请求都超时或其他原因失败，断路器都不会打开。</li><li>错误百分比阀值:当请求总数在快照时间窗内超过了阀值，比如发生了30次调用，如果在这30次调用中，有15次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%阀值情况下，这时候就会将断路器打开。</li></ul><h3 id="4-原理"><a href="#4-原理" class="headerlink" title="4.原理"></a>4.原理</h3><p><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works">https://github.com/Netflix/Hystrix/wiki/How-it-Works</a></p><h2 id="九、Gateway新一代网关"><a href="#九、Gateway新一代网关" class="headerlink" title="九、Gateway新一代网关"></a>九、Gateway新一代网关</h2><h3 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1.概述"></a>1.概述</h3><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/</a></p><p>Spring Cloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架</p><p>能干什么</p><ul><li>反向代理</li><li>鉴权</li><li>流量控制</li><li>熔断</li><li>日志监控</li></ul><img src="/2021/02/20/%E6%A1%86%E6%9E%B6/springCloud/image-20210222201839858.png" alt="image-20210222201839858" style="zoom:67%;"><h4 id="为什么用gateway"><a href="#为什么用gateway" class="headerlink" title="为什么用gateway"></a>为什么用gateway</h4><p>springcloud gateway特性</p><blockquote><p>基于<strong>Spring Framework 5, Project Reactor和Spring Boot 2.0进行构建</strong>;<br>动态路由:能够匹配任何请求属性;<br>可以对路由指定Predicate (断言）和Filter (过滤器);集成Hystrix的断路器功能;<br>集成Spring Cloud 服务发现功能;<br>易于编写的Predicate (断言）和Filter (过滤器);<br>请求限流功能;<br>支持路径重写。</p></blockquote><h4 id="三大核心概念"><a href="#三大核心概念" class="headerlink" title="三大核心概念"></a>三大核心概念</h4><p>Route(路由)：</p><ul><li>路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由</li></ul><p>Predicate（断言）</p><ul><li>参考的是java8的java.util.function.Predicate开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由</li></ul><p>Filter(过滤)</p><ul><li>指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。</li></ul><p>web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制。<br>predicate就是我们的匹配条件;而flter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了</p><h3 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a>2.案例</h3><p>cloud-gateway-gateway9527</p><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud2021<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-gateway-gateway9527<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--gateway--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--web--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一般通用配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--eureka-client--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入自己定义的api通用包，可以使用Payment支付Entity--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lq.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GateWayMain9527</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GateWayMain9527.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9527网关如何做路由映射那？？？</p><p>cloud-provider-payment8001看看controller的访问地址</p><p>我们目前不想暴露8001端口，希望在8001外面套一层9527</p><p>9527yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>   <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>  <span class="comment">#断言,路径相匹配的进行路由</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span>   <span class="comment">#断言,路径相匹配的进行路由</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动7001/8001/9527</p><p>去掉下面的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--web--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试</p><p><a href="http://localhost:8001/payment/get/31">http://localhost:8001/payment/get/31</a></p><p><a href="http://localhost:9527/payment/get/31">http://localhost:9527/payment/get/31</a></p><p>yml配置说明</p><p>1.yaml配置</p><p>2.代码中注入RouteLocator的Bean</p><h3 id="3-动态路由配置"><a href="#3-动态路由配置" class="headerlink" title="3.动态路由配置"></a>3.动态路由配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">    <span class="comment">#开启动态路由</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#路由的ID，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="comment">#uri: http://localhost:8001   #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span>  <span class="comment">#断言,路径相匹配的进行路由</span></span><br></pre></td></tr></table></figure><h3 id="4-Predicate的使用"><a href="#4-Predicate的使用" class="headerlink" title="4.Predicate的使用"></a>4.Predicate的使用</h3><p>配置信息加强</p><p>官网</p><h3 id="5-Filter"><a href="#5-Filter" class="headerlink" title="5.Filter"></a>5.Filter</h3><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。</p><p>生命周期，Only Two:pre,post</p><p>自定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogGateWayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;**********come in MyLogGateWayFilter&quot;</span>+ <span class="keyword">new</span> Date());</span><br><span class="line">        String uname = exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;uname&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uname)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;********用户名非法&quot;</span>);</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);</span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、SpringCloud-config分布式配置中心"><a href="#十、SpringCloud-config分布式配置中心" class="headerlink" title="十、SpringCloud config分布式配置中心"></a>十、SpringCloud config分布式配置中心</h2><h3 id="1-概述-5"><a href="#1-概述-5" class="headerlink" title="1.概述"></a>1.概述</h3><p>分布式系统面临的配置问题？</p><blockquote><p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。</p></blockquote><p>SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置。</p><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/">https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/2021/02/15/%E6%A1%86%E6%9E%B6/SpringSecurity/"/>
      <url>/2021/02/15/%E6%A1%86%E6%9E%B6/SpringSecurity/</url>
      
        <content type="html"><![CDATA[<h2 id="一、SpringSecurity框架简介"><a href="#一、SpringSecurity框架简介" class="headerlink" title="一、SpringSecurity框架简介"></a>一、SpringSecurity框架简介</h2><h3 id="1-1-概要"><a href="#1-1-概要" class="headerlink" title="1.1 概要"></a><strong>1.1</strong> 概要</h3><p>的关于安全方面的两个主要区域是“<strong>认证</strong>”和“<strong>授权</strong>”（或者访问控制），一般来说，Web 应用的安全性包括<strong>用户认证（Authentication）和用户授权（Authorization）</strong>两个部分，这两点也是 Spring Security 重要核心功能。</p><p>（1）用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。<strong>通俗点说就是系统认为用户是否能登录</strong></p><p>（2）用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。<strong>通俗点讲就是系统判断用户是否有权限去做某些事情。</strong></p><h3 id="1-2-同款产品对比"><a href="#1-2-同款产品对比" class="headerlink" title="1.2 同款产品对比"></a>1.2 同款产品对比</h3><h4 id="1-2-1-Spring-Security"><a href="#1-2-1-Spring-Security" class="headerlink" title="1.2.1 Spring Security"></a><strong>1.2.1 Spring Security</strong></h4><p>Spring 技术栈的组成部分。</p><p>SpringSecurity 特点：</p><ul><li><p>和 Spring 无缝整合。</p></li><li><p>全面的权限控制。</p></li><li><p>专门为 Web 开发而设计。</p><ul><li>旧版本不能脱离 Web 环境使用。</li><li>新版本对整个框架进行了分层抽取，分成了核心模块和 Web 模块。单独引入核心模块就可以脱离 Web 环境。</li></ul></li><li><p>重量级。</p></li></ul><h4 id="1-2-2-Shiro"><a href="#1-2-2-Shiro" class="headerlink" title="1.2.2 Shiro"></a><strong>1.2.2 Shiro</strong></h4><p>Apache 旗下的轻量级权限控制框架。</p><p>特点：</p><ul><li><p>轻量级。Shiro 主张的理念是把复杂的事情变简单。针对对性能有更高要求的互联网应用有更好表现。</p></li><li><p>通用性。</p><ul><li>好处：不局限于 Web 环境，可以脱离 Web 环境使用。</li><li>缺陷：在 Web 环境下一些特定的需求需要手动编写代码定制。</li></ul></li></ul><p>Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。</p><p>相对于 Shiro，在 SSM 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。</p><p>自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了自动化配置方案，可以使用更少的配置来使用 Spring Security。</p><p>因此，一般来说，常见的安全管理技术栈的组合是这样的：</p><ul><li><p>SSM + Shiro</p></li><li><p>Spring Boot/Spring Cloud + Spring Security</p></li></ul><p><strong>以上只是一个推荐的组合而已，如果单纯从技术上来说，无论怎么组合，都是可以运行的</strong>。</p><h4 id="1-3-模块划分"><a href="#1-3-模块划分" class="headerlink" title="1.3 模块划分"></a><strong>1.3</strong> <strong>模块划分</strong></h4><img src="/2021/02/15/%E6%A1%86%E6%9E%B6/SpringSecurity/模块划分.png" alt="image-20210215155226258" style="zoom:67%;"><h2 id="二、SpringSecurity-入门案例"><a href="#二、SpringSecurity-入门案例" class="headerlink" title="二、SpringSecurity 入门案例"></a>二、SpringSecurity 入门案例</h2><h3 id="2-1-创建一个项目"><a href="#2-1-创建一个项目" class="headerlink" title="2.1 创建一个项目"></a>2.1 创建一个项目</h3><p>引入springSecurity依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- iookup parent from repository --&gt;</span><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupld</span>&gt;</span> org.springframework.boot<span class="tag">&lt;/<span class="name">groupld</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写一个controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"><span class="meta">@GetMapping(&quot;hel1o&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello security&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认用户名：user,密码通过控制台找到</p><h3 id="2-2-SpringSecurity-基本原理"><a href="#2-2-SpringSecurity-基本原理" class="headerlink" title="2.2 SpringSecurity 基本原理"></a>2.2 SpringSecurity 基本原理</h3><p>SpringSecurity 本质是一个过滤器链：</p><p>从启动是可以获取到过滤器链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFil</span><br><span class="line">ter</span><br><span class="line">org.springframework.security.web.context.SecurityContextPersistenceFilter </span><br><span class="line">org.springframework.security.web.header.HeaderWriterFilter</span><br><span class="line">org.springframework.security.web.csrf.CsrfFilter</span><br><span class="line">org.springframework.security.web.authentication.logout.LogoutFilter </span><br><span class="line">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter </span><br><span class="line">org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter </span><br><span class="line">org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter</span><br><span class="line">org.springframework.security.web.savedrequest.RequestCacheAwareFilter</span><br><span class="line">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter</span><br><span class="line">org.springframework.security.web.authentication.AnonymousAuthenticationFilter </span><br><span class="line">org.springframework.security.web.session.SessionManagementFilter </span><br><span class="line">org.springframework.security.web.access.ExceptionTranslationFilter </span><br><span class="line">org.springframework.security.web.access.intercept.FilterSecurityInterceptor</span><br></pre></td></tr></table></figure><p>代码底层流程：重点看三个过滤器：</p><p><code>FilterSecurityInterceptor</code>：是一个方法级的权限过滤器, 基本位于过滤链的最底部。</p><p>在invoke方法中</p><p>super.beforeInvocation(fi) 表示查看之前的 filter 是否通过。</p><p>fi.getChain().doFilter(fi.getRequest(), fi.getResponse());表示真正的调用后台的服务。</p><p><code>ExceptionTranslationFilter</code>：是个异常过滤器，用来处理在认证授权过程中抛出的异常</p><p><code>UsernamePasswordAuthenticationFilter</code> ：对/login 的 POST 请求做拦截，校验表单中用户</p><p>名，密码。</p><p><strong>过滤器如何进行加载？</strong></p><p>1.使用SpringSecurity配置过滤器DelegatingFilterProxy</p><p>​    dofilter-&gt;initDelegate-&gt;FilterChainProxy加载所有过滤器</p><h3 id="2-3-UserDetailsService接口讲解"><a href="#2-3-UserDetailsService接口讲解" class="headerlink" title="2.3 UserDetailsService接口讲解"></a>2.3 UserDetailsService接口讲解</h3><p>当什么也没有配置的时候，账号和密码是由 Spring Security 定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。如果需要自定义逻辑时，只需要实现 UserDetailsService 接口即可。</p><p><strong>返回值</strong> <strong>UserDetails</strong> </p><p>这个类是系统默认的用户“<strong>主体</strong>”// 表示获取登录用户所有权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;? **extends** GrantedAuthority&gt; getAuthorities();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示获取密码</span></span><br><span class="line"><span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示获取用户名</span></span><br><span class="line"><span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示判断账户是否过期</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示判断账户是否被锁定</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示凭证&#123;密码&#125;是否过期</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示当前用户是否可用</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>创建类继承UsernamePasswordAuthenticationFilter，重写三个方法创建类实现UscrDetailScrvicc，编写查询数据过程，返回User对象，这个User对象是安全框架提供对象</p><h3 id="2-4-PasswordEncoder-接口讲解"><a href="#2-4-PasswordEncoder-接口讲解" class="headerlink" title="2.4 PasswordEncoder 接口讲解"></a>2.4 PasswordEncoder 接口讲解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示把参数按照特定的解析规则进行解析</span></span><br><span class="line"><span class="function">String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span></span>;</span><br><span class="line"><span class="comment">// 表示验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹</span></span><br><span class="line">配，则返回 <span class="keyword">true</span>；如果不匹配，则返回 <span class="keyword">false</span>。第一个参数表示需要被解析的密码。第二个</span><br><span class="line">参数表示存储的密码。</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span></span>;</span><br><span class="line"><span class="comment">// 表示如果解析的密码能够再次进行解析且达到更安全的结果则返回 true，否则返回</span></span><br><span class="line"><span class="keyword">false</span>。默认返回 <span class="keyword">false</span>。</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">upgradeEncoding</span><span class="params">(String encodedPassword)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br></pre></td></tr></table></figure><h2 id="三、SpringSecurity-Web-权限方案"><a href="#三、SpringSecurity-Web-权限方案" class="headerlink" title="三、SpringSecurity Web 权限方案"></a>三、SpringSecurity Web 权限方案</h2><h3 id="3-1-设置登录系统的账号、密码"><a href="#3-1-设置登录系统的账号、密码" class="headerlink" title="3.1 设置登录系统的账号、密码"></a>3.1 设置登录系统的账号、密码</h3><p>方式一：在 application.properties</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.security.user.name=admin</span></span><br><span class="line"><span class="string">spring.security.user.password=123</span></span><br></pre></td></tr></table></figure><p>方式二：编写类实现接口</p><p>第一步：创建配置类，设置使用哪个userDetailService实现类</p><p>第二步：编写实现类，返回User对象，User对象有用户名密码和操作权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    auth.userDetailsService(userDetailsService)</span><br><span class="line">            .passwordEncoder(passwordEncoder()); </span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 注入 PasswordEncoder 类到 spring 容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userDetailsService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断用户名是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">&quot;admin&quot;</span>.equals(username))&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;用户名不存在！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从数据库中获取的密码 atguigu 的密文</span></span><br><span class="line">    String pwd = </span><br><span class="line">    <span class="string">&quot;$2a$10$2R/M6iU3mCZt3ByG7kwYTeeW0w7/UqdeXrb27zkBIizBvAven0/na&quot;</span>;</span><br><span class="line">    <span class="comment">// 第三个参数表示权限</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(username,pwd, </span><br><span class="line">    AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin,&quot;</span>));</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-实现数据库认证来完成用户登录"><a href="#3-2-实现数据库认证来完成用户登录" class="headerlink" title="3.2 实现数据库认证来完成用户登录"></a>3.2 实现数据库认证来完成用户登录</h3><h4 id="3-2-1-准备-sql"><a href="#3-2-1-准备-sql" class="headerlink" title="3.2.1 准备 sql"></a>3.2.1 准备 sql</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users(</span><br><span class="line"> id <span class="type">bigint</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    password <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 密码 atguigu</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张</span></span><br><span class="line"><span class="string">san&#x27;</span>,<span class="string">&#x27;$2a$10$2R/M6iU3mCZt3ByG7kwYTeeW0w7/UqdeXrb27zkBIizBvAven0/na&#x27;</span>);</span><br><span class="line"><span class="comment">-- 密码 atguigu</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李</span></span><br><span class="line"><span class="string">si&#x27;</span>,<span class="string">&#x27;$2a$10$2R/M6iU3mCZt3ByG7kwYTeeW0w7/UqdeXrb27zkBIizBvAven0/na&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> role(</span><br><span class="line">    id <span class="type">bigint</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;普通用户&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> role_user(</span><br><span class="line">    uid <span class="type">bigint</span>,</span><br><span class="line">    rid <span class="type">bigint</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role_user <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role_user <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> menu(</span><br><span class="line">    id <span class="type">bigint</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    url <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    parentid <span class="type">bigint</span>,</span><br><span class="line">    permission <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> menu <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;系统管理&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;menu:system&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> menu <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;用户管理&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;menu:user&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> role_menu(</span><br><span class="line">    mid <span class="type">bigint</span>,</span><br><span class="line">    rid <span class="type">bigint</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role_menu <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role_menu <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role_menu <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="3-2-2-添加依赖"><a href="#3-2-2-添加依赖" class="headerlink" title="3.2.2 添加依赖"></a>3.2.2 添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--mybatis-plus--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--mysql--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--lombok 用来简化实体类--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-3-制作实体类"><a href="#3-2-3-制作实体类" class="headerlink" title="3.2.3 制作实体类"></a>3.2.3 制作实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Users</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"> <span class="keyword">private</span> String username;</span><br><span class="line"> <span class="keyword">private</span> String password; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-整合-MybatisPlus-制作-mapper"><a href="#3-2-4-整合-MybatisPlus-制作-mapper" class="headerlink" title="3.2.4 整合 MybatisPlus 制作 mapper"></a>3.2.4 整合 MybatisPlus 制作 mapper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UsersMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Users</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">配置文件添加数据库配置</span> <span class="string"></span></span><br><span class="line"><span class="comment">#mysql 数据库连接</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver </span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/demo?serverTimezone=GMT%2B8 </span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root </span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><h4 id="3-2-5-制作登录实现类"><a href="#3-2-5-制作登录实现类" class="headerlink" title="3.2.5 制作登录实现类"></a>3.2.5 制作登录实现类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;userDetailsService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Autowired</span></span><br><span class="line">     <span class="keyword">private</span> UsersMapper usersMapper;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException</span>&#123;</span><br><span class="line">     QueryWrapper&lt;Users&gt; wrapper = <span class="keyword">new</span> QueryWrapper();</span><br><span class="line">     wrapper.eq(<span class="string">&quot;username&quot;</span>,s);</span><br><span class="line">     Users users = usersMapper.selectOne(wrapper);</span><br><span class="line">     <span class="keyword">if</span>(users == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">&quot;用户名不存在！&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(users);</span><br><span class="line">     List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;role&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> User(users.getUsername(),<span class="keyword">new</span> BCryptPasswordEncoder().encode(users.getPassword()),auths);</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-未认证请求跳转到登录页"><a href="#3-3-未认证请求跳转到登录页" class="headerlink" title="3.3 未认证请求跳转到登录页"></a>3.3 未认证请求跳转到登录页</h3><h4 id="3-3-1-引入前端模板依赖"><a href="#3-3-1-引入前端模板依赖" class="headerlink" title="3.3.1 引入前端模板依赖"></a>3.3.1 引入前端模板依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-引入登录页面"><a href="#3-3-2-引入登录页面" class="headerlink" title="3.3.2 引入登录页面"></a>3.3.2 引入登录页面</h4><p>将准备好的登录页面导入项目中</p><h4 id="3-3-3-编写控制器"><a href="#3-3-3-编写控制器" class="headerlink" title="3.3.3 编写控制器"></a>3.3.3 编写控制器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;index&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;findAll&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;findAll&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-4-编写配置类放行登录页面以及静态资源"><a href="#3-3-4-编写配置类放行登录页面以及静态资源" class="headerlink" title="3.3.4 编写配置类放行登录页面以及静态资源"></a>3.3.4 编写配置类放行登录页面以及静态资源</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="comment">//注入 PasswordEncoder 类到 spring 容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         http.authorizeRequests()</span><br><span class="line">         .antMatchers(<span class="string">&quot;/layui/**&quot;</span>,<span class="string">&quot;/index&quot;</span>) <span class="comment">//表示配置请求路径</span></span><br><span class="line">        .permitAll() <span class="comment">// 指定 URL 无需保护。</span></span><br><span class="line">        .anyRequest() <span class="comment">// 其他请求</span></span><br><span class="line">        .authenticated(); <span class="comment">//需要认证</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-基于角色或权限进行访问控制"><a href="#3-4-基于角色或权限进行访问控制" class="headerlink" title="3.4 基于角色或权限进行访问控制"></a>3.4 基于角色或权限进行访问控制</h3><h4 id="3-4-1-hasAuthority-方法"><a href="#3-4-1-hasAuthority-方法" class="headerlink" title="3.4.1 hasAuthority 方法"></a>3.4.1 hasAuthority 方法</h4><p>如果当前的主体具有指定的权限，则返回 true,否则返回 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"><span class="comment">//注入 PasswordEncoder 类到 spring 容器中</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         http.authorizeRequests()</span><br><span class="line">         .antMatchers(<span class="string">&quot;/layui/**&quot;</span>,<span class="string">&quot;/index&quot;</span>) <span class="comment">//表示配置请求路径</span></span><br><span class="line">         .antMatchers(<span class="string">&quot;/test/index&quot;</span>).hasAuthority(<span class="string">&quot;admins&quot;</span>) <span class="comment">//当前登陆用户有这个admins权限才能访问</span></span><br><span class="line">        .permitAll() <span class="comment">// 指定 URL 无需保护。</span></span><br><span class="line">        .anyRequest() <span class="comment">// 其他请求</span></span><br><span class="line">        .authenticated(); <span class="comment">//需要认证</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在userDetailService中添加权限</p><h4 id="3-4-2-hasAnyAuthority-方法"><a href="#3-4-2-hasAnyAuthority-方法" class="headerlink" title="3.4.2 hasAnyAuthority 方法"></a>3.4.2 hasAnyAuthority 方法</h4><p>如果当前的主体有任何提供的角色（给定的作为一个逗号分隔的字符串列表）的话，返回true.</p><h4 id="3-4-3-hasRole-方法"><a href="#3-4-3-hasRole-方法" class="headerlink" title="3.4.3 hasRole 方法"></a>3.4.3 hasRole 方法</h4><p>如果用户具备给定角色就允许访问,否则出现 403。</p><p>如果当前主体具有指定的角色，则返回 true。</p><p>.antMatchers(“/test/index”).hasRole(“sale”) //当前登陆用户有这个admins权限才能访问</p><p>修改配置文件：</p><p>注意配置文件中不需要添加”ROLE_“，因为上述的底层代码会自动添加与之进行匹配。</p><h4 id="3-4-4-hasAnyRole"><a href="#3-4-4-hasAnyRole" class="headerlink" title="3.4.4 hasAnyRole"></a>3.4.4 hasAnyRole</h4><p>表示用户具备任何一个条件都可以访问。</p><h3 id="3-6-自定义-403-页面"><a href="#3-6-自定义-403-页面" class="headerlink" title="3.6 自定义 403 页面"></a>3.6 自定义 403 页面</h3><h4 id="3-6-1-修改访问配置类"><a href="#3-6-1-修改访问配置类" class="headerlink" title="3.6.1 修改访问配置类"></a><strong>3.6.1</strong> 修改访问配置类</h4><p><code>http.exceptionHandling().accessDeniedPage(**&quot;/unauth&quot;**);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/unauth&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">accessDenyPage</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;unauth&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line">unauth.html</span><br><span class="line">&lt;body&gt; </span><br><span class="line">    &lt;h1&gt;对不起，您没有访问权限！&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="3-8-基于数据库的记住我"><a href="#3-8-基于数据库的记住我" class="headerlink" title="3.8 基于数据库的记住我"></a>3.8 基于数据库的记住我</h3><p><img src="/2021/02/15/%E6%A1%86%E6%9E%B6/SpringSecurity/%E8%AE%B0%E4%BD%8F%E6%88%91%E6%B5%81%E7%A8%8B.png" alt="image-20210220165003654"></p><h3 id="3-9-用户注销"><a href="#3-9-用户注销" class="headerlink" title="3.9 用户注销"></a>3.9 用户注销</h3><h4 id="3-9-1-在登录页面添加一个退出连接"><a href="#3-9-1-在登录页面添加一个退出连接" class="headerlink" title="3.9.1 在登录页面添加一个退出连接"></a>3.9.1 在登录页面添加一个退出连接</h4><p>success.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">登录成功<span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/logout&quot;</span>&gt;</span>退出<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-9-2-在配置类中添加退出映射地址"><a href="#3-9-2-在配置类中添加退出映射地址" class="headerlink" title="3.9.2 在配置类中添加退出映射地址"></a>3.9.2 在配置类中添加退出映射地址</h4><p>http.logout().logoutUrl(“/logout”).logoutSuccessUrl(“/index”).permitAll</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger2</title>
      <link href="/2021/02/12/%E6%A1%86%E6%9E%B6/swagger/"/>
      <url>/2021/02/12/%E6%A1%86%E6%9E%B6/swagger/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Swagger简介"><a href="#一、Swagger简介" class="headerlink" title="一、Swagger简介"></a>一、Swagger简介</h2><p><strong>Swagger2 是一个规范和完整的框架，用于生成、描述、调用和可视化Restful风格的web服务。</strong></p><p>接口文档对于前后端开发人员都非常重要。Swagger可以使得接口文档动态生成</p><p><code>OpenApi</code>：是<strong>REST</strong> API的api描述格式</p><ul><li>每个访问地址类型。POST（写）或者GET（读）</li><li>每个操作的参数，包括输入输出参数</li><li>认证方法</li><li>连接信息，声明，使用团队和其他信息。</li></ul><p>Open API规范可以使用YAML或JSON格式进行编写。</p><p>Open API规范为REST API定义了一个与语言无关的标准接口。</p><p><code>Swagger2</code>的组件：</p><ul><li>Swagger Editor：基于浏览器编辑器，可以在里面编写Open API规范。配置中出现-&gt;定制文档</li><li><strong>Swagger UI：将Open API规范呈现为交互式API文档，用可视化UI展示描述文件。</strong></li><li>Swagger Codgen：将Open API规范生成为服务器存根和客户端库。</li><li>Swagger Inspector：跟ui有点类似，但是可以返回更多信息，也可以保存请求的实际参数数据。</li><li>Swagger Hub：集成上面所有项目的各个功能。</li></ul><p><code>spring fox</code>：<strong>是根据代码生成接口文档，所以生成进行更新项目版本</strong>，修改代码即可，而不需要跟随修改描述文件。</p><h2 id="二、Swagger-UI用法"><a href="#二、Swagger-UI用法" class="headerlink" title="二、Swagger-UI用法"></a>二、Swagger-UI用法</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在启动类上添加一个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableSwagger2</span> <span class="comment">//springfox的注解，开启swagger2相关技术的开启</span></span><br><span class="line"><span class="comment">//会扫描当前类所在的包以及子包中所有类型当中的注解。做swagger文档的定值</span></span><br></pre></td></tr></table></figure><p>可以通过 <code>localhost:8080/swagger-ui.html</code>来访问swagger文档</p><p>swagger-ui可以帮我们做请求的模拟处理（类似于postman）</p><h2 id="三、Swagger2配置"><a href="#三、Swagger2配置" class="headerlink" title="三、Swagger2配置"></a>三、Swagger2配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Docket类型的对象，并使用spring容器管理</span></span><br><span class="line"><span class="comment">     * Docket是Swagger的全局配置对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Docket docket = <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2);</span><br><span class="line"><span class="comment">//1.api帮助文档的描述信息</span></span><br><span class="line">        ApiInfo apiInfo =  <span class="comment">//api帮助文档的描述信息</span></span><br><span class="line">                <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                        .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;lqSwagger开发文档&quot;</span>,  <span class="comment">//文档的发布者名称</span></span><br><span class="line">                                <span class="string">&quot;http://localhost.com&quot;</span>, <span class="comment">//企业网站</span></span><br><span class="line">                                <span class="string">&quot;1426768270@qq.com&quot;</span>)) <span class="comment">//发布者的电子邮箱</span></span><br><span class="line">                        .title(<span class="string">&quot;Swagger框架学习帮助文档&quot;</span>)</span><br><span class="line">                        .description(<span class="string">&quot;Swagger框架学习帮助文档详细描述&quot;</span>)</span><br><span class="line">                        .version(<span class="string">&quot;1.2&quot;</span>)</span><br><span class="line">                        .build(); <span class="comment">//构建器模式创建对象</span></span><br><span class="line">        docket.apiInfo(apiInfo);<span class="comment">//给docket上下文配置api描述信息</span></span><br><span class="line">        docket</span><br><span class="line">                .select() <span class="comment">//2.获取Docket中的选择器 返回ApiSelectorBuilder.构建选择器 如：扫描什么包的注解</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.wang.controller&quot;</span>))<span class="comment">//3.设定扫描那个包（包含子包）中的注解</span></span><br><span class="line">                .apis(Predicates.not(<span class="comment">//取反</span></span><br><span class="line">                        RequestHandlerSelectors.withMethodAnnotation( <span class="comment">//当方法上有什么注解的时候返回true</span></span><br><span class="line">                                MyAnnotationSwagger.class)) <span class="comment">//自定义的注解</span></span><br><span class="line">                )<span class="comment">//4.整体表示方法上有这个注解的时候就不会生成文档在swagger上面了</span></span><br><span class="line">                .paths(Predicates.or(</span><br><span class="line">                        PathSelectors.regex(<span class="string">&quot;/swagger/.*&quot;</span>),</span><br><span class="line">                        PathSelectors.regex(<span class="string">&quot;/.*&quot;</span>),</span><br><span class="line">                        PathSelectors.regex(<span class="string">&quot;/swagger2/.*&quot;</span>))</span><br><span class="line">                )<span class="comment">//5.通过正则表达式约束生成api文档的路径地址  表示上面三个路径的任意一个都会返回true，也就是会在swagger文档中表现出来</span></span><br><span class="line">                .build();<span class="comment">//6.必须要build，要不然上面不会生效</span></span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的注解类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)</span> <span class="comment">//描述当前的注解可以定义在什么资源上面</span></span><br><span class="line"><span class="comment">//METHOD：方法  TYPE：类型 FILED：属性 PARAMETER：定义在方法参数上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">//当前注解什么时候有效</span></span><br><span class="line"><span class="comment">//RUNTIME：运行时有效 SOURCE：源码有效 CLASS：字节码有效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotationSwagger &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;<span class="comment">//自定义注解的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、Swagger2常用注解"><a href="#四、Swagger2常用注解" class="headerlink" title="四、Swagger2常用注解"></a>四、Swagger2常用注解</h2><ul><li><p>@Api：描述当前类型生成帮助文档的信息</p><p>tags属性其实就是给控制类起别名，在swagger上显示是别名（可以用中文），定义几个在ui中就显示几个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;Swagger学习控制器&quot;)</span> <span class="comment">//起别名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>@ApiOperation：给方法描述   value没有默认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;post方法，执行数据新增操作&quot;,notes = &quot;Swagger学习使用-处理POST请求方法&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/post&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;post&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@ApiParam</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;post方法，执行数据新增操作&quot;,notes = &quot;Swagger学习使用-处理POST请求方法&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/post&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">(<span class="meta">@ApiParam(name = &quot;用户名&quot;,value = &quot;新增用户时提供的用户名&quot;,required = true)</span> String username,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="meta">@ApiParam(name = &quot;密码&quot;,value = &quot;新增用户时提供的密码&quot;,required = true)</span> String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;post&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>@ApiIgnore ：忽略，当前注解描述的方法或者类型，不生成api帮助文档。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiIgnore</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;get&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@ApiImplicitParam：对方法的参数进行描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="meta">@ApiImplicitParam(name = &quot;a&quot;,value = &quot;test方法的参数a的描述&quot;,required = false,paramType = &quot;字符串&quot;,dataType = &quot;名值对&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String a,String b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@ApiModel：描述一个实体类型，当该实体类型会成为api帮助问你当方法的返回值类型的时候，则次注解会被解析。</p><p>@ApiModelProperty：对实体类的属性进行描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModel(value = &quot;用户类实体&quot;,description = &quot;存储用户数据&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;主键&quot;,name = &quot;主键（id）&quot;,required =false,example = &quot;1&quot;,hidden = false)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swagger2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发编程实战--第四部分 高级主题</title>
      <link href="/2021/01/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86(1)/"/>
      <url>/2021/01/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="第十三章、显示锁"><a href="#第十三章、显示锁" class="headerlink" title="第十三章、显示锁"></a>第十三章、显示锁</h2><h3 id="13-1-Lock-和ReentrantLock"><a href="#13-1-Lock-和ReentrantLock" class="headerlink" title="13.1 Lock 和ReentrantLock"></a>13.1 Lock 和ReentrantLock</h3><p>lock提供了一种无条件的、可轮询的、定时的以及可中断的锁获取操作。<br>为什么要创建一种与内置锁如此相似的新加锁机制?在大多数情况下，内置锁都能很好地工作，但在功能上存在一些局限性，例如，<strong>无法中断一个正在等待获取锁的线程，或者无法在请求获取一个锁时无限地等待下去。</strong>内置锁必须在获取该锁的代码块中释放，这就简化了编码工作，并且与异常处理操作实现了很好的交互，但却无法实现非阻塞结构的加锁规则。这些都是使用synchronized的原因，但在某些情况下，一种更灵活的加锁机制通常能提供更好的活跃性或性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock () ;</span><br><span class="line">...</span><br><span class="line">lock.lock ( ) ;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//更新对象状态</span></span><br><span class="line"><span class="comment">//捕获异常，并在必要时恢复不变性条件</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock ( ) ;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="轮询锁与定时锁"><a href="#轮询锁与定时锁" class="headerlink" title="轮询锁与定时锁"></a>轮询锁与定时锁</h4><p>由tryLock实现</p><p>如果不能获得所有需要的锁，那么可以使用可定时的或可轮询的锁获取方式，从而使你重新获得控制权，它会释放已经获得的销．然后重新尝试获取所有锁。</p><p>在实现具有时间限制的操作时，定锁同样非常有用。<strong>当在带有时同限的操作中调用了一个阻塞方法时，它能根据剩余时间来提供一个时限。如果操作不能在指定的时间内给出结果，那么就会使程序提前结束。当使用内置锁时，在开始请求锁后，这个操作将无法取消，因此内置锁很难实现带有时间限制的操作。</strong></p><h4 id="可中断的锁获取操作"><a href="#可中断的锁获取操作" class="headerlink" title="可中断的锁获取操作"></a>可中断的锁获取操作</h4><p>正如定时的锁获取操作能在带有时间限制的操作中使用独占锁，可中断的锁获取操作同样能在可取消的操作中使用加锁。<strong>lockInterruptibly方法能够在获得锁的同时保持对中断的响应</strong>，并且由于它包含在Lock中，因此无须创建其他类型的不可中断阻塞机制。<br>可中断的锁获取操作的标准结构比普通的锁获取操作略微复杂一些，因为需要两个try块。(如果在可中断的锁获取操作中抛出了InterruptedException，那么可以使用标准的try.finally加锁模式。）</p><h3 id="13-3-公平性"><a href="#13-3-公平性" class="headerlink" title="13.3 公平性"></a>13.3 公平性</h3><p>在ReentrantLock的构造函数中提供了两种公平性选择:<strong>创建一个非公平的锁（默认）或者一个公平的锁。</strong>在公平的锁上，<strong>线程将按照它们发出请求的顺序来获得锁，但在非公平的锁上，则允许“插队”:当一个线程请求非公平的锁时，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有的等待线程并获得这个锁。</strong></p><p>我们为什么不希望所有的锁都是公平的?毕竟，公平是一种好的行为，而不公平则是一种不好的行为，对不对?当执行加锁操作时，<strong>公平性将由于在挂起线程和恢复线程时存在的开销而极大地降低性能。</strong>在大多数情况下，非公平锁的性能要高于公平锁的性能。</p><h3 id="13-5-锁的选择"><a href="#13-5-锁的选择" class="headerlink" title="13.5 锁的选择"></a>13.5 锁的选择</h3><p>在一些内置锁无法满足需求的情况下，ReentrantLock 可以作为一种高级工具。当需要一些高级功能时才应该使用ReentrantLock,这些功能包括:<strong>可定时的、可轮询的与可中断为锁荻取操作，公平队列，以及非块结构的锁。</strong>否则，.还是应该优先使用synchronized。</p><h3 id="13-5-读写锁"><a href="#13-5-读写锁" class="headerlink" title="13.5 读写锁"></a>13.5 读写锁</h3><p>ReentrantLock实现了一种标准的互斥锁:<strong>每次最多只有一个线程能持有ReentrantLock。</strong>但对于维护数据的完整性来说，互斥通常是一种过于强硬的加锁规则，因此也就不必要地限制了并发性。互斥是一种保守的加锁策略，<strong>虽然可以避免“写/写”冲突和“写/读”冲突，但同样也避免了“读/读”冲突。</strong>在许多情况下，数据结构上的操作都是“读操作”—–虽然它们也是可变的并且在某些情况下被修改，但其中大多数访问操作都是读操作。此时，如果能够放宽加锁需求，允许多个执行读操作的线程同时访问数据结构，那么将提升程序的性能。只要每个线程都能确保读取到最新的数据，并且在读取数据时不会有其他的线程修改数据，那么就不会发生问题。<strong>在这种情况下就可以使用读/写锁:一个资源可以被多个读操作访问，或者被一个写操作访问，但两者不能同时进行。</strong><br>ReadWriteLock 中暴露了两个Lock对象，其中一个用于读操作，而另一个用于写操作。<strong>要读取由ReadWriteLock保护的数据，必须首先获得读取锁，当需要修改ReadWriteLock保护的数据时，必须首先获得写入锁。</strong>尽管这两个锁看上去是彼此独立的，但读取锁和写入锁只是读―写锁对象的不同视图。</p><p>读―写锁是一种性能优化措施，在一些特定的情况下能实现更高的并发性。<strong>在实际情况中，对于在多处理器系统上被频繁读取的数据结构，读-写锁能够提高性能。而在其他情况下，读一写锁的性能比独占锁的性能要略差一些，这是因为它们的复杂性更高。</strong><br>在读取锁和写入锁之间的交互可以采用多种实现方式。ReadWriteLock 中的一些可选实现包括:</p><ul><li><p>释放优先。当一个写入操作释放写入锁时，并且队列中同时存在读线程和写线程，那么应该优先选择读线程，写线程，还是最先发出请求的线程?</p></li><li><p><strong>读线程插队</strong>。如果锁是由读线程持有，但有写线程正在等待，那么新到达的读线程能否立即获得访问权，还是应该在写线程后面等待?如果允许读线程插队到写线程之前，那么将提高并发性，但却可能造成写线程发生饥饿问题。</p></li><li><p><strong>重入性</strong>。读取锁和写入锁是否是可重入的?</p></li><li><p><strong>降级</strong>。如果一个线程持有写人锁，那么它能否在不释放该锁的情况下获得读取锁?这可能会使得写入锁被“降级”为读取锁，同时不允许其他写线程修改被保护的资源。</p></li><li><p><strong>升级</strong>。读取锁能否优先于其他正在等待的读线程和写线程而升级为一个写入锁?在大多数的读一写锁实现中并不支持升级，因为如果没有显式的升级操作，那么很容易造成死锁。(如果两个读线程试图同时升级为写入锁，那么二者都不会释放读取锁。)</p></li></ul><h2 id="十四、构建自定义同步工具"><a href="#十四、构建自定义同步工具" class="headerlink" title="十四、构建自定义同步工具"></a>十四、构建自定义同步工具</h2><h3 id="14-1-状态依赖性的管理"><a href="#14-1-状态依赖性的管理" class="headerlink" title="14.1 状态依赖性的管理"></a>14.1 状态依赖性的管理</h3><p>在生产者一消费者的设计中经常会使用像ArrayBlockingQueue这样的有界缓存。在有界缓存提供的put和 take操作中都包含有一个前提条件﹔<strong>不能从空缓存中获取元素，也不能将元素放入已满的缓存中。</strong>当前提条件未满足时，依赖状态的操作可以抛出一个异常或返回一个错误状态（使其成为调用者的一个问题)，也可以保持阻塞直到对象进入正确的状态。<br>接下来介绍有界缓存的几种实现，其中将采用不同的方法来处理前提条件失败的问题。在每种实现中都扩展了BaseBoundedBuffer，在这个类中实现了一个基于数组的循环缓存，其中各个缓存状态变量(buf、head、tail和count)均由缓存的内置锁来保护。它还提供了同步的doPut和doTake方法，并在子类中通过这些方法来实现put和take操作，底层的状态将对子类隐藏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBoundedBuffere</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> <span class="keyword">final</span> v[] buf ;</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot; this&quot;</span> )<span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> <span class="keyword">int</span> head ;</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span>)<span class="keyword">private</span> <span class="keyword">int</span> count ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseBoundedBuffer</span> <span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buf = (V[]) <span class="keyword">new</span> Object [capacity] ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span> <span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        buf [tail] = v;</span><br><span class="line">        <span class="keyword">if</span> (++tail == buf.length)</span><br><span class="line">            tail = <span class="number">0</span> ;</span><br><span class="line">        ++count ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> V <span class="title">doTake</span> <span class="params">( )</span></span>&#123; </span><br><span class="line">        V v = buf [head] ;</span><br><span class="line">        buf [head] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(++head == buf.length)</span><br><span class="line">            head = <span class="number">0</span>;</span><br><span class="line">        --count ;</span><br><span class="line">        <span class="keyword">return</span> v ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count == buf.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> fina1 <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count == <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="示例：将前提条件的失败传递给调用者"><a href="#示例：将前提条件的失败传递给调用者" class="headerlink" title="示例：将前提条件的失败传递给调用者"></a>示例：将前提条件的失败传递给调用者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单有界缓存。put和take都进行了同步以确保对缓存状态的独占访问，线程检查后运行</span></span><br><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GrumpyBoundedBuffer</span>&lt;<span class="title">v</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">v</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GrumpyBoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123; <span class="keyword">super</span>(size); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span> <span class="params">(V v)</span> <span class="keyword">throws</span> BufferFul1Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isFull()))</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BufferFu1lException() ;doput (v) ;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> aynchronized V <span class="title">take</span> <span class="params">( )</span> <span class="keyword">throws</span> BufferEmptyException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty( ))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BufferEmptyException () ;</span><br><span class="line">        <span class="keyword">return</span> doTake ( ) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管这种方法实现起来很简单，但使用起来却并非如此。异常应该用于发生异常条件的情况中。<strong>“缓存已满”并不是有界缓存的一个异常条件</strong>。在实现缓存时得到的简化（使调用者管理状态依赖性）并不能抵消在使用时存在的复杂性，因为现在调用者必须做好捕获异常的准备，并且在每次缓存操作时都需要重试。程序清单14-4给出了对take的调用—并不是很漂亮，尤其是当程序中有许多地方都调用put和 take方法时。</p><h4 id="示例：通过轮询与休眠来实现简单的阻塞"><a href="#示例：通过轮询与休眠来实现简单的阻塞" class="headerlink" title="示例：通过轮询与休眠来实现简单的阻塞"></a>示例：通过轮询与休眠来实现简单的阻塞</h4><p>SleepyBoundedBuffer尝试通过put和 take方法来实现一种简单的“轮询与休眠”重试机制，从而使调用者无须在每次调用时都实现重试逻辑。<strong>如果缓存为空，那么take将休眠并直到另一个线程在缓存中放入一些数据:如果缓存是满的，那么put将休眠并直到另一个线程从缓存中移除一些数据，以便有空间容纳新的数据。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepyBoundedBuffer</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">v</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SleepyBoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123; <span class="keyword">super</span>(size); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span> <span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isFull())&#123;</span><br><span class="line">                doPut (v);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    Thread.sleep (SLEEP_GRANULARITY);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">take</span> <span class="params">( )</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( lisEmpty ())</span><br><span class="line">            <span class="keyword">return</span> doTake ( ) ;</span><br><span class="line">            &#125;</span><br><span class="line">    Thread.sleep ( SLEEP_GRANUI.ARITY);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SleepyBoundedBuffer的实现远比之前的实现复杂。<strong>缓存代码必须在持有缓存锁的时候才能测试相应的状态条件，因为表示状态条件的变量是由缓存锁保护的。如果测试失败，那么当前执行的线程将首先释放锁并休眠一段时间，从而使其他线程能够访问缓存。</strong>当线程醒来时，它将重新请求锁并再次尝试执行操作，因而线程将反复地在休眠以及测试状态条件等过程之间进行切换，直到可以执行操作为止。<br>从调用者的角度看，这种方法能很好地运行，如果某个操作可以执行，那么就立即执行，否则就阻塞，调用者无须处理失败和重试。<strong>要选择合适的休眠时间间隔，就需要在响应性与CPU使用率之间进行权衡。休眠的间隔越小，响应性就越高，但消耗的CPU资源也越高。</strong></p><p>休眠间隔对响应性的影响:在缓存中出现可用空间的时刻与线程醒来并再次检查的时刻之间可能存在延迟。线程刚进入休眠，条件立即为真，存在不必要的休眠时间。</p><h4 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h4><p>“条件队列”这个名字来源于:<strong>它使得一组线程（称之为等待线程集合）能够通过某种方式来等待特定的条件变成真。</strong>传统队列的元素是一个个数据， 而与之不同的是，条件队列中的元素是一个个正在等待相关条件的线程。</p><p>正如每个Java对象都可以作为一个锁，每个对象同样可以作为一个条件队列，并且<strong>Object中的wait、notify和notifyAll方法就构成了内部条件队列的API。</strong>对象的内置锁与其内部条件队列是相互关联的，要调用对象X中条件队列的任何一个方法，必须持有对象X上的锁。这是因为“等待由状态构成的条件”与“维护状态一致性”这两种机制必须被紧密地绑定在一起:只有能对状态进行检查时，才能在某个条件上等待，并且只有能修改状态时，才能从条件等待中释放另一个线程。<br><strong>Object.wait 会自动释放锁，并请求操作系统挂起当前线程，从而使其他线程能够获得这个锁并修改对象的状态。当被挂起的线程醒来时，它将在返回之前重新获取锁。</strong>从直观上来理解，调用wait意味着“我要去休息了，但当发生特定的事情时唤醒我”，而调用通知方法就意味着“特定的事情发生了”。·</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BoundedBuffer中使用了wait和notifyAll来实现一个有界缓存。这比使用“休眠”的有界缓存更简单，并且更高效（当缓存状态没有发生变化时，线程醒来的次数将更少)，响应性也更高（当发生特定状态变化时将立即醒来)。</span></span><br><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span>&lt;<span class="title">v</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBoundedBuffer</span>&lt;<span class="title">v</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//条件谓词: not -full ( !isFul1())</span></span><br><span class="line"><span class="comment">//条件谓词: not -empty ( !isEmpty ( ))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BoundedBuffer</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123; <span class="keyword">super</span> (size) ; &#125;</span><br><span class="line">    <span class="comment">//阻塞并直到:not-full</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span> <span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedBxception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isFull())</span><br><span class="line">        wait();</span><br><span class="line">        doPut(v);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//阻塞并直到: not-empty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> v <span class="title">take</span> <span class="params">( )</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( isEmpty (<span class="number">0</span>) )  </span><br><span class="line">        wait ();</span><br><span class="line">        V v = doTake();</span><br><span class="line">        notifyA11 ();</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意﹔与使用“休眠”的有界缓存相比，条件队列并没有改变原来的语义。它只是在多个方面进行了优化:<strong>CPU效率、上下文切换开销和响应性等</strong>。如果某个功能无法通过“轮询和休眠”来实现，那么使用条件队列也无法实现，但条件队列使得在表达和管理状态依赖性时更加简单和高效</p><h3 id="14-2-使用条件队列"><a href="#14-2-使用条件队列" class="headerlink" title="14.2 使用条件队列"></a>14.2 使用条件队列</h3><p>条件队列<strong>使构建高效以及高可响应性的状态依赖类变得更容易，但同时也很容易被不正确地使用。</strong>虽然许多规则都能确保正确地使用条件队列，但在编译器或系统平台上却并没有强制要求遵循这些规则。(这也是为什么要尽量基于LinkeBlockingQueue、Latch、Semaphore和FutureTask等类来构造程序的原因之一，如果能避免使用条件队列，那么实现起来将容易许多。)</p><h4 id="条件谓词"><a href="#条件谓词" class="headerlink" title="条件谓词"></a>条件谓词</h4><p>条件谓词是<strong>使某个操作成为状态依赖操作的前提条件</strong>。在有界缓存中，只有当缓存不为空时，take方法才能执行，否则必须等待。对take方法来说，它的条件谓词就是“缓存不为空”，take方法在执行之前必须首先测试该条件谓词。同样，put方法的条件谓词是“缓存不满”。条件谓词是由类中各个状态变量构成的表达式。BaseBoundedBuffer在测试“缓存不为空”时将把count与0进行比较，在测试“缓存不满”时将把count与缓存的大小进行比较。</p><h4 id="过早唤醒"><a href="#过早唤醒" class="headerlink" title="过早唤醒"></a>过早唤醒</h4><p>当执行控制重新进入调用wait的代码时，它已经重新获取了与条件队列相关联的锁。现在条件谓词是不是已经变为真了或许。<strong>在发出通知的线程调用notifyAll时，条件谓词可能已经变成真，但在重新获取锁时将再次变为假。在线程被唤醒到wait重新获取锁的这段时间里，可能有其他线程已经获取了这个锁，并修改了对象的状志。</strong>或者，条件谓词从调用wait起根本就没有变成真。你并不知道另一个线程为什么调用notify或notifyAll，也许是因为与同一条件队列相关的另一个条件谓词变成了真。“一个条件队列与多个条件谓词相关”是一种很常见的情况——在BoundedBuffer中使用的条件队列与“非满”和“非空”两个条件谓词相关。<br><strong>基于所有这些原因，每当线程从wait中唤醒时，都必须再次测试条件谓词，如果条件谓词不为真，那么就继续等待（或者失败)。</strong>由于线程在条件谓词不为真的情况下也可以反复地醒来，因此必须在一个循环中调用wait，并在每次迭代中都测试条件谓词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stateDependentMethod</span><span class="params">( )</span> <span class="keyword">throws</span> InterruptedException</span>&#123;&#125;</span><br><span class="line"><span class="comment">//必须通过一个锁来保护条件谓词</span></span><br><span class="line">    <span class="keyword">synchronized</span> ( lock) &#123;</span><br><span class="line">    <span class="keyword">while</span> ( !conditionPredicate ( ))</span><br><span class="line">            lock . wait () ;.</span><br><span class="line">    <span class="comment">//现在对象处于合适的状态</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="丢失的信号"><a href="#丢失的信号" class="headerlink" title="丢失的信号"></a>丢失的信号</h4><p>丢失的信号是指:<strong>线程必须等待一个已经为真的条件，但在开始等待之前没有检查条件谓词。现在，线程将等待一个已经发过的事件。</strong>这就好比在启动了烤面包机后出去拿报纸，当你还在屋外时烤面包机的铃声响了，但你没有听到，因此还会坐在厨房的桌子前等着烤面包机的铃声。你可能会等待很长的时间。通知并不像你涂在面包上的果酱，它没有“黏附性”。如果线程A通知了一个条件队列，而线程B随后在这个条件队列上等待，那么线程B将不会立即醒来，而是需要另一个通知来唤醒它。像上述程序清单中警示之类的编码错误（例如，没有在调用wait之前检测条件谓词）就会导致信号的丢失。</p><h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>在有界缓存中，如果缓存为空，那么在调用take时将阻塞。在缓存变为非空时，为了使take解除阻塞，必须<strong>确保在每条使缓存变为非空的代码路径中都发出一个通知。</strong>在BoundedBuffer中，只有一条代码路径，即在put方法之后。因此，put在成功地将一个元素添加到缓存后，将调用notifyAll。同样，take在移除一个元素后也将调用notifyAll，向任何正在等待“不为满”条件的线程发出通知:缓存已经不满了。</p><p>在BoundedBuffer的put和take方法中采用的通知机制是保守的:每当将一个对象放入缓存或者从缓存中移走一个对象时，就执行一次通知。我们可以对其进行优化:<strong>首先，仅当缓存从空变为非空，或者从满转为非满时，才需要释放一个线程。并且，仅当put或take影响到这些状态转换时，才发出通知。</strong>这也被称为“条件通知(Conditional Notification)。虽然“条件通知”可以提升性能，但却很难正确地实现(而且还会使子类的实现变得复杂)，因此在使用时应该谨慎。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(V v)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (isFull())</span><br><span class="line">    wait() ;</span><br><span class="line">    <span class="keyword">boolean</span> wasEmpty = isEmpty();</span><br><span class="line">    doPut (v) ;</span><br><span class="line">    <span class="keyword">if</span> (wasEmpty)</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="示例：阀门类"><a href="#示例：阀门类" class="headerlink" title="示例：阀门类"></a>示例：阀门类</h4><p>ThreadGate可以打开和关闭阀门，并提供一个await方法，该方法能一直阻塞直到阀门被打开。在open方法中使用了notifyAll，这是因为这个类的语义不满足单次通知的“单进单出”测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGate</span> </span>&#123;</span><br><span class="line"><span class="comment">//条件谓词:opened-since (n) (isopen [l generation&gt;n)</span></span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> <span class="keyword">boolean</span> isopen;</span><br><span class="line"><span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> <span class="keyword">int</span> generation ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    isopen = <span class="keyword">false</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ++generation ;</span><br><span class="line">        isopen = <span class="keyword">true</span>;</span><br><span class="line">        notifyAll();</span><br><span class="line">&#125;        </span><br><span class="line"><span class="comment">//阻塞并直到: opened-since (generation on entry)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">await</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arrivalGeneration = generation ;</span><br><span class="line">        <span class="keyword">while</span> ( !isopen &amp;&amp; arrivalGeneration == generation)</span><br><span class="line">        wait () ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在await 中使用的条件谓词比测试isOpen复杂得多。<strong>这种条件谓词是必需的，因为如果当阀门打开时有N个线程正在等待它，那么这些线程都应该被允许执行。</strong>然而，如果阀门在打开后又非常快速地关闭了，并且await方法只检查isOpen，<strong>那么所有线程都可能无法释放﹔当所有线程收到通知时，将重新请求锁并退出wait，而此时的阀门可能已经再次关闭了。</strong>因此，在ThreadGate中使用了一个更复杂的条件谓词:每次阀门关闭时，.递增一个“Generation”计数器，如果阀门现在是打开的，或者阀门自从该线程到达后就一直是打开的，那么线程就可以通过await。<br>由于ThreadGate 只支持等待打开阀门，因此它只在open 中执行通知。要想既支持“等待打开”又支持“等待关闭”，那么ThreadGate必须在open和close中都进行通知。这很好地说明了为什么在维护状态依赖的类时是非常困难的—当增加一个新的状态依赖操作时，可能需要对多条修改对象的代码路径进行改动，才能正确地执行通知。</p><h3 id="14-3-显示的Condition对象"><a href="#14-3-显示的Condition对象" class="headerlink" title="14.3 显示的Condition对象"></a>14.3 显示的Condition对象</h3><p>当内置锁过于灵活时，可以使用显示锁。Lock是一种广义的内置锁，Condition也是一种广义的内置条件队列。</p><p>使用显示的Lock和Condition，<strong>一个Condition和一个Lock关联在一起，就像一个条件队列和一个内置锁相关联一样。</strong>要创建一个Condition，可以在相关联的Lock 上调用Lock.newCondition方法。正如Lock 比内置加锁提供了更为丰富的功能，Condition同样比内置条件队列提供了更丰富的功能:<strong>在每个锁上可存在多个等待、条件等待可以是可中断的或不可中断的、基于时限的等待，以及公平的或非公平的队列操作</strong>。</p><p>与内置条件队列不同的是，对于每个Lock，可以有任意数量的Condition对象。Condition对象继承了相关的Lock对象的公平性，对于公平的锁，线程会依照FIFO顺序从Condition.await中释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给出了有界缓存的另一种实现，即使用两个Condition，分别为notFull和notEmpty，用于表示“非满”与“非空”两个条件谓词。当缓存为空时，take将阻塞并等待notEmpty，此时put向notEmpty发送信号，可以解除任何在take中阻塞的线程。</span></span><br><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionBoundedBuffer</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock () ;</span><br><span class="line">    <span class="comment">//条件谓词:notFull (count &lt; items . length)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> condition notFull= lock.newCondition ( ) ;</span><br><span class="line">    <span class="comment">//条件谓词:notEmpty (count &gt; 0 )</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> condition notEmpty= lock.newCondition( ) ;</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot; lock&quot;</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] items = (T[]) <span class="keyword">new</span> 0bject [BUFFER_SIZB];</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot; lock&quot;</span>) <span class="keyword">private</span> <span class="keyword">int</span> tail, head,count ;</span><br><span class="line"><span class="comment">//阻塞并直到: notFull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span> <span class="params">(T x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock ( ) ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count -= items.length)</span><br><span class="line">            notFull.await ();</span><br><span class="line">            items [tail] = x ;</span><br><span class="line">            <span class="keyword">if</span> (++tail == items.length)</span><br><span class="line">                tail = <span class="number">0</span> ;</span><br><span class="line">            ++count ;</span><br><span class="line">            notEmpty.signal ( );&#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock .unlock ( ) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//阻塞并直到:notEmpty</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span> <span class="params">( )</span> <span class="keyword">throws</span> IrterruptedException </span>&#123;</span><br><span class="line">        lock .lock ( ) ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await ( ); </span><br><span class="line">            T x = items [head] ;</span><br><span class="line">            items [head] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> ( ++head == items. length)</span><br><span class="line">            head = <span class="number">0</span> ;</span><br><span class="line">            --count ;</span><br><span class="line">            notFull.signal ();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock .unlock ( ) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="14-4-Synchronizer"><a href="#14-4-Synchronizer" class="headerlink" title="14.4 Synchronizer"></a>14.4 Synchronizer</h3><p><strong>在ReentrantLock和 Semaphore这两个接口之间存在许多共同点。这两个类都可以用做一个“阀门”，即每次只允许一定数量的线程通过，并当线程到达阀门时，可以通过（在调用lock 或acquire时成功返回)，也可以等待（在调用lock或acquire时阻塞)，还可以取消（在调用tryLock或tryAcquire时返回“假”，表示在指定的时间内锁是不可用的或者无法获得许可)</strong>。而且，这两个接口都支持可中断的、不可中断的以及限时的获取操作，并且也都支持等待线程执行公平或非公平的队列操作</p><p>事实上，它们在实现时都使用了一个共同的基类，即<code>AbstractQueuedSynchronizer</code>(AQS),这个类也是其他许多同步类的基类。AQS是一个用于构建锁和同步器的框架，许多同步器都可以通过AQS很容易并且高效地构造出来。<strong>不仅ReentrantLock和Semaphore是基于AQS构建的，还包括CountDownLatch、ReentrantReadWriteLock、SynchronousQueue和FutureTask。</strong></p><h3 id="14-5-AbstractQueuedSynchronizer"><a href="#14-5-AbstractQueuedSynchronizer" class="headerlink" title="14.5 AbstractQueuedSynchronizer"></a>14.5 AbstractQueuedSynchronizer</h3><p>大部分开发者都不会直接使用AQS。在基于AQS构建的同步器类中，最基本的操作包括各种形式的获取操作和释放操作。<strong>获取操作是一种依赖状态的操作，并且通常会阻塞。当使用锁或信号量时，“获取”操作的含义就很直观，即获取的是锁或者许可，并且调用者可能会一直等待直到同步器类处于可被获取的状态。</strong>在使用CountDownLatch时，<strong>“获取”操作意味着“等待并直到闭锁到达结束状态”</strong>，而在使用FutureTask时，<strong>则意味着“等待并直到任务已经完成”</strong>。“释放”并不是一个可阻塞的操作，当执行“释放”操作时，所有在请求时被阻塞的线程都会开始执行。<br>如果一个类想成为状态依赖的类，那么它必须拥有一些状态。AQS负责管理同步器类中的状态，它管理了一个整数状态信息，可以通过getState，setState以及compareAndSetState等protected类型方法来进行操作。这个整数可以用于表示任意状态。例如，<strong>ReentrantLock用它来表示所有者线程已经重复获取该锁的次数，Semaphore用它来表示剩余的许可数量，FutureTask用它来表示任务的状态（尚未开始、正在运行、已完成以及已取消)。在同步器类中还可以自行管理一些额外的状态变量，例如，ReentrantLock 保存了锁的当前所有者的信息，这样就能区分某个获取操作是重入的还是竞争的。</strong><br>AQS中的获取操作与释放操作的形式。根据同步器的不同，<strong>获取操作可以是一种独占操作（例如ReentrantLock)，也可以是一个非独占操作（例如Semaphore利CountDownLatch)。一个获取操作包括两部分。首先，同步器判断当前状态是否允许获得操作如果是，则允许线程执行，否则获取操作将阻塞或失败。这种判断是由同步器的语义决定的例如，对于锁来说，如果它没有被某个线程持有，那么就能被成功地获取，而对于闭锁来说如果它处于结束状态，那么也能被成功地获取。</strong></p><p>其次，就是更新同步器的状态，获取同步器的某个线程可能会对其他线程能否也获取该同步器造成影响。例如，当获取一个锁后，锁的状态将从“未被持有”变成“已被持有”，而从Semaphore中获取一个许可后，将把剩余许可的数量减1。然而，当一个线程获取闭锁时，并不会影响其他线程能否获取它，因此获取闭锁的操作不会改变闭锁的状态。</p><h3 id="14-6-java-util-concurrent同步器中的AQS"><a href="#14-6-java-util-concurrent同步器中的AQS" class="headerlink" title="14.6 java.util.concurrent同步器中的AQS"></a>14.6 java.util.concurrent同步器中的AQS</h3><h4 id="ReetntrantLock"><a href="#ReetntrantLock" class="headerlink" title="ReetntrantLock"></a>ReetntrantLock</h4><p>ReentrantLock <strong>只支持独占方式的获取操作</strong>，因此它实现了tryAcquire、tryRelease和isHeldExclusively。ReentrantLock将同步状态用于保存锁获取操作的次数，并且还维护一个owner变量来保存当前所有者线程的标识符，只有在当前线程刚刚获取到锁，或者正要释放锁的时候，才会修改这个变量。<strong>在tryRelease 中检查owner域，从而确保当前线程在执行unlock操作之前已经获取了锁:在tryAcquire中将使用这个域来区分获取操作是重入的还是竞争的。</strong></p><p><strong>当一个线程尝试获取锁时，tryAcquire将首先检查锁的状态。如果锁未被持有，那么它将尝试更新锁的状态以表示锁已经被持有。由于状态可能在检查后被立即修改，因此tryAcquire使用compareAndSetState来原子地更新状态，表示这个锁已经被占有，并确保状态在最后一次检查以后就没有被修改过。如果锁状态表明它已经被持有，并且如果当前线程是锁的拥有者，那么获取计数会递增，如果当前线程不是锁的拥有者，那么获取操作将失败。</strong><br>ReentrantLock还利用了AQS对多个条件变量和多个等待线程集的内置支持。Lock.newCondition将返回一个新的ConditionObject实例，这是AQS的一个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> ignored)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Thread current = Thread.currentThread ( ) ;</span><br><span class="line">    <span class="keyword">int</span> c = getstate ( ) ;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(compareAndsetstate(<span class="number">0</span>,<span class="number">1</span>)) &#123;</span><br><span class="line">        owner = current ;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (current == owner) &#123;</span><br><span class="line">        Setstate (c+<span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Semaphore-与CountDownLatch"><a href="#Semaphore-与CountDownLatch" class="headerlink" title="Semaphore 与CountDownLatch"></a>Semaphore 与CountDownLatch</h4><p>Semaphore将AQS的同步状态<strong>用于保存当前可用许可的数量</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryAcquireShared方法首先计算剩余许可的数量，如果没有足够的许可，那么会返回一个值表示获取操作失败。如果还有剩余的许可，那么tryAcquireShared会通过compareAndSetState以原子方式来降低许可的计数。如果这个操作成功(这意味着许可的计数自从上一次读取后就没有被修改过)，那么将返回一个值表示获取操作成功。在返回值中还包含了表示其他共享获取操作能否成功的信息，如果成功，那么其他等待的线程同样会解除阻塞。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireshared</span> <span class="params">(<span class="keyword">int</span> acquires)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> available = getstate () ;</span><br><span class="line">    <span class="keyword">int</span> remaining = available - acquires ;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span></span><br><span class="line">     || compareAndsetstate (available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseshared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> p = getstate ( ) ;</span><br><span class="line">    <span class="keyword">if</span> (compareAndsetstate(p, p + releases))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当没有足够的许可，或者当tryAcquireShared可以通过原子方式来更新许可的计数以响应获取操作时，while循环将终止。虽然对compareAndSetState的调用可能由于与另一个线程发生竞争而失败，并使其重新尝试，但在经过了一定次数的重试操作以后，在这两个结束条件中有一个会变为真。同样，tryReleaseShared将增加许可计数，这可能会解除等待中线程的阻塞状态，并且不断地重试直到更新操作成功。tryReleaseShared的返回值表示在这次释放操作中解除了其他线程的阻塞。</span></span><br></pre></td></tr></table></figure><p>CountDownLatch使用AQS的方式与Semaphore很相似:在同步状态中保存的是当前的计数值。countDown方法调用release，从而导致计数值递减，并且当计数值为零时，解除所有等待线程的阻塞。await 调用acquire，当计数器为零时，acquire将立即返回，否则将阻塞。</p><h4 id="Future-Task"><a href="#Future-Task" class="headerlink" title="Future Task"></a>Future Task</h4><p>初看上去，FutureTask甚至不像一个同步器，但Future.get的语义非常类似于闭锁的语义——如果发生了某个事件（由FutureTask表示的任务执行完成或被取消)，那么线程就可以恢复执行，否则这些线程将停留在队列中并直到该事件发生。<br>在FutureTask 中，<strong>AQS同步状态被用来保存任务的状态，例如，正在运行、已完成或已取消。</strong>FutureTask 还维护一些额外的状态变量，用来保存计算结果或者抛出的异常。此外，它还维护了一个引用，指向正在执行计算任务的线程（如果它当前处于运行状态)，因而如果任务取消，该线程就会中断。</p><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h4><p>ReadWriteLock 接口表示存在两个锁:一个读取锁和一个写入锁，但在基于AQS实现的ReentrantReadWriteLock 中，单个AQS子类将同时管理读取加锁和写入加锁。ReentrantReadWriteLock使用了一个16位的状态来表示写入锁的计数，并且使用了另一个16位的状态来表示读取锁的计数。<strong>在读取锁上的操作将使用共享的获取方法与释放方法，在写入锁上的操作将使用独占的获取方法与释放方法。</strong><br>AQS在内部维护一个等待线程队列，其中记录了某个线程请求的是独占访问还是共享访问。在ReentrantReadWriteLock中，当锁可用时，如果位于队列头部的线程执行写入操作，那么线程会得到这个锁，如果位于队列头部的线程执行读取访问，那么队列中在第一个写入线程之前的所有线程都将获得这个锁。</p><h2 id="十五、原子变量与非阻塞同步机制"><a href="#十五、原子变量与非阻塞同步机制" class="headerlink" title="十五、原子变量与非阻塞同步机制"></a>十五、原子变量与非阻塞同步机制</h2><h3 id="15-1-锁定劣势"><a href="#15-1-锁定劣势" class="headerlink" title="15.1 锁定劣势"></a>15.1 锁定劣势</h3><p>早锁的挂起和恢复过程中存在很大开销，并且通常存在长时间中断。与锁相比，volatile变量是一种更轻量级的同步操作，在使用这些变量时不会发生上下文切换或线程调度。然而，volatile变量同样存在一些局限:虽然它们提供了相似的可见性保证，但不能用于构建原子的复合操作。因此，当一个变量依赖其他的变量时，或者当变量的新值依赖于旧值时,就不能使用volatile变量。这些都限制了volatile变量的使用，因此它们不能用来实现一些常见的工具，例如计数器或互斥体(mutex)。<br>例如，虽然自增操作(++i)看起来像一个原子操作，但事实上它包含了3个独立的操作——获取变量的当前值，将这个值加1，然后再写入新值。为了确保更新操作不被丢失，整个的读一改–写操作必须是原子的。到目前为止，我们实现这种原子操作的唯一方式就是使用锁定方式。</p><h3 id="15-2-硬件对并发的支持"><a href="#15-2-硬件对并发的支持" class="headerlink" title="15.2 硬件对并发的支持"></a>15.2 硬件对并发的支持</h3><p>对于细粒度的操作，还有另外一种更高效的方法，也是一种乐观的方法，通过这种方法可以在不发生干扰的情况下完成更新操作。<strong>这种方法需要借助冲突检查机制来判断在更新过程中是否存在来自其他线程的干扰，如果存在，这个操作将失败，并且可以重试</strong>（也可以不重试)。</p><p>现在几乎所有的处理器都包含了某种形式的原子读-改-写指令。</p><h4 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h4><p>在CAS包含了3个操作数—<strong>需要读写的内存位置V、进行比较的值A和拟写入的新值B。当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。无论位置V的值是否等于A，都将返回V原有的值。</strong>(这种变化形式被称为比较并设置，无论操作是否成功都会返回。）CAS的含义是:“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”。CAS是一项乐观的技术，它希望能成功地执行更新操作，并且如果有另一个线程在最近一次检查后更新了该变量，那么CAS能检测到这个错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimulatedCAS 说明了CAS语义</span></span><br><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">simulatedcAs</span> </span>&#123;</span><br><span class="line"><span class="meta">@GuardedPy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedvalue,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> newvalue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldvalue = value;</span><br><span class="line">    <span class="keyword">if</span> (oldvalue == expectedvalue)value = newvalue;</span><br><span class="line">    <span class="keyword">return</span> oldva1ue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedvalue,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (expectedvalue</span><br><span class="line">    == compareAndswap (expectedvalue,newvalue) ) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都将失败。然而，<strong>失败的线程并不会被挂起（这与获取锁的情况不同:当获取锁失败时，线程将被挂起)，而是被告知在这次竞争中失败，并可以再次尝试。</strong>由于一个线程在竞争CAS时失败不会阻塞，因此它可以决定是否重新尝试，或者执行一些恢复操作，也或者不执行任何操作。<br>CAS的典型使用模式是:<strong>首先从V中读取值A，并根据A计算新值B，然后再通过CAS以原子方式将V中的值由A变成B</strong>。由于CAS能检测到来自其他线程的干扰，因此即使不使用锁也能够实现原子的读一改–写操作序列。</p><h4 id="非阻塞计数器"><a href="#非阻塞计数器" class="headerlink" title="非阻塞计数器"></a>非阻塞计数器</h4><p>CasCounter使用CAS实现了一个线程安全的计数器。递增操作采用了标准形式一一读取旧的值，根据它计算出新值（加1)，并使用CAS来设置这个新值。如果CAS失败，那么该操作将立即重试。通常，反复地重试是一种合理的策略，但在一些竞争很激烈的情况下，更好的方式是在重试之前首先等待一段时间或者回退，从而避免造成活锁问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cascounter</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> simulatedcAs value ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getvalue</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.get ( ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">increment</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">        v= value.get ( );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (v != value.compareAndswap(v, v +<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> v + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看起来，基于CAS的计数器似乎比基于锁的计数器在性能上更差一些，因为它需要执行更多的操作和更复杂的控制流，并且还依赖看似复杂的CAS操作。但实际上，<strong>当竞争程度不高时，基于CAS的计数器在性能上远远超过了基于锁的计数器，而在没有竞争时甚至更高。如果要快速获取无竞争的锁，那么至少需要一次CAS操作再加上与其他锁相关的操作，因此基于锁的计数器即使在最好的情况下也会比基于CAS的计数器在一般情况下能执行更多的操作。由于CAS在大多数情况下都能成功执行（假设竞争程度不高)，因此硬件能够正确地预测while循环中的分支，从而把复杂控制逻辑的开销降至最低。</strong><br>虽然Java语言的锁定语法比较简洁，但JVM和操作在管理锁时需要完成的工作却并不简单。在实现锁定时需要遍历JVM中一条非常复杂的代码路径，并可能导致操作系统级的锁定线程挂起以及上下文切换等操作。在最好的情况下，在锁定时至少需要一次CAS，因此虽然在使用锁时没有用到CAS，但实际上也无法节约任何执行开销。另一方面，在程序内部执行CAS时不需要执行JVM代码、系统调用或线程调度操作。在应用级上看起来越长的代码路径，如果加上JVM和操作系统中的代码调用，那么事实上却变得更短。CAS的主要缺点是，它将使调用者处理竞争问题（通过重试、回退、放弃)，而在锁中能自动处理竞争问题（线程在获得锁之前将一直阻塞)。</p><h4 id="JVM对-CAS的支持"><a href="#JVM对-CAS的支持" class="headerlink" title="JVM对 CAS的支持"></a>JVM对 CAS的支持</h4><p>那么,Java代码如何确保处理器执行CAS操作?在Java 5.0之前，如果不编写明确的代码,那么就无法执行CAS。在Java 5.0中引入了底层的支持，在int、long和对象的引用等类型上都公开了CAS操作，并且.JVM把它们编译为底层硬件提供的最有效方法。<strong>在原子变量类（例如java.util.concurrent.atomic中的AtomicXxx）中使用了这些底层的JVM支持为数字类型和引用类型提供一种高效的CAS操作，而在java.util.concurrent中的大多数类在实现时则直接或间接地使用了这些原子变量类。</strong></p><h3 id="15-3-原子变量类"><a href="#15-3-原子变量类" class="headerlink" title="15.3 原子变量类"></a>15.3 原子变量类</h3><p>原子变量类相当于一种泛化的volatile变量，能够支持原子的和有条件的读–改–写操作。AtomicInteger表示一个int类型的值，并提供了get和set方法，这些Volatile类型的int变量在读取和写入上有着相同的内存语义。它还提供了一个原子的<code>compareAndSet</code>方法.(如果该方法成功执行，那么将实现与读取/写入一个volatile变量相同的内存效果)，以及原子的添加、递增和递减等方法。AtomicInteger 表面上非常像一个扩展的Counter类，但在发生竞争的情况下能提供更高的可伸缩性，因为它直接利用了硬件对并发的支持。</p><p>共有12个原子变量类，可分为4组<strong>:标量类(Scalar)、更新器类、数组类以及复合变量类。</strong>最常用的原子变量就是标量类:AtomicInteger、AtomicLong、AtomicBoolean 以及AtomicReference。所有这些类都支持CAS，此外，AtornicInteger和 AtomicLong还支持算术运算。(要想模拟其他基本类型的原子变量，可以将short或byte等类型与int类型进行转换，以及使用floatToIntBits或doubleToLongBits来转换浮点数。)</p><p>原子数组类（只支持Integer、Long和Reference版本)中的元素可以实现原子更新。原子数组类为数组的元素提供了volatile类型的访问语义，这是普通数组所不具备的特性——volatile类型的数组仅在数组引用上具有volatile语义，而在其元素上则没有。</p><p>尽管原子的标量类扩展了Number类，但并没有扩展一些基本类型的包装类，例如Integer或Long。事实上，它们也不能进行扩展:<strong>基本类型的包装类是不可修改的，而原子变量类是可修改的。</strong>在原子变量类中同样没有重新定义hashCode或equals方法，每个实例都是不同的。与其他可变对象相同，它们也不宜用做基于散列的容器中的键值。</p><h4 id="原子变量是一种更好的volatile"><a href="#原子变量是一种更好的volatile" class="headerlink" title="原子变量是一种更好的volatile"></a>原子变量是一种更好的volatile</h4><p>可以将OneValueCache中的技术与原子引用结合起来，并且通过对指向不可变对象（其中保存了下界和上界）的引用进行原子更新以避免竟态条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用了AtomicReference和 IntPair来保存状态，并通过使用compare-AndSet，使它在更新上界或下界时能避免NumberRange的竞态条件。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CasNumberRange</span> </span>&#123;</span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> lower;<span class="comment">//不变性条件: lower &lt;=upper</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> upper ;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对对象进行原子操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;IntPair&gt; values = <span class="keyword">new</span> AtomicReference&lt;IntPair&gt; (<span class="keyword">new</span> IntPair(<span class="number">0</span>,<span class="number">0</span>) ) ;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLower</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> values.get ( ).lower; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUpper</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> values.get ( ).upper; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            IntPair oldv = values.get ( ) ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; oldv.upper)·</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException (</span><br><span class="line">            <span class="string">&quot; can&#x27;t set lower to &quot;</span> + i +<span class="string">&quot; &gt; upper&quot;</span> ) ;</span><br><span class="line">            IntPair newv = <span class="keyword">new</span> IntPair (i, oldv. upper) ;</span><br><span class="line">            <span class="keyword">if</span> (values.compareAndset(oldv, newv) )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//对setupper采用类似的方法</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="十六、Java内存模型"><a href="#十六、Java内存模型" class="headerlink" title="十六、Java内存模型"></a>十六、Java内存模型</h2><h3 id="16-1-什么是内存模型，为什么需要它"><a href="#16-1-什么是内存模型，为什么需要它" class="headerlink" title="16.1 什么是内存模型，为什么需要它"></a>16.1 什么是内存模型，为什么需要它</h3><p>JMM规定了JVM必须遵循一组最小保证，这组保证规定了对变量的写入操作在何时将对于其他线程可见。JMM在设计时就在可预测性和程序的易于开发性之间进行了权衡，从而在各种主流的处理器体系架构上能实现高性能的JVM。</p><h4 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h4><p>JMM还使得不同线程看到的操作执行顺序是不同的，从而导致在缺乏同步的情况下，要推断操作的执行顺序将变得更加复杂。各种使操作延迟或者看似乱序执行的不同原因，都可以归为重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#125;<span class="comment">//在没有正确同步的情况下，即使要推断最简单的并发程序的行为也很困难。很容易想象PossibleReordering是如何输出（1，0)或(0,1）或(1，1)的:线程A可以在线程B开始之前就执行完成，线程B也可以在线程A开始之前执行完成，或者二者的操作交替执行。但奇怪的是，PossibleReordering还可以输出（0，0)。由于每个线程中的各个操作之间不存在数据流依赖性，因此这些操作可以乱序执行。（即使这些操作按照顺序执行，但在将缓存刷新到主内存的不同时序中也可能出现这种情况，从线程B的角度看，线程A中的赋值操作可能以相反的次序执行。） </span></span><br><span class="line"><span class="comment">//x = b -&gt; b = 1 -&gt; y = a -&gt; a = 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PossibleReordering</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y =<span class="number">0</span> ;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(string []args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread one = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable ()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            x = b;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;) ;</span><br><span class="line">    <span class="function">Thread other  new <span class="title">Thread</span> <span class="params">(new Runnable ( )</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">                b = <span class="number">1</span>;</span><br><span class="line">                y = a;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;) ;</span><br><span class="line">    one.start () ; other.start ( ) ;</span><br><span class="line">        one .join() ;other.join ( ) ;</span><br><span class="line">    system.out.println ( <span class="string">&quot;(&quot;</span>+ x +<span class="string">&quot;,&quot;</span>+ y + <span class="string">&quot;)&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java内存模型简介"><a href="#Java内存模型简介" class="headerlink" title="Java内存模型简介"></a>Java内存模型简介</h4><p>Java内存模型是通过各种操作来定义的，包括对变量的读/写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。JMM为程序中所有的操作定义了一个偏序关系，称之为Happens-Before。要想保证执行操作B的线程看到操作A的结果（无论A和B是否在同一个线程中执行)，那么在A和B之间必须满足Happens-Before 关系。如果两个操作之间缺乏Happens-Before 关系，那么JVM可以对它们任意地重排序。<br>当一个变量被多个线程读取并且至少被一个线程写入时，如果在读操作和写操作之间没有依照Happens-Before来排序，那么就会产生数据竞争问题。在正确同步的程序中不存在数据竞争，并会表现出串行一致性，这意味着程序中的所有操作都会按照一种固定的和全局的顺序执行。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发编程实战--第三部分 活跃性、性能与测测</title>
      <link href="/2021/01/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/"/>
      <url>/2021/01/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="十、避免活跃性危险"><a href="#十、避免活跃性危险" class="headerlink" title="十、避免活跃性危险"></a>十、避免活跃性危险</h2><h3 id="10-1-死锁"><a href="#10-1-死锁" class="headerlink" title="10.1 死锁"></a>10.1 死锁</h3><ul><li><p>锁顺序死锁：一个锁先锁left 在锁right,另一个锁先锁right再锁left,会发生死锁。</p></li><li><p><strong>动态的锁顺序死锁</strong></p><p>有时候，并不能清楚地知道是否在锁顺序上有足够的控制权来避免死锁的发生。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:容易发生死锁!</span></span><br><span class="line"><span class="comment">//看似无害的代码，它将资金从一个账户转入另一个账户。在开始转账之前，首先要获得这两个Account对象的锁，以确保通过原子方式来更新两个账户中的余额，同时又不破坏一些不变性条件，例如“账户的余额不能为负数”。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferMoney</span> <span class="params">(Account fromAccount,</span></span></span><br><span class="line"><span class="params"><span class="function">Account toAccount ,Dol1arAmount amount)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InsufficientFundsException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (fromAccount) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (toAccount) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromAccount.getBalance( ).compareTo (amount) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientFundsException ( ) ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        fromAccount.debit (amount) ;</span><br><span class="line">                toAccount .credit (amount) ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个线程同时转账，一个从X向Y转账，另一个从Y向X转账，就会发生死锁。</p><p>可以使用System.identityHashCode方法，返回hash值，必须通过任意的方法来决定锁定顺序，但仍然有很小道可能发生死锁。</p></li><li><p><strong>在协作对象之间发送死锁。</strong>：这两个锁不一定在同一个方法中被获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:容易发生死锁!</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line"><span class="meta">@GuardedBy</span> (<span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> Point location,destination;<span class="comment">//位置和谜底</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher ; <span class="comment">//出租车车队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span> <span class="params">(Dispatcher dispatcher)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> location ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span> <span class="params">(Point location)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.location = location;</span><br><span class="line"><span class="keyword">if</span> ( location. equals(destination))</span><br><span class="line">dispatcher.notifyAvailable (<span class="keyword">this</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"><span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> <span class="keyword">final</span> set&lt;Taxi&gt; taxis;</span><br><span class="line"><span class="meta">@GuardedBy( &quot;this&quot; )</span> <span class="keyword">private</span> <span class="keyword">final</span> set&lt;Taxi&gt; availableTaxis;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">        taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt; ();</span><br><span class="line">        avai lableTaxis = <span class="keyword">new</span> Hashset&lt;Taxi&gt; ( ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span> <span class="params">(Taxi taxi)</span></span>&#123;</span><br><span class="line">    availableTaxis.add (taxi) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Image <span class="title">getImage</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> Image () ;</span><br><span class="line">        <span class="keyword">for</span> (Taxi t : taxis)</span><br><span class="line">        image.drawMarker(t.getLocation ());</span><br><span class="line">        <span class="keyword">return</span> image ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果一个线程在收到GPS接收器的更新事件时调用setLocation，那么它将首先更新出租车的位置，然后判断它是否到达了目的地。如果已经到达，它会通知Dispatcher : 它需要一个新的目的地。因为<strong>setLocation和notifyAvailable都是同步方法，因此调用setLocatior的线程将首先获取Taxi的锁，然后获取 Dispatcher的锁。同样，调用getImage的线程将首先获取 Dispatcher锁，然后再获取每一个Taxi的锁（每次获取一个)。</strong><br>如果在持有锁时调用某个外部方法那么将出现活跃性问题。在这个外部方法中可能会荻取其他锁:（这可能会产生死锁）,或者阻塞时间过长，导致其他线程无法及时获得;当前被持有的锁。</p></li><li><p>开放调用</p><p><strong>如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用</strong>(Open Call)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以很容易地将Taxi和 Dispatcher修改为使用开放调用，从而消除发生死锁的风险。这需要使同步代码块仅被用于保护那些涉及共享状态的操作，。通常，如果只是为了语法紧凑或简单性（而不是因为整个方法必须通过--个锁来保护）而使用同步方法（而不是同步代码块)，那么就会导致问题。(此外，收缩同步代码块的保护范围还可以提高可伸缩性)</span></span><br><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line"> <span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> Point location，destination;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Dispatcher dispatcher ;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Point <span class="title">getLocation</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> location;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span> <span class="params">( Point location)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> reachedDestination ;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.location = location ;</span><br><span class="line">    reachedDestination = location.equals(destination) ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(reachedDestination)</span><br><span class="line">    dispatcher.notifyAvailable(<span class="keyword">this</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line"><span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> <span class="keyword">final</span> set&lt;Taxi&gt; taxis;</span><br><span class="line">GuardedBy ( <span class="string">&quot;this&quot;</span>) <span class="keyword">private</span> <span class="keyword">final</span> set&lt;Taxi&gt; availableTaxis ;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span> <span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">    availableTaxis.add (taxi) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Image <span class="title">getImage</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;Taxi&gt;copy ;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        copy = <span class="keyword">new</span> Hashset&lt;Taxi&gt; (taxis) ;</span><br><span class="line">        &#125;</span><br><span class="line">        Image image = <span class="keyword">new</span> Image () ;</span><br><span class="line">        <span class="keyword">for</span> ( Taxi t : copy)</span><br><span class="line">        image.drawMarker (t.getLocation ( ) ) ;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>资源死锁</p></li></ul><h3 id="10-2-死锁的避免和诊断"><a href="#10-2-死锁的避免和诊断" class="headerlink" title="10.2 死锁的避免和诊断"></a>10.2 死锁的避免和诊断</h3><p>在使用细粒度锁的程序中，可以通过使用一种<strong>两阶段策略（Two-Part Strategy）来检查代码中的死锁:首先，找出在什么地方将获取多个锁（使这个集合尽量小)，然后对所有这些实例进行全局分析，从而确保它们在整个程序中获取锁的顺序都保持一致。</strong></p><ul><li>支持定时的锁</li><li>通过现场转储信息来分析死锁</li></ul><h3 id="10-3-其他活跃性问题"><a href="#10-3-其他活跃性问题" class="headerlink" title="10.3 其他活跃性问题"></a>10.3 其他活跃性问题</h3><ul><li><p>饥饿：</p><p>线程由于无法访问它所需的资源而不能继续执行，就发生了饥饿。（CPU时钟周期）</p></li><li><p>糟糕的响应性</p></li><li><p>活锁</p><p>活锁(Livelock)是另一种形式的活跃性问题，该<strong>问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复执行相同的操作，而且总会失败。</strong>活锁通常发生在处理事务消息的应用程序中﹔如果不能成功地处理某个消息，那么消息处理机制将回滚整个事务，并将它重新放到队列的开头。如果消息处理器在处理某种特定类型的消息时存在错误并导致它失败，那么每当这个消息从队列中取出并传递到存在错误的处理器时，都会发生事务回滚。由于这条消息又被放回到队列开头，因此处理器将被反复调用，并返回相同的结果。</p><p><strong>要解决这个问题需要在重试机制上加入随机性。在并发程序中，通过等待随机长度的时间和回退可以有效的避免活锁</strong></p></li></ul><h2 id="十一、性能与可伸缩性"><a href="#十一、性能与可伸缩性" class="headerlink" title="十一、性能与可伸缩性"></a>十一、性能与可伸缩性</h2><h3 id="11-1-对性能的思考"><a href="#11-1-对性能的思考" class="headerlink" title="11.1 对性能的思考"></a>11.1 对性能的思考</h3><p>要想通过并发来获得更好的性能，需要努力做好两件事情:<strong>更有效地利用现有处理资源，以及在出现新的处理资源时使程序尽可能地利用这些新资源。</strong></p><h4 id="性能与可伸缩性"><a href="#性能与可伸缩性" class="headerlink" title="性能与可伸缩性"></a>性能与可伸缩性</h4><p>应用程序的性能可以采用多个指标来衡量，例如服务时间、延迟时间、吞吐率、效率、可伸缩性以及容量等。其中一-些指标（服务时间、等待时间〉用于衡量程序的“运行速度”，即某个指定的任务单元需要“多快”才能处理完成。另一些指标（生产量、吞吐量〉用于程序的“处理能力”，即在计算资源一定的情况下，能完成“多少”工作。<br>可伸缩性指的是，当增加计算资源时程序的吞吐量或者处理能力能理应地增加。</p><h3 id="11-2-Amdahl定律"><a href="#11-2-Amdahl定律" class="headerlink" title="11.2 Amdahl定律"></a>11.2 Amdahl定律</h3><p>Amdahl定律描述的是﹔在增加计算资源的情况下，程序在理论上能够实现最高加速比，这个值取决于程序中可并行组件与串行组件所占的比重。</p><p>假设应用程序中N个线程正在执行，这些线程从一个共享的工作队列中取出任务进行处理，而且这里的任务都不依赖于其他任务的执行结果或影响。暂时先不考虑任务是如何进入这个队列的，如果增加处理器，那么应用程序的性能是否会相应地发生变化?初看上去，这个程序似乎能完全并行化:各个任务之间不会相互等待，因此处理器越多,能够并发处理的任务也就越多。<strong>然而，在这个过程中包含了一个串行部分—从队列中获取任务。所有工作者线程都共享同一个工作队列，因此在对该队列进行并发访问时需要采用某种同步机制来维持队列的完整性。如果通过加锁来保护队列的状态，那么当一个线程从队列中取出任务时，其他需要获取下一个任务的线程就必须等待，这就是任务处理过程中的串行部分。</strong></p><p>单个任务的处理时间不仅包括执行任务Runnable的时间，也包括从共享队列中取出任务的时间。<strong>如果使用LinkedBlockingQueue作为工作队列，那么出列操作被阻塞的可能性将小于使用同步LinkedList时发生阻塞的可能性，因为LinkedBlockingQueue使用了一种可伸缩性更高的算法。</strong>然而，无论访问何种共享数据结构，基本上都会在程序中引入一个串行部分。<br>这个示例还忽略了另一种常见的串行操作:对结果进行处理。所有有用的计算都会生成某种结果或者产生某种效应——如果不会，那么可以将它们作为“死亡代码”删除掉。由于Runnable没有提供明确的结果处理过程，因此这些任务一定会产生某种效果，例如将它们的结果写入到日志或者保存到某个数据结构。通常，日志文件和结果容器都会由多个工作者线程共享，并且这也是一个串行部分。如果所有线程都将各自的计算结果保存到自行维护数据结构中，并且在所有任务都执行完成后再合并所有的结果，那么这种合并操作也是一个串行部分。</p><h3 id="11-3-线程引入的开销"><a href="#11-3-线程引入的开销" class="headerlink" title="11.3 线程引入的开销"></a>11.3 线程引入的开销</h3><ul><li><p>上下文切换</p><p>如果主线程是唯一的线程，那么它基本上不会被调度出去。另一方面，如果可运行的线程数大于CPU的数量，那么操作系统最终会将某个正在运行的线程调度出来，从而使其他线程能够使用CPU。这将导致一次上下文切换，在这个过程中将保存当前运行线程的执行上下文，并将新调度进来的线程的执行上下文设置为当前上下文。</p></li><li><p>内存同步</p><p>在synchronized和volatile提供的可见性保证中可能会使用一些特殊指令，即内存栅栏(Memory Barrier)。内存栅栏可以刷新缓存，使缓存无效，剧新硬件的写缓冲，以及停止执行管道。<strong>内存栅栏可能同样会对性能带来间接的影响，因为它们将抑制-些编译器优化操作。</strong>在内存栅栏中，大多数操作都是不能被重排序的。<br>现代的JVM能通过优化来去掉一些不会发生竞争的锁，从而减少不必要的同步开销。如果一个锁对象只能由当前线程访问，那么JVM就可以通过优化来去掉这个锁获取操作</p></li><li><p>阻塞</p></li></ul><h3 id="11-4-减少锁的竞争"><a href="#11-4-减少锁的竞争" class="headerlink" title="11.4 减少锁的竞争"></a>11.4 减少锁的竞争</h3><p>有两个因素将影响在锁上发生竞争的可能性:<strong>锁的请求频率，以及每次持有该锁的时间</strong>。如果二者的乘积很小，那么大多数获取锁的操作都不会发生竞争，因此在该锁上的竞争不会对可伸缩性造成严重影响。然而，如果在锁上的请求量很高，那么需要获取该锁的线程将被阻塞并等待。在极端情况下，即使仍有大量工作等待完成，处理器也会被闲置。</p><ul><li><p>缩小锁的范围</p></li><li><p>减小锁的粒度</p><p>降低线程请求锁的频率，锁分解和锁分段。</p></li><li><p>锁分段</p></li><li><p>避免热点域</p><p>将一些反复计算的结果缓存起来</p></li><li><p>一些代替独占锁的方法</p><ul><li>ReadWriteLock 读取不加锁，写加锁</li><li>原子变量 </li></ul></li></ul><h3 id="11-5-比较Map的性能"><a href="#11-5-比较Map的性能" class="headerlink" title="11.5 比较Map的性能"></a>11.5 比较Map的性能</h3><p>在单线程环境下，ConcurrentHashMap 的性能比同步的HashMap 的性能略好一些，但在并发环境中则要好得多。<br>在同步Map的实现中，可伸缩性的最主要阻碍在于整个 Map中只有一个锁，因此每次只有一个线程能够访问这个 Map。不同的是，ConcurrentHashMap对于大多数读操作并不会加锁,并且在写人操作以及其他一些需要锁的读操作中使用了锁分段技术。因此，多个线程能并发地访问这个Map而不会发生阻塞。<br>ConcurrentHashMap,ConcurrentSkipListMap,以及通过synchronizedMap来包装的HashMap 和TreeMap。前两种Map是线程安全的，而后两种通过同步容器确保线程安全性。</p><h3 id="11-6-减少上下文切换的开销"><a href="#11-6-减少上下文切换的开销" class="headerlink" title="11.6 减少上下文切换的开销"></a>11.6 减少上下文切换的开销</h3><p>在许多任务中都包含一些可能被阻塞的操作。<strong>当任务在运行和阻塞这两个状态之间转换时，就相当于一次上下文切换。在服务器应用程序中，发生阻塞的原因之一就是在处理请求时产生各种日志消息。</strong></p><p>在大多数日志框架中都是简单地对println进行包装，当需要记录某个消息时，只需将其写人日志文件中。在第7章的LogWriter中给出了另一种方法:<strong>记录日志的工作由一个专门的后台线程完成，而不是由发出请求的线程完成。</strong>从开发人员的角度来看，这两种方法基本上是相同的。但二者在性能上可能存在一些差异，这取决于日志操作的工作量，即有多少线程正在记录日志，以及其他一些因素，例如上下文切换的开销等。<br><strong>日志操作的服务时间包括与I/О流类相关的计算时间，如果IО操作被阻塞，那么还会包括线程被阻塞的时间。</strong><br>请<strong>求服务的时间不应该过长，主要有以下原因。首先，服务时间将影响服务质量:服务时间越长，就意味着有程序在获得结果时需要等待更长的时间。但更重要的是，服务时间越长，也就意味着存在越多的锁竞争。</strong></p><h2 id="十二、并发程序的测试"><a href="#十二、并发程序的测试" class="headerlink" title="十二、并发程序的测试"></a>十二、并发程序的测试</h2><p>有两类测试：安全性测试和活跃性测试。</p><p><strong>在进行安全性测试时，通常会采用测试不变性条件的形式，即判断某个类的行为是否与其规范保持一致。</strong>例如，<br>测试活跃性本身也存在问题。活跃性测试包括<strong>进展测试和无进展测试</strong>两方面，这些都是很难量化的——如何验证某个方法是被阻塞了，而不只是运行缓慢﹖同样，如何测试某个算法不会发生死锁﹖要等待多久才能宣告它发生了故障?<br>与活跃性测试相关的是性能测试。性能可以通过多个方面来衡量，包括:</p><ul><li>吞吐量:指一组并发任务中已完成任务所占的比例。</li><li>响应性．指请求从发出到完成之间的实际</li><li>可伸缩性：在增加更多的资源情况下，吞吐量的提示情况。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发编程实战--第二部分 结构化并发应用程序(2)</title>
      <link href="/2021/01/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86(2)/"/>
      <url>/2021/01/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86(2)/</url>
      
        <content type="html"><![CDATA[<h2 id="八、线程池的使用"><a href="#八、线程池的使用" class="headerlink" title="八、线程池的使用"></a>八、线程池的使用</h2><h3 id="8-1-在任务与执行策略之间的隐性耦合"><a href="#8-1-在任务与执行策略之间的隐性耦合" class="headerlink" title="8.1 在任务与执行策略之间的隐性耦合"></a>8.1 在任务与执行策略之间的隐性耦合</h3><p>Executor框架可以将任务的提交和任务执行策略解耦。但有些任务需要明确指定执行策略：</p><ul><li><strong>依赖性任务</strong>。大多数行为正确的任务都是独立的:它们不依赖于其他任务的执行时序、执行结果或其他效果。<strong>当在线程池中执行独立的任务时，可以随意地改变线程池的大小和配置，这些修改只会对执行性能产生影响。然而，如果提交给线程池的任务需要依赖其他的任务，那么就隐含地给执行策略带来了约束，</strong>此时必须小心地维持这些执行策略以避免产生活跃性问题</li><li><strong>使用线程封闭机制的任务</strong>。</li><li>对响应时间敏感的任务。</li><li>使用ThreadLocal的任务</li></ul><h4 id="线程饥饿死锁"><a href="#线程饥饿死锁" class="headerlink" title="线程饥饿死锁"></a>线程饥饿死锁</h4><p>在线程池中,如果任务依赖于其他任务，那么可能产生死锁。<strong>在单线程的Executor中，如果一个任务将另一个任务提交到同一个Executor，并且等待这个被提交任务的结果，那么通常会引发死锁。第二个任务停留在工作队列中，并等待第一个任务完成，而第一个任务又无法完成，因为它在等待第二个任务的完成。</strong>在更大的线程池中，如果所有正在执行任务的线程都由于等待其他仍处于工作队列中的任务而阻塞，那么会发生同样的问题。这种现象被称为线程饥饿死锁(Thread Starvation Deadlock)，<strong>只要线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供的资源或条件，例如某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够大，否则将发生线程饥饿死锁。</strong></p><h3 id="8-2-设置线程池大小"><a href="#8-2-设置线程池大小" class="headerlink" title="8.2 设置线程池大小"></a>8.2 设置线程池大小</h3><p>要想正确地设置线程池的大小，必须分析计算环境、资源预算和任务的特性。在部署的系统中有多少个CPU ?多大的内存﹖任务是计算密集型、IO密集型还是二者皆可﹖它们是否需要像JDBC连接这样的稀缺资源﹖如果需要执行不同类别的任务，并且它们之间的行为相差很大，那么应该考虑使用多个线程池，从而使每个线程池可以根据各自的工作负载来调整。<br><strong>对于计算密集型的任务，在拥有N个处理器的系统上，当线程池的大小为Ncpu+1时，通常能实现最优的利用率。对于包含IO操作或者其他阻塞操作的任务，由于线程并不会一直执行，因此线程池的规模应该更大。</strong>要正确地设置线程池的大小，你必须估算出任务的等待时间与计算时间的比值。这种估算不需要很精确，并且可以通过一些分析或监控工具来获得。你还可以通过另一种方法来调节线程池的大小:在某个基准负载下，分别设置不同大小的线程池来运行应用程序，并观察CPU利用率的水平。</p><h3 id="8-3-配置ThreadPoolExecutor"><a href="#8-3-配置ThreadPoolExecutor" class="headerlink" title="8.3 配置ThreadPoolExecutor"></a>8.3 配置ThreadPoolExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span> <span class="params">(<span class="keyword">int</span> corePoolsize,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> maxirnumPoolsize,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">long</span> keepAliverime,</span></span></span><br><span class="line"><span class="params"><span class="function">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">BlockingQueue&lt;Runnable&gt; workQueue ,</span></span></span><br><span class="line"><span class="params"><span class="function">                           ThreadFactory threadFactory ,</span></span></span><br><span class="line"><span class="params"><span class="function">RejectedExecutionHandler handler)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="线程的创建与销毁"><a href="#线程的创建与销毁" class="headerlink" title="线程的创建与销毁"></a>线程的创建与销毁</h4><p>线程池的<strong>基本大小(Core Pool Size)、最大大小(Maximum Pool Size）以及存活时间等因素共同负责线程的创建与销毁。</strong>基本大小也就是线程池的目标大小，即在没有任务执行时线程池的大小，并且只有在<strong>工作队列满了的情况下才会创建超出这个数量的线程。</strong>线程池的最大大小表示可同时活动的线程数量的上限。<strong>如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收的</strong>，并且当线程池的当前大小超过了基本大小时，这个线程将被终止。</p><p><code>newFixedThreadPool</code> 工厂方法将线程池的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时。<code>newCachedThreadPool</code> 工厂方法将线程池的最大大小设置为Integer.MAX_VALUE，而将基本大小设置为零，并将超时设置为1分钟，这种方法创建出来的线程池可以被无限扩展，并且当需求降低时会自动收缩。其他形式的线程池可以通过显式的ThreadPoolExecutor 构造函数来构造。</p><h4 id="管理队列任务"><a href="#管理队列任务" class="headerlink" title="管理队列任务"></a>管理队列任务</h4><p>在有限的线程池中会限制可并发执行的任务数量。</p><p>请求的平均到达速率很稳定，也仍然会出现请求突增的情况。尽管队列有助于缓解任务的突增问题，但如果任务持续高速地到来，那么最终还是会抑制请求的到达率以避免耗尽内存。甚至在耗尽内存之前，响应性能也将随着任务队列的增长而变得越来越糟。</p><p>ThreadPoolExecutor 允许提供一个<code>BlockingQueue</code>来保存等待执行的任务。基本的任务排队方法有3种:<strong>无界队列、有界队列和同步移交</strong>(Synchronous Handoff)。队列的选择与其他的配置参数有关，例如线程池的大小等。<br><strong>newFixedThreadPool和newSingleThreadExecutor在默认情况下将使用一个无界的LinkedBlockingQueue。如果所有工作者线程都处于忙碌状态，那么任务将在队列中等候。如果任务持续快速地到达，并且超过了线程池处理它们的速度，那么队列将无限制地增加。</strong></p><p>一种更稳妥的资源管理策略是使用有界队列，例如<strong>ArrayBlockingQueue、有界的LinkedBlockingQueue、PriorityBlockingQueue</strong>。<strong>有界队列有助于避免资源耗尽的情况发生，但它又带来了新的问题:当队列填满后，新的任务该怎么办?</strong>（有许多饱和策略[SaturationPolicy]可以解决这个问题。）在使用有界的工作队列时，队列的大小与线程池的大小必须一起调节。如果线程池较小而队列较大，那么有助于减少内存使用量，降低CPU的使用率，同时还可以减少上下文切换，但付出的代价是可能会限制吞吐量。</p><p><strong>对于非常大的或者无界的线程池，可以通过使用SynchronousQueue来避免任务排队，以及直接将任务从生产者移交给工作者线程。</strong>SynchronousQueue不是一个真正的队列，而是一种在线程之间进行移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接受这个元素。如果没有线程正在等待，并且线程池的当前大小小于最大值，那么ThreadPoolExecutor将创建一个新的线程，否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交给执行它的线程，而不是被首先放在队列中，然后由工作者线程从队列中提取该任务。只有当线程池是无界的或者可以拒绝任务时，SynchronousQueue才有实际价值。在newCachedThreadPool 工厂方法中就使用了SynchronousQueue。</p><h4 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h4><p>当有界队列被填满后，饱和策略就开始发挥作用。</p><p><strong>“中止(Abort)”策略是默认的饱和策略，该策略将抛出未检查的RejectedExecutionException。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。</strong>当新提交的任务无法保存到队列中等待执行时，<strong>“抛弃( Discard)”策略会悄悄抛弃该任务。“抛弃最旧的(Discard-Oldest)”策略则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。</strong><br><strong>“调用者运行(Caller-Runs)”策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。</strong></p><p>当工作队列被填满后，没有预定义的饱和策略来阻塞execute。然而，通过使用<code>Semaphore</code>(信号量）来限制任务的到达率,就可以实现这个功能。</p><h4 id="线程工程"><a href="#线程工程" class="headerlink" title="线程工程"></a>线程工程</h4><p>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息。通过指定一个线程工厂方法，可以定制线程池的配置信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的线程工厂。它创建了一个新的MyAppThread实例，并将一个特定于线程池的名字传递给MyAppThread的构造函数，从而可以在线程转储和错误日志信息中区分来自不同线程池的线程。在应用程序的其他地方也可以使用MyAppThread，以便所有线程都能使用它的调试功能。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> string poolName ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadFactory</span> <span class="params">(string poolName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.poolName = poolName ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span> <span class="params">( Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyAppThread (runnable, poolName) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-扩展ThreadPoolExecutor"><a href="#8-4-扩展ThreadPoolExecutor" class="headerlink" title="8.4 扩展ThreadPoolExecutor"></a>8.4 扩展ThreadPoolExecutor</h3><p>ThreadPoolExecutor是可扩展的，它提供了几个可以在子类化中改写的方法<code>: beforeExecute、afterExecute和 terminated</code>，这些方法可以用于扩展ThreadPoolExecutor的行为。<br>在执行任务的线程中将调用beforeExecute和afterExecute等方法，在这些方法中还可以<strong>添加日志、计时、监视或统计信息收集的功能。</strong>无论任务是从run中正常返回，还是抛出一个异常而返回，afterExecute都会被调用。(如果任务在完成后带有一个Error，那么就不会调用afterExecute。）如果beforeExecute抛出一个RuntimeException，那么任务将不被执行，并且afterExecute也不会被调用。<br>在线程池完成关闭操作时调用terminated，也就是在所有任务都已经完成并且所有工作者线程也已经关闭后。terminated可以用来释放Executor 在其生命周期里分配的各种资源，此外还可以执行发送通知、记录日志或者收集finalize统计信息等操作。</p><h4 id="示例：给线程池添加统计信息"><a href="#示例：给线程池添加统计信息" class="headerlink" title="示例：给线程池添加统计信息"></a>示例：给线程池添加统计信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TimingThreadPool中给出了一个自定义的线程池，它通过beforeExecute、afterExecute和 terminated等方法来添加日志记录和统计信息收集。为了测量任务的运行时间，beforeExecute必须记录开始时间并把它保存到一个afterExecute可以访问的地方。因为这些方法将在执行任务的线程中调用，因此 beforeExecute可以把值保存到一个ThreadLocal变量中，然后由afterExecute来读取。在TimingThreadPool中使用了两个AtomicLong变量，分别用于记录已处理的任务数和总的处理时间，并通过terminated来输出包含平均任务时间的日志消息。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimingThreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; startTime= <span class="keyword">new</span> ThreadLocal&lt;Long&gt; ( );</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger log = Logger.getLogger(<span class="string">&quot;TimingThreadPool&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong numTasks = <span class="keyword">new</span> AtomicLong() ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicEong totalTime = <span class="keyword">new</span> AtomicLong ( ) ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span> <span class="params">(Thread t, Runnable r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.beforeExecute(t, r) ;</span><br><span class="line">    log.fine (string.format ( <span class="string">&quot;Thread *s: start %s&quot;</span>,t, r)) ;</span><br><span class="line">        startTime.set (system.nanoTime ( ) ) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span> <span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> endTime = system.nanoTime ( ) ;</span><br><span class="line">            <span class="keyword">long</span> taskTime = endTime - startTime.get ( ) ;</span><br><span class="line">            numTasks.incrementAndGet() ;</span><br><span class="line">        totalTime.addAndGet (taskTime);</span><br><span class="line">        log.fine (string.format ( <span class="string">&quot;Thread is: end %s, time=%dns &quot;</span> ,</span><br><span class="line">        t, r, taskTime) ) ;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.afterExecute (r, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(string.format ( <span class="string">&quot;Terminated: avg time=%dns&quot;</span> ,</span><br><span class="line">        totalTime.get() l numTasks.get ()));</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.terminated ( ) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-5-递归算法的并行化"><a href="#8-5-递归算法的并行化" class="headerlink" title="8.5 递归算法的并行化"></a>8.5 递归算法的并行化</h3><p>如果循环的迭代操作都是独立的，并且不需要等待所有的迭代操作都完成在继续进行那么可以使用Executor将串行循环转换为并行循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将串行执行转换为并行执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processSequentially</span><span class="params">(List&lt;Element&gt; elements)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Element e : elements)</span><br><span class="line">process(e) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用processInParallel 比调用processSequentially能更快地返回，因为processInParaliel 会在所有下载任务都进入了Executor的队列后就立即返回，而不会等待这些任务全部完成。如果需要提交一个任务集并等待它们完成，那么可以使用ExecutorService.invokeAll，并且在所有任务都执行完成后调用CompletionService来获取结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInParallel</span><span class="params">(Executor exec，List&lt;Element&gt; elements)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> Element e : elements)</span><br><span class="line">exec.execute (<span class="keyword">new</span> Runnable) &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123; process(e) ; &#125;</span><br><span class="line">    &#125;) ;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在一些递归设计中同样可以采用循环并行化的方法。在递归算法中通常都会存在串行循环，而且这些循环可以进行并行化。一种简单的情况是:<strong>在每个迭代操作中都不需要来自于后续递归迭代的结果。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sequentialRecursive用深度优先算法遍历一棵树，在每个节点上执行计算并将结果放入一个集合。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">sequentialRecursive</span><span class="params">(List&lt;Node&lt;T&gt;&gt; nodes,Collection&lt;T&gt; resuits)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;T&gt; n : nodes) &#123;</span><br><span class="line">results.add (n.compute()) ;</span><br><span class="line">sequentialRecursive(n.getChildren ( ) , results) ;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//修改后的parallelRecursive同样执行深度优先遍历，但它并不是在访问节点时进行计算，而是为每个节点提交一个任务来完成计算。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>&lt;T&gt; <span class="keyword">void</span> <span class="title">parallelRecursive</span> <span class="params">(<span class="keyword">final</span> Executor exec,</span></span></span><br><span class="line"><span class="params"><span class="function">List&lt;Node&lt;T&gt;&gt; nodes,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">final</span> collection&lt;T&gt; results)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> Node&lt;T&gt; n : nodes) &#123;</span><br><span class="line">exec.execute (<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">                results.add (n .compute() ) ;</span><br><span class="line">            &#125;);</span><br><span class="line">parallelRecursive (exec, n.getchildren( ), results);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当parallelRecursive返回时，树中的各个节点都已经访问过了（<strong>但是遍历过程仍然是串行的，只有compute调用才是并行执行的</strong>)，并且每个节点的计算任务也已经放入Executor的工作队列。parallelRecursive的调用者可以通过以下方式等待所有的结果:创建一个特定于遍历过Executor,并使用shutdown和awaitTermination方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>&lt;T&gt; collection&lt;T&gt; <span class="title">getParallelResults</span><span class="params">(List&lt;Node&lt;T&gt;&gt; nodes)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Executorservice exec = Executors.newCachedThreadPool ();</span><br><span class="line">    Queue&lt;T&gt; resultQueue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;T&gt;( ) ;</span><br><span class="line">    parallelRecursive (exec, nodes, resultQueue) ;</span><br><span class="line">exec.shutdown ( ) ;</span><br><span class="line">exec.awaitTermination (Long.MAx_VALUB，TimeUnit.sECONDS);</span><br><span class="line">    <span class="keyword">return</span> resultQueue ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例：谜题框架"><a href="#示例：谜题框架" class="headerlink" title="示例：谜题框架"></a>示例：谜题框架</h4><p>解决一些谜，这些谜题需要找出一系列的操作从初始状态转换到目标状态</p><p>我们将“谜题”定义为:<strong>包含了一个初始位置，一个目标位置，以及用于判断是否是有效移动的规则集。规则集包含两部分:计算从指定位置开始的所有合法移动，以及每次移动的结果位置。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//谜题的抽象类，其中的类型参数Р和M表示位置类和移动类。根据这个接口，我们可以写一个简单的串行求解程序，该程序将在谜题空间(PuzzleSpace)中查找，直到找到一个解答或者找遍了整个空间都没有发现答案。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Puzzle</span>&lt;<span class="title">P</span>,<span class="title">M</span>&gt;</span>&#123;</span><br><span class="line"> <span class="function">P <span class="title">initialPosition</span> <span class="params">( )</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isGoal</span> <span class="params">(P position)</span> </span>;</span><br><span class="line">    <span class="function">set&lt;M&gt; <span class="title">legalMoves</span><span class="params">(P position)</span> </span>;</span><br><span class="line">    move(P position,M move) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node代表通过一系列的移动到达的一个位置，其中保存了到达该位置的移动以及前一个Node。只要沿着Node链接逐步回溯，就可以重新构建出到达当前位置的移动序列。</span></span><br><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">static</span> clase Node&lt;P,M&gt; &#123;</span><br><span class="line"><span class="keyword">final</span> P pos ;</span><br><span class="line"><span class="keyword">final</span> Mmove;</span><br><span class="line"><span class="keyword">final</span> Node&lt;P，M&gt; prev ;</span><br><span class="line">    </span><br><span class="line">Node(P pos, M move,Node&lt;r，M&gt; prev) &#123;...&#125;</span><br><span class="line">    <span class="function">List&lt;M&gt; <span class="title">asMovelist</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;M&gt;solution = <span class="keyword">new</span> LinkedList&lt;M&gt;( ) ;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;P，M&gt; n = <span class="keyword">this</span>; n.move != <span class="keyword">null</span>; n = n.prev)</span><br><span class="line">            solution.add(o, n.move) ;</span><br><span class="line">        <span class="keyword">return</span> solution;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行解决方案，在谜题空间执行一次深度优先搜索</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sequentialPuzzlesolver</span>&lt;<span class="title">P</span>,&gt;<span class="title">i</span></span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">final</span> <span class="title">Puzzle</span>&lt;<span class="title">P</span>,<span class="title">M</span>&gt; <span class="title">puzzle</span></span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> set&lt;P&gt; seen = <span class="keyword">new</span> Hashset&lt;P&gt; () ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">sequentialPuzzlesolver</span> <span class="params">(Puzzle&lt;P，M&gt; puzzle)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.puzzle = puzzle ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;M&gt; <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pos = puzzle.initialPosition ( ) ;</span><br><span class="line">    <span class="keyword">return</span> search (<span class="keyword">new</span> Node&lt;P,M&gt;(pos,<span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;M&gt; <span class="title">search</span> <span class="params">(Node&lt;P，M&gt; node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !seen.contains (node.pos) ) &#123;</span><br><span class="line">        seen.add (node.pos);</span><br><span class="line">        <span class="keyword">if</span>(puzzle.isGoal (node.pos))</span><br><span class="line">        <span class="keyword">return</span> node. asMoveList ( );</span><br><span class="line">        <span class="keyword">for</span> (M move : puzzle.legalMoves(node.pos)) &#123;</span><br><span class="line">        P pos = puzzle.move (node. pos,move) ;</span><br><span class="line">        Node&lt;P，M&gt; child e <span class="keyword">new</span> Node&lt;P，M&gt;(pos,move,node);</span><br><span class="line">                List&lt;M&gt; result = search (child) ;</span><br><span class="line">        <span class="keyword">if</span> (result != nul1)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">P</span>,<span class="title">M</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过修改解决方案以利用并发性，可以以并行方式来计算下一步移动以及目标条件，因为计算某次移动的过程在很大程度上与计算其他移动的过程是相互独立的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentPuzzlesolver</span>&lt;<span class="title">P</span>,<span class="title">M</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Puzzle&lt;P,M&gt;puzzle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executorservice exec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;P,Boolean&gt; seen;</span><br><span class="line">    <span class="keyword">final</span> ValueLatch&lt;Node&lt;P,M&gt;&gt; solution= <span class="keyword">new</span> ValueLatch&lt;Node&lt;p,M&gt;&gt;() ;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;M&gt; <span class="title">solve</span><span class="params">( )</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            P p= puzzle.initialPosition ( ) ;</span><br><span class="line">            exec.execute (newTask(p, <span class="keyword">null</span>, <span class="keyword">null</span>)) ;/阻塞直到找到解答</span><br><span class="line">            Node&lt;P,M&gt; solnNode = solution.getvalue () ;</span><br><span class="line">            <span class="keyword">return</span> (solnNode == <span class="keyword">null</span>) ? <span class="keyword">null</span> : solnNode .asMoveList();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        exec. shutdown ( ) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Runnable <span class="title">newTask</span><span class="params">(P p, M m，Node&lt;p ,M&gt; n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> solverTask (p, m, n) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">solverTask</span> <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">P</span>，<span class="title">M</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> ( solution.isset() ||  seen.putIfAbsent (pos, <span class="keyword">true</span>) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">//已经找到了解答或者已经遍历了这个位置</span></span><br><span class="line">            <span class="keyword">if</span> (puzzle.isGoal (pos))</span><br><span class="line">        solution.setvalue (<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (M m : puzzle.legalMoves (pos))</span><br><span class="line">        exec.execute (</span><br><span class="line">        newTask (puzzle.move (pos, m) , m, <span class="keyword">this</span>)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发编程实战--第二部分 结构化并发应用程序(1)</title>
      <link href="/2021/01/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86(1)/"/>
      <url>/2021/01/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="六、任务执行"><a href="#六、任务执行" class="headerlink" title="六、任务执行"></a>六、任务执行</h2><h3 id="6-1-在线程中执行任务"><a href="#6-1-在线程中执行任务" class="headerlink" title="6.1 在线程中执行任务"></a>6.1 在线程中执行任务</h3><p>大多数服务器应用程序都提供了一种自然的任务边界选择方式:以独立的客户请求为边界。Web服务器、邮件服务器、文件服务器、EJB容器以及数据库服务器等，这些服务器都能通过网络接受远程客户的连接请求。<strong>将独立的请求作为任务边界，既可以实现任务的独立性，又可以实现合理的任务规模。</strong></p><h4 id="串行的执行任务"><a href="#串行的执行任务" class="headerlink" title="串行的执行任务"></a>串行的执行任务</h4><p>在单个线程中串行执行各项任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleThreadwebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(string[] args)</span> <span class="keyword">throws</span> IOBxception </span>&#123;</span><br><span class="line">        serversocket socket = <span class="keyword">new</span> serverSocket (8o ) ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        socket connection = socket .accept ( ) ;</span><br><span class="line">            handleRequest(connection) ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它每次只能处理一个请求。<strong>在单线程的服务器中，阻塞不仅会推迟当前请求的完成时间，而且还将彻底阻止等待中的请求被处理。</strong>如果请求阻塞的时间过长，用户将认为服务器是不可用的，因为服务器看似失去了响应。同时，服务器的资源利用率非常低，因为当单线程在等待I/O操作完成时;CPU将处于空闲状态。<br>在服务器应用程序中，串行处理机制通常都无法提供高吞吐率或快速响应性。也有一些例外，例如，当任务数量很少且执行时间很长时，或者当服务器只为单个用户提供服务，并且该客户每次只发出一个请求时——但大多数服务器应用程序并不是按照这种方式来工作的。</p><h4 id="显示地为任务创建线程"><a href="#显示地为任务创建线程" class="headerlink" title="显示地为任务创建线程"></a>显示地为任务创建线程</h4><p>通过为每个请求创建一个线程来提供服务，实现更高的相应性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskwebserver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(string[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        serversocket socket - <span class="keyword">new</span> serversocket (8o) ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            finalSocket connection = socket.accept ( ) ;</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>&#123;</span><br><span class="line">                handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPerTaskWebServer在结构上类似于前面的单线程版本——<strong>主线程仍然不断地交替执行“接受外部连接”与“分发请求”等操作。区别在于，对于每个连接，主循环都将创建一个新线程来处理请求，而不是在主循环中进行处理。</strong>由此可得出3个主要结论:</p><ul><li><strong>任务处理过程从主线程中分离出</strong>来，使得主循环能够更快地重新等待下一个到来的连接。这使得程序在完成前面的请求之前可以接受新的请求，从而提高响应性。</li><li><strong>任务可以并行处理，从而能同时服务多个请求。</strong></li><li><strong>任务处理代码必须是线程安全的，因为当有多个任务时会并发地调用这段代码。</strong></li></ul><h4 id="无限制创建线程的不足"><a href="#无限制创建线程的不足" class="headerlink" title="无限制创建线程的不足"></a>无限制创建线程的不足</h4><p>当创建大量线程时：</p><ul><li><p>线程生命周期开销非常高。<strong>线程创建和销毁不是没有代价的。</strong></p></li><li><p>资源消耗。<strong>活跃的线程会消耗系统资源，尤其是内存。如果可运行的线程数量多于可月处理器的数量，那么有些线程将闲置。</strong>如果你已经拥有足够多的线程使所有CPU保持忙碌状态，那么再创建更多的线程反而会降低性能。</p></li><li><p>稳定性。在可创建线程的数量上存在一个限制。这个限制值将随着平台的不同而不同，并且受<strong>多个因素制约，包括JVM的启动参数、Thread构造函数中请求的栈大小，以及底层操竹系统对线程的限制等。</strong>如果破坏了这些限制，那么很可能抛出OutOfMemoryError异常。</p><p><strong>在一定的范围内，增加线程可以提高系统的吞吐率，但如果超出了这个范围，再创建更多的线程只会降低程序的执行速度，“为每个任务分配一个线程”这种方法的问题在于，它没有限制可创建线程的数量，只限制了远程用户提交HTTP请求的速率。</strong></p></li></ul><h3 id="6-2-Executor框架"><a href="#6-2-Executor框架" class="headerlink" title="6.2 Executor框架"></a>6.2 Executor框架</h3><p>任务是一组逻辑工作单元，而线程则是使任务异步执行的机制。juc提供了一种灵活线程池实现作为Executor框架的一部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span> <span class="params">( Runnable command)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor是一个接口。为异步任务执行框架提供了基础。<strong>它提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用Runnable来表示任务。Executor的实现还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。</strong><br>Executor基于<strong>生产者–消费者</strong>模式，提交任务的操作相当于生产者，执行任务的线程则相当于消费者。</p><h4 id="示例：基于Executor的Web服务器"><a href="#示例：基于Executor的Web服务器" class="headerlink" title="示例：基于Executor的Web服务器"></a>示例：基于Executor的Web服务器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">classraskExecutionwebserver &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exec = executors.newFixedThreadPool(NTHREADS);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(string [] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    serversocket socket = <span class="keyword">new</span> serversocket (<span class="number">80</span>) ;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> socket connection = socket.accept ( );</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">                    handleRequest (connection) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(task) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用Executor，将<strong>请求处理任务的提交与任务的实际执行解耦开来</strong>，并且只需采用另一种不同的Executor实现，就可以改变服务器的行为。改变Executor实现或配置所带来的影响要远远小于改变任务提交方式带来的影响。通常，Executor的配置是一次性的，因此在部署阶段可以完成，而提交任务的代码却会不断地扩散到整个程序中，增加了修改的难度。<br>我们可以很容易地将TaskExecutionWebServer修改为类似ThreadPerTaskWebServer的行为，只需使用一个为每个请求都创建新线程的Executor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span> <span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(r).start () ;</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h4><p>通过将任务的提交与执行解耦开来，从而无须太大的困难就可以为某种类型的任务指定和修改执行策略。在执行策略中定义了任务执行的“What、Where、When、How”等方面，包括:</p><ul><li>在<strong>什么( What）线程</strong>中执行任务?</li><li>任务按照<strong>什么( What）顺序</strong>执行（FIFO、LIFO、优先级）?</li><li><strong>有多少个（How Many)任务</strong>能并发执行?</li><li>在队列中<strong>有多少个（How Many)任务在等待</strong>执行?</li><li>如果系统由于过载而需要拒绝一个任务，那么应该<strong>选择哪一个(Which）任务</strong>?另外，<strong>如何(How)通知应用程序有任务被拒绝?</strong></li><li>在执行一个任务之前或之后，应该进行<strong>哪些(What）动作</strong>?<br>各种执行策略都是一种<strong>资源管理工具</strong>，最佳策略取决于可用的计算资源以及对服务质量的需求。</li></ul><p>每当看到下面这种形式的代码时:<code>new Thread(runnable) .start()</code>虑使用Executor来代替Thread。</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>管理一组同构工作线程的资源池，线程池与工作队列相关，其中在工作队列中保存了所有等待执行的任务。工作者线程的任务很简单:从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。<br>“在线程池中执行任务”比“为每个任务分配一个线程”优势更多。<strong>通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。</strong>另一个额外的好处是，<strong>当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。</strong></p><p>同构Executors静态工厂方法来创建一个线程池：</p><p><code>newFixedThreadPool</code>。创建一个<strong>固定长度</strong>的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化(如果某个线程由于发生了未预期的Exception而结束，那么线程池会补充一个新的线程)。<br><code>newCachedThreadPool</code>。创建一个<strong>可缓存的线程池</strong>，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。<br><code>newSingleThreadExecutor</code>。是一个单线程的Executor，它创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来替代。newSingleThreadExecutor能<strong>确保依照任务在队列中的顺序来串行执行</strong>（例如FIFO、LIFO、优先级)。<br><code>newScheduledThreadPool</code>。创建了一个<strong>固定长度的线程池，而且以延迟或定时的方式来执行任务</strong>，<br>newFixedThreadPool和newCachedThreadPool这两个工厂方法返回通用的ThreadPoolExecutor实例，这些实例可以直接用来构造专门用途的executor。</p><p>为每个任务分配一个线程变成基于线程池的策略，由于<strong>服务器不会创建数千个线程来争夺有限的CPU和内存资源，因此服务器的性能将平缓地降低。通过使用Executor，可以实现各种调优、管理、监视、记录日志、错误报告和其他功能</strong>。</p><h4 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h4><p>Executor的实现通常会创建线程来执行任务。但JVM只有在所有（非守护）线程全部终止后才会退出。因此，如果无法正确地关闭Executor，那么JVM将无法结束。</p><p>Executor以异步方式来执行任务，提交任务的状态不是立即可见的。<strong>Executor是为应用程序提供服务的，因而它们也是可关闭的（无论采用平缓的方式还是粗暴的方式)，并将在关闭操作中受影响的任务的状态反馈给应用程序。</strong><br><strong>为了解决执行服务的生命周期问题，Executor扩展了ExecutorService接口，添加了一些用于生命周期管理的方法</strong>（同时还有一些用于任务提交的便利方法)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>. <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span> <span class="params">()</span>  </span>;</span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span> <span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span> <span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span> <span class="params">()</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span> <span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//……其他用于任务提交的便利方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExecutorService的生命周期有3种状态:<strong>运行、关闭和已终止</strong>。ExecutorService在初始创建时处于运行状态。<strong>shutdown方法将执行平缓的关闭过程:不再接受新的任务，同时等待已经提交的任务执行完成—―包括那些还未开始执行的任务。shutdownNow方法将执行粗暴的关闭过程:它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</strong><br>在ExecutorService关闭后提交的任务将由“拒绝执行处理器(Rejected Execution Handler)”来处理，<strong>它会抛弃任务，或者使得execute方法抛出一个未检查的RejectedExecutionException。</strong>等所有任务都完成后，ExecutorService将转入终止状态。<strong>可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询ExecutorService是否已经终止。通常在调用awaitTermination之后会立即调用shutdown，从而产生同步地关闭ExecutorService的效果</strong>。</p><h4 id="延迟任务与周期任务"><a href="#延迟任务与周期任务" class="headerlink" title="延迟任务与周期任务"></a>延迟任务与周期任务</h4><p>Timer类负责管理延迟任务(“在100ms后执行该任务”)以及周期任务(“每10ms执行一次该任务”)。然而，Timer存在一些缺陷，因此应该考虑使用<code>ScheduledThreadPoolExecutor</code> 来代替它。可以通过构造函数或<code>newScheduledThreadPool</code> 工厂方法来创建该类的对象。<br>Timer在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其他TimerTask的定时精确性。<br>Timer的另一个问题是，如果TimerTask抛出了一个未检查的异常，那么Timer将表现出糟糕的行为。<strong>Timer线程并不捕获异常，因此当TimerTask 抛出未检查的异常时将终止定时线程。</strong>这种情况下，Timer也不会恢复线程的执行，而是会错误地认为整个Timer都被取消了。因此，已经被调度但尚未执行的TimerTask将不会再执行，新的任务也不能被调度。这个问题称之为“线程泄漏“。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfTime</span> </span>&#123;</span><br><span class="line">    <span class="comment">//你认为程序6s结束，但是1s就结束了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(string[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer () ;</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> ThrowTask ( ) , <span class="number">1</span>) ;</span><br><span class="line">        SECONDs.sleep (<span class="number">1</span>);</span><br><span class="line">    timer.schedule (<span class="keyword">new</span> ThrowTask ( ) , <span class="number">1</span>) ;</span><br><span class="line">        SECONDs. sleep (<span class="number">5</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException( ) ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在Java 5.0或更高的JDK中，将很少使用Timer。</strong><br><strong>如果要构建自己的调度服务，那么可以使用DelayQueue，它实现了BlockingQueue，并为ScheduledThreadPoolExecutor提供调度功能。</strong>DelayQueue管理着一组Delayed对象。每个Delayed对象都有一个相应的延迟时间:在DelayQueue中，只有某个元素逾期后，才能从DelayQueue 中执行take操作。从DelayQueue中返回的对象将根据它们的延迟时间进行排序。</p><h3 id="6-3-找出可利用的并行性"><a href="#6-3-找出可利用的并行性" class="headerlink" title="6.3 找出可利用的并行性"></a>6.3 找出可利用的并行性</h3><p>如果要使用Executor，<strong>必须将任务表示为一个Runnable</strong>.大多数服务器应用程序存在一个边界：单个用户请求，在单个用户请求中仍存在并行性，如数据库服务器。</p><h4 id="示例：串行的页面渲染器"><a href="#示例：串行的页面渲染器" class="headerlink" title="示例：串行的页面渲染器"></a>示例：串行的页面渲染器</h4><p>最简单的方法就是对HTML文档进行串行处理。当遇到文本标签时，<strong>将其绘制到图像缓存中。当遇到图像引用时，先通过网络获取它，然后再将其绘制到图像缓存中。</strong>这很容易实现,程序只需将输入中的每个元素处理一次（甚至不需要缓存文档)，但这种方法可能会令用户感到烦恼，他们必须等待很长时间，直到显示所有的文本。<br>另一种串行执行方法更好一些，<strong>它先绘制文本元素，同时为图像预留出矩形的占位空间,在处理完了第一遍文本后，程序再开始下载图像，并将它们绘制到相应的占位空间中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行渲染页面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">singleThreadRenderer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span> <span class="params">(charsequence source)</span></span>&#123;</span><br><span class="line">        renderText ( source) ;</span><br><span class="line">        List&lt;ImageData&gt; imageData = <span class="keyword">new</span> ArrayList&lt;ImageData&gt;();</span><br><span class="line">        <span class="keyword">for</span> (rmageInfo imageInfo : scanForImageInfo (source))</span><br><span class="line">        imageData.add (imageInfo.downloadImage ( )) ;</span><br><span class="line">        <span class="keyword">for</span> ( ImageData data : imageData)</span><br><span class="line">        renderImage (data) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="携带结果的任务Callable与Future"><a href="#携带结果的任务Callable与Future" class="headerlink" title="携带结果的任务Callable与Future"></a>携带结果的任务Callable与Future</h4><p>Executor框架使用Runnable作为其基本的任务表示形式。<strong>Runnable是一种有很大局限的抽象，虽然run能写入到日志文件或者将结果放入某个共享的数据结构，但它不能返回一个值或抛出一个受检查的异常。</strong><br>许多任务实际上都是存在延迟的计算——执行数据库查询，从网络上获取资源，或者计算某个复杂的功能。对于这些任务，Callable是一种更好的抽象:<strong>它认为主入口点（即call）将返回一个值，并可能抛出一个异常。</strong><br>Runnable和Callable描述的都是抽象的计算任务。这些任务通常是有范围的，即都有一个明确的起始点，并且最终会结束。Executor执行的任务有4个生命周期阶段﹔<strong>创建、提交、开始和完成</strong>。由于有些任务可能要执行很长的时间，因此通常希望能够取消这些任务。在Executor框架中，<strong>已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能响应中断时，才能取消。取消一个已经完成的任务不会有任何影响。</strong><br><strong>Future表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。在 Future规范中包含的隐含意义是，任务的生命周期只能前进，不能后退，就像ExecutorService的生命周期一样。.当某个任务完成后，它就永远停留在“完成”状态上。</strong><br>get方法的行为取决于任务的状态（尚未开始、正在运行、已完成)。如果任务<strong>已经完成，那么get会立即返回或者抛出一个Exception，如果任务没有完成，那么get将阻塞并直到任务完成。</strong>如果任务抛出了异常，那么get将该异常封装为ExecutionException并重新抛出。如果任务被取消，那么get将抛出CancellationException。如果get抛出了ExecutionException，那么可以通过getCause来获得被封装的初始异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">V <span class="title">call</span> <span class="params">( )</span> <span class="keyword">throws</span> Exception </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span> <span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span> <span class="params">( )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span> <span class="params">( )</span> </span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span> <span class="params">( )</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, cancellationException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span> <span class="params">(<span class="keyword">long</span> timeout,TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,ExecutionException,</span></span><br><span class="line"><span class="function">    cancellationException,TimeoutException </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以通过许多种方法创建一个Future来描述任务。ExecutorService中的所有submit方法都将返回一个Future，从而将一个Runnable或Callable提交给Executor,</strong>并得到一个Future月来获得任务的执行结果或者取消任务。还可以显式地为某个指定的Runnable或Callable实例化一个FutureTask。</p><h4 id="示例-使用Future-实现页面渲染器"><a href="#示例-使用Future-实现页面渲染器" class="headerlink" title="示例:使用Future 实现页面渲染器"></a>示例:使用Future 实现页面渲染器</h4><p>首先将渲染过程分解为两个任务<strong>，一个是渲染所的文本，另一个是下载所有的图像。</strong>(因为其中一个任务是CPU密集型，而另一个任务是I/O密集型，因此这种方法即使在单CPU 系统上也能提升性能。)<br><strong>Callable和Future有助于表示这些协同任务之间的交互</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureRenderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor = ... ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span> <span class="params">(charsequence source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);</span><br><span class="line">        <span class="comment">//创建了一个Callable来下载所有的图像，并将其提交到一个ExecutorService。</span></span><br><span class="line">        Callable&lt;List&lt;ImageData&gt;&gt; task =<span class="keyword">new</span> Callable&lt;List&lt;ImageData&gt;&gt; ( )&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ImageData&gt; <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   List&lt;ImageData&gt; result = <span class="keyword">new</span> ArrayList&lt;ImageData&gt; ( ) ;</span><br><span class="line">    <span class="keyword">for</span> ( ImageInfo imageInfo : imageInfos)</span><br><span class="line">    result.add (imageInfo. downloadImage ( ) );</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">        <span class="comment">//返回一个描述任务执行情况的Future。当主任务需要图像时，它会等待Future.get的调用结果。如果幸运的话，当开始请求时所有图像就已经下载完成了，即使没有，至少图像的下载任务也已经提前开始了。</span></span><br><span class="line">    Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit (task);</span><br><span class="line">        renderText (source) ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;ImageData&gt; imageData =future.get ();</span><br><span class="line">            <span class="keyword">for</span> ( ImageData data : imageData)</span><br><span class="line">        renderImage(data) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">       <span class="comment">//重新设置线程的中断状态</span></span><br><span class="line">        Thread.currentThread () .interrupt ( );<span class="comment">//由于不需要结果，因此取消任务</span></span><br><span class="line">        future.cancel (<span class="keyword">true</span>) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> launderThrowable(e.getCause ());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get方法拥有“状态依赖”的内在特性，因而调用者不需要知道任务的状态，此外在任务提交和获得结果中包含的安全发布属性也确保了这个方法是线程安全的。</strong>Future.get 的异常处理代码将处理两个可能的问题:任务遇到一个Exception，或者调用get的线程在获得结果之前被中断<br>FutureRenderer使得渲染文本任务与下载图像数据的任务并发地执行。当所有图像下载完后，会显示到页面上。这将提升用户体验，不仅使用户更快地看到结果，还有效利用了并行性，但我们还可以做得更好。<strong>用户不必等到所有的图像都下载完成，而希望看到每当下载完一幅图像时就立即显示出来。</strong></p><h4 id="在异构任务并行化中查找的局限"><a href="#在异构任务并行化中查找的局限" class="headerlink" title="在异构任务并行化中查找的局限"></a>在异构任务并行化中查找的局限</h4><p>我们尝试并行地执行两个不同类型的任务——下载图像与渲染页面。然而，通过对异构任务进行并行化来获得重大的性能提升是很困难的。<br>两个人可以很好地分担洗碗的工作:其中一个人负责清洗，而另一个人负责烘干。然而,<strong>要将不同类型的任务平均分配给每个工人却并不容易。当人数增加时，如何确保他们能帮忙而不是妨碍其他人工作，或者在重新分配工作时，并不是容易的事情。</strong><br>当在多个工人之间分配异构的任务时，还有一个问题就是各个任务的大小可能完全不同。如果将两个任务A和B分配给两个工人，但A的执行时间是B的10倍，那么整个过程也只能加速9%。最后，当<strong>在多个工人之间分解任务时，还需要一定的任务协调开销</strong>:为了使任务分解能提高性能，这种开销不能高于并行性实现的提升。<br>FutureRenderer使用了两个任务，其中一个负责渲染文本，另一个负责下载图像。如果渲染文本的速度远远高于下载图像的速度（可能性很大)，那么程序的最终性能与串行执行时的性能差别不大，而代码却变得更复杂了。当使用两个线程时，至多能将速度提高一倍。<strong>因此,虽然做了许多工作来并发执行异构任务以提高并发度，但从中获得的并发性却是十分有限的。</strong><br><strong>只有当大量相互独立且同构的任务可以并发进行处理时，才能体现出将程序的.工作负载分配到多个任务中带来的真正性能提升。</strong></p><h4 id="CompletionServiceExecutor与-BlockingQueue"><a href="#CompletionServiceExecutor与-BlockingQueue" class="headerlink" title="CompletionServiceExecutor与 BlockingQueue"></a>CompletionServiceExecutor与 BlockingQueue</h4><p>如果向Executor提交了一组计算任务，并且希望在计算完成后获得结果，那么可以<strong>保留与每个任务关联的Future，然后反复使用get方法，同时将参数timeout 指定为0从而通过轮询来判断任务是否完成。</strong>这种方法虽然可行，但却有些繁琐。幸运的是，还有一种更好的方法:<strong>完成服务(CompletionService)。</strong><br><strong>CompletionService将Executor和 BlockingQueue的功能融合在一起。你可以将Callable任务提交给它来执行，然后使用类似于队列操作的 take和poll等方法来获得已完成的结果，而这些结果会在完成时将被封装为Future。</strong></p><h4 id="示例-使用CompletionService实现页面渲染器"><a href="#示例-使用CompletionService实现页面渲染器" class="headerlink" title="示例:使用CompletionService实现页面渲染器"></a>示例:使用CompletionService实现页面渲染器</h4><p>可以通过CompletionService从两个方面来提高页面渲染器的性能:<strong>缩短总运行时间以及提高响应性。为每一幅图像的下载都创建一个独立任务，并在线程池中执行它们，从而将串行的下载过程转换为并行的过程:这将减少下载所有图像的总时间。</strong>此外，通过从CompletionService中获取结果以及使每张图片在下载完成后立刻显示出来，能使用户获得一个更加动态和更高响应性的用户界面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line">Renderer (Executorservice executor) &#123; <span class="keyword">this</span>.executor = executor; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span> <span class="params">(Charsequence source)</span></span>&#123;</span><br><span class="line">        List&lt;ImageInfo&gt; info = scanForImageInfo (source) ;</span><br><span class="line">        Completionservice&lt;ImageData&gt; completionservice = <span class="keyword">new</span> Executorcompletionservice&lt;ImageData&gt; (executor);</span><br><span class="line">        <span class="comment">//为每个图片都开启一个线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> ImageInfo imageInfo : info)</span><br><span class="line">        completionservice.submit (<span class="keyword">new</span> callable&lt;ImageData&gt; ( ) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> ImageData <span class="title">call</span> <span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> imageinfo.downloadImage ( ) ;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;) ;</span><br><span class="line">        renderText (source) ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//陆续加载</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>, n = info.size( ) ; t &lt; n;t++)&#123;</span><br><span class="line">        Future&lt;ImageData&gt; f = completionservice.take ( );</span><br><span class="line">                ImageData imageData = f.get ( ) ;</span><br><span class="line">        renderImage (imageData) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        Thread.currentThread( ).interrupt ();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> launderThrowable(e.getCause ());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为任务设置时限"><a href="#为任务设置时限" class="headerlink" title="为任务设置时限"></a>为任务设置时限</h4><p>在有限时间内执行任务的主要困难在于，<strong>要确保得到答案的时间不会超过限定的时间，或者在限定的时间内无法获得答案。</strong>在支持时间限制的Future.get中支持这种需求:<strong>当结果可用时，它将立即返回，如果在指定时限内没有计算出结果，那么将抛出 TimeoutException。</strong><br>在使用限时任务时需要注意，<strong>当这些任务超时后应该立即停止</strong>，从而避免为继续计算一个不再使用的结果而浪费计算资源。要实现这个功能，可以由任务本身来管理它的限定时间,并且在超时后中止执行或取消任务。此时可再次使用Future，如果一个限时的get方法抛出了TimeoutException，那么可以通过Future来取消任务。如果编写的任务是可取消的，那么可以提前中止它，以免消耗过多的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page <span class="title">renderPagewithAd</span> <span class="params">( )</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> endNanos = system.nanoTime ( ) +TIME_BUDGET;</span><br><span class="line">    <span class="comment">//它将获取广告的任务提交给一个Executor</span></span><br><span class="line">    Future&lt;Ad&gt; f = exec.submit (<span class="keyword">new</span> FetchAdTask ( )) ;</span><br><span class="line">    <span class="comment">//在等待广告的同时显示页面</span></span><br><span class="line">    Page page = renderPageBody ( );</span><br><span class="line">    Ad ad;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//只等待指定的时间长度</span></span><br><span class="line">        <span class="keyword">long</span> timeLeft = endNanos - system.nanoTime ( ) ;</span><br><span class="line">        ad = f.get (timeLeft,NANOSECONDS) ;</span><br><span class="line">    <span class="comment">//如果get超时，那么将取消广告获取任务，并转而使用默认的广告信</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">        ad = DEFAULT_AD;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (TimeoutException e)&#123;</span><br><span class="line">    ad = DEFAULT_AD;</span><br><span class="line">    f.cancel (<span class="keyword">true</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    page.setAd (ad);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="示例：旅行预订门户网站"><a href="#示例：旅行预订门户网站" class="headerlink" title="示例：旅行预订门户网站"></a>示例：旅行预订门户网站</h4><p>考虑这样一个旅行预定门户网站:用户输入旅行的日期和其他要求，门户网站获取并显示来自多条航线、旅店或汽车租赁公司的报价。在获取不同公司报价的过程中，可能会调用Web服务、访问数据库、执行一个EDI事务或其他机制。在这种情况下，<strong>不宜让页面的响应时间受限于最慢的响应时间，而应该只显示在指定时间内收到的信息。</strong>对于没有及时响应的服务提供者，页面可以忽略它们，或者显示–个提示信息，例如“Did not hear from Air Java in time。”<br><strong>从一个公司获得报价的过程与从其他公司获得报价的过程无关，因此可以将获取报价的过程当成一个任务，从而使获得报价的过程能并发执行。</strong>创建n个任务，将其提交到一个线程池，保留n个 Future，并使用限时的get方法通过Future串行地获取每一个结果，这一切都很简单，<strong>但还有一个更简单的方法—-—invokeAll。</strong><br>支持限时的invokeAll，将多个任务提交到一个ExecutorService并获得结果。InvokeAll方法的参数为一组任务，并返回一组Future。这两个集合有着相同的结构。<strong>invokeAll 按照任务集合中迭代器的顺序将所有的Future添加到返回的集合中，从而使调用者能将各个Future与其表示的Callable 关联起来。当所有任务都执行完毕时，或者调用线程被中断时，又或者超过指定时限时，invokeAll将返回。</strong>当超过指定时限后，任何还未完成的任务都会取消。当invokeAll返回后，每个任务要么正常地完成，要么被取消，而客户端代码可以调用get 或isCancelled来判断究竟是何种情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QuoteTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">TravelQuote</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Travelcompany company ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TravelInfo travelInfo;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TravelQuote <span class="title">call</span> <span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> company.solicitQuote (travelInfo) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TravelQuote&gt; <span class="title">getRankedTravelQuotes</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TravelInfo travelInfo,Set&lt;Travelcompany&gt; companies,</span></span></span><br><span class="line"><span class="params"><span class="function">    Comparator&lt;TravelQuote&gt; ranking，<span class="keyword">long</span> time，TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//去那几个公司网站查找</span></span><br><span class="line">    List&lt;QuoteTask&gt; tasks = <span class="keyword">new</span> ArrayList&lt;QuoteTask&gt;( );</span><br><span class="line">    <span class="keyword">for</span> (Travelcompany company : companies)</span><br><span class="line">    tasks.add(<span class="keyword">new</span> QuoteTask(company, travelInfo) ) ;</span><br><span class="line">    <span class="comment">//Future列表</span></span><br><span class="line">    List&lt;Future&lt;TravelQuote&gt;&gt; futures =exec.invokeAll(tasks, time, unit);</span><br><span class="line">    </span><br><span class="line">    List&lt;TravelQuote&gt; quotes =<span class="keyword">new</span> ArrayList&lt;TravelQuote&gt;(tasks.size ()) ;</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;QuoteTask&gt; taskIter = tasks.iterator () ;</span><br><span class="line">    <span class="comment">//遍历每一个Future,执行相应的搜索任务</span></span><br><span class="line">    <span class="keyword">for</span> (Future&lt;TravelQuote&gt; f : futures) &#123;</span><br><span class="line">    QuoteTask task = taskIter.next ( ) ;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将每一个搜索结果添加到最后的列表中</span></span><br><span class="line">        quotes.add(f.get ()) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ExecutionException e)&#123;</span><br><span class="line">        quotes.add (task.getFailureQuote (e.getCause ())) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (cancellationException e) &#123;</span><br><span class="line">        quotes.add (task.getTimeoutQuote(e) ) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort (quotes, ranking) ;</span><br><span class="line">    <span class="keyword">return</span> quotes ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、取消与关闭"><a href="#七、取消与关闭" class="headerlink" title="七、取消与关闭"></a>七、取消与关闭</h2><p>要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了<strong>中断</strong>（Interruption)，这是一种协作机制，能够使-一-个线程终止另一个线程的当前工作。<br>这种协作式的方法是必要的，我们很少希望某个任务、线程或服务立即停止，因为这种立即停止会使共享的数据结构处于不一致的状态。相反，在编写任务和服务时可以使用-一种协作的方式:<strong>当需要停止时，它们首先会清除当前正在执行的工作，然后再结束。</strong></p><h3 id="7-1-任务取消"><a href="#7-1-任务取消" class="headerlink" title="7.1 任务取消"></a>7.1 任务取消</h3><p><strong>如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就可以称为可取消的</strong>(Cancellable)。取消某个操作的原因很多:</p><ul><li><strong>用户请求取消</strong>。用户点击图形界面程序中的“取消”按钮，或者通过管理接口来发出取消请求，例如JMX (Java Management Extensions)。</li><li><strong>有时间限制的操作</strong></li><li>应用程序事件。例如，应用程序对某个问题空间进行分解并搜索，从而使不同的任务可以搜索问题空间中的不同区域。当其中一个任务找到了解决方案时，所有其他仍在搜索的任务都取消</li><li><strong>错误</strong>。</li><li><strong>关闭</strong>。当一个程序或服务关闭时，必须对正在处理和等待处理的工作执行某种操作。在平缓的关闭过程中，当前正在执行的任务将继续执行直到完成，而在立即关闭过程中，当前的任务则可能取消。</li></ul><p>其中一种协作机制能<strong>设置某个“已请求取消(Cancellation Requested)”标志</strong>，而任务将定期地查看该标志。如果设置了这个标志，那么任务将提前结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedEy</span> ( <span class="string">&quot;this&quot;</span> )</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Eist&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayList&lt;BigInteger&gt; ();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    BigInteger p = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span> (!cancelled)&#123;</span><br><span class="line">    p = p.nextProbablePrime ();</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    primes.add(p) ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置cancelled标志</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span> <span class="params">( )</span> </span>&#123; cancelled = <span class="keyword">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title">get</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即让素数生成器运行1秒钟后取消。素数生成器通常并不会刚好在运行1秒钟后停止，因为在请求取消的时刻和run方法中循环执行下一次检查之间可能存在延迟。cancel方法由finally块调用，从而确保即使在调用sleep时被中断也能取消素数生成器的执行。如果cancel没有被调用，那么搜索素数的线程将永远运行下去，不断消耗CPU的时钟周期，并使得JVM不能正常退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;BigInteger&gt; <span class="title">asecondofPrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">PrimeGenerator generator </span>= <span class="keyword">new</span> PrimeGenerator ();</span><br><span class="line"><span class="keyword">new</span> Thread(generator).start( ) ;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SECONDS.sleep(<span class="number">1</span>) ;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">generator.cancel();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> generator.get() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个可取消的任务必须拥有取消策略，<strong>其他代码如何(How）请求取消该任务，任务在可时(When)检查是否已经请求了取消，以及在响应取消请求时应该执行哪些（What）操作。</strong>。<br>PrimeGenerator使用了一种简单的取消策略:客户代码通过调用cancel来请求取消，primeGenerator在每次搜索素数前首先检查是否存在取消请求，如果存在则退出。</p><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>PrimeGenerator中的取消机制最终会使得搜索素数的任务退出，但在退出过程中需要花费一定的时间。<strong>然而，如果使用这种方法的任务调用了一个阻塞方法，例如BlockingQueue.put,那么可能会产生一个更严重的问题——任务可能永远不会检查取消标志，因此永远不会结束。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">生产者线程生成素数，并将它们放入一个阻塞队列。如果生产者的速度超过了消费者的处理速度，队列将被填满，put方法也会阻塞。当生产者在put方法中阻塞时，如果消费者希望取消生产者任务，那么将发生什么情况﹖它可以调用cancel方法来设置cancelled标志，但此时生产者却永远不能检查这个标志，因为它无法从阻塞的put方法中恢复过来（因为消费者此时已经停止从队列中取出素数，所以put方法将一直保持阻塞状态)。*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrokenPrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> B1ockingQueue&lt;BigInteger&gt; queue ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cance1led = <span class="keyword">false</span> ;</span><br><span class="line">BrokenPrimeProducer (B1ockingQueue&lt;BigInteger&gt; queue)&#123;</span><br><span class="line"><span class="keyword">this</span>.queue = queue ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span> ( !cancelled)</span><br><span class="line">        queue.put (p = p.nextProbablePrime()) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException consumed)&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123; cancelled = <span class="keyword">true</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumePrimes</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    BlockingQueue&lt;BigInteger&gt; primes = ...;</span><br><span class="line">    BrokenPrimeProducer producer = <span class="keyword">new</span> BrokenPrimeProducer (primes);</span><br><span class="line">    producer.start ( ) ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (needMorePrimes ())</span><br><span class="line">    consume (primes.take ());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    producer.cancel ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程中断是一种协作机制，线程可以通过这种机制来通知另一个线程。<strong>每个线程都有一个boolean的中断标志,当中断线程时，这个线程的中断状态将被设置为true。在Thread中包含了中断线程以及查询线程中断状态的方法</strong>，interrupt方法能中断目标线程，而isInterrupted方法能返回目标线程的中断状态。静态的interrupted方法将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。</p><p>对中断操作的正确理解是：<strong>它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。</strong>(这些时刻也被称为取消点)。有些方法，例如<strong>wait、sleep和join</strong>等，将严格地处理这种请求，当它们收到中断请求或者在开始执行时发现某个已被设置好的中断状态时，将抛出一个异常。设计良好的方法可以完全忽略这种请求，只要它们能使调用代码对中断请求进行某种处理。设计糟糕的方法可能会屏蔽中断请求，从而导致调用栈中的其他代码无法对中断请求作出响应。<br>在使用静态的interrupted时应该小心，因为它会清除当前线程的中断状态。如果在调用interrupted时返回了true，<strong>那么除非你想屏蔽这个中断，否则必须对它进行处理——可以抛出InterruptedException</strong>，或者通过再次调用interrupt来恢复中断状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用中断而不是boolean标志来取消</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue)&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = queue ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        BigInteger p = BigInteger.ONE;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread( ).isInterrupted())</span><br><span class="line">        queue.put (p = p.nextProbablePrime()) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException consumed)&#123;</span><br><span class="line">            <span class="comment">/*允许线程退出*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span> <span class="params">( )</span> </span>&#123; interrupt ( ) ; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h4><p>中断策略规定线程如何解释某个中断请求，当发现中断请求时，应做哪些工作，哪些工作单元对于中断来说是原子操作，以及多快速度来相应中断。</p><h4 id="相应中断"><a href="#相应中断" class="headerlink" title="相应中断"></a>相应中断</h4><p>当调用可中断的阻塞函数时，例如<strong>Thread.sleep或BlockingQueue.put</strong>等，有两种实用策略可用于处理InterruptedException;</p><ul><li>传递异常（可能在执行某个特定于任务的清除操作之后)，从而使你的方法也成为可中断的阻塞方法。</li><li>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于一些不支持取消但仍然可以调用可中断阻塞的方法，他们必须在循环中调用这些方法，并在中断后重新尝试，如果过早的设置中断状态，就会引起无线循环因为大多数可中断的阻塞方法都会在入口检查中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span> <span class="params">(BlockingQueue&lt;Taskgt ; queue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span> ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue.take () ;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            interrupted = <span class="keyword">true</span> ;</span><br><span class="line">                <span class="comment">//重新尝试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (interrupted)</span><br><span class="line">    Thread.currentThread ( ) .interrupt () ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例：计时运行"><a href="#示例：计时运行" class="headerlink" title="示例：计时运行"></a>示例：计时运行</h4><p>许多问题永远无法解决，例如枚举所有的素数。</p><p>在执行任务时的另一个方面是，<strong>你希望知道在任务执行过程中是否会抛出异常如果PrimeGenerator在指定时限内抛出了一个未检查的异常，那么这个异常可能会被忽略，因为素数生成器在另一个独立的线程中运行，而这个线程并不会显式地处理异常。</strong><br>在程序清单7-8中给出了在指定时间内运行一个任意的Runnable的示例。它在调用线程中运行任务，并安排了一个取消任务，在运行指定的时间间隔后中断它。这解决了从任务中抛出未检查异常的问题，因为该异常会被timedRun的调用者捕获。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在外部线程中安排中断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> scheduledBxecutorservice cancelExec = ...;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span> <span class="params">(Runnable r,<span class="keyword">long</span> timeout,TimeUnit unit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Thread taskThread = Thread.currentThread ( );</span><br><span class="line">cancelExec.schedule (<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123; taskThread.interrupt ()；&#125;</span><br><span class="line">    &#125;, timeout, unit) ;</span><br><span class="line">r.run () ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过Future来实现取消"><a href="#通过Future来实现取消" class="headerlink" title="通过Future来实现取消"></a>通过Future来实现取消</h4><p>ExecutorService.submit将返回一个Future来描述任务。Future拥有一个cancel方法，该方法带有一个boolean类型的参数mayInterruptIfRunning，表示取消操作是否成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span> <span class="params">(Runnable r,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">long</span> timeout, TimeUnit unit)</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//将任务提交给ExecutorService</span></span><br><span class="line">Future&lt;?&gt; task = taskExec.submit(r) ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过定时任务Future.get来获得结果</span></span><br><span class="line">    task.get (timeout, unit);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">    <span class="comment">//接下来任务将被取消</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">        <span class="comment">//如果在任务中抛出了异常，那么重新抛出该异常</span></span><br><span class="line">        <span class="keyword">throw</span> launderThrowable(e.getCause ( ));</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//如果任务已经结束，那么执行取消操作也不会带来任何影响</span></span><br><span class="line">    task.cancel (<span class="keyword">true</span>);/如果任务正在运行，那么将被中断</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Future.get 抛出 <code>InterruptedException</code>或 <code>TimeoutException</code>时,如果你知道不再需要结果,那么就可以调用Future.cancel来取消任务。</p><h4 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h4><p>对于那些由于执行不可中断操作而被阻塞的线程，可以使用类似于中断的手段来停止线程，但要求我们知道线程阻塞的原因：</p><ul><li><p><strong>Java.io包中的同步Socket l/O。</strong>在服务器应用程序中，最常见的阻塞I/O形式就是对套接字进行读取和写入。虽然InputStream和OutputStream中的read和 write等方法都不会响应中断，但通过关闭底层的套接字，可以使得由于执行read或write等方法而被阻塞的线程抛出一个SocketException。</p></li><li><p><strong>Java.io包中的同步IO。</strong></p></li><li><p><strong>Selector的异步IO。</strong>如果一个线程在调用Selector.select方法（在java.nio.channels 中)时阻塞了，那么调用close或wakeup方法会使线程抛出 ClosedSelectorException 并提前返回。</p></li><li><p><strong>获取某个锁。</strong>如果一个线程由于等待某个内置锁而阻塞，那么将无法响应中断，因为线程认为它肯定会获得锁，所以将不会理会中断请求。但是，在Lock类中提供了lockInterruptibly方法，该方法允许在等待一个锁的同时仍能响应中断。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReaderThread管理了一个套接字连接，它采用同步方式从该套接字中读取数据,并将接收到的数据传递给processBuffer。为了结束某个用户的连接或者关闭服务器，ReaderThread改写了interrupt方法，使其既能处理标准的中断，也能关闭底层的套接字。因此，无论ReaderThread线程是在read方法中阻塞还是在某个可中断的阻塞方法中阻塞，都可以被中断并停止执行当前的工作。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> socket socket ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Inputstream in;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReaderThread</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket ;</span><br><span class="line">        <span class="keyword">this</span>.in = socket.getInputstream ( );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        socket.close( ) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException ignored)&#123;&#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.interrupt ( );</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[]buf = <span class="keyword">new</span> <span class="keyword">byte</span> [BUFSZ];</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> count = in.read ( buf) ;</span><br><span class="line">                <span class="keyword">if</span> (count &lt; <span class="number">0</span> )</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; o)</span><br><span class="line">                    processBuffer (buf,count) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123; <span class="comment">/*允许线程退出*/</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="采用newTaskFor来封装非标准的取消"><a href="#采用newTaskFor来封装非标准的取消" class="headerlink" title="采用newTaskFor来封装非标准的取消"></a>采用newTaskFor来封装非标准的取消</h4><p>当把一个 Callable提交给ExecutorService时,<strong>submit方法会返回一个Future，我们可以通过这个Future来取消任务。newTaskFor是一个工厂方法，它将创建Future来代表任务。</strong>newTaskFor还能返回一个RunnableFuture接口，该接口扩展了Future和 Runnable (并由FutureTask实现)。<br><strong>通过定制表示任务的Future可以改变Future.cancel 的行为。</strong>例如，定制的取消代码可以实现日志记录或者收集取消操作的统计信息，<strong>以及取消一些不响应中断的操作。</strong>通过改写interrupt方法，ReaderThread可以取消基于套接字的线程。同样，通过改写任务的Future.cancel方法也可以实现类似的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个CancellableTask接口，该接口扩展了Callable,并增加了一个cancel方法和一个newTask 工厂方法来构造RunnableFuture。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CancellableTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cancel</span> <span class="params">( )</span> </span>;</span><br><span class="line">    <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTask</span> <span class="params">( )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CancellingExecutor扩展了ThreadPoolExecutor，并通过改写newTaskFor使得CancellableTask可以创建自己的Future。</span></span><br><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancellingExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="keyword">protected</span>&lt;T&gt; RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (callable <span class="keyword">instanceof</span> cancellableTask)</span><br><span class="line"><span class="keyword">return</span> ( (cancellableTask&lt;T&gt;) callable) .newTask ();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.newTaskFor (callable) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SocketUsingTask实现了CancellableTask，并定义了Future.cancel来关闭套接字和调用super.cancel。如果SocketUsingTask通过其自己的 Future来取消，那么底层的套接字将被关闭并且线程将被中断。因此它提高了任务对取消操作的响应性∶不仅能够在调用可中断方法的同时确保响应取消操作，而且还能调用可阻调的套接字IO方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketUsingTask</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">CancellableTask</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> Socket socket ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSocket</span> <span class="params">(Socket s)</span> </span>&#123; socket = s;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cancel</span> <span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>)</span><br><span class="line">        socket.close ( ) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ignored)&#123; &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RunnableFuture&lt;T&gt; <span class="title">newTask</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span> <span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    SocketUsingTask.<span class="keyword">this</span>.cancel( ) ;</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.cancel( mayInterruptIfRunning) ;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-停止基于线程的服务"><a href="#7-2-停止基于线程的服务" class="headerlink" title="7.2 停止基于线程的服务"></a>7.2 停止基于线程的服务</h3><p>应用程序通常会创建拥有多个线程的服务，例如线程池，并且这些服务的生命周期通常比创建它们的方法的生命周期更长。如果应用程序准备退出，那么这些服务所拥有的线程也需要结束。由于无法通过抢占式的方法来停止线程，因此它们需要自行结束。<br><strong>正确的封装原则是:除非拥有某个线程，否则不能对该线程进行操控。</strong>例如，中断线程或者修改线程的优先级等。在线程API中，并没有对线程所有权给出正式的定义:线程由Thread对象表示，并且像其他对象一样可以被自由共享。然而，<strong>线程有一个相应的所有者，,即创建该线程的类。因此线程池是其工作者线程的所有者，如果要中断这些线程，那么应该使用线程池。</strong><br>与其他封装对象一样，线程的所有权是不可传递的:<strong>应用程序可以拥有服务，服务也可以拥有工作者线程，但应用程序并不能拥有工作者线程，因此应用程序不能直接停止工作者线程。</strong>相反，服务应该提供生命周期方法(Lifecycle Method)来关闭它自己以及它所拥有的线程。这样，当应用程序关闭该服务时，服务就可以关闭所有的线程了。在ExecutorScevice 中提供了shutdown和 shutdownNow等方法。同样，在其他拥有线程的服务中也应该提供类似的关闭机制。</p><h4 id="示例：日志服务"><a href="#示例：日志服务" class="headerlink" title="示例：日志服务"></a>示例：日志服务</h4><p>将调用log方法将日志放入某个队列中，交给其他线程来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LogWriter中给出了一个简单的日志服务示例，其中日志操作在单独的日志线程中执行。产生日志消息的线程并不会将消息直接写入输出流，而是由LogWrite通过BlockingQueue将消息提交给日志线程，并由日志线程写入。这是一种多生产者单消费者(Multiple-Producer,Single-Consumer）的设计方式:每个调用log 的操作都相当于一个生产者，而后台的日志线程则相当于消费者。如果消费者的处理速度低于生产者的生成速度，那么BlockingQueue将阻塞生产者，直到日志线程有能力处理新的日志消息。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogWriter</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;string&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logwriter</span> <span class="params">(Writer writer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(CAPACITY);</span><br><span class="line">        <span class="keyword">this</span>.logger = <span class="keyword">new</span> LoggerThread(writer);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123; logger.start (); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(string msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    queue.put (msg) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Printwriter writer;</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">            writer.println (queue.take ( ) ) ;</span><br><span class="line">            &#125;<span class="keyword">catch</span> ( InterruptedException ignored)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writer.close ( ) ;</span><br><span class="line">       &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要一种终止日志线程的方法，避免使JVM无法正常关闭。</p><p>要停止日志线程是很容易的，因为它会反复调用take，而take能响应中断。<strong>如果将日志线程修改为当捕获到InterruptedException时退出，那么只需中断日志线程就能停止服务。</strong><br>然而，如果只是使日志线程退出，那么还不是一种完备的关闭机制。<strong>这种直接关闭的做法会丢失那些正在等待被写入到日志的信息，不仅如此，其他线程将在调用log时被阻塞，因为日志消息队列是满的，因此这些线程将无法解除阻塞状态。</strong>当取消一个生产者-消费者操作时，需要同时取消生产者和消费者。在中断日志线程时会处理消费者，但在这个示例中，由于生者并<br>另一种关闭LogWriter的方法是<strong>:设置某个“已请求关。在收到关闭请求后，消费者会把队列中的所有消息写入日志,解除所有在调用log时阻塞的生产者。</strong>然而，在这个方法中存在着竞态条件问题，使得该方并不可靠。log 的实现是一种“先判断再运行”的代码序列:生产者发现该服务还没有关闭，此在关闭服务后仍然会将日志消息放入队列，这同样会使得生产者可能在调用log时阻塞并无法解除阻塞状态。可以通过一些技巧来降低这种情况的发生概率</p><p>为LogWriter提供可靠关闭操作的方法是解决竞态条件问题<strong>，因而要使日志消息的提交操作成为原子操作。</strong>然而，我们不希望在消息加入队列时去持有一个锁，因为put方法本身就可以阻塞。我们采用的方法是:<strong>通过原子方式来检查关闭请求，并且有条件地递增一个计数器来“保持”提交消息的权利。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logservice</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;String&gt; queue ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LoggerThread loggerThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Printwriter writer ;</span><br><span class="line">    <span class="comment">//是否关闭</span></span><br><span class="line"><span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> <span class="keyword">boolean</span> isShutdown ;</span><br><span class="line">    <span class="comment">//计数器</span></span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> ) <span class="keyword">private</span> <span class="keyword">int</span> reservations ;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123; loggerThread.start ( ) ; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span> <span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; isShutdown = <span class="keyword">true</span>; &#125;</span><br><span class="line">        loggerThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(string msg)</span> <span class="keyword">throws</span> InterruptedBxception </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isShutdown)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalstateException (...) ;</span><br><span class="line">            ++reservations ;</span><br><span class="line">        &#125;</span><br><span class="line">        gueue.put (msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//原子方式来检查关闭请求</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (Logservice.<span class="keyword">this</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (isshutdown &amp;&amp; reservations ==o)</span><br><span class="line">                   <span class="keyword">break</span> ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    String msg = queue.take () ;</span><br><span class="line">                        <span class="comment">//记录一个就</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (LogService.<span class="keyword">this</span>) &#123; --reservations;&#125; writer.println (msg) ;</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;<span class="comment">/*retry */</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                writer.close ( ) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭ExecutorService"><a href="#关闭ExecutorService" class="headerlink" title="关闭ExecutorService"></a>关闭ExecutorService</h4><p>ExecutorService提供了两种关闭方法:<strong>使用shutdown正常关闭,以及使用shutdownNow强行关闭</strong>。在进行强行关闭时，shutdownNow首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单。<br>这两种关闭方式的差别在于各自的安全性和响应性:<strong>强行关闭的速度更快，但风险也更大，因为任务很可能在执行到一半时被结束﹔而正常关闭虽然速度慢，但却更安全，因为ExecutorService 会一直等到队列中的所有任务都执行完成后才关闭。</strong>在其他拥有线程的服务中也应该考虑提供类似的关闭方式以供选择。<br>简单的程序可以直接在main 函数中启动和关闭全局的ExecutorService。而在复杂程序中，通常会将ExecutorService封装在某个更高级别的服务中，并且该服务能提供其自己的生命周期方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//它将管理线程的工作委托给一个 ExecutorService，而不是由其自行管理。通过封装ExecutorService，可以将所有权链(Ownership Chain）从应用程序扩展到服务以及线程，所有权链上的各个成员都将管理它所拥有的服务或线程的生命周期。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = <span class="keyword">new</span> SingleThreadExecutor( ) ;:..</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        exec.shutdown ();</span><br><span class="line">        exec.awaitTermination (TIMEOUr,UNIT);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">writer.close () ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span> <span class="params">(string msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        exec.execute (<span class="keyword">new</span> writeTask (msg) ) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RejectedExecutionException ignored)&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="毒丸对象"><a href="#毒丸对象" class="headerlink" title="毒丸对象"></a>毒丸对象</h4><p>另-种关闭生产者一消费者服务的方式就是使用“毒丸(Poison Pill)”对象:“毒丸”是指<strong>一个放在队列上的对象，其含义是:“当得到这个对象时，立即停止。</strong>”在FIFO（先进先出）队列中，<strong>“毒丸”对象将确保消费者在关闭之前首先完成队列中的所有工作，在提交“毒丸”对象之前提交的所有工作都会被处理，而生产者在提交了“毒丸”对象后，将不会再提交任何工作。</strong></p><p>给出一个单生产者-单消费者的桌面搜索示例（来自程序清单5-8)，在这个示例中使用了“毒丸”对象来关闭服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单生产者-单消费者的桌面搜索</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Indexingservice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> File POISON = <span class="keyword">new</span> File (<span class="string">&quot;&quot;</span>) ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IndexerThread consumer = <span class="keyword">new</span> IndexerThread( ) ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CrawlerThread producer = <span class="keyword">new</span> CrawlerThread ( ) ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;File&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileFilter fileFilter ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> File root ;</span><br><span class="line">    <span class="comment">//生产者线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrawlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                crawl (root);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e)&#123; <span class="comment">/*发生异常*/</span>&#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ( <span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//重点</span></span><br><span class="line">                        queue.put (POISON);</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> ( InterruptedException e1) &#123;<span class="comment">/*重新尝试*/</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">crawl</span><span class="params">(File root)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//消费者线程    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    File file = queue.take ();</span><br><span class="line">                    <span class="comment">//重点</span></span><br><span class="line">                    <span class="keyword">if</span>(fle == POISON)</span><br><span class="line">                        <span class="keyword">break</span> ;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        indexFile(file) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException consumed)&#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">producer.start () ;</span><br><span class="line">        consumer.start () ;</span><br><span class="line">&#125;</span><br><span class="line">                                       </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span> <span class="params">()</span> </span>&#123; producer.interrupt( ) ; &#125;</span><br><span class="line">                                       </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitTermination</span> <span class="params">( )</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">consumer.join ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只有在生产者和消费者的数量都已知的情况下，才可以使用“毒丸”对象。</strong></p><h4 id="示例：只执行一次的服务"><a href="#示例：只执行一次的服务" class="headerlink" title="示例：只执行一次的服务"></a>示例：只执行一次的服务</h4><p><strong>如果某个方法需要处理一批任务，并且当所有任务都处理完成后才返回，那么可以通过一个私有的Executor来简化服务的生命周期管理，其中该Executor 的生命周期是由这个方法来控制的。</strong>(在这种情况下，invokeAll和invokeAny等方法通常会起较大的作用。)</p><h4 id="shutdownNow的局限性"><a href="#shutdownNow的局限性" class="headerlink" title="shutdownNow的局限性"></a>shutdownNow的局限性</h4><p>当通过shutdownNow来强行关闭ExecutorService时，<strong>它会尝试取消正在执行的任务，并返回所有已提交但尚未开始的任务，从而将这些任务写入日志或者保存起来以便之后进行处理。</strong><br>要知道哪些任务还没有完成，你不仅需要知道哪些任务还没有开始，而且还需要知道当Executor 关闭时哪些任务正在执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过封装ExecutorService并使得execute（类似地还有submit，在这里没有给出）记录哪些任务是在关闭后取消的，TrackingExecutor可以找出哪些任务已经开始但还没有正常完成。在Executor结束后，getCancelledTasks返回被取消的任务清单。要使这项技术能发挥作用，任务在返回时必须维持线程的中断状态，在所有设计良好的任务中都会实现这个功能。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackingExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executorservice exec ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> set&lt;Runnable&gt; tasksCancelledAtshutdown =</span><br><span class="line">Collections.synchronizedset (<span class="keyword">new</span> HashSet&lt;Runnable&gt; () ) ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">getCancelledTasks</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !exec.isTerminated ( ))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalstateException (...) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Runnable&gt; (tasksCancelledAtshutdown) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span> <span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">    exec.execute (<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    runnable.run ( ) ;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( isshutdown ( )</span><br><span class="line">    &amp;&amp; Thread.currentThread ( ).isInterrupted ())</span><br><span class="line">                        tasksCancelledAtshutdown.add (runnable) ;</span><br><span class="line">    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将Executorservice的其他方法委托给exec</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WebCrawler中给出了TrackingExecutor的用法。网页爬虫程序的工作通常是无穷尽的，因此当爬虫程序必须关闭时，我们通常希望保存它的状态，以便稍后重新房动。CrawlTask提供了一个getPage方法，该方法能找出正在处理的页面。当爬虫程序关闭时无论是还没有开始的任务，还是那些被取消的任务，都将记录它们的URL，因此当爬虫程序重新启动时，就可以将这些URL的页面抓取任务加入到任务队列中。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">webCrawler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> TrackingExecutor exec ;</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> )</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> set&lt;URL&gt; urlsToCrawl = <span class="keyword">new</span> Hashset&lt;URL&gt; ( ) ;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">    exec = <span class="keyword">new</span> TrackingExecutor (Executors.newCachedThreadPool ());</span><br><span class="line">        <span class="comment">//为每一个url提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (URL url : urlsToCrawl) submitcrawlTask (url) ;</span><br><span class="line">        urlsToCrawl.clear () ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//停止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            saveUncrawled ( exec. shutdownNow () ;</span><br><span class="line">            <span class="keyword">if</span> ( exec.awaitTermination (TIMEOUT,UNIT))</span><br><span class="line">            saveUncrawled (exec.getcancelledTasks ( ));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             exec = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;URL&gt;processPage (URL url) ;</span><br><span class="line">    <span class="comment">//保存没有爬取的页面                       </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveUncrawled</span> <span class="params">(List&lt;Runnable&gt; uncrawled)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Runnable task : uncrawled)</span><br><span class="line">        urlsToCrawl.add (((crawlTask) task).getPage()) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始爬取                       </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitcrawlTask</span> <span class="params">(URL u)</span></span>&#123;</span><br><span class="line">    exec.execute (<span class="keyword">new</span> crawlTask(u));</span><br><span class="line">    &#125;</span><br><span class="line">                           </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CrawlTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    ...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (URL link : processPage (url))&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted ())</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">                submitCrawlTask (link) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">URLgetPage</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> url ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在TrackingExecutor中存在一个不可避免的竞态条件，从而产生“误报”问题:<strong>一些被认为已取消的任务实际上已经执行完成</strong>。这个问题的原因在于，在任务执行最后一条指令以及线程池将任务记录为“结束”的两个时刻之间，线程池可能被关闭。如果任务是幂等的(Idempotent，即将任务执行两次与执行一次会得到相同的结果)，那么这不会存在问题，在网页爬虫程序中就是这种情况。否则，在应用程序中必须考虑这种风险，并对“误报”问题做好准备。</p><h3 id="7-3-处理非正常的线程终止"><a href="#7-3-处理非正常的线程终止" class="headerlink" title="7.3 处理非正常的线程终止"></a>7.3 处理非正常的线程终止</h3><p><strong>如果并发程序中的某个线程发生故障，在控制台中可能会输出栈追踪信息，但没有人会观察控制台。此外，当线程发生故障时，应用程序可能看起来仍然在工作，所以这个失败很可能会被忽略。幸运的是，我们有可以监测并防止在程序中“遗漏”线程的方法。</strong><br>导致线程提前死亡的最主要原因就是<code>RuntimeException</code>。由于这些异常表示出现了某种编程错误或者其他不可修复的错误，因此它们通常不会被捕获。它们不会在调用栈中逐层传递,而是默认地在控制台中输出栈追踪信息，并终止线程。<br>线程非正常退出的后果可能是良性的，也可能是恶性的，这要取决于线程在应用程序中的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在线程池内部构建一个工作者线程。如果任务抛出了一个未检查异常，那么它将使线程终结，但会首先通知框架该线程已经终结。然后，框架可能会用新的线程来代替这个工作线程，也可能不会，因为线程池正在关闭，或者当前已有足够多的线程能满足需要。ThreadPoolExecutor和 Swing都通过这项技术来确保行为糟糕的任务不会影响到后续任务的执行。当编写一个向线程池提交任务的工作者线程类时，或者调用不可信的外部代码时（例如动态加载的插件)，使用这些方法中的某一种可以避免某个编写得糟糕的任务或插件不会影响调用它的整个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run &#123;</span><br><span class="line">Throwable thrown = <span class="keyword">null</span> ;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( !isInterrupted ())</span><br><span class="line">        runTask (getTaskFromworkQueue () ) ;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">    thrown = e ;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    threadExited (<span class="keyword">this</span>, thrown) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-廖雪峰</title>
      <link href="/2021/01/09/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git-%E5%BB%96%E9%9B%AA%E5%B3%B0/"/>
      <url>/2021/01/09/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git-%E5%BB%96%E9%9B%AA%E5%B3%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git教程"><a href="#Git教程" class="headerlink" title="Git教程"></a>Git教程</h1><p>次教程基于<a href="https://www.liaoxuefeng.com/wiki/">https://www.liaoxuefeng.com/wiki/</a></p><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p><strong>集中式版本控制系统</strong>：版本库存放在中央服务器，用自己的电脑干活，类似于图书馆，必须互联网才能工作，CVS，SVN。</p><p><strong>分布式版本控制系统</strong>：每个人的电脑都是一个完整的版本库，工作的时候不需要联网，安全性高的多</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><h3 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h3><p>首先，你可以试着输入<code>git</code>，看看系统有没有安装Git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program &#x27;git&#x27; is currently not installed. You can install it by typing:</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。</p><p>老一点的Debian或Ubuntu Linux，要把命令改为<code>sudo apt-get install git-core</code>，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫<code>git-core</code>了。由于Git名气实在太大，后来就把GNU Interactive Tools改成<code>gnuit</code>，<code>git-core</code>正式改为<code>git</code>。</p><p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。</p><h3 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h3><p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/。">http://brew.sh/。</a></p><p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p><h3 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h3><p>从Git官网直接<a href="https://git-scm.com/downloads">下载安装程序</a>，然后按默认选项安装即可。</p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>版本库又名仓库，repository，类似于一个目录，这个目录所有的文件都可以被Git管理起来，每个文件的修改、删除，Git都能追逐。</p><p>第一步、创建版本库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></table></figure><p> 如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p><p>第二步</p><p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></table></figure><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><p>编写一个<code>readme.txt</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><p><code>-m</code>后面输入的是本次提交的说明，可以输入任意内容</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure><p>Git命令必须在Git仓库目录内执行</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>初始化一个Git仓库，使用<code>git init</code>命令。</p><p>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li></ol><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>如果修改文件</p><p>运行<code>git status</code>命令看看结果</p><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态</p><p><code>git diff</code>这个命令可以查看具体修改了哪些内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add distributed&quot;</span><br></pre></td></tr></table></figure><ul><li><p><code>HEAD</code>指向的版本就是当前版本，回退版本时，Git只是改变指向，使用命令<code>git reset --hard commit_id</code>。</p><p><code>git reset --hard HEAD^</code></p></li><li><p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p><p>如果觉得输出信息太多<code>--pretty=oneline</code><br>会看到commit id(版本号)Git是分布式控制系统，需要多人在同一个版本库中工作</p></li><li><p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p></li></ul><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p><strong>工作区</strong>：电脑中能看到的目录</p><p><strong>版本库</strong>：</p><p>工作区有一个隐藏目录<code>.git</code>,就是Git的版本库<br>版本库中最重要的就是叫stage的暂存区，Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code></p><p>把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>第二次修改没有被提交</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p><p>如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p><code>git checkout -- file</code>可以丢弃工作区的修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><ul><li>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ul><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令</p><p>用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192">版本回退</a>一节，不过前提是没有推送到远程库。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>当你删除了文件，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了</p><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code></p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>在github创建一个远程仓库，在本地仓库执行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:1426768270/learngit.git</span><br></pre></td></tr></table></figure><p>远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>把本地库的所有内容推送到远程库上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h4 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h4><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &#x27;github.com&#x27; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:1426768270/gitskills.git</span><br></pre></td></tr></table></figure><p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建和合并分支"><a href="#创建和合并分支" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h3><p>每次提交，Git会把它们串成一条时间线，这条时间线就是一个分支，<code>master</code>主分支，<code>HEAD</code>严格来讲不是指向提交，而是指向master，master才是指向提交，<code>HEAD</code>指向当前分支。</p><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前。</p><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><img src="/2021/01/09/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git-%E5%BB%96%E9%9B%AA%E5%B3%B0/创建分支.png" alt="image-20210111174341419" style="zoom:67%;"><p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化</p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><img src="/2021/01/09/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git-%E5%BB%96%E9%9B%AA%E5%B3%B0/创建分支2.png" alt="image-20210111174516314" style="zoom:67%;"><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><img src="/2021/01/09/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git-%E5%BB%96%E9%9B%AA%E5%B3%B0/创建分支3.png" alt="image-20210111174605298" style="zoom:67%;"><p>实际的命令</p><p>创建<code>dev</code>分支，然后切换到<code>dev</code>分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><p>然后，用<code>git branch</code>命令查看当前分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，然后提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;branch test&quot;</span><br></pre></td></tr></table></figure><p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上</p><p>把<code>dev</code>分支的工作成果合并到<code>master</code>分支上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure><p><code>git merge</code>命令用于合并指定分支到当前分支。</p><p><code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p>合并完成后，就可以放心地删除<code>dev</code>分支了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p><p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p><p>创建并切换到新的<code>dev</code>分支，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c dev</span><br></pre></td></tr></table></figure><p>直接切换到已有的<code>master</code>分支，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch master</span><br></pre></td></tr></table></figure><p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p><code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样</p><img src="/2021/01/09/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git-%E5%BB%96%E9%9B%AA%E5%B3%B0/分支冲突.png" alt="image-20210111191526854" style="zoom:67%;"><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突</p><p>手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><p>解决冲突之后重新提交</p><img src="/2021/01/09/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git-%E5%BB%96%E9%9B%AA%E5%B3%B0/分支冲突2.png" alt="image-20210111192522446" style="zoom:67%;"><p>用带参数的<code>git log</code>也可以看到分支的合并情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>不使用<code>Fast forward</code>模式，merge后就像这样：</p><img src="/2021/01/09/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git-%E5%BB%96%E9%9B%AA%E5%B3%B0/分支管理.png" alt="image-20210112162312255" style="zoom:67%;"><h4 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h4><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你正在修复一个bug时，突然让你修复另外一个bug，旧的没法完成提交，利用Git的<code>stash</code>功能，把工作现场储藏起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p><code>git stash list</code>命令查看工作现场</p><p>用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了</p><p>可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><p>如果同样的bug要在dev上修复，只需要把同一样的修改复制到这个分支<code>cherry-pick</code>复制一个特定的提交到当前分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick 4c805e2</span><br></pre></td></tr></table></figure><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p><p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>要查看远程库的信息，用<code>git remote</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>或者，用<code>git remote -v</code>显示更详细的信息</p><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>把该分支上的所有本地提交推送到远程库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>当另一个人要从远程库clone时，只能看见本地的master，必须创建远程origin的dev分支到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:1426768270/learngit.git</span><br><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>当你的同伴向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送，会推送失败</p><p>Git提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送</p><p>指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><p>然后解决冲突，提交在push。</p><p>多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul><li>查看远程库信息，使用<code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li><li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li></ul><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>当多次push,pull后git的提交历史很乱，可以使用rebase把它变成一条干净的直线。</p><p>Git把我们本地的提交“挪动”了位置把本地分支放到最后</p><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>切换到需要打标签的分支上，<code>git tag &lt;name&gt;</code> </p><p>命令<code>git tag</code>查看所有标签</p><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签需要找到历史提交的commit id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure><p>标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字</p><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字</p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v0.1</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.0</span><br></pre></td></tr></table></figure><p>一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><p>删除远程标签，先从本地删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v0.9</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/v0.9</span><br></pre></td></tr></table></figure><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li></ul><h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><p>让Git显示颜色，会让命令输出看起来更醒目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global color.ui true</span><br></pre></td></tr></table></figure><h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p><a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p><p>GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。</p><p>忽略文件的原则是：</p><ol><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件</li></ol><p>把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -f App.class</span><br></pre></td></tr></table></figure><p>用<code>-f</code>强制添加到Git</p><p>用<code>git check-ignore</code>命令检查是那条规则忽略这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git check-ignore -v App.class</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 排除所有.开头的隐藏文件:</span><br><span class="line">.*</span><br><span class="line"># 排除所有.class文件:</span><br><span class="line">*.class</span><br></pre></td></tr></table></figure><p><code>.*</code>这个规则把<code>.gitignore</code>也排除了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 不排除.gitignore和App.class:</span><br><span class="line">!.gitignore</span><br><span class="line">!App.class</span><br></pre></td></tr></table></figure><p>把指定文件排除在<code>.gitignore</code>规则外的写法就是<code>!</code>+文件名，所以，只需把例外文件添加进去即可。</p><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><ul><li>忽略某些文件时，需要编写<code>.gitignore</code>；</li><li><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</li></ul><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.* 命令</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br></pre></td></tr></table></figure><p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cat .git/config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = true</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    ignorecase = true</span><br><span class="line">    precomposeunicode = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url = git@github.com:michaelliao/learngit.git</span><br><span class="line">    fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br><span class="line">[alias]</span><br><span class="line">    last = log -1</span><br></pre></td></tr></table></figure><p>当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中</p>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-应用实践</title>
      <link href="/2020/09/11/redis/redis%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
      <url>/2020/09/11/redis/redis%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis深度历险：核心原理和应用实践"><a href="#Redis深度历险：核心原理和应用实践" class="headerlink" title="Redis深度历险：核心原理和应用实践"></a>Redis深度历险：核心原理和应用实践</h1><h2 id="应用1：千帆竞发–分布式锁"><a href="#应用1：千帆竞发–分布式锁" class="headerlink" title="应用1：千帆竞发–分布式锁"></a>应用1：千帆竞发–分布式锁</h2><p>要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修改，改完了再存回去。如果这样的操作同时进行了，就会出现并发问题，因为读取和保存状态这两个操作不是原子的。</p><p><strong>原子操作</strong>是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束</p><p>这个时候就要使用到分布式锁来限制程序的并发执行。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a><strong>分布式锁</strong></h3><p>分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。</p><p>占坑一般是使用 <strong>setnx</strong>(set if not exists) 指令，只允许被一个客户端占坑。先来先占， 用完了，再调用 <strong>del</strong> 指令释放茅坑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; setnx lock:codehole true</span><br><span class="line">OK</span><br><span class="line">... do something critical ...</span><br><span class="line">&gt; del lock:codehole</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>如果逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样就会陷入死锁，锁永远得不到释放。</p><p>于是我们在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也可以保证 5 秒之后锁会自动释放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; setnx lock:codehole true</span><br><span class="line">OK</span><br><span class="line">&gt; expire lock:codehole 5</span><br><span class="line">... do something critical ...</span><br><span class="line">&gt; del lock:codehole</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>如果在 setnx 和 expire 之间服务器进程突然挂掉了,还是会造成死锁。</p><p>这种问题的根源就在于 setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。也许你会想到用 Redis 事务来解决。但是这里不行，<strong>因为 expire 是依赖于 setnx 的执行结果的，如果 setnx 没抢到锁，expire 是不应该执行的。</strong></p><p>为了治理这个乱象，Redis 2.8 版本中作者加入了 set 指令的扩展参数，使得 setnx 和expire 指令可以一起执行，彻底解决了分布式锁的乱象。从此以后所有的第三方分布式锁library 可以休息了。 <strong>&gt; set lock:codehole true ex 5 nx OK … do something critical … &gt; del lock:codehole</strong> 上面这个指令就是 setnx 和 expire 组合在一起的原子指令，它就是分布式锁的奥义所在。</p><h3 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h3><p>Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁，但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻辑执行完之间拿到了锁。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-动态规划</title>
      <link href="/2020/09/06/leetcode/leetcode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2020/09/06/leetcode/leetcode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53 最大子序和"></a>53 最大子序和</h2><p><img src="/2020/09/06/leetcode/leetcode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.png" alt="image-20200906151116068"></p><p>如果 sum &gt; 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字<br>如果 sum &lt;= 0，则说明 sum 对结果无增益效果，需要舍弃，则 sum 直接更新为当前遍历数字<br>每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">leet_53</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];<span class="comment">//最大子序和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//当前位置的子序和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sum = num;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h2><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>可以从下一层跨上去，也可以从 下两层跨上去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++ )&#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="121-买股票的最佳时期"><a href="#121-买股票的最佳时期" class="headerlink" title="121 买股票的最佳时期"></a>121 买股票的最佳时期</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p><p>注意：你不能在买入股票前卖出股票。</p><h2 id="983-最低票价"><a href="#983-最低票价" class="headerlink" title="983 最低票价"></a>983 最低票价</h2><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p><p>火车票有三种不同的销售方式：</p><p>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p><p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：days = [1,4,6,7,8,20], costs = [2,7,15]</span><br><span class="line">输出：11</span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。</span><br><span class="line">在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。</span><br><span class="line">在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。</span><br><span class="line">你总共花了 $11，并完成了你计划的每一天旅行。</span><br><span class="line"></span><br><span class="line">输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： </span><br><span class="line">在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。</span><br><span class="line">在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 </span><br><span class="line">你总共花了 $17，并完成了你计划的每一天旅行。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>今天不需要出门，不用买票</li><li>今天如果要出门，需要买几天？<ul><li>看往后几天（最多 30 天内）要不要出门<ul><li>30 天内都没有要出行的，那只买今天就好</li><li>有要出门的（不同决策）<ul><li>这次 和 后面几次 分开买更省</li><li>这次 和 后面几次 一起买更省</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>海康威视</title>
      <link href="/2020/08/28/%E7%AC%94%E8%AF%95/%E6%B5%B7%E5%BA%B7%E5%A8%81%E8%A7%86/"/>
      <url>/2020/08/28/%E7%AC%94%E8%AF%95/%E6%B5%B7%E5%BA%B7%E5%A8%81%E8%A7%86/</url>
      
        <content type="html"><![CDATA[<h2 id="3x0-1-0-3"><a href="#3x0-1-0-3" class="headerlink" title="3x0.1 = = 0.3"></a>3x0.1 = = 0.3</h2><p>false </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3x0.1 = 0.300000000000004 计算机存储问题</span><br><span class="line">0.3</span><br></pre></td></tr></table></figure><h2 id="非检查性异常"><a href="#非检查性异常" class="headerlink" title="非检查性异常"></a>非检查性异常</h2><p>空指针异常</p><h2 id="类的访问权限，同一包的类和子类可以访问"><a href="#类的访问权限，同一包的类和子类可以访问" class="headerlink" title="类的访问权限，同一包的类和子类可以访问"></a>类的访问权限，同一包的类和子类可以访问</h2><p>protected: 类+子类<br>private: 类<br>public: all<br>无: 包内</p><h2 id="排序的顺序对排序算法没有影响"><a href="#排序的顺序对排序算法没有影响" class="headerlink" title="排序的顺序对排序算法没有影响"></a>排序的顺序对排序算法没有影响</h2><p>堆排序，归并排序</p><h2 id="以下对JDBC事务描述错误的是"><a href="#以下对JDBC事务描述错误的是" class="headerlink" title="以下对JDBC事务描述错误的是"></a>以下对JDBC事务描述错误的是</h2><p>JDBC右connection发起可控制</p><h2 id="关于Servlet说法错误的是"><a href="#关于Servlet说法错误的是" class="headerlink" title="关于Servlet说法错误的是"></a>关于Servlet说法错误的是</h2><p>A．Servlet的生命周期由Servlet实例控制  （创建 Servlet 实例后响应客户请求直至销毁的全过程.）</p><p>B．init()方法在创建完Servlet实例后对其进行初始化，传递的参数为实现ServletContext接口的对象</p><p>C．service()方法响应客户端发出的请</p><p>D．destroy()方法释放Servlet实例    (销毁)</p><p>选c</p><p>多选</p><h2 id="在数据库操作中，如果不考虑事务的隔离性，会发生下面哪种情况"><a href="#在数据库操作中，如果不考虑事务的隔离性，会发生下面哪种情况" class="headerlink" title="在数据库操作中，如果不考虑事务的隔离性，会发生下面哪种情况"></a>在数据库操作中，如果不考虑事务的隔离性，会发生下面哪种情况</h2><ol><li>脏读：A事务中读取到了B事务中未提交的数据，造成数据错误</li><li>不可重复读：A事务中读取到了B事务中已提交的数据，在特定情景下会产生影响，比如生成统一的数据报表</li><li>虚读（幻读）：A事务中读取到了B事务中已提交的新插入的数据，影响同上</li></ol><p>可重复读不算</p><h2 id="完全二叉树第5层有10个节点，二叉树最少有几个节点"><a href="#完全二叉树第5层有10个节点，二叉树最少有几个节点" class="headerlink" title="完全二叉树第5层有10个节点，二叉树最少有几个节点"></a>完全二叉树第5层有10个节点，二叉树最少有几个节点</h2><p>只有5层的情况下2^4^-1+10 = 25</p><p>有6层的情况下  第5层有10个叶子节点，其他都是分支节点 2^5^-1+12 = 43</p><p>​                                                    如果只有1个孩子2^5^-1+11 = 42</p><h2 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h2><p>tb_score 姓名name 科目sourse 成绩score 用一条sql每门课大于80分的学生的姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name form (<span class="keyword">select</span> name,<span class="built_in">min</span>(score) <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> name <span class="keyword">having</span> <span class="built_in">min</span>(score)<span class="operator">&gt;</span><span class="number">80</span>) stu;</span><br></pre></td></tr></table></figure><h2 id="编程器"><a href="#编程器" class="headerlink" title="编程器"></a>编程器<img src="/2020/08/28/%E7%AC%94%E8%AF%95/%E6%B5%B7%E5%BA%B7%E5%A8%81%E8%A7%86/编程题.jpg" alt="编程题" style="zoom: 33%;"></h2>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java并发编程实战--第一部分 基础知识</title>
      <link href="/2020/08/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
      <url>/2020/08/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="二、线程安全性"><a href="#二、线程安全性" class="headerlink" title="二、线程安全性"></a>二、线程安全性</h2><p>核心在于要对状态访问进行管理，特别是共享、可变的。</p><p>共享意味着变量可以由多个线程进行访问，可变意味着变量的值发生变化。</p><p>java同步机制是关键词synchronized,他提供一种加锁方式，但同步术语还得volatile。</p><p>修复线程安全的方式：</p><ul><li>不在线程之间共享该状态变量</li><li>将状态变量修改为不可变的变量</li><li>在访问状态变量时使用同步</li></ul><h3 id="2-1线程安全性"><a href="#2-1线程安全性" class="headerlink" title="2.1线程安全性"></a>2.1线程安全性</h3><p>当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。</p><p>大多数Servlet对象时无状态的</p><p><strong>无状态对象一定是线程安金的。</strong><br>只有当Servlet在处理请求时需要保存些信息，线程安全性才会成为一个问题。由于线程访问无状态对象的行为并不会影响其他线程中操作的正确性，因此无状大多数Servlet都是无状态的，从而极大地降低了在实现Servlet线程安全性时的复杂性。</p><h3 id="2-2-原子性"><a href="#2-2-原子性" class="headerlink" title="2.2 原子性"></a>2.2 原子性</h3><p>当在无状态对象中增加一个状态，如命中计算器，来统计所处理的请求数量。当对一个值，进行修改时，操作并不是原子性的，包括“读取-修改-写入”。在并发编程中执行时序不正确的结果是一种非常重要的情况，他有一个正式的名字：<strong>竞态条件</strong>。</p><h4 id="2-2-1-竞态条件"><a href="#2-2-1-竞态条件" class="headerlink" title="2.2.1 竞态条件"></a>2.2.1 <strong>竞态条件</strong></h4><p>正确的结果取决于运气。最常见的就是“先检查后执行，通过一个可能失效的观测结果决定下一步的动作。</p><h4 id="2-2-2-实例：延迟初始化化的竞态条件"><a href="#2-2-2-实例：延迟初始化化的竞态条件" class="headerlink" title="2.2.2 实例：延迟初始化化的竞态条件"></a>2.2.2 实例：延迟初始化化的竞态条件</h4><p>使用“先检查后执行”的一种常见情况就是延迟初始化。延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。</p><p>单例模式中没有加入双重检查的getInstance</p><h4 id="2-2-3-复合操作"><a href="#2-2-3-复合操作" class="headerlink" title="2.2.3 复合操作"></a>2.2.3 复合操作</h4><p>要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改状态的过程中。</p><p>例如修改变量的操作是原子操作，为了保证线程的安全性，’先检查后执行’和‘读取修改写入’操作必须是原子性，这些操作我们称之为复合操作，包含了一组以原子操作来确保线程的安全性。</p><p>在<strong>java.util.concurrent.atomic</strong>包中包含了一些原子变量类，用于实现在数值和对象引用上的原子状态转换。通过用AtomicLong来代替long 类型的计数器，能够确保所有对计数器状态的访问操作都是原子的。°由于Servlet的状态就是计数器的状态，并且计数器是线程安全的，因此这里的Servlet也是线程安全的。</p><p>我们在因数分解的Servlet中增加了一个计数器，并通过使用线程安全类AtomicLong来管理计数器的状态，从而确保了代码的线程安全性。当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。然而，在2.3节你将看到，当状态变量的数量由一个变为多个时，并不会像状态变量数量由零个变为一个那样简单。</p><h3 id="2-3-加速机制"><a href="#2-3-加速机制" class="headerlink" title="2.3 加速机制"></a>2.3 加速机制</h3><p>当在Servlet中添加一个状态变量时，可以通过线程安全的对象来管理Servlet的状态以维护Servlet的线程安全性。但如果想在Servlet中添加更多的状态，那么是否只需添加更多的线程安全状态变量就足够了?</p><p>当线程A获取这个值时，线程B可能修改了他们，这样线程A也就不会发现不变性条件被破坏了。</p><p>要保证状态的一致性， 就需要在单个原子操作中更新所有相关的状态变量。</p><h4 id="2-3-1内置锁"><a href="#2-3-1内置锁" class="headerlink" title="2.3.1内置锁"></a>2.3.1内置锁</h4><p>java提供一种内置的机制保证原子性，<strong>同步代码块</strong>。</p><p>同步代码块包括2个部分：</p><ul><li>一个作为锁的对象引用</li><li>一个作为由这锁保护的代码块</li></ul><p>以关键词synchronized修饰的方法计算横跨整个方法体的同步代码块，其中该代码块的锁计算方法调用所在的对象。</p><p>每个Java对象都可以用做一个实现同步的锁，这些锁被称为<strong>内置锁</strong>(Intrinsic Lock)或监视器锁(Monitor Lock)。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过从代码块中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。</p><p>Java的内置锁相当于一种<strong>互斥体</strong>（或互斥锁)，这意味着最多只有一个线程能持有这种锁，当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或者阻塞，直到线程B释放这个锁。如果B永远不释放锁，那么A也将永远地等下去。</p><p>这种方法很安全，但是性能非常低，无法令人接受。</p><h4 id="2-3-2-重入"><a href="#2-3-2-重入" class="headerlink" title="2.3.2 重入"></a>2.3.2 重入</h4><p>·当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，<strong>因此如果某个线程试图获得一个已经由它自己持有的锁，那么这个请求就会成功。</strong>“重入”意味着获取锁的操作的粒度是“线程”，而不是“调用”。</p><blockquote><p>重入的一种实现方式是，为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为О时，这个锁将被释放。</p></blockquote><p><strong>重入进一步提升了加锁行为的封装性。</strong></p><blockquote><p>当子类改写了父类的synchronized的方法，然后调用父类的方法，如果没有可重入锁，那么这段代码就会产生死锁</p></blockquote><h3 id="2-4-用锁来保护状态"><a href="#2-4-用锁来保护状态" class="headerlink" title="2.4 用锁来保护状态"></a>2.4 用锁来保护状态</h3><p>由于锁能使其保护的代码路径以<strong>串行形式</strong>来来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。只要始终遵循这些协议，就能确保状态的一致性。</p><blockquote><p>访问共享状态的复合操作，例如命中计数器的递增操作（读取–修改-写人）或者延迟初始化（先检查后执行)，都必须是原子操作以避免产生竟态条件。如果在复合操作的执行过程中持有一个锁，那么会使复合操作成为原子操作。然而，仅仅将复合操作封装到一个同步代码块中是不够的。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同-一个锁。</p></blockquote><p><strong>一种常见的错误是认为，只有在写入共享变量时才需要使用同步</strong>，然而事实并非如此（3.1）节将进一步解释其中的原因)。</p><blockquote><p>对象的内置锁与其状态之间没有内在的关联。虽然大多数类都将内置锁用做一种有效的加锁机制，但对象的域并不一定要通过内置锁来保护。当获取与对象关联的锁时，并不能阻止其他线程访问该对象，某个线程在获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，只是为了免去显式地创建锁对象。你需要自行构造加锁协议或者同步策略来实现对共享状态的安全访问，并且在程序中自始至终地使用它们。</p></blockquote><p>一种常见的加锁约定是，将所有的可变状态都封装在对象内部，通过内置锁进行同步，例如Vector当包含多个变量的不变性条件是,其中所有的变量都需要由同一把锁来保护。</p><h3 id="2-5-活跃性和性能"><a href="#2-5-活跃性和性能" class="headerlink" title="2.5 活跃性和性能"></a>2.5 活跃性和性能</h3><p>当使用锁时，你应该清楚代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论是执行计算密集的操作，还是在执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题。</p><h2 id="三、对象的共享"><a href="#三、对象的共享" class="headerlink" title="三、对象的共享"></a>三、对象的共享</h2><p>第2章的开头曾指出，要编写正确的并发程序，关键问题在于:<strong>在访问共享的可变状态时需要进行正确的管理</strong>。</p><h3 id="3-1-可见性"><a href="#3-1-可见性" class="headerlink" title="3.1 可见性"></a>3.1 可见性</h3><p><strong>通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用司步机制。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!ready).</span><br><span class="line">    Thread.yield () ;</span><br><span class="line">    system.out.println (number) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(string []args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> ReaderThread ( ) .start ( ) ;</span><br><span class="line">    number = <span class="number">42</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NoVisibility可能会持续循环下去，<strong>因为读线程可能永远都看不到ready的值</strong>。一种更奇怪的现象是，<strong>NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写人number的值，这种现象被称为“重排序(Reordering)”。</strong>只要在某个线程中无法检测到重排序情况（即使在其他线程中可以很明显地看到该线程中的重排序)，那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写人number，然后在没有同步的情况下写人ready，那么读线程看到的顺序可能与写人的顺序完全相反。</p><p>在没有同步的情况下，<strong>编译器、处理器以及运行时等都可能对操作的执行顺序进行些意想不到的调整。</strong>在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。</p><h4 id="3-1-1-失效数据"><a href="#3-1-1-失效数据" class="headerlink" title="3.1.1 失效数据"></a>3.1.1 失效数据</h4><p>NoVisibility展示了在缺乏同步的程序中可能产生错误结果的–种情况﹔失效数据。<strong>当读线程查看ready变量时，可能会得到一个已经失效的值。除非在每次访问变量时都使用同步，否则很可能获得该变量的一个失效值。</strong>更糟糕的是，失效值可能不会同时出现:一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。</p><p>如果某个线程调用了set，那么一个正在调用get的线程可能会看到更新后的value值，也可能看不到。.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutableInteger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">intget</span><span class="params">( &#123;return value; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> set(<span class="keyword">int</span> value)</span> </span>&#123; <span class="keyword">this</span>.value = value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-非原子的64位操作"><a href="#3-1-2-非原子的64位操作" class="headerlink" title="3.1.2 非原子的64位操作"></a>3.1.2 非原子的64位操作</h4><p>当线程在没有同步的情况下读取变量时，可能会得到一个失效值，<strong>但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性。</strong><br>最低安全性适用于绝大多数变量，但是存在一个例外:<strong>非volatile类型的64位数值变量(double和long，请参见3.1.4节)。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取-个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位</strong>。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的long和double等类型的变量也是不安全的，除非用关键字·volatile来声明它们，或者用锁保护起来。</p><h4 id="3-1-3-加锁与可见性"><a href="#3-1-3-加锁与可见性" class="headerlink" title="3.1.3 加锁与可见性"></a>3.1.3 加锁与可见性</h4><p>内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的结果。</p><p>当线程A执行某个同步代码块时，线程B随后进人由同一个锁保护的同步代码块，在这种情况下可以保证，在锁被释放之前，A看到的变量值在B获得锁后同样可以由B看到。换句话说，当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个同步代码块中的所有操作结果。如果没有同步，那么就无法实现上述保证。</p><img src="/2020/08/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/同步的可见性保证.png" alt="image-20200826092118572" style="zoom:67%;"><h4 id="3-1-4-Volatile"><a href="#3-1-4-Volatile" class="headerlink" title="3.1.4 Volatile"></a>3.1.4 Volatile</h4><p><strong>volatile变量，用来确保将变量的更新操作通其他线程。</strong>当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，此不会将该变量上的操作与其他内存操作一起重排序。<strong>volatile变量不会被缓存在寄存器或者其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</strong><br>理解volatile变量的一种有效方法是，将它们的行为想象成程序清单3-3中SynchronizedInteger类似行为，并将volaLile变量的读操作和写操作分别替换为get方法和set方法。然而，<strong>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞</strong>，因此 volatile变量是一svchronized关键空<strong>更轻量级</strong>的同步机制。</p><p>因此，从内存可见性的角度来看，写入volatile变量相当于退出同步代码块，而读取volatile变量就相当于进入同步代码块。<br>虽然volatile变量很方便，但也存在一些局限性。<strong>volatile变量通常用做某个操作完成、发生中断或者状态的标志</strong>。尽管volatile变量也可以用于表示其他的状态信息，但在使用时要非常小心。例如，<strong>volatile的语义不足以确保递增操作(count++)的原子性</strong>，除非你能确保只有一个线程对变量执行写操作。</p><p>加锁机制既可以确保可见性又可以确保原子性,volatile只能保证可见性。<br>当且仅当满足以下所有条件时，才应该使用volatile变量:</p><ul><li>对变量的<strong>写人操作不依赖变量的当前值</strong>，或者你能确保只有单个线程更新变量的值。</li><li>该变量不会与其他状态变量一起纳人不变性条件中。</li><li>在访问变量时不需要加锁。</li></ul><h3 id="3-2-发布和溢出"><a href="#3-2-发布和溢出" class="headerlink" title="3.2 发布和溢出"></a>3.2 发布和溢出</h3><p><a href="https://blog.csdn.net/flysqrlboy/article/details/10607295?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduend~default-1-10607295.nonecase">https://blog.csdn.net/flysqrlboy/article/details/10607295?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduend~default-1-10607295.nonecase</a></p><p>“发布(Publish)”一个对象的意思是指，<strong>使对象能够在当前作用域之外的代码中使用。</strong>多数情况要确保对象及其内部状态不能被发布。</p><p><strong>当某个不应该发布的对象被发布时，这种情况就被称为逸出(Escape)。</strong></p><p>隐式的使this引用溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">thisEscape</span> <span class="params">(Eventsource source)</span></span>&#123;</span><br><span class="line">source.registerListener (</span><br><span class="line"><span class="keyword">new</span> EventListener()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span> <span class="params">(Event e)</span> </span>&#123;</span><br><span class="line">dosomething(e) ;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当内部的EventListener实例发布时，在外部封装的ThisEscape实例也逸出了。当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。因此，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。如果this引用在构造过程中逸出，那么这种对象就被认为是不正确构造°。</p><p>在构造过程中使this 引用逸出的一个常见错误是，<strong>在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，</strong>无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread或Runnable是该对象的一个内部类)，<strong>this 引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。在构造函数中创建线程并没有错误，但最好不要立即启动它</strong>，而是通过一个start或initialize方法来启动</p><p>如果在构造函数中注册一个事件监听机制或启动线程，<strong>可以使用一个私有的构造方法和一个公共的工厂方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">safeListener</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventListener listener;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">safeListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">        listener = <span class="keyword">new</span> EventListener()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span> <span class="params">(Event e)</span></span>&#123;</span><br><span class="line">        dosomething(e) ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> safeListener <span class="title">newInstance</span><span class="params">(Eventsource source)</span></span>&#123;</span><br><span class="line">        safeListener safe = <span class="keyword">new</span> safeListener ( ) ;</span><br><span class="line">        source.registerListener (safe.listener) ;</span><br><span class="line">        <span class="keyword">return</span> safe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-线程封闭"><a href="#3-3-线程封闭" class="headerlink" title="3.3 线程封闭"></a>3.3 线程封闭</h3><p>当访问共享的可变数据时，一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这这种技术被称为线程封闭。</p><p>线程封闭技术的另一个常见应用是JDBC的Connection对象。JDBC的规范不要求Connection对象是线程安全的，大多数请求都是由单个线程采用同步的方式来处理，并在Connection对象返回之前，连接池都不会再将它分配给其他线程</p><ul><li><p>Ad-hoc线程封闭</p><p>维护线程封闭性的职责完全由程序实现来承担。少用</p></li><li><p>栈封闭</p><p>线程封闭的特例，只能通过局部变量才能访问对象。</p></li><li><p>ThreadLocal类</p><p>维护线程封闭性的规范的方法是使用ThreadLocal，他提供了get和set等访问接口或方法，<strong>这些方法为每个使用该变量的线程都存有一份独立的副本</strong>，get总是返回由当前执行线程在调用set时设置的新值。</p><p>ThreadLocal对象通常用于防止对可变的单实例变量(Singleton）或全局变量进行共享。例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。</p><p>通过将JDBC连接保存到Thread中，每个线程都会拥有属于自己的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder</span><br><span class="line">       =<span class="keyword">new</span> ThreadLocal&lt;connection&gt; ()&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> Connection <span class="title">initialvalue</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> DriverManager.getConnection (DB_URL);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> connection <span class="title">getconnection</span> <span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> connectionHolder.get ( ) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象</strong>，就可以使用这项技术。例如，在Java 5.0之前，Integer.toString()方法使用ThreadLocal对象来保存一个12字节大小的缓冲区，用于对结果进行格式化，而不是使用共享的静态缓冲区（这需要使用锁机制）或者在每次调用时都分配一个新的缓冲区。<br>当某个线程初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。<strong>从概念上看，你可以将ThreadLocal<T>视为包含了Map&lt; Thread,T&gt;对象</T></strong>，其中保存了特定于该线程的值，但ThreadLocal 的实现并非如此。这些特定于线程的值保存在Thread对象中，<strong>当线程终止后，这些值会作为垃圾回收。</strong></p><p>假设你需要将一个单线程应用程序移植到多线程环境中，通过将共享的全局变量转换为ThreadLocal对象（如果全局变量的语义允许)，可以维持线程安全性。然而，如果将应用程序范围内的缓存转换为线程局部的缓存，就不会有太大作用。</p></li></ul><h3 id="3-4-不变性"><a href="#3-4-不变性" class="headerlink" title="3.4 不变性"></a>3.4 不变性</h3><p>满足同步需求的另一种方法是使用不可变对象。不可变对象只有一种状态并且这个状态由构造函数控制。</p><p><strong>不可变性并不等于将对象中所有的域都声明为final类型</strong>，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为在final类型的域中可以保存对可变对象的引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当满足以下条件时,对象才是不可变的:</span><br><span class="line">    对象创建以后其状态就不能修改。</span><br><span class="line">    对象的所有域都是final类型。</span><br><span class="line">    转城时对象是正确创建的(在对象的创建期间,this引用没有逸出)。</span><br></pre></td></tr></table></figure><p>不可变对象内部可以使用可变对象来管理他们的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@rmmutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Threestooges</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> set&lt;string&gt; stooges = <span class="keyword">new</span> Hashset&lt;string&gt;( ) ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Threestooges</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    stooges .add ( <span class="string">&quot;Moe&quot;</span> ) ;</span><br><span class="line">    stooges.add ( <span class="string">&quot;Larry&quot;</span> );</span><br><span class="line">    stooges.add ( <span class="string">&quot;curly&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isstooge</span> <span class="params">(string name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stooges. contains (name) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stooges是一个final类型的引用变量。</p><ul><li><p>Final域</p><p>final类型的域是不能修改的，final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象，并在共享这些对象时无需同步。</p></li><li><p>使用Volatile类型发布不可变对象</p><p>分解Servlet的2个原子操作，更新缓存的结果，通过判断缓存招聘那个数值来决定是否直接读取缓存中的分解结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnevalueCache</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BigInteger lastNumber ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger [] lastFactors;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Onevaluecache</span> <span class="params">(BigInteger i,</span></span></span><br><span class="line"><span class="params"><span class="function">    BigInteger [] factors)</span> </span>&#123;</span><br><span class="line">        lastNumber = i;</span><br><span class="line">        lastFactors = Arrays.copyof (factors,factors.length) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> BigInteger [] getFactors (BigInteger i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lastNumber == <span class="keyword">null</span> || !lastNumber.equals(i))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.copyof (lastFactors,lastFactors.length) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">volatilecachedFactorizer</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> volati1e OnevalueCache cache =<span class="keyword">new</span> Onevaluecache (<span class="keyword">null</span>,<span class="keyword">null</span>) ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req,ServletResponse resp)</span></span>&#123;</span><br><span class="line">        Big Integer i = extractFromRequest (req) ;</span><br><span class="line">        BigIntegeri] factors = cache . getFactors (i) ;</span><br><span class="line">        <span class="keyword">if</span> (factors == <span class="keyword">null</span>)&#123;</span><br><span class="line">            factors = factor (i) ;</span><br><span class="line">            cache = <span class="keyword">new</span> Onevaluecache (i, factors) ;</span><br><span class="line">    &#125;</span><br><span class="line">    encodeintoResponse (resp, factors) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码使用了OneValueCache来保存缓存的数值及其因数，当一个线程将volatile类型的cache设置为引用一个新的OneValueCache时，其他线程就会立即看到新缓存的数据。</p></li></ul><h3 id="3-5-安全发布"><a href="#3-5-安全发布" class="headerlink" title="3.5 安全发布"></a>3.5 安全发布</h3><p>在某些情况下我们希望在多个线程间共享对象，必须确保安全的进行共享。</p><h4 id="不正确的发布：正确的对象被破坏"><a href="#不正确的发布：正确的对象被破坏" class="headerlink" title="不正确的发布：正确的对象被破坏"></a>不正确的发布：正确的对象被破坏</h4><p>不能指望一个没用被完全创建的对象拥有完整性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">this</span>.n = n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assertsanity</span><span class="params">( )</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n != n)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AssertionBrror ( <span class="string">&quot;This statement is false. &quot;</span> ) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有使用同步来确保Holder对象其他线程可见，有2个问题，除了发布对象线程外，其他线程可以看到Holder是一个失效值。线程看到Holder是最新的，但Holder状态的值是失效的</p><h4 id="不可变对象与初始化安全性"><a href="#不可变对象与初始化安全性" class="headerlink" title="不可变对象与初始化安全性"></a>不可变对象与初始化安全性</h4><p>某个想的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程一定是可见的</p><p>即使发布不可变对象的引用没有使用同步，也仍然可以安全地访问对象。为了满足初始化安全性必须满足不可变性的条件：<strong>状态不可修改，所有域都是final,以及正确的构造过程</strong>。</p><h4 id="安全发布的采用模式"><a href="#安全发布的采用模式" class="headerlink" title="安全发布的采用模式"></a>安全发布的采用模式</h4><p>可变对象必须使用同步。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布:</span><br><span class="line">-在静态初始化函数中初始化一个对象引用。</span><br><span class="line">-将对象的引用保存到volatile 类型的域或者AtomicReferance对象中。</span><br><span class="line">-将对象的引用保存到某个正确构造对象的final类型域中。</span><br><span class="line">-将对象的引用保存到个由锁保护的域中。</span><br></pre></td></tr></table></figure><p>线程安全同步容器内部的同步意味着，将对象放入某个容器。例如Vector或synchronizedList满足最后一条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过将一个键或者值放入Hashtable、synchronizedMap或者ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程（无论是直接访问还是通过迭代器访问)。</span><br><span class="line">通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程。</span><br><span class="line">通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程。</span><br><span class="line">类库中的其他数据传递机制（例如Future和 Exchanger）同样能实现安全发布，在介绍这些机制时将讨论它们的安全发布功能。</span><br></pre></td></tr></table></figure><p>通常，要发布一个静态构造的对象，最简单使用静态初始化器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Holder holder = <span class="keyword">new</span> Holder(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>静态初始化由JVM在类初始化阶段执行。JVM内部存在同步机制，通过这种方法初始化的任何对象都可以安全发布。</p><h4 id="事实不可变对象"><a href="#事实不可变对象" class="headerlink" title="事实不可变对象"></a>事实不可变对象</h4><p>如果想从技术上看是可变的，但状态在发布后不会改变，那么把这种对象称为事实不可变对象。</p><p>例如，Date本身是可变的·，但如果将它作为不可变对象来使用，那么在多个线程之间共享Date对象时，就可以省去对锁的使用。假设需要维护一个Map对象，其中保存了每位用户的最近登录时间:<br><code>public Map&lt;string, Date&gt; iastLogin =</code><br><code>collections.synchronizedMap(new HashMap&lt;string,Date&gt;()) ;</code><br>如果Date对象的值在被放入Map后就不会改变，那么synchronizedMap中的同步机制就足以使 Date值被安全地发布，并且在访问这些Date值时不需要额外的同步。</p><h4 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h4><p>对象的发布需求取决于它的可变性:</p><ul><li>不可变对象可以通过任意机制来发布。</li><li>事实不可变对象必须通过安全方式来发布,</li><li>可变对象必须通过安全方式来发布,并且必须是线程安全的或者由某个锁保护起来。</li></ul><h4 id="安全的共享对象"><a href="#安全的共享对象" class="headerlink" title="安全的共享对象"></a>安全的共享对象</h4><p>在并发程序中使用和共享对象时,可以使用一些实用的策略,包括:</p><ul><li><strong>线程封闭</strong>。线程封闭的对象只能由一个线程拥有,对象被封闭在该线程中，并且只能由这个线程修改。</li><li><strong>只读共享</strong>。在没有额外同步的情况下,共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。</li><li><strong>线程安全共享</strong>,线程安全的对象在其内部实现同步,因此多个线程可以通过对象的公有接口来进行访闻而不需要进一步的同步。</li><li><strong>保护对象</strong>。被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他.线程安全对象中的对象，以及已发布的并且由某个特定销保护的对象。</li></ul><h2 id="四、对象的组合"><a href="#四、对象的组合" class="headerlink" title="四、对象的组合"></a>四、对象的组合</h2><h3 id="4-1-设计线程安全的类"><a href="#4-1-设计线程安全的类" class="headerlink" title="4.1 设计线程安全的类"></a>4.1 设计线程安全的类</h3><p>在设计线程安全类的过程中,需要包含以下三个基本要素:</p><ul><li>找出构成对象状态的所有变量。</li><li>找出约束状态变量的不变性条件。</li><li>建立对象状态的并发访问管理策略。</li></ul><p>要分析对象的状态，首先从对象的域开始。如果对象中所有的域都是基本类型的变量，那么这些域将构成对象的全部状态。</p><p>对于含有n个基本类型域的对象，其状态就是这些域构成的n元组。例如，二维点的状态就是它的坐标值(x，y)。如果在对象的域中引用了其他对象，那么该对象的状态将包含被引用对象的域。例如，LinkedList的状态就包括该链表中所有节点对象的状态。</p><h4 id="收集同步需求"><a href="#收集同步需求" class="headerlink" title="收集同步需求"></a>收集同步需求</h4><h4 id="依赖状态的操作"><a href="#依赖状态的操作" class="headerlink" title="依赖状态的操作"></a>依赖状态的操作</h4><p>某些对象的方法中包括一些基于状态的先验条件。</p><h4 id="状态的所有权"><a href="#状态的所有权" class="headerlink" title="状态的所有权"></a>状态的所有权</h4><h3 id="4-2-实例封闭"><a href="#4-2-实例封闭" class="headerlink" title="4.2 实例封闭"></a>4.2 实例封闭</h3><p>将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Personset</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot; this&quot;</span> )</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> set&lt;Person&gt; myset = <span class="keyword">new</span> Hashset&lt;Person&gt; () ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addperson</span> <span class="params">( Person p)</span></span>&#123;</span><br><span class="line">    myset.add(p) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsPerson</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myset.contains(p) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PersonSet 的状态由HashSet来管理的，而HashSet并非线程安全的。但由于mySet是私有的并且不会逸出，因此HashSet被封闭在PersonSet中。唯一能访问mySet的代码路径是addPerson与containsPerson，在执行它们时都要获得PersonSet上的锁。PersonSet的状态完全由它的内置锁保护，因而PersonSet是一个线程安全的类。</p><p>这个示例并未对Person的线程安全性做任何假设，但如果Person类是可变的，那么在访问从PersonSet中获得的Person对象时，还需要额外的同步。要想安全地使用Person对象，最可靠的方法就是使Person成为一个线程安全的类。另外，也可以使用锁来保护Person对象，并确保所有客户代码在访问Person对象之前都已经获得正确的锁。</p><p>在Java平台的类库中还有很多线程封闭的示例，其中有些类的唯一用途就是将非线程安全的类转化为线程安全的类。一些基本的容器类并非线程安全的，例如ArrayList和HashMap,但类<strong>库提供了包装器工厂方法（例如Collections.synehronizedList 及其类似方法)</strong>，使得这些非线程安全的类可以在多线程环境中安全地使用。这些工厂方法通过“装饰器（Decorator)”模式(Gamma et al.,1995)将容器类封装在一个同步的包装器对象中，而包装器能将接口中的每个方法都实现为同步方法，并将调用请求转发到底层的容器对象上。只要包装器对象拥有对底层容器对象的唯一引用（即把底层容器对象封闭在包装器中)，那么它就是线程安全的。</p><h4 id="Java监视器模式"><a href="#Java监视器模式" class="headerlink" title="Java监视器模式"></a>Java监视器模式</h4><p>遵循Java监视器模式的对象会把对象的所有可变状态封装起来，并且右自己内置锁保护</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateLock</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> object myLock = <span class="keyword">new</span> Object () ;</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot;myLock&quot;</span> )widget widget ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someMethod</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (myLock)&#123;</span><br><span class="line"><span class="comment">//访问或修改widget的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用私有的锁对象而不是对象的内置锁，有许多优点。<strong>私有的锁对象可以将锁封装起来，使客户代码无法得到锁，但客户代码可以通过公有方法来访问锁，以便（正确或者不正确地）参与到它的同步策略中。</strong>如果客户代码错误地获得了另一个对象的锁，那么可能会产生活跃性问题。此外，要想验证某个公有访问的锁在程序中是否被正确地使用，则需要检查整个程序，而不是单个的类。</p><h4 id="车辆追踪"><a href="#车辆追踪" class="headerlink" title="车辆追踪"></a>车辆追踪</h4><p>一个用于调度车辆的“车辆追踪器”，例如出租车、警车、货车等。首先使用监视器模式来构建车辆追踪器，然后再尝试放宽某些封装性需求同时又保持线程安全性。<br>每台车都由一个String对象来标识，并且拥有一个相应的位置坐标(x,y)。在VehicleTracke类中封装了车辆的标识和位置，因而它非常适合作为基于MVC (Model-View-Controller，模型–视图一控制器）模式的GUI应用程序中的数据模型，并且该模型将由一个视图线程和多个执行更新的线程共享。<strong>视图会读取每辆车辆的名字和位置，并将它们显示在界面上</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;string,Point&gt; locations e vehicles.getLocations() ;</span><br><span class="line"><span class="keyword">for</span> (string key : locations.keyset () )</span><br><span class="line">rendervehicle (key, locations.get (key) ) ;</span><br></pre></td></tr></table></figure><p>修改车辆位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vehicleMoved</span> <span class="params">(vehicleMovedEvent evt)</span> </span>&#123;</span><br><span class="line">    Point loc n evt.getNewLocation ( ) ;</span><br><span class="line">    vehicles.setLocation (evt.getvehicleld(), loc.x，loc.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Threadsafe</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorvehicleTracker</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;string,MutablePoint&gt; locations ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MonitorvehicleTracker</span> <span class="params">(Map&lt;string, MutablePoint&gt; locations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.1ocations = deepcopy (locations) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Map&lt;string,MutablePoint&gt; <span class="title">getLocations</span> <span class="params">( )</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> deepcopy ( locations) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> MutablePoint <span class="title">getLocation</span><span class="params">(string id)</span> </span>&#123;</span><br><span class="line">        MutablePoint loc = locations.get (id) ;</span><br><span class="line">        <span class="keyword">return</span> loc == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> MutablePoint (loc) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span> <span class="params">(string id,<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    MutablePoint loc = locations.get (id);</span><br><span class="line">    <span class="keyword">if</span> ( loc == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException ( <span class="string">&quot;No such ID: &quot;</span> + id) ;</span><br><span class="line">        loc.x = x;</span><br><span class="line">    loc.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;string，MutablePoint &gt; deepCopy(</span><br><span class="line">    Map&lt;string,MutablePoint&gt; m)&#123;</span><br><span class="line">    Map&lt;String,MutablePoint&gt; result = <span class="keyword">new</span> HashMap&lt;string,MutablePoint&gt;() ;</span><br><span class="line">        <span class="keyword">for</span> (string id : m.keyset ())</span><br><span class="line">    result.put (id,<span class="keyword">new</span> MutablePoint (m.get (id))) ;</span><br><span class="line">        <span class="keyword">return</span> collections.unmodifiableMap (result) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePoint</span> <span class="params">()</span> </span>&#123; x = <span class="number">0</span> ; y = <span class="number">0</span> ; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePoint</span> <span class="params">(MutablePoint p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = p.x;</span><br><span class="line">        <span class="keyword">this</span>.y = p.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每次调用getLocation就要复制数据，因此将出现一种错误情况–—虽然车辆的实际位置发生了变化，但返回的信息却保持不变。这种情况是好还是坏，要取决于你的需求。如果在location集合上存在内部的一致性需求，那么这就是优点，在这种情况下返回一致的快照就非常重要。然而，如果调用者需要每辆车的最新信息，那么这就是缺点，因为这需要非常频繁地刷新快照。</p><h3 id="4-3-线程安全性的委托"><a href="#4-3-线程安全性的委托" class="headerlink" title="4.3 线程安全性的委托"></a>4.3 线程安全性的委托</h3><h4 id="基于委托的车辆追踪器"><a href="#基于委托的车辆追踪器" class="headerlink" title="基于委托的车辆追踪器"></a>基于委托的车辆追踪器</h4><p>我们将车辆位置保存到一个Map对象中，因此首先设计线程安全的Map类型，ConcurrentHashMap，用一个不可变的Point类，是一个线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Immutable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;.</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x ;</span><br><span class="line">        <span class="keyword">this</span>.y = y ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用concurrentHashMap管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingvehicleTracker</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> concurrentMap&lt;String,Point&gt; locations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,Point&gt; unmodifiableMap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegatingvehicleTracker</span> <span class="params">(Map&lt;string，Point&gt; points)</span></span>&#123;</span><br><span class="line">    locations = <span class="keyword">new</span> ConcurrentHashMap&lt;string，Point&gt;(points) ;</span><br><span class="line">        unmodifiableMap = Collections.unmodifiableMap (locations) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Point&gt; <span class="title">getLocations</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unmodifiableMap ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Point <span class="title">getLocation</span> <span class="params">(String id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> locations.get (id);</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span> <span class="params">(String id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( locations.replace(id, <span class="keyword">new</span> Point (x, y)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> 1llegalArgumentException (<span class="string">&quot;invalid vehicle name : &quot;</span> + id) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是实时的车辆快照。</p><p>如果需要一个不发生变化的车辆视图，可以返回一个浅拷贝。犹豫Map内容不可变，只需要复制Map的结构，不复制内容。不能保证返回一个线程安全的Map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Point&gt; <span class="title">getLocations</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableMap (<span class="keyword">new</span> HashMap&lt;String, Point&gt; ( 1ocations));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="独立的状态向量"><a href="#独立的状态向量" class="headerlink" title="独立的状态向量"></a>独立的状态向量</h4><p>我们还可以将线程安全性委托给多个状态向量</p><p>以下代码是一个图形组件，监控鼠标和键盘的事件，它为每种事件都有一个已注册的监听器列表，<strong>键盘和鼠标的监听器直接不存在关联，二者是彼此独立的，可以将线程安全性委托给两个线程安全的监听器列表。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisualComponent</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;KeyListener&gt; keyListeners= <span class="keyword">new</span> CopyonwriteArrayList&lt;KeyListener&gt; ( );</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MouseListener&gt; mouseListeners = <span class="keyword">new</span> CopyonwriteArrayList&lt;MouseListener&gt; () ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addKeyListener</span><span class="params">(KeyListener listener)</span> </span>&#123;</span><br><span class="line">    keyListeners.add (listener);</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMouseListener</span><span class="params">(MouseListener listener)</span></span>&#123;</span><br><span class="line">    mouseListeners.add ( listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeKeyListener</span><span class="params">(KeyListener listener)</span></span>&#123;</span><br><span class="line">    keyListeners.remove (listener) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMouseistener</span><span class="params">(MouseListener listener)</span></span>&#123;</span><br><span class="line">   mouseListeners.remove (listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用CopyonwriteArrayList保存各个监听器列表，是一个线程安全的列表。</p><h4 id="当委托失效时"><a href="#当委托失效时" class="headerlink" title="当委托失效时"></a>当委托失效时</h4><p>大多数组合不会这么简单，他们的状态变量直接存在着某些不变性条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberRange</span> </span>&#123;</span><br><span class="line"><span class="comment">//不变性条件: lower &lt;= upper</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger lower = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>) ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> atomicInteger upper = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>) ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意--—不安全的“先检查后执行”</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; upper.get ( ) )</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> I1iegalArgumentException (<span class="string">&quot;can&#x27;t set lower to &quot;</span> + i +<span class="string">&quot; &gt; upper&quot;</span> ) ;</span><br><span class="line">    lower.set (i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpper</span> <span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">//注意——不安全的“先检查后执行”</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; lower.get ())</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException (<span class="string">&quot;can!t set upper to &quot;</span> + i +<span class="string">&quot; &lt; lower&quot;</span> ) ;</span><br><span class="line">upper.set (i) ;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInRange</span> <span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &gt;= lower.get ( ) &amp;&amp; i &lt;= upper.get ( ) ) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码使用2个AtomicInteger来管理状态，并且有个约束条件，第一个数值要小于等于第二个数值。这个代码不是线程安全的，没有位置对下界和上界进行约束的不变性条件。<strong>先检查后执行，没有使用加锁机制来保证操作的原子性。</strong>一个线程setLower（5），一个线程setUpper(4),都是先检查，那么取值范围就是（5，4）。虽然AtomicInteger是线程安全的，但组合得到的类不是。</p><h4 id="发布底层的状态变量"><a href="#发布底层的状态变量" class="headerlink" title="发布底层的状态变量"></a>发布底层的状态变量</h4><p>什么时候才可以发布这些变量，使其他类修改他们？</p><p>取决于类对这些变量施加了哪些不变性条件。</p><h4 id="发布状态的车辆追踪器"><a href="#发布状态的车辆追踪器" class="headerlink" title="发布状态的车辆追踪器"></a>发布状态的车辆追踪器</h4><p>可变且线程安全的Point类,x和y必须同时操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSare</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">safePoint</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span>)<span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">safePoint</span> <span class="params">(<span class="keyword">int</span> [] a)</span> </span>&#123; <span class="keyword">this</span>(a[o], a[<span class="number">1</span>]); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">safePoint</span> <span class="params">(safePoint p)</span> </span>&#123; <span class="keyword">this</span>(p.get()); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">safePoint</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> [] get ( ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123; x, y &#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublishingvehicleTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,safePoint&gt; locations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, SafePoint&gt; unmodifiableMap;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">publishingvehicleTracker</span><span class="params">(Map&lt;string, safePoint&gt; locations)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.locations= <span class="keyword">new</span> concurrentHashMap&lt;String，safePoint&gt; (locations);</span><br><span class="line">        <span class="keyword">this</span>.unmodifiableMap = Collections.unmodifiableMap(<span class="keyword">this</span>.locations) ;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;string, safePoint&gt; <span class="title">getLocations</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unmodifiableMap ; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> safePoint <span class="title">getLocation</span> <span class="params">(string id)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> locations.get (id) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span> <span class="params">(String id,<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !locations.containsKey (id))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalkrgumentException (<span class="string">&quot;invalid vehicle name :&quot;</span> +id) ;</span><br><span class="line">        locations.get (id) .set (x, y) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将线程安全性委托给ConcurrentHashMap，Map中元素是线程安全且可变的Point.getLocation方法返回的是一个不可变副本，调用者不能增加或删除车辆，只能修改返回map中的值来改变车辆位置。</p><h3 id="4-4-在现有线程安全类中添加功能"><a href="#4-4-在现有线程安全类中添加功能" class="headerlink" title="4.4 在现有线程安全类中添加功能"></a>4.4 在现有线程安全类中添加功能</h3><p>扩展一个若没有则添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Tnreadsate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bettervector</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">vector</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span> <span class="params">( x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> absent = ! contains (x ) ;</span><br><span class="line">        <span class="keyword">if</span> (absent)</span><br><span class="line">        add (x) ;</span><br><span class="line">        <span class="keyword">return</span> absent ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="客户端加锁机制"><a href="#客户端加锁机制" class="headerlink" title="客户端加锁机制"></a>客户端加锁机制</h4><p>对于由Collections.synchronizedList封装的ArrayList，这两种方法在原始类中添加一个方法或者对类进行扩展都行不通，因为客户代码并不知道在同步封装器工厂方法中返回的List对象的类型。第三种策略是扩展类的功能，但并不是扩展类本身，而是将扩展代码放入一个“辅助类”中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list =collections.synchronizedList (<span class="keyword">new</span> ArrayList&lt;E&gt;( )) ;...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span> <span class="params">(E x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> absent = !list.contains (x) ;</span><br><span class="line">        <span class="keyword">if</span> (absent)</span><br><span class="line">            list.add (x);</span><br><span class="line">            <span class="keyword">return</span> absent ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能实现线程安全性,这里虽然所有的操作都被声明为synchronized,但是使用了不同的锁，无法确保putIfAbsent执行时另一个线程不会修改链表。<strong>list是发布出去的</strong></p><p>必须使客户端内部和外部加锁使用同一个锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListHelper</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;E&gt; list =collections.synchronizedList (<span class="keyword">new</span> ArrayList&lt;E&gt; ( ));...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putIfAbsent</span> <span class="params">(E x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> absent = !list.contains (x) ;</span><br><span class="line">            <span class="keyword">if</span> (absent)</span><br><span class="line">            list.add(x) ;</span><br><span class="line">            <span class="keyword">return</span> absent ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>必须保证加锁的对象不会改变。对list加锁，其他地方就会不能修改list</p><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>对一个现有的类添加一个原子操作时使用组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Threadsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImprovedList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImprovedList</span> <span class="params">(List&lt;T&gt; list)</span> </span>&#123; <span class="keyword">this</span>.list = list; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> put <span class="title">IfAbsent</span> <span class="params">(T x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> contains = list .contains (x) ;</span><br><span class="line">        <span class="keyword">if</span> (contains)</span><br><span class="line">        list.add(x) ;</span><br><span class="line">        <span class="keyword">return</span> !contains ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">( )</span> </span>&#123; list.clear( ) ; &#125;</span><br><span class="line">    <span class="comment">//..．按照类似的方式委托List 的其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、基础模块构建"><a href="#五、基础模块构建" class="headerlink" title="五、基础模块构建"></a>五、基础模块构建</h2><h3 id="5-1-同步容器类"><a href="#5-1-同步容器类" class="headerlink" title="5.1 同步容器类"></a>5.1 同步容器类</h3><p>同步容器类实现线程安全的方式是：<strong>将它们的状态封装起来，并对每个共有方法都进行同步，使得每次只有一个线程能访问容器的状态。</strong></p><h4 id="同步容器类的问题"><a href="#同步容器类的问题" class="headerlink" title="同步容器类的问题"></a>同步容器类的问题</h4><p>当复合操作时例如，迭代、跳转、条件运算（若没有则添加）。这些操作在没有客户端加锁的情况下是线程安全的，但当其他线程并发的修改容器，会出问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getLast</span> <span class="params">(vector list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last Index = list.size () - l;</span><br><span class="line">    <span class="keyword">return</span> list.get ( lastIndex) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteLast</span> <span class="params">(Vector list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = list.size ()- <span class="number">1</span> ;</span><br><span class="line">    list.remove ( lastIndex) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题A线程调用getLast，B线程调用deleteLast,会出现问题。在调用size与调用getLast操作直接，Vector变小了，使的到的索引不在有效。</p><p><strong>使用客户端加锁就可以解决，通过同步容器类自身的锁来保护每个方法，使操作变成原子操作。</strong><code>synchronized(list)</code></p><p>在size和get之间Vector的长度会发生改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(vector)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; vector.size ( ) ; i++)</span><br><span class="line">        dosomething (vector.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代器与ConcurentModificationException"><a href="#迭代器与ConcurentModificationException" class="headerlink" title="迭代器与ConcurentModificationException"></a>迭代器与ConcurentModificationException</h4><p><strong>许多现代的容器都没有消除复合操作的问题。无论是之间迭代还是foreach，使用的都是Iterator,如果有线程并发的修改容器，那么使用迭代器也无法问题。及时失败（fail-fast）。</strong></p><p><strong>这意味着，当它们发现容器在迭代过程中被修改时，就会抛出一个ConcurrentModificationException异常。</strong><br>这种“及时失败”的迭代器并不是一种完备的处理机制，而只是“善意地”捕获并发错误，因此只能作为并发问题的预警指示器。它们采用的实现方式是，将计数器的变化与容器关联起来:<strong>如果在迭代期间计数器被修改，那么hasNext或next将抛出ConcurrentModificationException</strong>。然而，这种检查是在没有同步的情况下进行的，因此可能会看到失效的计数值，而迭代器可能并没有意识到已经发生了修改。</p><h4 id="隐藏迭代器"><a href="#隐藏迭代器" class="headerlink" title="隐藏迭代器"></a>隐藏迭代器</h4><p><strong>虽然加锁可以防止迭代器抛出ConcurrentModificationException，但你必须要记住在所有对共享容器进行迭代的地方都需要加锁。</strong>实际情况要更加复杂，因为在某些情况下，迭代器会隐藏起来，在HiddenIterator中没有显式的迭代操作，代码中将执行迭代操作。编译器将字符串的连接操作转换为调用StringBuildet.append(Object)，而这个方法又会调用容器的 toString方法，标准容器的 toString方法将迭代容器，并在每个元素上调用toString来生成容器内容的格式化表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiddenIterator</span> </span>&#123;</span><br><span class="line"><span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span> )</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> set&lt;Integer&gt; set = <span class="keyword">new</span> Hashset&lt;Integer&gt; ( ) ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer i)</span> </span>&#123; set.add(i); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">remove</span> <span class="params">(Integer i)</span> </span>&#123; set.remove(i); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTenThings</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random ( ) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)</span><br><span class="line">        add(r.nextInt( )) ;</span><br><span class="line">        <span class="comment">//这里</span></span><br><span class="line">        system.out.print1n( <span class="string">&quot;DBBUG: added ten elements to &quot;</span> + set);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器的<strong>hashCode和equals</strong>等方法也会间接地执行迭代操作，当容器作为另一个容器的元素或键值时，就会出现这种情况。同样，<strong>containsAll、renoveAll和retainAll</strong>等方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所有这些间接的迭代操作都可能抛出ConcurrentModificationException。</p><h3 id="5-2-并发容器"><a href="#5-2-并发容器" class="headerlink" title="5.2 并发容器"></a>5.2 并发容器</h3><p>同步容器将对容器状态的访问串行化，实现线程安全性，代价是严重降低并发性，吞吐量降低。</p><p>新的ConcurrentMap接口中添加了一家常见的复合操作，例如“若没有则添加”，替换以及有条件删除。</p><p>2个新的容器类型：Queue和BlockingQueue。</p><p>Queue用来临时保存一组等待处理队列。。它提供了几种实现，包括:ConcurrentLinkedQueue，这是一个传统的先进先出队列，以及 PriorityQueue，这是一个(非并发的）优先队列。<strong>Queue 上的操作不会阻塞，如果队列为空，那么获取元素的操作将返回空值。</strong>虽然可以用List来模拟Queue的行为——事实上，正是通过LinkedList来实现Queue的，但还需要一个Queue的类，因为它能去掉List 的随机访问需求，从而实现更高效的并发。<br><strong>BlockingQueue扩展了Queue，增加了可阻塞的插入和获取等操作。</strong>如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现–个可用的元素。如果队列已满（对于有界队列来说)，那么插入元素的操作将一直阻塞，直到队列中出现可用的空间。在“<strong>生产者–消费者</strong>”这种设计模式中，阻塞队列是非常有用的。</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>基于散列的Map,任意数量的线程可以并发的访问Map，在并发环境下实现更高的吞吐量，在单线程只损失非常小的性能。</p><p>有一下需要权衡的因素，size和isEmpty，<strong>由于size返回的结果计算时可能已经过期了</strong>，实际上是一个估计值，返回一个近似值而不是精确值。这些操作的需求被弱化了，以换取对其他更重要的操作性能优化，get、put、containsKey、remove.</p><p>与Hashtable和 synchronizedMap相比,ConicurrentHashMap有着更多的优势以及更少的劣势,因此在大多数情况下，用ConcurrentHashMap来代替同步Map能进一-步提高代码的可伸缩性<strong>。只有当应用程序需要加锁Map以进行独占访问时，才应该放弃使用ConcurrentHashMap。</strong></p><h4 id="额外的原子操作"><a href="#额外的原子操作" class="headerlink" title="额外的原子操作"></a>额外的原子操作</h4><p>由于ConcurrentHashMap不能被加锁来执行独占访问，因此我们无法使用客户端加锁来创建新的原子操作。但是，一些常见的复合操作，例如“若没有则添加”、“若相等则移除(Remove-If-Equal)”和“若相等则替换(Replace-If-Equal)”等，都已经实现为原子操作并且在ConcurrentMap的接口中声明，如程序清单5-7所示。如果你需要在现有的同步Map中添加这样的功能，那么很可能就意味着应该考虑使用ConcurrentMap 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//仅当K没有相应的映射值时才插入</span></span><br><span class="line">    <span class="function">V put <span class="title">IfAbsent</span> <span class="params">(K key, V value)</span> </span>;</span><br><span class="line">    <span class="comment">//仅当K被映射到v时才移除</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(K key , V value)</span> </span>;</span><br><span class="line">    <span class="comment">//仅当K被映射到oldvalue时才替换为newvalue</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key , V oldvalue, V newValue)</span> </span>;</span><br><span class="line">    <span class="comment">//仅当K被映射到某个值时才替换为newvalue</span></span><br><span class="line">    <span class="function">V <span class="title">replace</span> <span class="params">(K key. V newvalue)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>代替同步List,写入时复制，只要正确的发布一个事实不可变对象，那么在访问该对象时就不再需要进一步的同步。<strong>在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。“写入时复制”容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。</strong>因此，多个线程可以同时对这个容器进行迭代，而不会彼此干扰或者与修改容器的线程相互干扰。“写入时复制”容器返回的迭代器不会抛出ConcurrentModificationException,’并且返回的元素与迭代器创建时的元素完全一致，而不必考虑之后修改操作所带来的影响。<br><strong>显然，每当修改容器时都会复制底层数组，这需要一定的开销</strong>，特别是当容器的规模较大时。<strong>仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器。</strong>这个准则很好地描述了许多事件通知系统:在分发通知时需要迭代已注册监听器链表，并调用每一个监听器，在大多数情况下，注册和注销事件监听器的操作远少于接收事件通知的操作。</p><h3 id="5-3-阻塞队列和生产者消费者模式"><a href="#5-3-阻塞队列和生产者消费者模式" class="headerlink" title="5.3 阻塞队列和生产者消费者模式"></a>5.3 阻塞队列和生产者消费者模式</h3><p>阻塞队列提供put和take方法，已以及支持定时的offer和poll方法。如果队列已经满了，put方法将阻塞直到有空间可用；如果队列为空，take方法会阻塞直到有元素可用。</p><p>阻塞队列支持生产者–消费者这种设计模式。<strong>该模式将“找出需要完成的工作”与“执行工作”这两个过程分离开来，并把工作项放入一个“待完成”列表中以便在随后处理，而不是找出后立即处理。</strong>生产者一消费者模式能简化开发过程，因为它消除了生产者类和消费者类之间的代码依赖性，此外，该模式还将生产数据的过程与使用数据的过程<strong>解耦</strong>开来以简化工作负载的管理，因为这两个过程在处理数据的速率上有所不同。</p><p>阻塞队列简化了消费者程序的编码。take会阻塞直到有可用的数据；out会阻塞直到有消防支队到来；当数据项不能被添加到队列中，会返回一个失败状态。</p><p>在类库中包含了BlockingQueue的多种实现，其中，<strong>LinkedBlockingQueue和 ArrayBlockingQueue</strong>是FIFO队列，二者分别与LinkedList和 ArrayList类似，但比同步List拥有更好的并发性能。<strong>PriorityBlockingQueue是一个按优先级排序的队列</strong>，当你希望按照某种顺序而不是FIFO来处理元素时，这个队列将非常有用。正如其他有序的容器一样，PriorityBlockingQueue既可以根据元素的自然顺序来比较元素（如果它们实现了Comparable方法)，也可以使用Comparator来比较。<br>最后一个 BlockingQueue实现是SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，<strong>这些线程在等待着把元素加入或移出队列。</strong></p><h4 id="示例：桌面搜索"><a href="#示例：桌面搜索" class="headerlink" title="示例：桌面搜索"></a>示例：桌面搜索</h4><p>代理程序，它将扫描本地驱动器上的文件并建立索引以便随后进行搜索。生产者任务FileCrawler：在某个文件层次结构中搜索复合索引标准的文件，并将它们放入工作队列。消费者任务：从队列中取出文件建立索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCrawler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;File&gt; fileQueue ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileFilter fileFilter;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File root ;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             crawl(root) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        Thread.currentThread ( ).interrupt ();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">crawl</span><span class="params">(File root)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        File[] entries = root.listFiles (fileFilter) ;<span class="comment">//找出所有文件</span></span><br><span class="line">        <span class="keyword">if</span> (entries != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File entry : entries)<span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (entry .isDirectory ())   <span class="comment">//目录就递归遍历</span></span><br><span class="line">                    crawl(entry) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( !alreadyIndexed (entry)) <span class="comment">//文件就添加到队列</span></span><br><span class="line">       fileQueue.put (entry) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Indexer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;File&gt; queue ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Indexer</span><span class="params">(BlockingQueue&lt;File&gt; queue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">( )</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        indexFile (queue.take());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException.e) &#123;</span><br><span class="line">        Thread.currentThread().interrupt() ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将文件遍历和建立索引分解为独立的操作，每个操作只完成一个任务，并且阻塞队伍将负责所有控制流。<strong>如果生产者和消费者并行度不同，那么他们紧密耦合在已经会把整体并行度降低为二者中更小行度</strong></p><p>下面程序中启动了多个爬虫程序和索引建立程序，消费者线程永远不会退出，程序无法终止，生产者-消费者线程通过Executor任务执行框架来做。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startIndexing</span> <span class="params">(File[] roots)</span></span>&#123;</span><br><span class="line">BlockingQueue&lt;File&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;File&gt;(BOUND);</span><br><span class="line">    FileFilter filter = <span class="keyword">new</span> FileFilter()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span> <span class="params">(File file)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (File root : roots)</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Filecrawler(queue，filter，root )).start () ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N_CONSUMERS ; i++)</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Indexer(queue)).start ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="串行线程封闭"><a href="#串行线程封闭" class="headerlink" title="串行线程封闭"></a>串行线程封闭</h4><p>对于可变对象，生产者-消费者这种设计与阻塞队列一起，促进了串行线程封闭，从而将对象所有权从生产者交付给消费者。<strong>线程封闭对象只能由单个线程拥有，但可以通过安全地发布该对象来“转移”所有权。</strong>在转移所有权后，也只有另一个线程能获得这个对象的访问权限，并且发布对象的线程不会再访问它。这种安全的发布确保了对象状态对于新的所有者来说是可见的，并且由于最初的所有者不会再访问它，因此对象将被封闭在新的线程中。</p><p>我们也可以使用其他发布机制来传递可变对象的所有权，但必须确保只有一个线程能接受被转移的对象。阻塞队列简化了这项工作。除此之外，还可以通过ConcurrentMap的原子方法remove或者AtomicReference的原子方法compareAndSet来完成这项工作。</p><h4 id="双端队列与工作密取"><a href="#双端队列与工作密取" class="headerlink" title="双端队列与工作密取"></a>双端队列与工作密取</h4><p><strong>Deque是一个双端队列，实现了在队列头和队列尾的高效插入和移除。具体实现包括 ArrayDeque和LinkedBlockingDeque。</strong><br>正如阻塞队列适用于生产者–消费者模式，双端队列同样适用于另一种相关模式，即工作密取（Work Stealing)。在生产者一消费者设计中，所有消费者有一个共享的工作队列，而在工作密取设计中，<strong>每个消费者都有各自的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾秘密地获取工作。</strong>密取工作模式比传统的生产者一消费者模式具有更高的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。在大多数时候，它们都只是访问自己的双端队列，从而极大地减少了竞争。当工作者线程需要访问另一个队列时，<strong>它会从队列的尾部而不是从头部获取工作，因此进一步降低了队列上的竞争程度。</strong><br>工作密取非常适用于既是消费者也是生产者问题——当执行某个工作时可能导致出现更多的工作。例如，在网页爬虫程序中处理一个页面时，通常会发现有更多的页面需要处理。类似的还有许多搜索图的算法，例如在垃圾回收阶段对堆进行标记，都可以通过工作密取机制来实现高效并行。当一个工作线程找到新的任务单元时，它会将其放到自己队列的末尾(或者在工作共享设计模式中，放入其他工作者线程的队列中)。当双端队列为空时，它会在另一个线程的队列队尾查找新的任务，从而确保每个线程都保持忙碌状态。</p><h3 id="5-4-阻塞方法与中断方法"><a href="#5-4-阻塞方法与中断方法" class="headerlink" title="5.4 阻塞方法与中断方法"></a>5.4 阻塞方法与中断方法</h3><p>被阻塞的线程必须等待不受它控制点事件发生后才能继续执行。</p><p>Thread提供了interrupt方法，用于中断线柱或者查询线程是否已经被中断。每个线程都有一个布尔类型的属性，表示线程的中断状态，当中断线程时将设置这个状态。<br>中断是一种协作机制。一个线程不能强制其他线程停止正在执行的操作而去执行其他的操作。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作——前提是如果线程B愿意停止下来。虽然在API或者语言规范中并没有为中断定义任何特定应用级别的语义，但最常使用中断的情况就是取消某个操作。方法对中断请求的响应度越高，就越容易及时取消那些执行时间很长的操作。</p><h3 id="5-5-同步工具类"><a href="#5-5-同步工具类" class="headerlink" title="5.5 同步工具类"></a>5.5 同步工具类</h3><p>同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流。阻塞队可以作为同步工具类，其他类型的同步工具类还包括<strong>信号量(Semaphore)、栅栏（Barrier)以及闭锁(Latch)</strong>。在平台类库中还包含其他一些同步工具类的类，如果这些类还无法满足需要，那么可以按照第14章中给出的机制来创建自己的同步工具类。.<br>所有的同步工具类都包含一些特定的结构化属性：<strong>它们封装了一些状态，这些状态将决定丸行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用千高效地等待同光工具.类讲入到预期状态。</strong></p><h4 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h4><p>延迟线程的进度直到其到达终止状态。相当于一扇门:<strong>在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。</strong></p><ul><li>确保某个计算在其需要的所有资源都被初始化之后才继续执行。二元闭锁（包括两个状态）可以用来表示“资源R已经被初始化”，而所有需要R的操作都必须先在这个闭锁上等待。</li><li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动。每个服务都有一个相关的二元闭锁。当启动服务S时，将首先在S依赖的其他服务的闭锁上等待，在所有依赖的服务都启动后会释放闭锁S，这样其他依赖S的服务才能继续执行。</li><li>等待直到某个操作的所有参与者（例如，在多玩家游戏中的所有玩家）都就绪再继续执行。在这种情况中，当所有玩家都准备就绪时，闭锁将到达结束状态。</li></ul><p>CountDownLatch是一种灵活的闭锁。它使多个线程等待一组事件。<strong>闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown方法递减计数器，表示有一个事件已经发生了，而await方去等待计数器达到零，这表示所有需要等待的事件都已经发生。如果计数器的值非零，那么wait会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span> <span class="params">(<span class="keyword">int</span> nThreads,<span class="keyword">final</span> Runnable task)</span><span class="keyword">throws</span> interruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//起始门，1</span></span><br><span class="line">        <span class="keyword">final</span> countDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//结束门，工作线程</span></span><br><span class="line">        <span class="keyword">final</span> countDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads) ;</span><br><span class="line">        <span class="comment">//保证所有线程都就绪再启动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = o ; i &lt; nThreads ; i++) &#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread () &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        startGate.await () ;</span><br><span class="line">                        <span class="keyword">try</span> &#123; </span><br><span class="line">        task.run();</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        endGate.countDown() ;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> ( InterruptedException ignored)&#123; &#125;</span><br><span class="line">        &#125; ;</span><br><span class="line">        t.start() ;</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime( );</span><br><span class="line">        startGate.countDown ( );</span><br><span class="line">    endGate.await() ;</span><br><span class="line">    <span class="keyword">long</span> end = system.nanoTime ( ) ;</span><br><span class="line">        <span class="keyword">return</span> end-start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>也是一直闭锁，通过Callable实现，相当于一种可生成结果的Runnable,有3种状态：等待运行、正在运行、运行完成。</p><p><strong>Future.get的行为取决于任务的状态。如果任务已经完成，那么get 会立即返回结果，否则get将阻塞直到任务进入完成状态，然后返回结果或者抛出异常。</strong>FutureTask 将计算结果从执行计算的线程传递到<strong>获取这个结果的线程</strong>，而FutureTask 的规范确保了这种传递过程能实现结果的安全发布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Preloader</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Future,包含从数据库加载产品信息的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;ProductInfo&gt; future =</span><br><span class="line">    <span class="keyword">new</span> FutureTask&lt;ProductInfo&gt;(<span class="keyword">new</span> callable&lt;ProductInfo&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">call</span> <span class="params">()</span> <span class="keyword">throws</span> DataLoadException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadProductInfo ( ) ;</span><br><span class="line">             &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread (future) ;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span> <span class="params">( )</span> </span>&#123; thread.start () ; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">get</span> <span class="params">()</span> <span class="keyword">throws</span> DataLoadException,InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> future.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    Throwable cause = e.getCause ( ) ;</span><br><span class="line">    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> DataLoadException)</span><br><span class="line">                <span class="keyword">throw</span> (DataLoadException) cause;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">throw</span> 1aunderThrowab1e (cause) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>控制同时访问某个特定资源的操作数量。Semaphore中管理着一组虚拟的许可(permit)，许可的初始数量可通过构造函数来指定。<strong>在执行操作时可以首先获得许可（只要还有剩余的许可)，并在使用以后释放许可。如果没有许可，那么acquire将阻塞直到有许可(或者直到被中断或者操作超时)。</strong>release方法将返回一个许可给信号量。计算信号量的一种简化形式是二值信号量，即初始值为1的Semaphore。二值信号量可以用做互斥体(mutex)，并具备不可重入的加锁语义i谁拥有这个唯一的许可，谁就拥有了互斥锁。可用于实现资源池，如数据库连接池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashset</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> set&lt;T&gt; set ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> semaphore sem;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashset</span> <span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.set = collections.synchronizedset (<span class="keyword">new</span> Hashset&lt;T&gt;());</span><br><span class="line">       sem = <span class="keyword">new</span> semaphore (bound);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span> <span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sem.acquire ( ) ;</span><br><span class="line">    <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123; </span><br><span class="line">    wasAdded = set.add (o) ;</span><br><span class="line">            <span class="keyword">return</span> wasAdded;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !wasAdded)</span><br><span class="line">    sem.release () ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span> <span class="params">(object o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> wasRemoved = set.remove (o);</span><br><span class="line">        <span class="keyword">if</span> (wasRemoved)</span><br><span class="line">    sem.release ();</span><br><span class="line">        <span class="keyword">return</span> wasRemoved ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h4><p>闭锁是一次性对象，一旦进入终止状态，就不能重置。栅栏也是闭锁，能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，<strong>所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。</strong><br>CyclicBarrier可以<strong>使一定数量的参与方反复地在栅栏位置汇集，它在并行迭代算法中非常有用:这种算法通常将一个问题拆分成一系列相互独立的子问题。</strong>当线程到达栅栏位置时将调用await方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达了栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏将被重置以便下次使用。如果对await的调用超时，或者await阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的await调用都将终止并抛出 BrokenBarrierException。如果成功地通过栅栏，那么await将为每个线程返回一个唯一的到达索引号，我们可以利用这些索引来“选举”产生一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。CyclicBarrier还可以使你将一个栅栏操作传递给构造函数，这是一个Runnable，当成功通过栅栏时会（在一个子任务线程中）执行它，但在阻塞线程被释放之前是不能执行的。</p><p>另一种形式的栅栏是<strong>Exchanger</strong>，它是一种两方（Two-Party)栅栏，各方在栅栏位置上交换数据。当两方执行不对称的操作时，Exchanger会非常有用，例如当一个线程向缓冲区写入数据，而另一个线程从缓冲区中读取数据。这些线程可以使用Exchanger来汇合，并将满的缓冲区与空的缓冲区交换。当两个线程通过Exchanger交换对象时，这种交换就把这两个对象安全地发布给另一方。</p><h3 id="5-6-构建高效且可伸缩的结果缓存"><a href="#5-6-构建高效且可伸缩的结果缓存" class="headerlink" title="5.6 构建高效且可伸缩的结果缓存"></a>5.6 构建高效且可伸缩的结果缓存</h3><p>开发一个高效且可伸缩的缓存，改进一个高计算函数。</p><p>在 ExpensiveFunction中实现的Computable，需要很长的时间来计算结果，我们将创建一个Computable包装器，帮助记住之前的计算结果，并将缓存过程封装起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">v</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">V <span class="title">compute</span><span class="params">(A arg)</span><span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpensiveFunction</span> <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">string</span>,<span class="title">BigInteger</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigInteger <span class="title">compute</span><span class="params">(string arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">//在经过长时间的计算后</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BigInteger (arg) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer1</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span> ( <span class="string">&quot;this&quot;</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, v&gt; cache = <span class="keyword">new</span> HashMap&lt;A,V&gt; ( ) ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A,V&gt; c ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Memoizer1</span> <span class="params">(Computable&lt;A, v&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedBxception</span>&#123;</span><br><span class="line">        V result = cache.get(arg) ;</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">        result = c.compute(arg) ;</span><br><span class="line">            cache.put(arg, result) ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一种方法使用HashMap保存之前计算的结果。compute首先检查需要的结果是否已经在缓存中。HashMap不是线程安全的，对整个方法进行同步，但是如果有另外一个线程正在计算结果，就会阻塞。</p><p>Memoizer2<strong>用ConcurrentHashMap代替HashMap</strong>。由于ConcurrentHashMap是线程安全的，因此在访问底层Map时就不需要进行同步，因而避免了在对Memoizer1中的compute方法进行同步时带来的串行性。</p><p>Memoizer2 比Memoizerl有着更好的并发行为﹔多线程可以并发地使用它。但它在作为缓存时仍然存在一些不足—<strong>当两个线程同时调用compute时存在一个漏洞，可能会导致计算得到相同的值。</strong>在使用memoization的情况下，这只会带来低效，因为缓存的作用是避免相同的数据被计算多次。但对于更通用的缓存机制来说，这种情况将更为糟糕。对于只提供单次初始化的对象缓存来说，这个漏洞就会带来安全风险。.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer2</span>&lt;<span class="title">A</span>,<span class="title">v</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>, <span class="title">v</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A, V&gt; cache = <span class="keyword">new</span> concurrentHashMap&lt;A, v&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> computable&lt;A,v&gt; c;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Memoizer2</span> <span class="params">( Computable&lt;A, V&gt; c)</span> </span>&#123; <span class="keyword">this</span>.c - c; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  V <span class="title">compute</span><span class="params">(A arg)</span> <span class="keyword">throws</span> InterruptedBxception</span>&#123;</span><br><span class="line">        V result = cache.get(arg) ;</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="keyword">null</span>)&#123;</span><br><span class="line">        result = c.compute(arg) ;</span><br><span class="line">            cache.put(arg, result) ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Memoizer2的问题在于，<strong>如果某个线程启动了一个开销很大的计算，而其他线程并不知道这个计算正在进行，那么很可能会重复这个计算</strong>。需要让其他线程知道这个计算正在进行中。<br>我们已经知道有一个类能基本实现这个功能:FutureTask。<strong>FutureTask表示一个计算的过程，这个过程可能已经计算完成，也可能正在进行。</strong>如果有结果可用，那么FutureTask.get将立即返回结果，否则它会一直阻塞，直到结果计算出来再将其返回。</p><p>Memoizer3将用于缓存值的Map重新定义为<strong>ConcurrentHashMap&lt;A,Future<V>&gt;</V></strong>，替换原来的ConcurrentHashMap&lt;A，V&gt;。Memoizer3首先检查某个相应的计算是否已经开始(Memoizer2与之相反，它首先判断某个计算是否已经完成)。如果还没有启动，那么就创建一个FutureTask，并注册到Map中，然后启动计算:如果已经启动，那么等待现有计算的结果。结果可能很快会得到，也可能还在运算过程中，但这对于Future.get的调用者来说是透明的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer3</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A,Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;A,Future&lt;V&gt;&gt;() ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A,v&gt; c ;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Memoizer3</span> <span class="params">(Computable&lt;A, v&gt; c)</span> </span>&#123; <span class="keyword">this</span>.c = c; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">compute</span> <span class="params">(<span class="keyword">final</span> A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Future&lt;V&gt; f = cache.get(arg) ;</span><br><span class="line"><span class="keyword">if</span> (f == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Callable&lt;V&gt; eval = <span class="keyword">new</span> callable&lt;V&gt; () &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> V <span class="title">call</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> c.compute(arg) ;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">            FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;V&gt; (eval);</span><br><span class="line">            f = ft ;</span><br><span class="line">            cache.put (arg, ft);</span><br><span class="line">            ft.run () ; <span class="comment">//在这里将调用c.compute</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f.get(); .</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> launderThrowable(e.getCause ());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Memoizer3的实现几乎是完美的:它表现出了非常好的并发性（基本上是源于ConcurrentHashMap高效的并发性)，若结果已经计算出来，那么将立即返回。<strong>如果其他线程正在计算该结果，那么新到的线程将一直等待这个结果被计算出来。</strong>它只有一个缺陷，即仍然存在两个线程计算出相同值的漏洞。 if 代码仍然是“先检查后执行”。</p><p>Memoizer使用了ConcurrentMap中的原子方法 <strong>putIfAbsent</strong>，避免了Memoizer3的漏洞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;A,Future&lt;V&gt;&gt; cache = <span class="keyword">new</span> ConcurrentHashMap&lt;A,Future&lt;V&gt;&gt;() ;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A,v&gt; c ;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Memoizer3</span> <span class="params">(Computable&lt;A, v&gt; c)</span> </span>&#123; <span class="keyword">this</span>.c = c; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">compute</span> <span class="params">(<span class="keyword">final</span> A arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Future&lt;V&gt; f = cache.get(arg) ;</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>)&#123;</span><br><span class="line">                Callable&lt;V&gt; eval = <span class="keyword">new</span> callable&lt;V&gt; () &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> V <span class="title">call</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> c.compute(arg) ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                FutureTask&lt;V&gt; ft = <span class="keyword">new</span> FutureTask&lt;V&gt; (eval);</span><br><span class="line">                <span class="comment">//这里放入如果对应value存在，就返回value,如果不存在,返回null</span></span><br><span class="line">                f = cache.putIfAbsent(arg, ft);</span><br><span class="line">                <span class="keyword">if</span>(f == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    f = ft;</span><br><span class="line">                    ft.run () ; <span class="comment">//在这里将调用c.compute</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> f.get ( ) ;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (cancellationException e) &#123;</span><br><span class="line">            cache.remove (arg, f);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> launderThrowable (e.getcause ()) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当缓存的是Future而不是值时，将导致缓存污染(Cache Pollution）问题:<strong>如果某个计算被取消或者失败，那么在计算这个结果时将指明计算过程被取消或者失败。为了避免这种情况，如果Memoizer发现计算被取消，那么将把Future从缓存中移除。如果检测到RuntimeException,那么也会移除Future，这样将来的计算才可能成功。</strong>Memoizer同样没有解决缓存逾期的问题，但它可以通过使用FutureTask的子类来解决，在子类中为每个结果指定一个逾期时间，并定期扫描缓存中逾期的元素。(同样，它也没有解决缓存清理的问题，即移除旧的计算结果以便为新的计算结果腾出空间，从而使缓存不会消耗过多的内存。)·<br>在完成并发缓存的实现后，就可以为第2章中因式分解servlet添加结果缓存。程序清单5-20中的Factorizer使用Memoizer来缓存之前的计算结果，这种方式不仅高效，而且可扩展性也更高。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro</title>
      <link href="/2020/08/23/%E6%A1%86%E6%9E%B6/shiro/"/>
      <url>/2020/08/23/%E6%A1%86%E6%9E%B6/shiro/</url>
      
        <content type="html"><![CDATA[<h1 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h1><h2 id="一、权限的管理"><a href="#一、权限的管理" class="headerlink" title="一、权限的管理"></a>一、权限的管理</h2><h3 id="1-1-什么是权限管理"><a href="#1-1-什么是权限管理" class="headerlink" title="1.1 什么是权限管理"></a>1.1 什么是权限管理</h3><p>基本上涉及到用户参与的系统都要进行权限管理，权限管理属于系统安全的范畴，权限管理实现<code>对用户访问系统的控制</code>，按照安全规则或者<a href="http://baike.baidu.com/view/160028.htm">安全策略</a>控制用户可以访问而且只能访问自己被授权的资源。</p><p>权限管理包括用户<code>身份认证</code>和<code>授权</code>两部分，简称<code>认证授权</code>。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。</p><h3 id="1-2-什么是身份认证"><a href="#1-2-什么是身份认证" class="headerlink" title="1.2 什么是身份认证"></a>1.2 什么是身份认证</h3><p><code>身份认证</code>，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。对于采用<a href="http://baike.baidu.com/view/5628.htm">指纹</a>等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。</p><h3 id="1-3-什么是授权"><a href="#1-3-什么是授权" class="headerlink" title="1.3 什么是授权"></a>1.3 什么是授权</h3><p><code>授权，即访问控制</code>，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的</p><h2 id="2-什么是shiro"><a href="#2-什么是shiro" class="headerlink" title="2.什么是shiro"></a>2.什么是shiro</h2><blockquote><p><strong>Apache Shiro™</strong> is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.  </p><p>Shiro 是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。</p></blockquote><p><code>Shiro是apache旗下一个开源框架，它将软件系统的安全认证相关的功能抽取出来，实现用户身份认证，权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。</code></p><h2 id="3-shiro的核心架构"><a href="#3-shiro的核心架构" class="headerlink" title="3.shiro的核心架构"></a>3.shiro的核心架构</h2><img src="/2020/08/23/%E6%A1%86%E6%9E%B6/shiro/shiro框架.png" alt="image-20200520220413190" style="zoom:150%;"><h3 id="3-1-Subject"><a href="#3-1-Subject" class="headerlink" title="3.1 Subject"></a>3.1 Subject</h3><p><code>Subject即主体</code>，外部应用与subject进行交互，subject记录了当前操作用户，将用户的概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是一个运行的程序。    Subject在shiro中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过subject进行认证授，而subject是通过SecurityManager安全管理器进行认证授权</p><h3 id="3-2-SecurityManager"><a href="#3-2-SecurityManager" class="headerlink" title="3.2 SecurityManager"></a>3.2 SecurityManager</h3><p><code>SecurityManager即安全管理器</code>，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等。</p><p><code>SecurityManager是一个接口，继承了Authenticator, Authorizer, SessionManager这三个接口。</code></p><h3 id="3-3-Authenticator"><a href="#3-3-Authenticator" class="headerlink" title="3.3 Authenticator"></a>3.3 Authenticator</h3><p><code>Authenticator即认证器</code>，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器。</p><h3 id="3-4-Authorizer"><a href="#3-4-Authorizer" class="headerlink" title="3.4 Authorizer"></a>3.4 Authorizer</h3><p><code>Authorizer即授权器</code>，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限。</p><h3 id="3-5-Realm"><a href="#3-5-Realm" class="headerlink" title="3.5 Realm"></a>3.5 Realm</h3><p><code>Realm即领域</code>，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息。</p><ul><li>​    注意：不要把realm理解成只是从数据源取数据，在realm中还有认证授权校验的相关的代码。</li></ul><h3 id="3-6-SessionManager"><a href="#3-6-SessionManager" class="headerlink" title="3.6 SessionManager"></a>3.6 SessionManager</h3><p><code>sessionManager即会话管理</code>，shiro框架定义了一套会话管理，它不依赖web容器的session，所以shiro可以使用在非web应用上，也可以将分布式应用的会话集中在一点管理，此特性可使它实现单点登录。</p><h3 id="3-7-SessionDAO"><a href="#3-7-SessionDAO" class="headerlink" title="3.7 SessionDAO"></a>3.7 SessionDAO</h3><p><code>SessionDAO即会话dao</code>，是对session会话操作的一套接口，比如要将session存储到数据库，可以通过jdbc将会话存储到数据库。</p><h3 id="3-8-CacheManager"><a href="#3-8-CacheManager" class="headerlink" title="3.8 CacheManager"></a>3.8 CacheManager</h3><p><code>CacheManager即缓存管理</code>，将用户权限数据存储在缓存，这样可以提高性能。</p><h3 id="3-9-Cryptography"><a href="#3-9-Cryptography" class="headerlink" title="3.9 Cryptography"></a>3.9 Cryptography</h3><p>​    <code>Cryptography即密码管理</code>，shiro提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能。</p><h2 id="4-shiro中的认证"><a href="#4-shiro中的认证" class="headerlink" title="4. shiro中的认证"></a>4. shiro中的认证</h2><h3 id="4-1-认证"><a href="#4-1-认证" class="headerlink" title="4.1 认证"></a>4.1 认证</h3><p>身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。</p><h3 id="4-2-shiro中认证的关键对象"><a href="#4-2-shiro中认证的关键对象" class="headerlink" title="4.2 shiro中认证的关键对象"></a>4.2 shiro中认证的关键对象</h3><ul><li><strong>Subject：主体</strong></li></ul><p>访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体； </p><ul><li><strong>Principal：身份信息</strong></li></ul><p>是主体（subject）进行身份认证的标识，标识必须具有<code>唯一性</code>，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（Primary Principal）。</p><ul><li><strong>credential：凭证信息</strong></li></ul><p>是只有主体自己知道的安全信息，如密码、证书等。</p><h3 id="4-3-认证流程"><a href="#4-3-认证流程" class="headerlink" title="4.3 认证流程"></a>4.3 认证流程</h3><p>![image-20200521204452288](F:/Chrome/shiro实战教程资料/Shiro 实战教程.assets/image-20200521204452288.png)</p><h3 id="4-4-认证的开发"><a href="#4-4-认证的开发" class="headerlink" title="4.4 认证的开发"></a>4.4 认证的开发</h3><h5 id="1-创建项目并引入依赖"><a href="#1-创建项目并引入依赖" class="headerlink" title="1. 创建项目并引入依赖"></a>1. 创建项目并引入依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-引入shiro配置文件并加入如下配置"><a href="#2-引入shiro配置文件并加入如下配置" class="headerlink" title="2. 引入shiro配置文件并加入如下配置"></a>2. 引入shiro配置文件并加入如下配置</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">xiaochen</span>=<span class="number">123</span></span><br><span class="line"><span class="attr">zhangsan</span>=<span class="number">456</span></span><br></pre></td></tr></table></figure><p>![image-20200521205219719](F:/Chrome/shiro实战教程资料/Shiro 实战教程.assets/image-20200521205219719.png)</p><h5 id="3-开发认证代码"><a href="#3-开发认证代码" class="headerlink" title="3.开发认证代码"></a>3.开发认证代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAuthenticator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建securityManager</span></span><br><span class="line">        DefaultSecurityManager defaultSecurityManager = <span class="keyword">new</span> DefaultSecurityManager();</span><br><span class="line">        defaultSecurityManager.setRealm(<span class="keyword">new</span> IniRealm(<span class="string">&quot;classpath:shiro.ini&quot;</span>));</span><br><span class="line">        <span class="comment">//将安装工具类中设置默认安全管理器</span></span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line">        <span class="comment">//获取主体对象</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//创建token令牌</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;xiaochen1&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);<span class="comment">//用户登录</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名错误!!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;密码错误!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>DisabledAccountException（帐号被禁用）</p></li><li><p>LockedAccountException（帐号被锁定）</p></li><li><p>ExcessiveAttemptsException（登录失败次数过多）</p></li><li><p>ExpiredCredentialsException（凭证过期）等</p></li></ul><hr><h3 id="4-5-自定义Realm"><a href="#4-5-自定义Realm" class="headerlink" title="4.5 自定义Realm"></a>4.5 自定义Realm</h3><p>上边的程序使用的是Shiro自带的IniRealm，IniRealm从ini配置文件中读取用户的信息，大部分情况下需要从系统的数据库中读取用户信息，所以需要自定义realm。</p><h5 id="1-shiro提供的Realm"><a href="#1-shiro提供的Realm" class="headerlink" title="1.shiro提供的Realm"></a>1.shiro提供的Realm</h5><p>![image-20200521212728541](F:/Chrome/shiro实战教程资料/Shiro 实战教程.assets/image-20200521212728541.png)</p><h5 id="2-根据认证源码认证使用的是SimpleAccountRealm"><a href="#2-根据认证源码认证使用的是SimpleAccountRealm" class="headerlink" title="2.根据认证源码认证使用的是SimpleAccountRealm"></a>2.根据认证源码认证使用的是SimpleAccountRealm</h5><p>![image-20200521213451998](F:/Chrome/shiro实战教程资料/Shiro 实战教程.assets/image-20200521213451998.png)</p><p><code>SimpleAccountRealm的部分源码中有两个方法一个是 认证 一个是 授权</code>,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleAccountRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"><span class="comment">//.......省略</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        UsernamePasswordToken upToken = (UsernamePasswordToken) token;</span><br><span class="line">        SimpleAccount account = getUser(upToken.getUsername());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (account != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (account.isLocked()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> LockedAccountException(<span class="string">&quot;Account [&quot;</span> + account + <span class="string">&quot;] is locked.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (account.isCredentialsExpired()) &#123;</span><br><span class="line">                String msg = <span class="string">&quot;The credentials for account [&quot;</span> + account + <span class="string">&quot;] are expired&quot;</span>;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ExpiredCredentialsException(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        String username = getUsername(principals);</span><br><span class="line">        USERS_LOCK.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.users.get(username);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            USERS_LOCK.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-自定义realm"><a href="#3-自定义realm" class="headerlink" title="3.自定义realm"></a>3.自定义realm</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义realm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//认证方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//授权方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String principal = (String) token.getPrincipal();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;xiaochen&quot;</span>.equals(principal))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(principal,<span class="string">&quot;123&quot;</span>,<span class="keyword">this</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-使用自定义Realm认证"><a href="#4-使用自定义Realm认证" class="headerlink" title="4.使用自定义Realm认证"></a>4.使用自定义Realm认证</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAuthenticatorCusttomerRealm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建securityManager</span></span><br><span class="line">        DefaultSecurityManager defaultSecurityManager = <span class="keyword">new</span> DefaultSecurityManager();</span><br><span class="line">        <span class="comment">//IniRealm realm = new IniRealm(&quot;classpath:shiro.ini&quot;);</span></span><br><span class="line">        <span class="comment">//设置为自定义realm获取认证数据</span></span><br><span class="line">        defaultSecurityManager.setRealm(<span class="keyword">new</span> CustomerRealm());</span><br><span class="line">        <span class="comment">//将安装工具类中设置默认安全管理器</span></span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line">        <span class="comment">//获取主体对象</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//创建token令牌</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;xiaochen&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);<span class="comment">//用户登录</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名错误!!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;密码错误!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-使用MD5和Salt"><a href="#4-6-使用MD5和Salt" class="headerlink" title="4.6 使用MD5和Salt"></a>4.6 使用MD5和Salt</h3><blockquote><p>实际应用是将盐和散列后的值存在数据库中，自动realm从数据库取出盐和加密后的值由shiro完成密码校验。</p></blockquote><h5 id="1-自定义md5-salt的realm"><a href="#1-自定义md5-salt的realm" class="headerlink" title="1.自定义md5+salt的realm"></a>1.自定义md5+salt的realm</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义md5+salt realm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//认证方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//授权方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String principal = (String) token.getPrincipal();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;xiaochen&quot;</span>.equals(principal))&#123;</span><br><span class="line">            String password = <span class="string">&quot;3c88b338102c1a343bcb88cd3878758e&quot;</span>;</span><br><span class="line">            String salt = <span class="string">&quot;Q4F%&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(principal,password, </span><br><span class="line">                                                ByteSource.Util.bytes(salt),<span class="keyword">this</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="2-使用md5-salt-认证"><a href="#2-使用md5-salt-认证" class="headerlink" title="2.使用md5 + salt 认证"></a>2.使用md5 + salt 认证</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAuthenticatorCusttomerRealm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建securityManager</span></span><br><span class="line">        DefaultSecurityManager defaultSecurityManager = <span class="keyword">new</span> DefaultSecurityManager();</span><br><span class="line">        <span class="comment">//IniRealm realm = new IniRealm(&quot;classpath:shiro.ini&quot;);</span></span><br><span class="line">        <span class="comment">//设置为自定义realm获取认证数据</span></span><br><span class="line">        CustomerRealm customerRealm = <span class="keyword">new</span> CustomerRealm();</span><br><span class="line">        <span class="comment">//设置md5加密</span></span><br><span class="line">        HashedCredentialsMatcher credentialsMatcher = <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        credentialsMatcher.setHashIterations(<span class="number">1024</span>);<span class="comment">//设置散列次数</span></span><br><span class="line">        customerRealm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">        defaultSecurityManager.setRealm(customerRealm);</span><br><span class="line">        <span class="comment">//将安装工具类中设置默认安全管理器</span></span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line">        <span class="comment">//获取主体对象</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//创建token令牌</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;xiaochen&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);<span class="comment">//用户登录</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名错误!!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;密码错误!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/2020/08/20/redis/redis/"/>
      <url>/2020/08/20/redis/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="一、redis数据结构"><a href="#一、redis数据结构" class="headerlink" title="一、redis数据结构"></a>一、redis数据结构</h2><p>/获取帮助, 可以使用Tab键来切换 help 命令名称 help @组名</p><img src="/2020/08/20/redis/redis/redis数据结构.png" alt="image-20200820172151178" style="zoom:67%;"><h3 id="字符串类型string"><a href="#字符串类型string" class="headerlink" title="字符串类型string"></a>字符串类型string</h3><p>是redis中最基本的数据类型，一个key对应一个value。</p><p>String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。</p><ul><li>string在redis内部存储默认就是一个<strong>字符串</strong>，当遇到增减类操作incr，decr时会<strong>转成数值型</strong>进行计算。</li><li>redis所有的操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li><li>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li></ul><p><strong>tips：</strong></p><ul><li>redis用于控制数据库表主键id，为数据库表主键<strong>提供生成策略</strong>，保障数据库表的主键<strong>唯一性</strong></li><li>此方案适用于所有数据库，且支持数据库集群</li></ul><p>字符串结构使用非常广泛，一个常见的用途就是缓存用户信息。我们将用户信息结构体使用 JSON 序列化成字符串，然后将序列化后的字符串塞进 Redis 来缓存。同样，取用户信息会经过一次反序列化的过程</p><p>Redis 的字符串是<strong>动态字符串</strong>，是可以修改的字符串，内部结构实现上类似于 Java 的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">常用操作</span><br><span class="line">set key value //存入</span><br><span class="line">mset key value[key value]//批量存入</span><br><span class="line">setnx key value  //存入一个不存在的字符键值对</span><br><span class="line">get key//获取</span><br><span class="line">mget key [key...]//批量获取</span><br><span class="line">del key [key]//删除</span><br><span class="line">expore key seconds//设置一个键的过期时间</span><br><span class="line">append key value //追加信息到原始信息后部</span><br><span class="line">设置生命周期</span><br><span class="line">setex key seconds value</span><br><span class="line">psetex key milliseconds value //时效性 ，如验证码</span><br><span class="line"></span><br><span class="line">原子加减</span><br><span class="line">incr key//key中存储数字加1</span><br><span class="line">decr key//key 存储数字-1</span><br><span class="line">incrby key increment//key所存储的值+increment</span><br><span class="line">decrby key decrement//key 存储- increment</span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">单值操作</span><br><span class="line">set key value</span><br><span class="line">get key </span><br><span class="line"></span><br><span class="line">* 对象缓存</span><br><span class="line">set user:1 value(json数据)</span><br><span class="line">mset user:1:name zhuge user:1:balance 1888</span><br><span class="line">mget user:1:name user:1:balance</span><br><span class="line">//这2个的区别</span><br><span class="line"> 如果只修改一个字段，就值修改一个就可以 ，而用json就需要json转对象-修改-对象转json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 分布式锁</span><br><span class="line">setnx product:10001 true  //取锁成功</span><br><span class="line">setnx product:10001 false//取锁失败</span><br><span class="line">//和set不同 set相同的key会覆盖，而这里相同的key会失败</span><br><span class="line">...执行业务操作</span><br><span class="line">del product:10001 //执行完业务是否锁</span><br><span class="line"></span><br><span class="line">set product:10001 true ex 10 nx //防止程序以为终止导致死锁</span><br><span class="line"></span><br><span class="line">* 计数器</span><br><span class="line">incr article:readcount:&#123;文章id&#125; //用户浏览文章，浏览一次+1</span><br><span class="line">get article:readcount:&#123;文章id&#125;</span><br><span class="line"></span><br><span class="line">* Web 集群session 共享</span><br><span class="line">spring session+redis实现session共享</span><br><span class="line"></span><br><span class="line">* 分布式系统系统全局序列号</span><br><span class="line">incrby orderld 1000  //批量生成序列号提示性能</span><br></pre></td></tr></table></figure><p><strong>命名规范</strong></p><img src="/2020/08/20/redis/redis/命名规范.png" alt="image-20200821140718597" style="zoom:67%;"><h3 id="哈希Hash"><a href="#哈希Hash" class="headerlink" title="哈希Hash"></a>哈希Hash</h3><p>hash是一个Map ,值本身又是一种键值对结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如 value=&#123;&#123;field1,value1&#125;,......fieldN,valueN&#125;&#125;</span><br></pre></td></tr></table></figure><p>hash类型：底层用hash表实现数据存储</p><p>hash结构优化：</p><ul><li>field数量较少，存储结构优化为类数组结构</li><li>field数量较多，存储结构使用hashmap结构</li></ul><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a><strong>操作</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hset key field value//存储一个hash表的key键值对</span><br><span class="line">hsetnx key field value  //存储一个不存在的哈希表key的键值</span><br><span class="line">hmset key field value [field value ..//在一个哈希表key中存储多个键值对</span><br><span class="line"></span><br><span class="line">hget key field//获取哈希表key对应的field键值</span><br><span class="line">hmget key field [field ..]//批量获取哈希表key中多个field键值</span><br><span class="line"></span><br><span class="line">hdel key field [field ..//删除哈希表key中的field键值</span><br><span class="line">hlen key//返回哈希表key中field的数量</span><br><span class="line">hgetall key//返回哈希表key中所有的键值</span><br><span class="line">hincrby key field increment //为哈希表key中field键的值加上增量increment</span><br><span class="line"></span><br><span class="line">//获取哈希表中所有的字段名或字段值 </span><br><span class="line">hkeys key</span><br><span class="line">hvals key //val可以重复</span><br></pre></td></tr></table></figure><img src="/2020/08/20/redis/redis/hash.png" alt="image-20200820225031328" style="zoom: 80%;"><h4 id="hash-类型数据操作的注意事项"><a href="#hash-类型数据操作的注意事项" class="headerlink" title="hash 类型数据操作的注意事项"></a>hash <strong>类型数据操作的注意事项</strong></h4><ul><li>hash类型下的value<strong>只能存储字符串</strong>，不允许存储其他数据类型，<strong>不存在嵌套现象</strong>。如果数据未获取到， 对应的值为（nil）</li><li>每个 hash 可以存储 2^32 - 1 个键值</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，<strong>切记不可滥用</strong>，更<strong>不可以将hash作为对象列表使用</strong></li><li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体<strong>数据效率就很会低</strong>，有可能成为数据访问瓶颈</li></ul><h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a><strong>操作</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hset key field value//存储一个hash表的key键值对</span><br><span class="line">hsetnx key field value  //存储一个不存在的哈希表key的键值</span><br><span class="line">hmset key field value [field value ..//在一个哈希表key中存储多个键值对</span><br><span class="line"></span><br><span class="line">hget key field//获取哈希表key对应的field键值</span><br><span class="line">hmget key field [field ..]//批量获取哈希表key中多个field键值</span><br><span class="line"></span><br><span class="line">hdel key field [field ..//删除哈希表key中的field键值</span><br><span class="line">hlen key//返回哈希表key中field的数量</span><br><span class="line">hgetall key//返回哈希表key中所有的键值</span><br><span class="line">hincrby key field increment //为哈希表key中field键的值加上增量increment</span><br><span class="line"></span><br><span class="line">//获取哈希表中所有的字段名或字段值 </span><br><span class="line">hkeys key</span><br><span class="line">hvals key //val可以重复</span><br></pre></td></tr></table></figure><p>Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。</p><p>渐进式 rehash 会在 rehash 的同时，<strong>保留新旧两个 hash 结构</strong>，查询时会同时查询两个hash 结构，然后在后续的定时任务中以及 hash 的子指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。</p><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a><strong>应用</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">* 对象缓存</span><br><span class="line">    hmset user &#123;userld&#125;:name zhuge &#123;userld&#125;:balance 1888</span><br><span class="line">    hmset user 1:name zhuge 1:balance 1 888</span><br><span class="line">    hmset user 1:name 1:balance</span><br><span class="line">//当用户数据量过大的情况，不可能全部存入，只会存热数据</span><br><span class="line">//但是热数据也过大的情况下，可以使用分段 key user0001 user0002</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 电商购物车</span><br><span class="line">    1)以用户id为key</span><br><span class="line">    2)商品id为field</span><br><span class="line">    3)商品数量为value</span><br><span class="line">    购物车操作</span><br><span class="line">        1)添加商品&gt;hset cart:1001 10088 1</span><br><span class="line">        2)增加数量&gt;hincrby cart:1001 10088 1</span><br><span class="line">        3)商品总数&gt;hlen cart:1001</span><br><span class="line">        4)删除商品&gt;hdel cart:1001 10088</span><br><span class="line">        5)获取购物车所有商品&gt;hgetall cart:1001 </span><br><span class="line"></span><br><span class="line">    当前设计是否加速了购物车的呈现？</span><br><span class="line">    当前仅仅是将数据存储到了redis中，并没有起到加速的作用，商品信息还需要二次查询数据库</span><br><span class="line">    * 每条购物车中的商品记录保存成两条field</span><br><span class="line">    * field1专用于保存购买数量</span><br><span class="line">        命名格式:商品id:nums</span><br><span class="line">        保存数据:数值</span><br><span class="line">    * field2专用于保存购物车中显示的信息，包含文字描述,图片地址,所属商家信息等</span><br><span class="line">        命名格式:商品id:info</span><br><span class="line">        保存数据: json</span><br><span class="line"></span><br><span class="line">    hsetnx key field value</span><br><span class="line"></span><br><span class="line">双11活动日，销售手机充值卡的商家对移动、联通、电信的30元、50元、 100元商品推出抢购活动,每种商</span><br><span class="line">品抢购.上限1000张</span><br><span class="line">解决方案</span><br><span class="line">    ●以商家id作为key</span><br><span class="line">    ●将参与抢购的商品id作为field</span><br><span class="line">    ●将参与抢购的商品数量作为对应的value</span><br><span class="line">    ●抢购时使用降值的方式控制产品数量</span><br><span class="line">    ●实际业务中还有超卖等实际问题,这里不做讨论</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优点</p><ul><li>同类数据归类整合储存，<strong>方便数据管理</strong></li><li>相比string操作消耗内存5cpu更小</li><li>相比string储存更节省空间</li></ul><p>缺点</p><ul><li>过期功能 不能使用在field上，只能用在key上</li><li>Redis集群架构 下不适合大规模使用 数据分布存储，可能导致数据分布不平衡</li></ul><h3 id="链表List"><a href="#链表List" class="headerlink" title="链表List"></a>链表List</h3><p>就是链表（redis 使用<strong>双端链表</strong>实现的 List），是<strong>有序的，value可以重复，</strong>可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。</p><p>相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为O(n)，这点让人非常意外。</p><p><img src="/2020/08/20/redis/redis/list.png" alt="image-20200820232127776"></p><p><strong>操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lpush key value [value.]//将个或多 个值value插入到key列表的表头(最左边)</span><br><span class="line">rpush key value [value ..//将一个或多个值value插入到key列表的表尾(最右边)</span><br><span class="line">lpop key//移除并返回key列表的头元素</span><br><span class="line">rpop key//移除并返回key列表的尾元素</span><br><span class="line">lrange key start stop//返回列表key中指定区间内的元素，区间以偏移量start和stop指定</span><br><span class="line">0,-1就是全部</span><br><span class="line">blpop key [key .... timeout//从key列表表头弹出一个元素，若列表中没有元素，阻塞等待timeout秒</span><br><span class="line">                    如果timeout=0,一直阻塞等待</span><br><span class="line">brpop key [key ..] timeout//从key列表表尾弹出一个元素，若列表中没有元素，阻塞等待timeout秒</span><br><span class="line">如果timeout=0.一直阻寒等待</span><br><span class="line">lrem key count value //移除</span><br></pre></td></tr></table></figure><p><strong>慢操作</strong> </p><p>lindex 相当于 Java 链表的 <strong>get(int index)</strong>方法，它需要对链表进行遍历，性能随着参数index 增大而变差。 ltrim 和字面上的含义不太一样，个人觉得它叫 lretain(保留) 更合适一些，因为 ltrim 跟的两个参数 <strong>start_index</strong> 和 <strong>end_index</strong> 定义了一个区间，在这个区间内的值，ltrim 要保留，区间之外统统砍掉。我们可以通过 ltrim 来实现一个定长的链表，这一点非常有用。index 可以为负数，index=-1 表示倒数第一个元素，同样 index=-2 表示倒数第二个元素。</p><p><strong>快速列表</strong></p><p>Redis 底层存储的还不是一个简单的 linkedlist，而是称之为快速链表 <strong>quicklist</strong> 的一个结构。</p><p>首先在列表<strong>元素较少</strong>的情况下会使用<strong>一块连续的内存存储</strong>，这个结构是 <strong>ziplist</strong>，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当<strong>数据量比较多</strong>的时候才会改成 <strong>quicklist</strong>。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是 <strong>int</strong> 类型的数据，结构上还需要两个额外的指针 prev 和 next 。所以 Redis 将链表和 <strong>ziplist</strong> 结合起来组成了 <strong>quicklist</strong>。也就是将多个ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><p><strong>使用列表的技巧</strong></p><ul><li>lpush+lpop=Stack(栈)</li><li>lpush+rpop=Queue（队列）</li><li>lpush+ltrim=Capped Collection（有限集合）</li><li>lpush+brpop=Message Queue（消息队列）</li></ul><p>实战场景：</p><p>1.timeline：例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">微博消息和微信公号消息，最新消息的展示</span><br><span class="line">    诸葛老师关注了MacTalk,备胎说车等大V</span><br><span class="line">    1) MacTalk发微博， 消息ID为10018</span><br><span class="line">    LPUSH msg:&#123;诸葛老师-1D&#125; 10018</span><br><span class="line">    2)备胎说车发微博，消息ID为10086</span><br><span class="line">    LPUSH msg:&#123;诸葛老师-ID&#125; 10086</span><br><span class="line">    3)查看最新微博消息</span><br><span class="line">    LRANGE msg:诸葛老师-ID&#125; 0 4 就是一页展示的消息</span><br><span class="line">    但是当人数过多的情况下，这种做法会阻塞</span><br><span class="line">    </span><br><span class="line">微信朋友圈点赞，要求按照点赞顺序显示点赞好友信息，如果取消点赞，移除对应好友信息</span><br><span class="line"></span><br><span class="line">twitter.新浪微博、腾讯微博中个人用户的关注列表需要按照用户的关注顺序进行展示，粉丝列表需要将最新关注的粉丝列在前面</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。</li><li>list具有索引的概念，但是操作数据时通常以<strong>队列</strong>的形式进行入队出队(rpush, rpop)操作，或以<strong>栈</strong>的形式进行入栈出栈(lpush, lpop)操作</li><li>获取全部数据操作结束索引设置为-1 (倒数第一个元素)</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</li></ul><h3 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h3><p>操作</p><p>集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中 1. <strong>不允许有重复的元素</strong>，2.集合中的元素是<strong>无序</strong>的，不能通过索引下标获取元素，3.支持集合间的操作，可以取多个集合取交集、并集、差集。</p><p>新的存储需求:存储大量的数据，在查询方面提供更高的效率<br>需要的存储结构:能够保存大量的数据,效的内部存储机制，便于查询<br>set类型: 与hash存储结构完全相同,仅存储键，不存储值(nil) ，并且值是不允许重复的</p><img src="/2020/08/20/redis/redis/Set.png" alt="image-20200820234156699" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* Set常用操作</span><br><span class="line">sadd key member [member ..]//往集合key中存入元素，元素存在则忽略，</span><br><span class="line">若key不存在则新建</span><br><span class="line">srem key member [member ...//从集合key中删除元素</span><br><span class="line">smembers key//获取集合key中所有元素</span><br><span class="line">scard key//获取集合key的元素个数</span><br><span class="line">sismember key member//判断member元素是否存在于集合key中</span><br><span class="line">srandmember key [count]//从集合key中选出count个元素，元素不从key中删除</span><br><span class="line">spop key [count]//从集合key中选出count个元素，元素从key中删除</span><br><span class="line"></span><br><span class="line">* Set运算操作</span><br><span class="line">sinter key [key ..].//交集运算</span><br><span class="line">sinterstore destination key [key .]//将交集结果存入新集合destination中</span><br><span class="line">sunion key [key .]//并集运算</span><br><span class="line">sunionstore destination key [key ..].//将并集结果存入新集合destination中</span><br><span class="line">sdiff key [key ..//差集运算 以第一个集合为基本</span><br><span class="line">sdiffstore destination key [key ...//将差集结果存入新集合destination中</span><br></pre></td></tr></table></figure><p>实战场景;</p><p>1.标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</p><p>2.点赞，或点踩，收藏等，可以放到set中实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">* 微信抽奖小程序</span><br><span class="line">    1)点击参与抽奖加入集合</span><br><span class="line">        sadd key &#123;userID&#125;</span><br><span class="line">    2)查看参与抽奖所有用户</span><br><span class="line">        smembers key</span><br><span class="line">    3)抽取count名中奖者</span><br><span class="line">        srandmember key [count] / SPOP key [count]</span><br><span class="line">        多次抽奖可以使用 spop</span><br><span class="line"></span><br><span class="line">* 微信微博点赞，收藏，标签</span><br><span class="line">    1)点赞</span><br><span class="line">        sadd like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class="line">    2)取消点赞</span><br><span class="line">        srem like:&#123;消息|ID&#125; &#123;用户ID&#125;</span><br><span class="line">    3)检查用户是否点过赞</span><br><span class="line">        sismember like:&#123;消息ID&#125; &#123;用户ID&#125;</span><br><span class="line">    4)获取点赞的用户列表</span><br><span class="line">        smembers like:&#123;消息|D&#125;   //只能实现发消息的人能看到</span><br><span class="line">    5)获取点赞用户数</span><br><span class="line">        scard like:&#123;消息ID&#125; </span><br><span class="line"></span><br><span class="line">* 集合操作实现微博微信关注模型)</span><br><span class="line">    1)诸葛老师关注的人:</span><br><span class="line">        zhugeSet-&gt; &#123;yangguo, sima, luban&#125;</span><br><span class="line">    2)杨过老师关注的人:</span><br><span class="line">        yangguoSet--&gt; &#123;zhuge, sima, luban, guojia&#125;</span><br><span class="line">    3)司马老师关注的人:</span><br><span class="line">        simaSet-&gt; &#123;zhuge, yangguo, guojia, luban, xunyu)</span><br><span class="line">    4)我和杨过老师共同关注:</span><br><span class="line">        sinter zhugeSet yangguoSet--&gt; &#123;sima, luban&#125;</span><br><span class="line">    5)我关注的人也关注他(杨过老师):</span><br><span class="line">        sismember simaSet yangguo</span><br><span class="line">        sismember lubanSet yangguo</span><br><span class="line">    6)我可能认识的人: </span><br><span class="line">        sdiff yangguoSet zhugeSet-&gt; (zhuge, guojia&#125;</span><br><span class="line">        </span><br><span class="line">业务场景</span><br><span class="line">    每位用户首次使用今日头条时会设置3项爱好的内容，但是后期为了增加用户的活跃度、兴趣点，必须让用户</span><br><span class="line">    对其他信息类别逐渐产生兴趣，增加客户留存度,如何实现?</span><br><span class="line">业务分析</span><br><span class="line">    ●系统分析出各个分类的最新或最热点信息条目并组织成set集合</span><br><span class="line">    ●随机挑选其中部分信息</span><br><span class="line">    ●配合用户关注信息分类中的热点信息组织成展示的全信息集合</span><br><span class="line">解决方案</span><br><span class="line">●随机获取集合中指定数量的数据</span><br><span class="line">srandmember key [count]</span><br><span class="line">●随机获取集合中的某个数据并将该数据移</span><br><span class="line">spop key</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="有序集合zset"><a href="#有序集合zset" class="headerlink" title="有序集合zset"></a>有序集合zset</h3><p>有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，<strong>有序集合中的元素是可以排序的，</strong>它给每个元素设置一个分数，作为排序的依据。</p><p>Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫着「<strong>跳跃列表</strong>」的数据结构。</p><p>（有序集合中的元素不可以重复，但是score 分数 可以重复，就和一个班里的同学学号不能重复，但考试成绩可以相同）。</p><img src="/2020/08/20/redis/redis/Zset.png" alt="image-20200821001009556" style="zoom:67%;"><p><strong>操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* ZSet常用操作</span><br><span class="line">zadd key score member [[score member]..] //往有序集合key中加入带分值元素</span><br><span class="line">zrem key member [member ..//从有序集合key中删除元素</span><br><span class="line">zscore key member//返回有序集合key中元素member的分值</span><br><span class="line">zincrby key increment member//为有序集合key中元素member的分值加上increment</span><br><span class="line">zcard key//返回有序集合key中元素个数</span><br><span class="line">zrange key start stop [withscores]//正序获取有序集合key从start下标到stop下标的元素</span><br><span class="line">withscores将分值数也带上</span><br><span class="line">zrevrange key start stop [withscores]//倒序获取有序集合key从start下标到stop下标的元素</span><br><span class="line">zrangk key member//获得排名</span><br><span class="line"></span><br><span class="line">* set集合操作</span><br><span class="line">zunionstore destkey numkeys key [key ..] //并集计算</span><br><span class="line">zinters TORE destkey numkeys key [key .. //交集计算</span><br><span class="line"></span><br><span class="line">* 按条件获取数据</span><br><span class="line">zrangebyscore key min max [WI THSCORES] [LIMIT] </span><br><span class="line">zrevrangebyscore key max min [WITHSCORES]</span><br><span class="line"></span><br><span class="line">* 条件删除数据</span><br><span class="line">zremrangebyrank key start stop</span><br><span class="line">zremrangebyscore key min max</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>跳跃列表</strong> </p><p>zset 内部的排序功能是通过「<strong>跳跃列表</strong>」数据结构来实现的，它的结构非常特殊，也比较复杂。</p><p>因为 zset 要支持<strong>随机的插入和删除</strong>，所以它不好使用数组来表示。</p><p>我们需要这个链表按照 score 值进行排序。这意味着当有新元素需要插入时，要定位到特定位置的插入点，这样才可以继续保证链表是有序的。通常我们会通过<strong>二分查找来找到插入点</strong>，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到。</p><p>跳跃列表就是<strong>层级制</strong>，最下面一层所有的元素都会串起来。然后每隔几个元素挑选出一个代表来，再将这几个代表使用另外一级指针串起来。然后在这些代表里再挑出二级代表，再串起来。最终就形成了金字塔结构。</p><p><img src="/2020/08/20/redis/redis/%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8.png" alt="image-20200911170050751"></p><p>「跳跃列表」之所以「跳跃」，是因为内部的元素可能「身兼数职」，比如上图中间的这个元素，<strong>同时处于 L0、L1 和 L2 层，可以快速在不同层次之间进行「跳跃」</strong>。</p><p>定位插入点时，<strong>先在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置</strong>，将新元素插进去。你也许会问，那新插入的元素如何才有机会「身兼数职」呢？</p><p>跳跃列表采取一个随机策略来决定新元素可以兼职到第几层。</p><p>首先 L0 层肯定是 100% 了，L1 层只有 50% 的概率，L2 层只有 25% 的概率，L3 层只有 12.5% 的概率，一直随机到最顶层 L3 层。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，能够深入的层次就越深，能进入到顶层的概率就会越大。</p><p>实战场景：</p><p>1.排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Zset集合操作实现排行榜</span><br><span class="line">    1)点击新闻</span><br><span class="line">        zincrby hotNews:20190819 1 //守护香港</span><br><span class="line">    2)展示当日排行前十</span><br><span class="line">    zrevrange hotNews:20190819 0 9 withscores</span><br><span class="line">    3)七日搜索榜单计算</span><br><span class="line">        zunionstore hotNews:20190813-20190819 7</span><br><span class="line">        hotNews:20190813 hotNews:20190814... hotNews:20190819</span><br><span class="line">    4)展示七日排行前十</span><br><span class="line">        zrevrange hotNews:20190813-20190819 0 9 withscores</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">业务场景.</span><br><span class="line">    基础服务+增值服务类网站会设定各位会员的试用，让用户充分体验会员优势。例如观影试用VIP、游戏VIP体验、云盘下载体验VIP、数据查看体验VIP。当VIP体验到期后,如果有效管理此类信息。即便对于正式VIP用户也存在对应的管理方式。网站会定期开启投票、讨论,限时进行，逾期作废。如何有效管理此类过期信息。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意事项</p><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，<strong>可能会丢失精度</strong>，使用时候要<strong>慎重</strong></li><li>sorted_set 底层存储还是<strong>基于set</strong>结构的，因此数据<strong>不能重复</strong>，如果重复添加相同的数据，score值将被反复覆盖，<strong>保留最后一次</strong>修改的结果</li></ul><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">业务场景</span><br><span class="line">    人工智能领域的语义识别与自动对话将是未来服务业机器人应答呼叫体系中的重要技术，百度自研用户评价</span><br><span class="line">    语义识别服务,免费开放给企业试用，同时训练百度自己的模型。现对试用用户的使用行为进行限速，限制</span><br><span class="line">    每个用户每分钟最多发起10次调用</span><br><span class="line">解决方案</span><br><span class="line">    ●设计计数器，记录调用次数,用于控制业务执行次数。以用户id作为key, 使用次数作为value</span><br><span class="line">    ●在调用前获取次数，判断是否超过限定次数</span><br><span class="line">        不超过次数的情况下，每次调用计数+ 1</span><br><span class="line">        业务调用失败，计数-1 .</span><br><span class="line">    ●为计数器设置生命周期为指定周期,例如1秒/分钟，自动清空周期内使用次数</span><br><span class="line">解决方案改良</span><br><span class="line">    ●取消最大值的判定,利用incr操作超过最大值抛出异常的形式替代每次判断是否大于最大值</span><br><span class="line">    ●判断是否为nil,</span><br><span class="line">        如果是，设置为Max次数</span><br><span class="line">        如果不是，计数+1 .</span><br><span class="line">        业务调用失败，计数-1</span><br><span class="line">    ●遇到异常即+操作超过上限，视为使用达到上限</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="容器型数据的通用规则"><a href="#容器型数据的通用规则" class="headerlink" title="容器型数据的通用规则"></a>容器型数据的通用规则</h3><p>list/set/hash/zset 这四种数据结构是容器型数据结构，它们共享下面两条通用规则：</p><p><strong>1、create if not exists</strong> </p><p>如果容器不存在，那就创建一个，再进行操作。比如 rpush 操作刚开始是没有列表的，Redis 就会自动创建一个，然后再 rpush 进去新元素。</p><p><strong>2、drop if no elements</strong> </p><p>如果容器里元素没有了，那么立即删除元素，释放内存。这意味着 lpop 操作到最后一个元素，列表就消失了。</p><p><strong>过期时间</strong></p><p>Redis 所有的数据结构都可以设置过期时间，时间到了，Redis 会自动删除相应的对象。需要注意的是过期是以对象为单位，比如一个 hash 结构的过期是整个 hash 对象的过期，而不是其中的某个子 key。</p><p>还有一个需要特别注意的地方是如果一个字符串已经设置了过期时间，然后你调用了set 方法修改了它，它的过期时间会消失。</p><h2 id="二、通用指令"><a href="#二、通用指令" class="headerlink" title="二、通用指令"></a>二、通用指令</h2><h3 id="key通用命令"><a href="#key通用命令" class="headerlink" title="key通用命令"></a>key通用命令</h3><h4 id="1、Key的特征"><a href="#1、Key的特征" class="headerlink" title="1、Key的特征"></a>1、Key的特征</h4><ul><li>key是一个<strong>字符串</strong>，通过key获取redis中保存的数据</li></ul><h4 id="2、Key的操作"><a href="#2、Key的操作" class="headerlink" title="2、Key的操作"></a>2、Key的操作</h4><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查看key是否存在</span><br><span class="line">exists key</span><br><span class="line"></span><br><span class="line">//删除key</span><br><span class="line">del key</span><br><span class="line"></span><br><span class="line">//查看key的类型</span><br><span class="line">type keyCopy</span><br></pre></td></tr></table></figure><h5 id="拓展操作（时效性操作）"><a href="#拓展操作（时效性操作）" class="headerlink" title="拓展操作（时效性操作）"></a>拓展操作（时效性操作）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//设置生命周期</span><br><span class="line">expire key seconds</span><br><span class="line">pexpire key milliseconds</span><br><span class="line"></span><br><span class="line">//查看有效时间, 如果有有效时间则返回剩余有效时间, 如果为永久有效，则返回-1, 如果Key不存在则返回-2</span><br><span class="line">ttl key</span><br><span class="line">pttl key</span><br><span class="line"></span><br><span class="line">//将有时限的数据设置为永久有效</span><br><span class="line">persist keyCopy</span><br></pre></td></tr></table></figure><h5 id="拓展操作（查询操作）"><a href="#拓展操作（查询操作）" class="headerlink" title="拓展操作（查询操作）"></a>拓展操作（查询操作）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//根据key查询符合条件的数据</span><br><span class="line">keys pattern</span><br></pre></td></tr></table></figure><img src="/2020/08/20/redis/redis/查询规则.png" alt="img" style="zoom:80%;"><h5 id="拓展操作（其他操作）"><a href="#拓展操作（其他操作）" class="headerlink" title="拓展操作（其他操作）"></a>拓展操作（其他操作）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//重命名key，为了避免覆盖已有数据，尽量少去修改已有key的名字，如果要使用最好使用renamenx</span><br><span class="line">rename key newKey</span><br><span class="line">renamenx key newKey</span><br><span class="line"></span><br><span class="line">//查看所有关于key的操作, 可以使用Tab快速切换</span><br><span class="line">help @generic</span><br></pre></td></tr></table></figure><h3 id="数据库通用操作"><a href="#数据库通用操作" class="headerlink" title="数据库通用操作"></a>数据库通用操作</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li>Redis为每个服务提供有16个数据库，编号从0到15</li><li>每个数据库之间的数据相互独立</li></ul><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//切换数据库 0~15</span><br><span class="line">select index</span><br><span class="line"></span><br><span class="line">//其他操作</span><br><span class="line">quit</span><br><span class="line">ping</span><br><span class="line">echo massageCopy</span><br></pre></td></tr></table></figure><h4 id="拓展操作"><a href="#拓展操作" class="headerlink" title="拓展操作"></a>拓展操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//移动数据, 必须保证目的数据库中没有该数据</span><br><span class="line">mov key db</span><br><span class="line"></span><br><span class="line">//查看该库中数据总量</span><br><span class="line">dbsize</span><br></pre></td></tr></table></figure><h2 id="三、Jedis"><a href="#三、Jedis" class="headerlink" title="三、Jedis"></a>三、Jedis</h2><p><strong>JAVA</strong>操作Redis需要导入jar或引入Maven依赖</p><p><strong>JAVA</strong>操作Redis需要导入jar或引入Maven依赖</p><h3 id="1、Java操作redis的步骤"><a href="#1、Java操作redis的步骤" class="headerlink" title="1、Java操作redis的步骤"></a>1、Java操作redis的步骤</h3><ul><li><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients&lt;/ groupId&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencv</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>连接Redis</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数为Redis所在的ip地址和端口号</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(String host, <span class="keyword">int</span> port)Copy</span><br></pre></td></tr></table></figure><ul><li>操作Redis</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作redis的指令和redis本身的指令几乎一致</span></span><br><span class="line">jedis.set(String key, String value);Copy</span><br></pre></td></tr></table></figure><ul><li>断开连接</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h3 id="2、配置工具"><a href="#2、配置工具" class="headerlink" title="2、配置工具"></a>2、配置工具</h3><ul><li>配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis.host=47.103.10.63</span><br><span class="line">redis.port=6379</span><br><span class="line">redis.maxTotal=30</span><br><span class="line">redis.maxIdle=10Copy</span><br></pre></td></tr></table></figure><ul><li>工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chen Panwen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span> 2020/4/6 16:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisUtil</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String host = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用静态代码块，只加载一次</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">//读取配置文件</span></span><br><span class="line">ResourceBundle resourceBundle = ResourceBundle.getBundle(<span class="string">&quot;redis&quot;</span>);</span><br><span class="line"><span class="comment">//获取配置文件中的数据</span></span><br><span class="line">host = resourceBundle.getString(<span class="string">&quot;redis.host&quot;</span>);</span><br><span class="line">port = Integer.parseInt(resourceBundle.getString(<span class="string">&quot;redis.port&quot;</span>));</span><br><span class="line"><span class="comment">//读取最大连接数</span></span><br><span class="line">maxTotal = Integer.parseInt(resourceBundle.getString(<span class="string">&quot;redis.maxTotal&quot;</span>));</span><br><span class="line"><span class="comment">//读取最大活跃数</span></span><br><span class="line">maxIdle = Integer.parseInt(resourceBundle.getString(<span class="string">&quot;redis.maxIdle&quot;</span>));</span><br><span class="line">        </span><br><span class="line">JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">jedisPoolConfig.setMaxTotal(maxTotal);</span><br><span class="line">jedisPoolConfig.setMaxIdle(maxIdle);</span><br><span class="line"><span class="comment">//获取连接池</span></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, host, port);</span><br><span class="line">jedis = jedisPool.getResource();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> jedis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、持久化"><a href="#四、持久化" class="headerlink" title="四、持久化"></a>四、持久化</h2><h3 id="基于Center-OS7安装Redis"><a href="#基于Center-OS7安装Redis" class="headerlink" title="基于Center OS7安装Redis"></a>基于Center OS7安装Redis</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">下载安装包</span><br><span class="line">wget http://download.redis.io/releases/redis- ??.tar.gz</span><br><span class="line">解压</span><br><span class="line">tar -xvf文件名.tar.gz</span><br><span class="line">编译</span><br><span class="line">make</span><br><span class="line">安装</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Redis服务启动"><a href="#Redis服务启动" class="headerlink" title="Redis服务启动"></a>Redis服务启动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">●默认配置启动</span><br><span class="line">redis-server</span><br><span class="line">redis-server --port 6379</span><br><span class="line">redis-server --port 6380</span><br><span class="line">.....</span><br><span class="line">●指定配置文件启动</span><br><span class="line">redis-server redis.conf</span><br><span class="line">redis-server redis-6379.conf</span><br><span class="line">redis-server redis-6380.conf</span><br><span class="line">redis-server conf/redis- 6379.conf</span><br><span class="line">redis-server config/redis-6380.conf ....</span><br></pre></td></tr></table></figure><p>redis-6379.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 6379#端口</span><br><span class="line">daemonize yes#后台启动</span><br><span class="line">logfile &quot;6379.log&quot;#日志文件</span><br><span class="line">dir /redis-4.0.0/data#存放位置</span><br><span class="line">port 6379#端</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;6379.log&quot;</span><br><span class="line">dir /redis-4.0.0/data</span><br></pre></td></tr></table></figure><h3 id="Redis容器配置redis-conf"><a href="#Redis容器配置redis-conf" class="headerlink" title="Redis容器配置redis.conf"></a>Redis容器配置redis.conf</h3><ul><li><p>redis容器里边的配置文件是需要在<strong>创建容器时映射</strong>进来的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">停止容器：docker container stop myredis</span><br><span class="line">删除容器：docker container rm myredis</span><br></pre></td></tr></table></figure></li><li><p>重新开始创建容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 创建docker统一的外部配置文件</span><br><span class="line"></span><br><span class="line">mkdir -p docker/redis/&#123;conf,data&#125;</span><br><span class="line"></span><br><span class="line">2. 在conf目录创建redis.conf的配置文件</span><br><span class="line"></span><br><span class="line">touch /docker/redis/conf/redis.conf</span><br><span class="line"></span><br><span class="line">3. redis.conf文件的内容需要自行去下载，网上很多</span><br><span class="line"></span><br><span class="line">4. 创建启动容器，加载配置文件并持久化数据</span><br><span class="line"></span><br><span class="line">docker run -d --privileged=true -p 6379:6379 -v /docker/redis/conf/redis.conf:/etc/redis/redis.conf -v /docker/redis/data:/data --name myredis redis redis-server /etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure></li><li><p>文件目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/docker/redis</span><br></pre></td></tr></table></figure></li></ul><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h4><p>利用<strong>永久性</strong>存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。</p><h4 id="为什么要持久化"><a href="#为什么要持久化" class="headerlink" title="为什么要持久化"></a>为什么要持久化</h4><p><strong>防止</strong>数据的意外<strong>丢失</strong>，确保数据<strong>安全性</strong></p><h4 id="持久化过程保存什么"><a href="#持久化过程保存什么" class="headerlink" title="持久化过程保存什么"></a>持久化过程保存什么</h4><ul><li>将当前<strong>数据状态</strong>进行保存，<strong>快照</strong>形式，存储数据结果，存储格式简单，关注点在<strong>数据</strong></li><li>将数据的<strong>操作过程</strong>进行保存，<strong>日志</strong>形式，存储操作过程，存储格式复杂，关注点在数据的操作<strong>过程</strong></li></ul><img src="/2020/08/20/redis/redis/持久化.png" alt="image-20200822174337888" style="zoom:80%;"><h3 id="2、RDB"><a href="#2、RDB" class="headerlink" title="2、RDB"></a>2、RDB</h3><h4 id="RDB启动方式——save"><a href="#RDB启动方式——save" class="headerlink" title="RDB启动方式——save"></a>RDB启动方式——save</h4><ul><li><p>命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save</span><br></pre></td></tr></table></figure></li><li><p>作用</p><p>手动执行一次保存操作</p></li></ul><h4 id="RDB配置相关命令"><a href="#RDB配置相关命令" class="headerlink" title="RDB配置相关命令"></a>RDB配置相关命令</h4><ul><li>dbfilename dump.rdb<ul><li>说明：设置本地数据库文件名，默认值为 dump.rdb</li><li>经验：通常设置为dump-端口号.rdb</li></ul></li><li>dir<ul><li>说明：设置存储.rdb文件的路径</li><li>经验：通常设置成存储空间较大的目录中，目录名称data</li></ul></li><li>rdbcompression yes<ul><li>说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩</li><li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</li></ul></li><li>rdbchecksum yes<ul><li>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行</li><li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</li></ul></li></ul><h4 id="RDB启动方式——save指令工作原理"><a href="#RDB启动方式——save指令工作原理" class="headerlink" title="RDB启动方式——save指令工作原理"></a>RDB启动方式——save指令工作原理</h4><img src="/2020/08/20/redis/redis/RDB.png" alt="img" style="zoom: 50%;"><p><strong>注意</strong>：<strong>save指令</strong>的执行会<strong>阻塞</strong>当前Redis服务器，直到当前RDB过程完成为止，有可能会造成<strong>长时间阻塞</strong>，线上环境<strong>不建议使用</strong>。</p><h4 id="RDB启动方式——bgsave"><a href="#RDB启动方式——bgsave" class="headerlink" title="RDB启动方式——bgsave"></a>RDB启动方式——bgsave</h4><ul><li><p>命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgsave</span><br></pre></td></tr></table></figure></li><li><p>作用</p><p>手动启动后台保存操作，但<strong>不是立即执行</strong></p></li></ul><h4 id="RDB启动方式-——-bgsave指令工作原理"><a href="#RDB启动方式-——-bgsave指令工作原理" class="headerlink" title="RDB启动方式 —— bgsave指令工作原理"></a>RDB启动方式 —— bgsave指令工作原理</h4><p><img src="/2020/08/20/redis/redis/RDB_bgsave.png" alt="img"></p><p><strong>注意</strong>： <strong>bgsave命令</strong>是针对save阻塞问题做的<strong>优化</strong>。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用，推荐使用bgsave</p><p><strong>bgsave的保存操作可以通过redis的日志查看</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs myredis</span><br></pre></td></tr></table></figure><h4 id="RDB启动方式-——save配置"><a href="#RDB启动方式-——save配置" class="headerlink" title="RDB启动方式 ——save配置"></a>RDB启动方式 ——save配置</h4><ul><li><p>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save second changes</span><br></pre></td></tr></table></figure></li><li><p>作用</p><p>满足<strong>限定时间</strong>范围内key的变化数量达到<strong>指定数量</strong>即进行持久化</p></li><li><p>参数</p><ul><li>second：监控时间范围</li><li>changes：监控key的变化量</li></ul></li><li><p>配置位置</p><p>在<strong>conf文件</strong>中进行配置</p></li></ul><h4 id="RDB启动方式-——save配置原理"><a href="#RDB启动方式-——save配置原理" class="headerlink" title="RDB启动方式 ——save配置原理"></a>RDB启动方式 ——save配置原理</h4><p><img src="/2020/08/20/redis/redis/RDB%E5%90%AF%E5%8A%A8_save.png" alt="img"></p><ul><li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</li><li>save配置中对于second与changes设置通常具有<strong>互补对应</strong>关系（一个大一个小），尽量不要设置成包含性关系</li><li>save配置启动后执行的是<strong>bgsave操作</strong></li></ul><h4 id="RDB启动方式对比"><a href="#RDB启动方式对比" class="headerlink" title="RDB启动方式对比"></a>RDB启动方式对比</h4><p><img src="/2020/08/20/redis/redis/RDB%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F.png" alt="img"></p><h4 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h4><ul><li>优点<ul><li>RDB是一个紧凑压缩的二进制文件，<strong>存储效率较高</strong></li><li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于<strong>数据备份，全量复制</strong>等场景</li><li>RDB恢复数据的<strong>速度</strong>要比AOF<strong>快</strong>很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，<strong>用于灾难恢复</strong></li></ul></li><li>缺点<ul><li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作<strong>创建子进程</strong>，要<strong>牺牲</strong>掉一些<strong>性能</strong></li><li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式<strong>无法兼容</strong>现象</li></ul></li></ul><h3 id="3、AOF"><a href="#3、AOF" class="headerlink" title="3、AOF"></a>3、AOF</h3><h4 id="AOF概念"><a href="#AOF概念" class="headerlink" title="AOF概念"></a>AOF概念</h4><ul><li>AOF(append only file)持久化：以独立日志的方式记录<strong>每次</strong>写命令，重启时再重新执行AOF文件中命令，以达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</li><li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的<strong>主流</strong>方式</li></ul><h4 id="AOF写数据过程"><a href="#AOF写数据过程" class="headerlink" title="AOF写数据过程"></a>AOF写数据过程</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142645.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142645.png" alt="img"></a></p><h4 id="AOF写数据三种策略-appendfsync"><a href="#AOF写数据三种策略-appendfsync" class="headerlink" title="AOF写数据三种策略(appendfsync)"></a>AOF写数据三种策略(appendfsync)</h4><ul><li>always<ul><li>每次写入操作均同步到AOF文件中，数据零误差，<strong>性能较低</strong>,<strong>不建议使用</strong></li></ul></li><li>everysec<ul><li>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，<strong>性能较高</strong> ，<strong>建议使用</strong>，也是默认配置</li><li>在系统突然宕机的情况下丢失1秒内的数据</li></ul></li><li>no<ul><li>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong></li></ul></li></ul><h4 id="AOF功能开启"><a href="#AOF功能开启" class="headerlink" title="AOF功能开启"></a>AOF功能开启</h4><ul><li><p>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes|no</span><br></pre></td></tr></table></figure><ul><li>作用<ul><li>是否开启AOF持久化功能，<strong>默认为不开启状态</strong></li></ul></li></ul></li><li><p>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always|everysec|no</span><br></pre></td></tr></table></figure><ul><li>作用<ul><li>AOF写数据策略</li></ul></li></ul></li></ul><p>在配置文件中</p><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>降低磁盘占用量，提高磁盘利用率</li><li>提高持久化效率，降低持久化写时间，提高IO性能</li><li>降低数据恢复用时，提高数据恢复效率</li></ul><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li><p>进程内已超时的数据不再写入文件</p></li><li><p>忽略</p><p>无效指令</p><p>，重写时使用进程内数据直接生成，这样新的AOF文件</p><p>只保留最终数据的写入命令</p><ul><li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</li></ul></li><li><p>对同一数据的多条写命令合并为一条命令</p><ul><li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c</li><li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li></ul></li></ul><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><ul><li><p>手动重写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgrewriteaof</span><br></pre></td></tr></table></figure></li><li><p>自动重写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size size </span><br><span class="line">auto-aof-rewrite-percentage percentage</span><br></pre></td></tr></table></figure></li></ul><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="/2020/08/20/redis/redis/E:%5CBlog%5Csource_posts%5Credis%5Credis%5CAOP%E9%87%8D%E5%86%99.png" alt="img"></p><h5 id="AOF自动重写"><a href="#AOF自动重写" class="headerlink" title="AOF自动重写"></a>AOF自动重写</h5><ul><li><p>自动重写触发条件设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//触发重写的最小大小</span><br><span class="line">auto-aof-rewrite-min-size size </span><br><span class="line">//触发重写须达到的最小百分比</span><br><span class="line">auto-aof-rewrite-percentage percent</span><br></pre></td></tr></table></figure></li><li><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//当前.aof的文件大小</span><br><span class="line">aof_current_size </span><br><span class="line">//基础文件大小</span><br><span class="line">aof_base_size</span><br></pre></td></tr></table></figure></li><li><p>自动重写触发条件</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142715.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142715.png" alt="img"></a></p></li></ul><p><img src="/2020/08/20/redis/redis/AOP%E9%87%8D%E5%86%99%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="img"></p><p><img src="/2020/08/20/redis/redis/AOP%E9%87%8D%E5%86%99%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B2.png" alt="img"></p><h5 id="缓冲策略"><a href="#缓冲策略" class="headerlink" title="缓冲策略"></a>缓冲策略</h5><p>AOF缓冲区同步文件策略，由参数<strong>appendfsync</strong>控制</p><ul><li>write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用 来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依 赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之 前，如果此时系统故障宕机，缓冲区内数据将丢失。</li><li>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞知道 写入硬盘完成后返回，保证了数据持久化。</li></ul><h3 id="4、RDB-VS-AOF"><a href="#4、RDB-VS-AOF" class="headerlink" title="4、RDB VS AOF"></a>4、RDB VS AOF</h3><p><img src="/2020/08/20/redis/redis/RDB%E5%AF%B9%E6%AF%94AOF.png" alt="img"></p><h5 id="RDB与AOF的选择之惑"><a href="#RDB与AOF的选择之惑" class="headerlink" title="RDB与AOF的选择之惑"></a>RDB与AOF的选择之惑</h5><ul><li>对数据非常敏感，建议使用默认的AOF持久化方案<ul><li>AOF持久化策略使用<strong>everysecond</strong>，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li><li>注意：由于AOF文件<strong>存储体积较大</strong>，且<strong>恢复速度较慢</strong></li></ul></li><li>数据呈现阶段有效性，建议使用RDB持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且<strong>恢复速度较快</strong>，阶段 点数据恢复通常采用RDB方案</li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低</li></ul></li><li>综合比对<ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常<strong>敏感</strong>，选用<strong>AOF</strong></li><li>如能承受数分钟以内的数据丢失，且追求大数据集的<strong>恢复速度</strong>，选用<strong>RDB</strong></li><li><strong>灾难恢复选用RDB</strong></li><li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据 </li></ul></li></ul><h2 id="五、Redis事务"><a href="#五、Redis事务" class="headerlink" title="五、Redis事务"></a>五、Redis事务</h2><h3 id="1、Redis事务的定义"><a href="#1、Redis事务的定义" class="headerlink" title="1、Redis事务的定义"></a>1、Redis事务的定义</h3><p>redis事务就是一个命令执行的队列，将一系列预定义命令<strong>包装成一个整体</strong>（一个队列）。当执行时，<strong>一次性按照添加顺序依次执行</strong>，中间不会被打断或者干扰</p><h3 id="2、事务的基本操作"><a href="#2、事务的基本操作" class="headerlink" title="2、事务的基本操作"></a>2、事务的基本操作</h3><ul><li><p>开启事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br></pre></td></tr></table></figure><ul><li>作用<ul><li>作设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li></ul></li></ul></li><li><p>取消事务</p><p>discardCopy</p><ul><li>作用<ul><li>终止当前事务的定义，发生在multi之后，exec之前</li></ul></li></ul></li><li><p>执行事务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec</span><br></pre></td></tr></table></figure><ul><li>作用<ul><li>设定事务的结束位置，同时执行事务。<strong>与multi成对出现</strong>，成对使用</li></ul></li></ul></li></ul><p><a href="http://www.wenwenlulu.cn/2020/06/07/Redis学习文档/#命名规范">http://www.wenwenlulu.cn/2020/06/07/Redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83</a></p><p><a href="https://www.cnblogs.com/haoprogrammer/p/11068396.html">https://www.cnblogs.com/haoprogrammer/p/11068396.html</a></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔试</title>
      <link href="/2020/08/20/%E7%AC%94%E8%AF%95/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/20/%E7%AC%94%E8%AF%95/%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="脚本语言和编译语言"><a href="#脚本语言和编译语言" class="headerlink" title="脚本语言和编译语言"></a>脚本语言和编译语言</h2><p>抽象的级别不同：脚本语言更抽象。在脚本语言中，存在有高级的数据结构，如列表和字典结构，和对这种结构简单方便的嵌套和操作。编译语言有比较明确的定义等等。</p><p>类型定义不同：脚本语言对类型的定义就比较松散，不需要类型声明，而且在运行时自动进行动态类型检查。而编译语言通常是强类型定义或静态定义，也就是说变量的类型在程序中指定了。</p><p>执行方式不同：脚本语言是解释成指令被立即执行。这样完全将编译过程从编辑-编译-运行循环中去掉了。而编译语言的程序被编译成可执行的二进制。</p><p>运行速度不同：脚本语言是解释执行的，在运行时解释每一条语句然后执行。这样比编译执行的语言要慢。而编译语言因为编译成机器码，可以直接运行，所以在运行速度上快比较快。</p>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>绿盟</title>
      <link href="/2020/08/20/%E7%AC%94%E8%AF%95/%E7%BB%BF%E7%9B%9F/"/>
      <url>/2020/08/20/%E7%AC%94%E8%AF%95/%E7%BB%BF%E7%9B%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="给定年月日计算是那一天"><a href="#给定年月日计算是那一天" class="headerlink" title="给定年月日计算是那一天"></a>给定年月日计算是那一天</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Day</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (input.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> year = input.nextInt();</span><br><span class="line">            <span class="keyword">int</span> month = input.nextInt();</span><br><span class="line">            <span class="keyword">int</span> day = input.nextInt();</span><br><span class="line">            <span class="keyword">int</span> daysInYear = getDaysInYear(year, month, day);</span><br><span class="line">            System.out.println(daysInYear);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDaysInYear</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (month-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:total += <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:total += <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:total += <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:total += <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:total += <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:total += <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:total += <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:total += <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:total += <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:total += <span class="number">28</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:total += <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isR(year))&#123;</span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line">        total +=day;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isR</span><span class="params">(<span class="keyword">int</span> year)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>||(year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算回文素数"><a href="#计算回文素数" class="headerlink" title="计算回文素数"></a>计算回文素数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sushu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> b = in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=a;i&lt;=b;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime(i) &amp;&amp; isHuiO(i))&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是不是素数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;Math.sqrt(n);i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i ==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHuiO</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        String s = String.valueOf(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.length()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)!=s.charAt(s.length()-i-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gradle</title>
      <link href="/2020/08/18/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Gradle/"/>
      <url>/2020/08/18/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Gradle/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2020/08/18/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git/"/>
      <url>/2020/08/18/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-SVN和Git"><a href="#1-SVN和Git" class="headerlink" title="1.SVN和Git"></a>1.SVN和Git</h2><p><strong>集中式(svn)</strong>：svn存放的是差异，每次回滚的速度慢</p><ul><li>优点：代码放在单一的服务器，便于项目的管理。</li><li>缺点：<ul><li>服务器宕机：代码得不到保障</li><li>服务器炸了：整个项目的历史记录丢失</li></ul></li></ul><p><strong>分布式(git)</strong>：每次存放的都是项目的完整快照，需要磁盘空间相对大一点。</p><ul><li>客户端并不只是提取最新版本的文件快照，而是把代码仓库完整的镜像下来。</li><li>存放的不是版本和版本直接的差异，他存放的是索引(所需磁盘空间最小)</li></ul><h2 id="2-初次运行-Git-前的配置"><a href="#2-初次运行-Git-前的配置" class="headerlink" title="2. 初次运行 Git 前的配置"></a>2. 初次运行 Git 前的配置</h2><p>Git 提供了一个叫做 git config 的工具（译注：实际是 <code>git-config</code> 命令，只不过可以通过 <code>git</code> 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p><ul><li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li><li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li><li>当前项目的 git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li></ul><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;John Doe&quot;</span><br><span class="line">    $ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><p>要检查已有的配置信息，可以使用 <code>git config --list</code></p><h2 id="3-Git基本概念"><a href="#3-Git基本概念" class="headerlink" title="3. Git基本概念"></a>3. Git基本概念</h2><h3 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 工作区 （沙箱环境 git不会管理 随便更改操作）</span><br><span class="line"></span><br><span class="line">* 暂存区  （记录文件的操作）</span><br><span class="line"></span><br><span class="line">* 版本库   （最终的代码实现提交到这里 .git目录就是版本库）</span><br></pre></td></tr></table></figure><h3 id="初始化git"><a href="#初始化git" class="headerlink" title="初始化git"></a>初始化git</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* git init （初始化仓库 生成.git文件）</span><br><span class="line">* git config --global user.name &quot;Is zyd&quot;</span><br><span class="line">* git config --global user.email 1426593075@qq.com</span><br><span class="line">* git config --list</span><br></pre></td></tr></table></figure><h3 id="git目录下文件的介绍"><a href="#git目录下文件的介绍" class="headerlink" title=".git目录下文件的介绍"></a>.git目录下文件的介绍</h3><ul><li>hooks (钩子函数的一个库 类似于回调函数)</li><li>info (包含一个全局性的排除文件)</li><li><strong>objects (目录存储所有数据内容)</strong></li><li><strong>refs (目录存储指向数据（分支）的提交对象的指针)</strong></li><li>config (文件包含项目特有的配置选项)</li><li>description (显示对仓库的描述信息)</li><li><strong>HEAD (文件目前被检出的分支)</strong></li><li><strong>logs (日志信息)</strong></li><li>index (文件保存暂存区的信息)</li></ul><h3 id="Git对象"><a href="#Git对象" class="headerlink" title="Git对象"></a>Git对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">git核心本质上是一个键值对数据库。可以向该数据库插入任意类型的内容，</span><br><span class="line">  他会返回一个键值，通过该值可以在任意时刻再次检索该内容。</span><br><span class="line">    - echo &quot;hello&quot; | git hash-object --stdin </span><br><span class="line">     - 这句命令返回一个hash值用来标识这句话 但是并没有写到数据库中  </span><br><span class="line">     - 内容不一样对应的hash值不一样</span><br><span class="line">     --stdin 从标准输入中读取内容</span><br><span class="line"></span><br><span class="line">    - echo &quot;hello&quot; | git hash-object -w --stdin</span><br><span class="line">     - 这句命令返回一个hash值用来标识这句话 并写到数据库中  </span><br><span class="line">     - 查看有没有存在 可以通过 find ./ -type f 找对应hash的文件</span><br><span class="line">     - 里面的内容是压缩的 通过 git cat-file -p hash注意前面的那两个字母也加上</span><br><span class="line">     - git cat-file -t hash 查看git对象的类型 blob</span><br><span class="line"></span><br><span class="line">    - 将新创建的文件添加到git数据库中即生成一个git对象</span><br><span class="line">     - git hash-object -w ./a.txt</span><br><span class="line"></span><br><span class="line">    - 如果文件更改git数据库里面不会自动的添加要手动添加过去 这时会在添加一个git对象</span><br><span class="line">     - git hash-object -w ./a.txt</span><br><span class="line">    </span><br><span class="line">    - 实质上Git对象是一个KYE：VALUE hash/value    </span><br><span class="line">    - git对象不能当作项目的一次快照 只是组成项目的一部分</span><br><span class="line"></span><br><span class="line">    - 存在的问题？</span><br><span class="line">     - 记住文件的每一个（版本）对应的hash值并不现实</span><br><span class="line">     - 在git中，文件名并没有被保存，只能通过hash得到内容</span><br><span class="line">     解决：树对象</span><br><span class="line"></span><br><span class="line">    - 注意：此时的操作只是针对本地数据库进行操作，不涉及暂存区。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 树对象</span><br><span class="line">    * 树对象能够解决文件名保存的问题，也允许我们将多个文件组织到一起。</span><br><span class="line">  通过update-index,write-tree，read-tree等命令来构建树并放入暂存区</span><br><span class="line">  </span><br><span class="line">    * 构建树对象</span><br><span class="line">     - git update-index --add --cacheinfo 100644 915c628f360b2d8c3edbe1ac65cf575b69029b61 test.txt</span><br><span class="line">     - 文件模式为100644 表明这是一个普通文件</span><br><span class="line">     - 文件模式为100755 表明这是一个可执行文件</span><br><span class="line">     - 文件模式为120000 表明这是一个符号连接</span><br><span class="line">     -  --add 因为此前该文件并没有在暂存区中 首次要加add</span><br><span class="line">     -  --cacheinfo 因为要添加的文件在git数据库中,没有位于当前目录下</span><br><span class="line"></span><br><span class="line">    * 暂存区做一个快照生成一个对象放到git数据库中</span><br><span class="line">     - git write-tree</span><br><span class="line">        对象类型是一个树对象</span><br><span class="line">        树对象里面的内容是暂存区的快照（项目的快照）</span><br><span class="line">    * 暂存区中文件名字不变 如果改变文件的内容，就会重新生成一个hash</span><br><span class="line"></span><br><span class="line">    * 存在的问题？</span><br><span class="line">     - 不知道hash值对应的是哪一个版本</span><br><span class="line">     - 不知道这个版本的一些基础信息    </span><br><span class="line"></span><br><span class="line">* 提交对象    </span><br><span class="line">    - 提交对象完美的解决了上面的问题</span><br><span class="line">    - 本质就是给树对象做一层包裹包含项目的基础信息</span><br><span class="line">    - commit-tree创建一个提交对象，为此需要指定一个树对象的hash值,以及该提交的父提交对象  </span><br><span class="line">    - echo &quot;second commit&quot; | git commit-tree     019fb2c522b604cd94929085bbac93d60e2f2063 -p  d248eb19a125c</span><br><span class="line"></span><br><span class="line">    - 真正代表一个项目的是一个提交对象（数据和基本信息）这是一个链式的！！ </span><br></pre></td></tr></table></figure><h2 id="4-Git操作"><a href="#4-Git操作" class="headerlink" title="4. Git操作"></a>4. Git操作</h2><h3 id="取得项目的Git仓库"><a href="#取得项目的Git仓库" class="headerlink" title="取得项目的Git仓库"></a>取得项目的Git仓库</h3><h4 id="初始化git-1"><a href="#初始化git-1" class="headerlink" title="初始化git"></a>初始化git</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init （初始化仓库 生成.git文件）</span><br></pre></td></tr></table></figure><h4 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* git add ./   首先将工作区（文件）做成git对象放到版本库 然后再放到暂存区 但是这里没有生成树对象</span><br><span class="line">* git ls-files -s  查看暂存区的当前状态</span><br></pre></td></tr></table></figure><h4 id="添加到版本库"><a href="#添加到版本库" class="headerlink" title="添加到版本库"></a>添加到版本库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* git commit -m &#x27;提交的信息&#x27;</span><br></pre></td></tr></table></figure><h4 id="从现有仓库克隆"><a href="#从现有仓库克隆" class="headerlink" title="从现有仓库克隆"></a>从现有仓库克隆</h4><p>这就需要用到 <code>git clone</code> 命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git://github.com/schacon/grit.git</span><br><span class="line">这会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。如果进入这个新建的 grit 目录，你会看到项目中的所有文件已经在里边了，准备好后续的开发和使用。如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</span><br><span class="line">$ git clone git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure><h4 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h4><p>作目录下面的所有文件都不外乎这两种状态：<strong>已跟踪或未跟踪</strong>。</p><p>已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是<strong>未更新，已修改或者已放入暂存区。</strong>而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p><p><img src="/2020/08/18/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git/%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81.png" alt="img"></p><ul><li><h3 id="高级命令（crud）"><a href="#高级命令（crud）" class="headerlink" title="高级命令（crud）"></a>高级命令（crud）</h3></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* git init               初始化   </span><br><span class="line">* git status              查看当前状态</span><br><span class="line">* git diff                查看当先做的哪些更新没有暂存</span><br><span class="line">* git diff -cached        查看哪些已经暂存了准备下次提交</span><br><span class="line">* git commit -m &quot;注释&quot;     提交项目</span><br><span class="line">* git commit -a -m        git跳过暂存区直接提交，跳过add</span><br><span class="line">* git add ./ 添加暂存区   </span><br><span class="line">* git commit -m &quot;rename zx&quot;</span><br><span class="line">* git log --oneline      查看提交历史记录</span><br><span class="line">-p仅显示最近的2次更新</span><br><span class="line"></span><br><span class="line">* rm yd.txt               删除文件 暂存区里没有文件 版本库多了一个提交对象不过没有内容</span><br><span class="line">* 删除文件属于修改操作 跟上面的提交步骤一样</span><br><span class="line">*进行了2步先将工作区的文件删除，再将暂存区的文件删除</span><br><span class="line">* mv z.txt zx.txt         重新起名字跟已修改一样的操作</span><br><span class="line"></span><br><span class="line">* git commit --amend 这个命令可撤消刚才的提交操作，如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 --amend 提交</span><br></pre></td></tr></table></figure><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 一次完整的项目提交 包括至少一个提交对象 一个树对象 0或多个git对象</span><br><span class="line">* 工作目录中文件只有两种状态 已跟踪（只要第一次add就跟踪上了） 未跟踪</span><br><span class="line">* 已经跟踪的文件还有三种状态 已提交 已修改 已暂存</span><br><span class="line">* 如果一个已经提交的文件再次修改要重新添加到暂存区否则显示已修改状态</span><br><span class="line">* 如果一个文件暂存完了没有提交前还要在修改 这时会出现一个暂存一个已修改的情况需要重新add</span><br></pre></td></tr></table></figure><h4 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。来看一个实际的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitignore</span><br><span class="line">    *.[oa]</span><br><span class="line">    *~</span><br></pre></td></tr></table></figure><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（<code>~</code>）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 <code>log</code>，<code>tmp</code> 或者 <code>pid</code> 目录，以及自动生成的文档等等。要养成一开始就设置好 <code>.gitignore</code> 文件的习惯，以免将来误提交这类无用的文件。</p><p>文件 <code>.gitignore</code> 的格式规范如下：</p><ul><li>所有空行或者以注释符号 <code>＃</code> 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式最后跟反斜杠（<code>/</code>）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。</p><p>我们再看一个 <code>.gitignore</code> 文件的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line">    # 忽略所有 .a 结尾的文件</span><br><span class="line">    *.a</span><br><span class="line">    # 但 lib.a 除外</span><br><span class="line">    !lib.a</span><br><span class="line">    # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line">    /TODO</span><br><span class="line">    # 忽略 build/ 目录下的所有文件</span><br><span class="line">    build/</span><br><span class="line">    # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br><span class="line">    doc/*.txt</span><br></pre></td></tr></table></figure><h3 id="Git分支操作"><a href="#Git分支操作" class="headerlink" title="Git分支操作"></a>Git分支操作</h3><p>分支就是为了保护代码方便更改存在的 假如master里面的提交对象完美了就可以在创建一个分支   添加功能如果可以就可以master合并 不行的话就可以删除这个分支 这样对于master没有影响</p><ul><li>新建一个分支到一个提交对象上面 这样做的好处是实现版本回推但是不改边主仓库的东西 用完    删除这个分支就可以了特别方便</li></ul><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">* 每一个功能都可以开一个分支，不影响主线的分支</span><br><span class="line">* 分支就是一个活动的指针就在提交对象的前面指向最新提交</span><br><span class="line">* master默认是主分支</span><br><span class="line">* git branch  显示分支列表</span><br><span class="line">* git branch test    会在当前的提交对象上创建一个分支</span><br><span class="line"></span><br><span class="line">* git checkout test  将分支切换到test上面来</span><br><span class="line"></span><br><span class="line">* git branch -d test  合并之后删除</span><br><span class="line">* git branch -D test  删除分支 不能自己删自己</span><br><span class="line"></span><br><span class="line">* git log --oneline --decorate --graph --all  查看完整的分支图（没删除前）</span><br><span class="line"></span><br><span class="line">* git config --global alias.lol ‘log --oneline --decorate --graph --all’ 陪别名</span><br><span class="line"></span><br><span class="line">* git branch -v  查看分支的最后一个提交</span><br><span class="line"></span><br><span class="line">* git branch test hash  新建一个分支到hash所对应的提交对象上，就是创建一个分支到一个之前的hash版本上</span><br><span class="line"></span><br><span class="line">* git checkout -b test  创建分支并且切换过去</span><br><span class="line"></span><br><span class="line">* git merge hotbug(分支名)</span><br></pre></td></tr></table></figure><ul><li><p>git checkout name   </p><ul><li>每次切换都要动三个地方HEAD、暂存区、工作目录</li><li><strong>切换分支的时候一定要提交完的时候再切否则会出现问题</strong><br>*<em>每次切换分支前当前分支一定要是已提交状态 ，如果有第一次未暂存的 或 未提交的 会污染主分支 *</em></li><li><strong>如果第一次提交了再修改的时候没有提交他就不让切换分支了</strong></li></ul></li></ul><p>合并分支一定要注意顺序 后面的可能会过期还会存在bug 会产生冲突</p><ul><li><p>快速合并 一条分支 快进合并</p></li><li><img src="/2020/08/18/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git/快速合并.png" alt="image-20200819101638197" style="zoom:67%;"></li><li><p>典型合并 多条分支 会有冲突（打开冲突文件看哪里要留 然后暂存提交）</p><img src="/2020/08/18/%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6/Git/典型合并.png" alt="image-20200819101608222" style="zoom:67%;"></li><li><p>同事之间的冲突才是最麻烦的</p></li></ul><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 解决的问题 不想过多的创建提交比如iss53那个分支，不想为了1点点的工作而提交</span><br><span class="line">* git stash list 查看存储</span><br><span class="line">* git stash apply  拿出栈顶的元素 但是不会消除</span><br><span class="line">* git stash drop 名字</span><br></pre></td></tr></table></figure><h3 id="后悔药"><a href="#后悔药" class="headerlink" title="后悔药"></a>后悔药</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 工作区撤回在工作目录中的修改</span><br><span class="line">  * git restore  filename  本质是相当于重置</span><br><span class="line">* 暂存区撤回自己的暂存</span><br><span class="line">  * git restore HEAD filename</span><br><span class="line">* 提交区注释写错了修改注释,或者有几个文件没有加 先add在执行</span><br><span class="line">  * git commit --amend   </span><br></pre></td></tr></table></figure><p>reset</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git log：</span><br><span class="line">git reflog:只有HEAD有变化，就会记录下来</span><br><span class="line"></span><br><span class="line">* 撤销上一次提交，上一次提交没用了</span><br><span class="line">  * git reset --soft HEAD~</span><br><span class="line">  只动HEAD指针（带着分支一起移动），不会变工作区和暂存区</span><br><span class="line">  * git reset [--mixed] HEAD~</span><br><span class="line">  只动HEAD指针（带着分支一起移动），会动暂存区</span><br><span class="line">  * git reset --hard HEAD~</span><br><span class="line">  只动HEAD指针（带着分支一起移动），会动暂存区,和工作区</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">checkout brancname 和 git reset --hard commithash</span><br><span class="line">共同点：都重置 HEAD 暂存区，工作区</span><br><span class="line">区别： checkout对工作区是安全的，hard是强制覆盖</span><br><span class="line">checkout只移动HEAD </span><br><span class="line">reset 会让HEAD和分支一起移动</span><br></pre></td></tr></table></figure><h3 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">列出tag</span><br><span class="line">* git tag </span><br><span class="line">* git tag -l v1.8.5*</span><br><span class="line">创建标签</span><br><span class="line">* git tag v1.0 标签是不会移动的</span><br><span class="line">查看特定标签</span><br><span class="line">* git show v1.0</span><br><span class="line">删除标签</span><br><span class="line">* git tag -d v1.0</span><br><span class="line">检出标签</span><br><span class="line">* git checkout v1.0  分离头指针的状态,必须创建分支</span><br><span class="line">    * git checkout -b &quot;v1.0&quot; 创建一个分支</span><br></pre></td></tr></table></figure><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="主用户创建远程操作github仓库步骤"><a href="#主用户创建远程操作github仓库步骤" class="headerlink" title="主用户创建远程操作github仓库步骤"></a>主用户创建远程操作github仓库步骤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 先在github上创建一个空的仓库new repository 注意不要有readme.md文件</span><br><span class="line">2. 创建本地仓库然后基础设置   git init</span><br><span class="line">3. 然后给github上面的地址起别名和用户别名</span><br><span class="line">  * git remote add use(别名) https://github.com/xxx/git_to_use.git</span><br><span class="line">  * git config --list</span><br><span class="line">4. 注意如果是复制别人的github 要把.git删掉只复制项目部分代码到自己的本地仓库</span><br><span class="line">5. 注意凭据 本人是可以直接上传的需要配置用户名和邮箱</span><br><span class="line">6. 检查完毕后推送到远地仓库  git push use(别名) master（分支）</span><br><span class="line">7. 给员工开放权限通过github里面的manage access contributor</span><br><span class="line">8. 获取员工上传的代码 git fetch use(别名)</span><br><span class="line">9. 切换成远程跟踪分支 git checkout use/master</span><br><span class="line">10. 合并远程跟踪分支 git merge use/master </span><br><span class="line">11. git pull  获取数据并合并</span><br></pre></td></tr></table></figure><h4 id="拉取仓库代码"><a href="#拉取仓库代码" class="headerlink" title="拉取仓库代码"></a>拉取仓库代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 本地不用创建仓库 直接克隆下来</span><br><span class="line">  * git clone https://github.com/xxx/git_to_use.git</span><br><span class="line">2. 它自动创建一个别名; 查看别名git remote -v       </span><br><span class="line">3. 创建新的文件 echo &quot;hello world&quot;&gt;test.txt</span><br><span class="line">4. git add ./   </span><br><span class="line">5. git commit -m &quot;tijiao&quot;</span><br><span class="line">6. git push origin master</span><br></pre></td></tr></table></figure><h4 id="本地分支-远程分支-远程跟踪分支"><a href="#本地分支-远程分支-远程跟踪分支" class="headerlink" title="本地分支 远程分支 远程跟踪分支"></a>本地分支 远程分支 远程跟踪分支</h4><ul><li>本地分支是本机电脑的</li><li>远程分支是github上对应的分支</li><li>远程跟踪分支是本地与远程分支的一个映射</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* 成员克隆远程仓库以后默认本地分支和对应的远程跟踪分支有同步关系</span><br><span class="line">* 在push的时候会生成对应的远程跟踪分支</span><br><span class="line">* 在fetch的时候把数据下载到远程跟踪分支里面</span><br><span class="line">* 注意成员开辟新分支提交的时候 经理在fetch的时候要创建对应的分支不用加别名</span><br><span class="line">* 主分支和远程跟踪分支自动绑定的功能(默认情况下push的时候)</span><br><span class="line">* 建立同步关系 git branch -u (远程跟踪分支) 注意要在那个分支里面输入这个命令</span><br><span class="line">* git checkout --track remote别名/分支名  最自动创建本地分支并且与远程跟踪分支绑定</span><br><span class="line">* git checkout -b 分支名 remote别名/分支名 效果与上面一样     </span><br></pre></td></tr></table></figure><h3 id="一个本地分支这么跟踪一个远程分支"><a href="#一个本地分支这么跟踪一个远程分支" class="headerlink" title="一个本地分支这么跟踪一个远程分支"></a>一个本地分支这么跟踪一个远程分支</h3><ol><li>当克隆的时候，会自动生成一个master本地分支（已经跟踪了对于的远程跟踪分支）</li><li>当新建其他分支是，可以指定要跟踪的远程跟踪分支<ol><li>git checkout -b 本地分支 远程分支名</li><li>git checkout –track 远程分支名</li></ol></li><li>将一个已经存在的本地分支 改成一个跟踪分支<ol><li>git branch -u 远程跟踪分支</li></ol></li></ol><h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* git push use(别名) --delete (分支名)  删除远程分支</span><br><span class="line">* git remote prune use --dry-run  列出仍在远程跟踪但是远程分支已经被删除的无用分支</span><br><span class="line">* git remote prune use    清除上面的命令列出来的远程跟宗</span><br></pre></td></tr></table></figure><h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* git本地操作的冲突</span><br><span class="line">    * 典型合并的时候</span><br><span class="line">* git远程协作的时候</span><br><span class="line">    * push</span><br><span class="line">        * 两个人同时推（更改同一个文件）解决办法只能先把远程仓库拉下来 然后再更改那个    文件然后再add commit push  </span><br><span class="line">    * pull</span><br><span class="line">        * 更改完以后不push 直接pull会报错 远程仓库会覆盖更改的内容建议push 不过push还会出错就是上面那个错误</span><br></pre></td></tr></table></figure><h4 id="参加开源项目的步骤-（pull-request）"><a href="#参加开源项目的步骤-（pull-request）" class="headerlink" title="参加开源项目的步骤 （pull request）"></a>参加开源项目的步骤 （pull request）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* 如果参加某个项目时，但是没有推送权限，这时候可以通过对这个项目进行fork。这会在你的空间中创建一个完全属于你的项目副本，且你对其具有推送权限。通过这个方式项目的管理者不用忙着添加贡献者，人们可以fork这个项目将修改推送到项目副本上，并通过pull </span><br><span class="line">  request来将他们的改动进入源版本库</span><br><span class="line"></span><br><span class="line">1. 先将源仓库fork到自己的仓库</span><br><span class="line">2. 然后clone到本地仓库</span><br><span class="line">3. 更改后提交到自己的远程仓库</span><br><span class="line">4. pull request</span><br><span class="line">5. 管理人审核 然后merge</span><br><span class="line"></span><br><span class="line">* 不重新fork怎么解决</span><br><span class="line">  * git 支持同时跟踪多个仓库</span><br><span class="line">    git remote add 别名2 地址</span><br><span class="line">    &lt;!-- git remote rm 别名1 --&gt;</span><br><span class="line">    git fetch 别名2</span><br><span class="line">    git branch -u 远程跟踪分支</span><br><span class="line">    git merge 对应的远程跟踪分支</span><br><span class="line">    git push (这里还是会提交到自己上面)</span><br><span class="line">    然后pull request</span><br></pre></td></tr></table></figure><h2 id="5-IDEA-git开发"><a href="#5-IDEA-git开发" class="headerlink" title="5. IDEA git开发"></a>5. IDEA git开发</h2><ol><li><p>在Version 中配置git</p></li><li><p>VCS -&gt; import into Version Control -&gt; Create GitRepository -&gt;选择要创建的仓库</p><ul><li>红色代码 工作区</li><li>绿色代码 add 之后 暂存区 </li><li>commit 之后到本地库中 ，变为正常颜色</li></ul></li></ol><ol start="3"><li>创建仓库，将本地仓库push到远程仓库 Git -&gt; Repository </li></ol><ul><li>Remotes 远程仓库的地址<ul><li>Pull 拉取</li><li>Push 发送</li></ul></li></ul><ol start="4"><li><p>其他人员clone 项目 VCS -&gt; Checkout… -&gt;填写地址</p><ol><li>修改 -&gt; add -&gt; commit  (如果要push到仓库需要权限)</li></ol></li><li><p>如果代码发送冲突</p><ol><li>idea会直接拒绝，需要远程更改 Merge</li><li>修改冲突 Head表示最新版本  ====表示远程代码</li></ol></li></ol><p><a href="https://gitee.com/progit/">Pro Git</a></p>]]></content>
      
      
      <categories>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring知识点</title>
      <link href="/2020/08/17/Spring/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/08/17/Spring/Spring%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-的理解"><a href="#Spring-的理解" class="headerlink" title="Spring 的理解"></a>Spring 的理解</h2><p>Spring 是一个开源框架，为简化企业级应用开发而生。Spring 可以是使简单的 JavaBean 实现以前只有 EJB 才能实现的功能。Spring 是一个 IOC 和 AOP 容器框架。</p><p>Spring 容器的主要核心是：</p><ul><li><code>控制反转（IOC）</code>，传统的 java 开发模式中，当需要一个对象时，我们会自己使用 new 或者 getInstance 等直接或者间接调用构造方法创建一个对象。而在 spring 开发模式中，spring 容器使用了工厂模式为我们创建了所需要的对象，不需要我们自己创建了，直接调用 spring 提供的对象就可以了，这是控制反转的思想。</li><li><code>依赖注入（DI）</code>，spring 使用 javaBean 对象的 set 方法或者带参数的构造方法为我们在创建所需对象时将其属性自动设置所需要的值的过程，就是依赖注入的思想。</li><li><code>面向切面编程（AOP）</code>，在面向对象编程（oop）思想中，我们将事物纵向抽成一个个的对象。而在面向切面编程中，我们将一个个的对象某些类似的方面横向抽成一个切面，对这个切面进行一些如权限控制、事物管理，记录日志等。公用操作处理的过程就是面向切面编程的思想。AOP 底层是动态代理，如果是接口采用 JDK 动态代理，如果是类采用CGLIB 方式实现动态代理。</li></ul><h2 id="使用Spring框架的好处是什么？缺点？"><a href="#使用Spring框架的好处是什么？缺点？" class="headerlink" title="使用Spring框架的好处是什么？缺点？"></a>使用Spring框架的好处是什么？缺点？</h2><p>好处：</p><ul><li><strong>轻量：</strong>Spring是轻量的，基本的版本大约2MB。</li><li><strong>控制反转：</strong>Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li><li><strong>面向切面的编程(AOP)：</strong>Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li><li><strong>容器：</strong>Spring包含并管理应用中对象的生命周期和配置。</li><li><strong>MVC</strong> <strong>框架</strong>：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li><li><strong>事务管理：</strong>Spring提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。</li><li><strong>异常处理：</strong>Spring提供方便的API把具体技术相关的异常（比如由JDBC，HibernateorJDO抛出的）转化为一致的unchecked异常。</li></ul><p>缺点：</p><ul><li>依赖反射，影响性能。</li></ul><h2 id="Spring-中的设计模式有哪些"><a href="#Spring-中的设计模式有哪些" class="headerlink" title="Spring 中的设计模式有哪些"></a>Spring 中的设计模式有哪些</h2><p><strong>工厂模式：</strong><br>BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p><p><strong>单例模式：</strong><br>Bean默认为单例模式。</p><p><strong>代理模式：</strong><br>Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p><p><strong>模板方法：</strong><br>用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p><p><strong>观察者模式：</strong><br>定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现ApplicationListener。</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="Spring-bean-的生命周期"><a href="#Spring-bean-的生命周期" class="headerlink" title="Spring bean 的生命周期"></a>Spring bean 的生命周期</h3><ul><li><p><code>Bean 定义</code>：在配置文件里面用</p><p>来进行定义。</p></li><li><p><code>Bean 初始化</code>：有两种方式初始化:<br>①在配置文件中通过指定 init-method 属性来完成<br>②实现 org.springframwork.beans.factory.InitializingBean 接口</p></li><li><p><code>Bean 调用</code>：有三种方式可以得到 bean 实例，并进行调用</p></li><li><p><code>Bean 销毁</code>：销毁有两种方式<br>①使用配置文件指定的 destroy-method 属性<br>②实现 org.springframwork.bean.factory.DisposeableBean 接口</p></li></ul><h3 id="Spring支持的几种bean的作用域。"><a href="#Spring支持的几种bean的作用域。" class="headerlink" title="Spring支持的几种bean的作用域。"></a>Spring支持的几种bean的作用域。</h3><p>Spring框架支持以下五种bean的作用域：</p><ul><li><strong>singleton:</strong>bean在每个Springioc容器中只有一个实例。</li><li><strong>prototype</strong>：一个bean的定义可以有多个实例。</li><li><strong>request</strong>：每次http请求都会创建一个bean，该作用域仅在基于web的SpringApplicationContext情形下有效。</li><li><strong>session</strong>：在一个HTTPSession中，一个bean定义对应一个实例。该作用域仅在基于web的SpringApplicationContext情形下有效。</li><li><strong>global-session</strong>：在一个全局的HTTPSession中，一个bean定义对应一个实例。该作用域仅在基于web的SpringApplicationContext情形下有效。</li></ul><p>缺省的Springbean的作用域是Singleton.</p><h3 id="Spring-框架中的bean是线程安全的吗"><a href="#Spring-框架中的bean是线程安全的吗" class="headerlink" title="Spring 框架中的bean是线程安全的吗?"></a><strong>Spring</strong> 框架中的bean是线程安全的吗?</h3><h4 id="原型Bean"><a href="#原型Bean" class="headerlink" title="原型Bean"></a>原型Bean</h4><p>对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。</p><h4 id="单例Bean"><a href="#单例Bean" class="headerlink" title="单例Bean"></a>单例Bean</h4><p>不，Spring框架中的单例bean不是线程安全的。</p><p>对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。</p><p>如果是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p><p>对于有状态的bean，Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法，比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。<br><strong>注： Spring容器本身并没有提供线程安全的策略，因此是否线程安全完全取决于Bean本身的特性。</strong></p><h3 id="IOC注入哪几种方式？"><a href="#IOC注入哪几种方式？" class="headerlink" title="IOC注入哪几种方式？"></a>IOC注入哪几种方式？</h3><ul><li><strong>构造器</strong>：构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。</li><li><strong>setter</strong>：Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。</li><li>接口</li></ul><h3 id="复杂类型的注入"><a href="#复杂类型的注入" class="headerlink" title="复杂类型的注入"></a>复杂类型的注入</h3><p>用于list结构的注入：list,array,set</p><p>用于map结构集合的注入：map，props</p><h3 id="那种依赖注入的方式比较好？"><a href="#那种依赖注入的方式比较好？" class="headerlink" title="那种依赖注入的方式比较好？"></a>那种依赖注入的方式比较好？</h3><p>两种依赖方式都可以使用，最好的解决方案是用构造器参数实现强制依赖，setter方法实现可选依赖。</p><h3 id="ApplicationContext-通常的实现是什么"><a href="#ApplicationContext-通常的实现是什么" class="headerlink" title="ApplicationContext 通常的实现是什么?"></a>ApplicationContext 通常的实现是什么?</h3><ul><li><strong>FileSystemXmlApplicationContext</strong> <strong>：</strong>此容器从一个XML文件中加载beans的定义，XMLBean配置文件的全路径名必须提供给它的构造函数。</li><li><strong>ClassPathXmlApplicationContext</strong> <strong>：</strong>此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置。</li><li><strong>AnnotationConfigApplicationContext</strong>：它是用于读取注解创建容器的。</li></ul><p><strong>BeanFactory和Applicationcontexts有什么区别？</strong></p><p>Applicationcontexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Applicationcontexts中以声明的方式处理。Applicationcontexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。<strong>适合单例对象使用</strong></p><p>BeanFactory <strong>多例对象使用</strong> ，它在构建核心容器时，创建对象采取的策略是采用延迟加载的方式。也就是说，什么时候根据id获取对象了，什么时候才真正的创建对象。</p><h3 id="不同方式的自动装配。"><a href="#不同方式的自动装配。" class="headerlink" title="不同方式的自动装配。"></a>不同方式的自动装配。</h3><p>有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。</p><ul><li><strong>no</strong>：默认的方式是不进行自动装配，通过显式设置ref属性来进行装配。</li><li><strong>byName</strong> <strong>：</strong>通过参数名自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</li><li><strong>byType:</strong>：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</li><li><strong>constructor</strong> <strong>：这个方式类似于</strong>byType，但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li><li><strong>autodetect</strong> <strong>：</strong>首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</li></ul><h3 id="自动装配有哪些局限性"><a href="#自动装配有哪些局限性" class="headerlink" title="自动装配有哪些局限性?"></a>自动装配有哪些局限性?</h3><p>自动装配的局限性是：</p><p><strong>重写</strong>：你仍需用和配置来定义依赖，意味着总要重写自动装配。</p><p><strong>基本数据类型</strong>：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</p><p><strong>模糊特性：</strong>自动装配不如显式装配精确，如果有可能，建议使用显式装配。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="Spring-管理事务的方式？"><a href="#Spring-管理事务的方式？" class="headerlink" title="Spring 管理事务的方式？"></a>Spring 管理事务的方式？</h3><ul><li><code>编程式事务：</code>在代码中硬编码。</li><li><code>声明式事务：</code>在配置文件中配置<br>声明式事务又分为：<br>①基于XML的声明式事务<br>②基于注解的声明式事务</li></ul><h3 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h3><p><strong>Joinpoint</strong>(连接点): 目标对象中所有可以增强的方法</p><p><strong>Pointcut</strong>(切入点): 我们对其进行增强的方法.</p><p><strong>Advice</strong>(通知/增强): 对切入点进行的增强操作</p><p>​        包括前置通知,后置通知,异常通知,最终通知,环绕通知</p><p><strong>Weaving</strong>(织入): 是指把增强应用到目标对象来创建新的代理对象的过程。</p><p><strong>Aspect</strong>(切面): 是切入点和通知的结合。它将多个类的通用行为封装成可重用的模块，该模块含有一组API提供横切功能。比如，一个日志模块可以被称作日志的AOP切面。</p><h3 id="Spring-的通知是什么？有哪几种类型？"><a href="#Spring-的通知是什么？有哪几种类型？" class="headerlink" title="Spring 的通知是什么？有哪几种类型？"></a>Spring 的通知是什么？有哪几种类型？</h3><p>Spring 切面可以应用五种类型的通知：</p><ul><li><code>before</code>：前置通知，在一个方法执行前被调用。</li><li><code>after</code>: 在方法执行之后调用的通知，无论方法执行是否成功。</li><li><code>after-returning</code>: 仅当方法成功完成后执行的通知。</li><li><code>after-throwing</code>: 在方法抛出异常退出时执行的通知。</li><li><code>around</code>: 在方法执行之前和之后调用的通知。</li></ul><h3 id="有几种不同类型的自动代理？"><a href="#有几种不同类型的自动代理？" class="headerlink" title="有几种不同类型的自动代理？"></a>有几种不同类型的自动代理？</h3><p>BeanNameAutoProxyCreator</p><p>DefaultAdvisorAutoProxyCreator</p><p>Metadataautoproxying</p><h3 id="Spring的事务传播行为有哪些"><a href="#Spring的事务传播行为有哪些" class="headerlink" title="Spring的事务传播行为有哪些"></a>Spring的事务传播行为有哪些</h3><p>1、<code>PROPAGATION_REQUIRED</code>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。<br>2、<code>PROPAGATION_SUPPORTS</code>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。<br>3、<code>PROPAGATION_MANDATORY</code>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。<br>4、<code>PROPAGATION_REQUIRES_NEW</code>：创建新事务，无论当前存不存在事务，都创建新事务。<br>5、<code>PROPAGATION_NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>6、<code>PROPAGATION_NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常。<br>7、<code>PROPAGATION_NESTED</code>：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</p><h3 id="Spring事务的隔离级别"><a href="#Spring事务的隔离级别" class="headerlink" title="Spring事务的隔离级别"></a>Spring事务的隔离级别</h3><p>1、<code>ISOLATION_DEFAULT</code>：这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。<br>2、<code>ISOLATION_READ_UNCOMMITTED</code>：读未提交，允许另外一个事务可以看到这个事务未提交的数据。<br>3、<code>ISOLATION_READ_COMMITTED</code>：读已提交，保证一个事务修改的数据提交后才能被另一事务读取，而且能看到该事务对已有记录的更新。<br>4、<code>ISOLATION_REPEATABLE_READ</code>：可重复读，保证一个事务修改的数据提交后才能被另一事务读取，但是不能看到该事务对已有记录的更新。<br>5、<code>ISOLATION_SERIALIZABLE</code>：一个事务在执行的过程中完全看不到其他事务对数据库所做的更新。</p><h2 id="Spring-的常用注解？"><a href="#Spring-的常用注解？" class="headerlink" title="Spring 的常用注解？"></a>Spring 的常用注解？</h2><p>@Required：该注解应用于设值方法,过一个bean定义的显式的属性值或通过自动装配<br>@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。<br>@Qualifier：当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier注解和@Autowire注解结合使用以消除这种混淆，指定需要装配的确切的bean。</p><p>@Aspect</p><h3 id="声明Bean的注解"><a href="#声明Bean的注解" class="headerlink" title="声明Bean的注解"></a>声明Bean的注解</h3><ul><li>@Component</li><li>@Service</li><li>@Controller</li><li>@Repository</li></ul><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把<code>Model，View，Controller</code>分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h3 id="SpringMVC-的工作原理？"><a href="#SpringMVC-的工作原理？" class="headerlink" title="SpringMVC 的工作原理？"></a>SpringMVC 的工作原理？</h3><ol><li>用户向服务器发送请求，请求被 springMVC 前端控制器 <code>DispatchServlet</code> 捕获；</li><li>DispatcherServle 对请求 URL 进行解析，得到请求资源标识符（URL），然后根据该 URL 调用 <code>HandlerMapping</code>，将请求映射到处理器 <code>HandlerExcutionChain</code>；</li><li>DispatchServlet 根据获得 Handler 选择一个合适的 <code>HandlerAdapter</code> 适配器处理；</li><li>Handler 对数据处理完成以后将返回一个 <code>ModelAndView（）</code>对象给 DisPatchServlet;</li><li>Handler 返回的 ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet 通过<br><code>ViewResolver</code> 试图解析器将逻辑视图转化为真正的视图 View;</li><li>DispatcherServle 通过 model 解析出 ModelAndView()中的参数进行解析最终展现出完整的  <code>view</code> 并返回给客户端;</li></ol><p>首先，服务器的前端处理器会根据前端的request请求查找到相应的处理映射器，处理映射器会在控制层查找到相应的方法，控制层再通过业务层来实现具体的业务操作（包括对数据库的处理，调用）如何再封装到相应的视图层，在视图层封装之后再通过业务层和控制层传回用户。</p><h3 id="说说Spring-MVC的几个重要组件？"><a href="#说说Spring-MVC的几个重要组件？" class="headerlink" title="说说Spring MVC的几个重要组件？"></a>说说Spring MVC的几个重要组件？</h3><p>1.<code>前端控制器 DispatcherServlet</code><br>作用：接收请求、响应结果，相当于转发器，有了DispatcherServlet 就减少了其它组件之间的耦合度。<br>2.<code>处理器映射器HandlerMapping</code><br>作用：根据请求的URL来查找Handler<br>3.<code>处理器适配器HandlerAdapter</code><br>注意：在编写Handler的时候要按照HandlerAdapter要求的规则去编写，这样适配器HandlerAdapter才可以正确的去执行Handler。<br>4.<code>处理器Handler</code><br>5.<code>视图解析器 ViewResolver</code><br>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）<br>6.<code>视图View</code><br>View是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf等等）</p><h3 id="SpringMVC-常用注解都有哪些？"><a href="#SpringMVC-常用注解都有哪些？" class="headerlink" title="SpringMVC 常用注解都有哪些？"></a>SpringMVC 常用注解都有哪些？</h3><ul><li><code>@requestMapping</code> 用于请求 url 映射。</li><li><code>@RequestBody</code> 注解实现接收 http 请求的 json 数据，将 json 数据转换为 java 对象。</li><li><code>@ResponseBody</code> 注解实现将 controller 方法返回对象转化为 <strong>json</strong> 响应给客户。</li><li><code>@PathVariable</code> URL 中占位符参数绑定到控制器处理方法的入参中</li><li><code>@Cacheable</code> 标记缓存查询</li><li><code>@CacheEvict</code> 清空缓存</li></ul><p>@RestController = @ResponseBody ＋ @Controller</p><h3 id="如何开启注解处理器和适配器？"><a href="#如何开启注解处理器和适配器？" class="headerlink" title="如何开启注解处理器和适配器？"></a>如何开启注解处理器和适配器？</h3><p>在 <code>springmvc.xml</code> 中通过开启 ``来实现注解处理器和适配器的开启。</p><h3 id="如何解决-get-和-post-乱码问题？"><a href="#如何解决-get-和-post-乱码问题？" class="headerlink" title="如何解决 get 和 post 乱码问题？"></a>如何解决 get 和 post 乱码问题？</h3><p><strong>post 请求乱码：</strong><br>在 <code>web.xml</code> 里边配置一个 <code>CharacterEncodingFilter</code> 过滤器。设置为 <code>utf-8</code>。</p><p><strong>get 请求的乱码：</strong><br>两种方法:<br>①修改 tomcat 配置文件添加编码与工程编码一致。<br>②对参数进行重新编码 <code>String userName = New String(Request.getParameter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;);</code></p><h3 id="SpringMVC怎么样设定重定向和转发的"><a href="#SpringMVC怎么样设定重定向和转发的" class="headerlink" title="SpringMVC怎么样设定重定向和转发的?"></a>SpringMVC怎么样设定重定向和转发的?</h3><p>1、转发：在返回值前面加<code>&quot;forward:&quot;</code><br>2、重定向：在返回值前面加<code>&quot;redirect:&quot;</code></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring循环依赖</title>
      <link href="/2020/08/17/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2020/08/17/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring循环依赖---属性注入---自动注入</span><br><span class="line">spring bean的生命周期</span><br><span class="line">springbean实例化的大概过程</span><br><span class="line">spring循环依赖</span><br><span class="line">spring中循环依赖是如何解决的</span><br><span class="line">spring中是默认支持循环依赖的</span><br><span class="line">这么证明他是默认支持的？这么关闭循环依赖</span><br><span class="line">spring解决循环依赖的细节--源码</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置一个循环依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.lq&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IndexService&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(userService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IndexService indexService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserService...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        ac.getBean(IndexService.class).getService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">IndexService</span></span><br><span class="line"><span class="comment">UserService...</span></span><br><span class="line"><span class="comment">com.lq.service.UserService@2de8284b</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>依赖注入，Spring初始化时就已经完成</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.初始化bean---bean有一个初始化的过程---Spring bean的生命周期</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><img src="/2020/08/17/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/spring生命周期.jpg" alt="spring生命周期" style="zoom:200%;"><p>所有的对象都是Bean? 不是 </p><p>所有的Bean都是对象</p><p>Bean的生命周期指的就是：在Spring中，Bean是如何生成的？</p><p>class—-beanDefinition —-object(bean)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">被Spring管理的对象叫做Bean。Bean的生成步骤如下：</span><br><span class="line">1. jvm讲所有的类加载到方法区</span><br><span class="line">2. Spring扫描class(@ComponentScan(&quot;com.lq&quot;))得到BeanDefinition</span><br><span class="line">3. 根据得到的BeanDefinition去生成bean</span><br><span class="line">4. 首先根据class推断构造方法</span><br><span class="line">5. 根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）</span><br><span class="line">6. 填充原始对象中的属性（依赖注入）</span><br><span class="line">7. 如果原始对象中的某个方法被AOP了，那么则需要根据原始对象生成一个代理对象</span><br><span class="line">8. 把最终生成的代理对象放入单例池（源码中叫做singletonObjects）中，下次getBean时就直接从单例池拿即可</span><br></pre></td></tr></table></figure><p>可以看到，对于Spring中的Bean的生成过程，步骤还是很多的，并且不仅仅只有上面的8步，还有很多很多，比如Aware回调、初始化等等，</p><p>在放入map之前 会检查类有没有实现BeanFactoryPostProcessor 扩展内容</p><p>Spring默认是支持循环依赖的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring在初始化bean生命周期的过程中有一个节阶段是，是判断容器是不是支持循环依赖，spring默认是支持的，需要通过spring 提供的api来修改修改这个属性关闭循环依赖的支持</span><br></pre></td></tr></table></figure><h4 id="Spring创建Bean的流程"><a href="#Spring创建Bean的流程" class="headerlink" title="Spring创建Bean的流程"></a>Spring创建Bean的流程</h4><p><img src="/2020/08/17/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/spring%E5%88%9B%E5%BB%BABean%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="在这里插入图片描述"></p><p>对Bean的创建最为核心三个方法解释如下：</p><ul><li><code>createBeanInstance</code>：例化，其实也就是调用对象的<strong>构造方法</strong>实例化对象</li><li><code>populateBean</code>：填充属性，这一步主要是对bean的依赖属性进行注入(<code>@Autowired</code>)</li><li><code>initializeBean</code>：回到一些形如<code>initMethod</code>、<code>InitializingBean</code>等方法</li></ul><p>从对<code>单例Bean</code>的初始化可以看出，循环依赖主要发生在<strong>第二步（populateBean）</strong>，也就是field属性注入的处理。</p><p>Spring在处理属性注入的时候有很多的后置处理器，用来对当前的类进行属性注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ibp.postProcessProPerties()//每个后置处理器负责一种注入</span><br><span class="line">//有注入Autowired 有注入 Resource的 有处理AOP的等等</span><br></pre></td></tr></table></figure><p>注入的流程，拿ndexService注入UserService</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需要从getBean(user)---从容器中取出</span><br><span class="line">可能拿不到---判断从第三个缓存中拿到---拿就开始new这个对象---就开始走UserService的生命周期---注入indexService---从容器中getBean(index) (这个容器就是单例池)</span><br><span class="line">到这里getBean时 会判断到indexService正在创建过程中，然后从一个缓存中获取这个对象，虽然index对象是一个半成品，但是还是可以给user注入成功。这里还需要判断spring是否支持循环依赖。</span><br><span class="line">因为所有正在创建的bean会被放入一个set集合，这集合用于判断这个对象是不是正在创建过程中。</span><br></pre></td></tr></table></figure><p><strong>获取单例Bean的源码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">   Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">   <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">         singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">         <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">               singletonObject = singletonFactory.getObject();</span><br><span class="line">               <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">               <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三个缓存"><a href="#三个缓存" class="headerlink" title="三个缓存"></a>三个缓存</h3><p>三个map</p><ol><li><p>singletonObjects Spring的容器 单例池 一级缓存<br><code>private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</code></p></li><li><p>earlySingletonObjects 二级缓存<br><code>private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);</code><br>表示缓存的是早期的bean对象。早期是什么意思？表示Bean的生命周期还没走完就把这个Bean放入了earlySingletonObjects。</p></li><li><p>singletonFactories 这里存放的就是单例工厂 三级缓存 这里存放的是一个ObjectFactory函数式接口<br><code>private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);</code></p></li></ol><h4 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h4><p>当前2个缓存中没有 ，这里需要判断是不是允许的循环依赖<br>从三级缓存中存入二级缓存，然后清除<br>在创建对象时会将创建的bean放入一个map (beanName,singletoFactory单例工厂)<br>    .getObject();这里可以产生一个对象，可以对对象做很多事情，如AOP<br>作用：工厂，用于产生一个对象<br>    从三级缓存中获取工厂，根据工厂产生一个对象，放入2级缓存中<br>问题：为什么不直接创建一个对象返回？三级缓存的意义<br>    防止重复创建，优化性能，创建一个新的对象消耗很多的资源，如使用AOP代理</p><h5 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.lq&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个切面</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotVeryUsefulAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.lq.service.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyPublicMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;anyPublicMethod()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------aop-----------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">IndexService</span></span><br><span class="line"><span class="comment">UserService...</span></span><br><span class="line"><span class="comment">-----------aop-----------</span></span><br><span class="line"><span class="comment">com.lq.service.UserService@2002fc1d</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在放入缓存的时候是放入一个工厂，方便之后使用AOP的代理</p><p>SpringBean初始化方法</p><p>先注解，在implement，再xml</p><p>Spring在执行生命周期回调时会按这个顺序进行检查。</p><h3 id="解决循环依赖思路分析"><a href="#解决循环依赖思路分析" class="headerlink" title="解决循环依赖思路分析"></a>解决循环依赖思路分析</h3><p>么如何打破这个循环，加个中间人（缓存）</p><img src="/2020/08/17/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/解决循环依赖.png" alt="image-20200817224030561" style="zoom:67%;"><p>A的Bean在创建过程中，在进行依赖注入之前，先把A的原始Bean放入缓存（提早暴露，只要放到缓存了，其他Bean需要时就可以从缓存中拿了），放入缓存后，再进行依赖注入，此时A的Bean依赖了B的Bean，如果B的Bean不存在，则需要创建B的Bean，而创建B的Bean的过程和A一样，也是先创建一个B的原始对象，然后把B的原始对象提早暴露出来放入缓存中，然后在对B的原始对象进行依赖注入A，此时能从缓存中拿到A的原始对象（虽然是A的原始对象，还不是最终的Bean），B的原始对象依赖注入完了之后，B的生命周期结束，那么A的生命周期也能结束。</p><p>因为整个过程中，都只有一个A原始对象，所以对于B而言，就算在属性注入时，注入的是A原始对象，也没有关系，因为A原始对象在后续的生命周期中在堆中没有发生变化。</p><p>从上面这个分析过程中可以得出，只需要一个缓存就能解决循环依赖了，那么为什么Spring中还需要<strong>singletonFactories</strong>呢？</p><p>这是难点，基于上面的场景想一个问题：如果A的原始对象注入给B的属性之后，A的原始对象进行了AOP产生了一个代理对象，此时就会出现，对于A而言，它的Bean对象其实应该是AOP之后的代理对象，而B的a属性对应的并不是AOP之后的代理对象，这就产生了冲突。</p><p><strong>B依赖的A和最终的A不是同一个对象</strong>。</p><p>那么如何解决这个问题？这个问题可以说没有办法解决。</p><p>因为在一个Bean的生命周期最后，Spring提供了BeanPostProcessor可以去对Bean进行加工，这个加工不仅仅只是能修改Bean的属性值，也可以替换掉当前Bean。</p><p>举个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里，生成了一个新的User对象</span></span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;user&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(bean);</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AnnotationConfigApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        </span><br><span class="line">        User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">com.lq.service.User@5e025e70</span></span><br><span class="line"><span class="comment">com.lq.service.User@1b0375b3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>所以在BeanPostProcessor中可以完全替换掉某个beanName对应的bean对象。</p><p>而BeanPostProcessor的执行在Bean的生命周期中是处于属性注入之后的，循环依赖是发生在属性注入过程中的，所以很有可能导致，<strong>注入给B对象的A对象和经历过完整生命周期之后的A对象，不是一个对象</strong>。这就是有问题的。</p><p><strong>所以这种情况下的循环依赖，Spring是解决不了的，因为在属性注入时，Spring也不知道A对象后续会经过哪些BeanPostProcessor以及会对A对象做什么处理</strong>。</p><h3 id="Spring到底解决了哪种情况下的循环依赖"><a href="#Spring到底解决了哪种情况下的循环依赖" class="headerlink" title="Spring到底解决了哪种情况下的循环依赖"></a>Spring到底解决了哪种情况下的循环依赖</h3><p>AOP就是通过一个BeanPostProcessor来实现的，这个BeanPostProcessor就是AnnotationAwareAspectJAutoProxyCreator，它的父类是AbstractAutoProxyCreator，而在Spring中AOP利用的要么是JDK动态代理，要么CGLib的动态代理，所以如果给一个类中的某个方法设置了切面，那么这个类最终就需要生成一个代理对象。</p><p>一般过程就是：A类—&gt;生成一个普通对象–&gt;属性注入–&gt;基于切面生成一个代理对象–&gt;把代理对象放入singletonObjects单例池中。</p><p>而AOP可以说是Spring中除开IOC的另外一大功能，而循环依赖又是属于IOC范畴的，所以这两大功能想要并存，Spring需要特殊处理。</p><p>如何处理的，就是利用了第三级缓存<strong>singletonFactories</strong>。</p><p>首先，singletonFactories中存的是某个beanName对应的ObjectFactory，在bean的生命周期中，生成完原始对象之后，就会构造一个ObjectFactory存入singletonFactories中。这个ObjectFactory是一个函数式接口，所以支持Lambda表达式：<strong>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</strong></p><p>上面的Lambda表达式就是一个ObjectFactory，执行该Lambda表达式就会去执行getEarlyBeanReference方法，而该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会去执行SmartInstantiationAwareBeanPostProcessor中的getEarlyBeanReference方法，而这个接口下的实现类中只有两个类实现了这个方法，一个是AbstractAutoProxyCreator，一个是InstantiationAwareBeanPostProcessorAdapter，它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InstantiationAwareBeanPostProcessorAdapter</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutoProxyCreator</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">    <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以很明显，在整个Spring中，默认就只有AbstractAutoProxyCreator真正意义上实现getEarlyBeanReference方法，而该类就是用来进行AOP的。上文提到的AnnotationAwareAspectJAutoProxyCreator的父类就是AbstractAutoProxyCreator。</p><p>那么getEarlyBeanReference方法到底在干什么？</p><p>首先得到一个cachekey，cachekey就是beanName。</p><p>然后把beanName和bean（这是原始对象）存入earlyProxyReferences中</p><p>调用wrapIfNecessary进行AOP，得到一个代理对象。</p><p><img src="/2020/08/17/Spring/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/%E8%A7%A3%E5%86%B3AOP.png" alt="img"></p><p><strong>左边文字</strong>：</p><p>这个ObjectFactory就是上文说的labmda表达式，中间有getEarlyBeanReference方法，注意存入singletonFactories时并不会执行lambda表达式，也就是不会执行getEarlyBeanReference方法</p><p><strong>右边文字</strong>：</p><p>从singletonFactories根据beanName得到一个ObjectFactory，然后执行ObjectFactory，也就是执行getEarlyBeanReference方法，此时会得到一个A原始对象经过AOP之后的代理对象，然后把该代理对象放入earlySingletonObjects中，注意此时并没有把代理对象放入singletonObjects中，那什么时候放入到singletonObjects中呢？</p><p>我们这个时候得来理解一下earlySingletonObjects的作用，此时，我们只得到了A原始对象的代理对象，<strong>这个对象还不完整，因为A原始对象还没有进行属性填充，所以此时不能直接把A的代理对象放入singletonObjects中，所以只能把代理对象放入earlySingletonObjects</strong>，假设现在有其他对象依赖了A，那么则可以从earlySingletonObjects中得到A原始对象的代理对象了，并且是A的同一个代理对象。</p><p>当B创建完了之后，A继续进行生命周期，而A在完成属性注入后，会按照它本身的逻辑去进行AOP，而此时我们知道A原始对象已经经历过了AOP，所以对于A本身而言，不会再去进行AOP了，那么怎么判断一个对象是否经历过了AOP呢？会利用上文提到的<strong>earlyProxyReferences</strong>，在AbstractAutoProxyCreator的postProcessAfterInitialization方法中，会去判断当前beanName是否在earlyProxyReferences，如果在则表示已经提前进行过AOP了，无需再次进行AOP。</p><p>对于A而言，进行了AOP的判断后，以及BeanPostProcessor的执行之后，就需要把A对应的对象放入singletonObjects中了，但是我们知道，应该是要A的代理对象放入singletonObjects中，所以此时需要从earlySingletonObjects中得到代理对象，然后入singletonObjects中。</p><p><strong>整个循环依赖解决完毕。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，总结一下三级缓存：</p><ol><li><strong>singletonObjects</strong>：缓存某个beanName对应的经过了完整生命周期的bean</li><li><strong>earlySingletonObjects</strong>：缓存提前拿原始对象进行了AOP之后得到的代理对象，原始对象还没有进行属性注入和后续的BeanPostProcessor等生命周期</li><li><strong>singletonFactories</strong>：缓存的是一个ObjectFactory，主要用来去生成原始对象进行了AOP之后得到的代理对象，在每个Bean的生成过程中，都会提前暴露一个工厂，这个<strong>工厂可能用到，也可能用不到</strong>，如果没有出现循环依赖依赖本bean，那么这个工厂无用，本bean按照自己的生命周期执行，执行完后直接把本bean放入singletonObjects中即可，如果出现了循环依赖依赖了本bean，则另外那个bean执行ObjectFactory提交得到一个AOP之后的代理对象(如果有AOP的话，如果无需AOP，则直接得到一个原始对象)。</li><li>其实还要一个缓存，就是<strong>earlyProxyReferences</strong>，它用来记录某个原始对象是否进行过AOP了。</li></ol><p><a href="https://blog.csdn.net/f641385712/article/details/92801300">https://blog.csdn.net/f641385712/article/details/92801300</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql高级</title>
      <link href="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/"/>
      <url>/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><h2 id="一、索引"><a href="#一、索引" class="headerlink" title="一、索引"></a>一、索引</h2><h3 id="B-Tree-原理"><a href="#B-Tree-原理" class="headerlink" title="B+ Tree 原理"></a>B+ Tree 原理</h3><p>b+树演示：  <a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a> </p><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h4><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。只有叶子节点存储数据。</p><p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key<del>i</del> 和 key<del>i+1</del>，且不为 null，则该指针指向节点的所有 key 大于等于 key<del>i</del> 且小于等于 key<del>i+1</del>。</p><img src="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/B+树.png" alt="image-20200815124537590" style="zoom:80%;"><h4 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h4><p>进行查找操作时，<strong>首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</strong></p><p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p><h4 id="3-与红黑树的比较"><a href="#3-与红黑树的比较" class="headerlink" title="3. 与红黑树的比较"></a>3. 与红黑树的比较</h4><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。</p><p>（一）<strong>B+ 树有更低的树高</strong></p><p>平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p><p>（二）<strong>磁盘访问原理</strong></p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，<strong>内存与磁盘以页为单位交换数据</strong>。数据库系统<strong>将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</strong></p><p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。<strong>B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比</strong>，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p><p>（三）<strong>磁盘预读特性</strong></p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h3 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h3><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h4 id="1-B-Tree-索引"><a href="#1-B-Tree-索引" class="headerlink" title="1. B+Tree 索引"></a>1. B+Tree 索引</h4><p>是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p><p><strong>可以指定多个列作为索引列，多个索引列共同组成键</strong>。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><h5 id="B-树的优势："><a href="#B-树的优势：" class="headerlink" title="B+树的优势："></a><strong>B+树的优势：</strong></h5><p>1.单一节点存储更多的元素，使得查询的IO次数更少。</p><p>2.所有查询都要查找到叶子节点，查询性能稳定。</p><p>3.所有叶子节点形成有序链表，便于范围查询。</p><p>InnoDB 的 B+Tree 索引分为<strong>主索引和辅助索引</strong>。<strong>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。</strong>因为无法把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引。</strong></p><img src="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/主索引.png" alt="image-20200815204457542" style="zoom:67%;"><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><img src="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/辅助索引.png" alt="image-20200815204823473" style="zoom:67%;"><h5 id="InnoDB的聚簇索引"><a href="#InnoDB的聚簇索引" class="headerlink" title="InnoDB的聚簇索引"></a>InnoDB的聚簇索引</h5><ol><li><strong>InnoDB对主键建立聚簇索引</strong>。</li><li>如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。</li><li>如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。</li></ol><p>InnoDB默认使用聚簇索引来组织数据，如果你用InnoDB，而且不需要特殊的聚簇索引，一个好的做法就是使用代理主键(surrogate key)——独立于你的应用中的数据。最简单的做法就是使用一个AUTO_INCREMENT的列，这会保证记录按照顺序插入，而且能提高使用primary key进行连接的查询的性能。应该尽量避免随机的聚簇主键，例如字符串主键就是一个不好的选择，它使得插入操作变得随机。</p><p>一般来说，DBMS都会以聚簇索引的形式来存储实际的数据，它是其它二级索引的基础：</p><ul><li>聚簇索引（primary索引）：主键索引</li><li>非聚簇索引（second索引）：二级索引</li></ul><h5 id="聚簇索引结构"><a href="#聚簇索引结构" class="headerlink" title="聚簇索引结构"></a>聚簇索引结构</h5><p>聚簇索引的结构大致如下：</p><ul><li><strong>聚簇索引：节点页只包含了索引列，叶子页包含了行的全部数据。</strong>聚簇索引“就是表”，因此可以不需要独立的行存储。</li></ul><p><strong>聚簇索引保证关键字的值相近的元组存储的物理位置也相近</strong>（所以字符串类型不宜建立聚簇索引，特别是随机字符串，会使得系统进行大量的移动操作）。</p><ul><li><strong>二级索引：</strong>叶子节点保存的不是指行的物理位置的指针，<strong>而是行的主键值</strong>。</li></ul><p>这意味着通过二级索引查找行，存储引擎需要：1、找到二级索引的叶子节点获取对应的主键值，2、根据这个主键值去聚簇索引中查找到对应的行。这里需要两次B-Tree查找而不是一次。</p><p>覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚簇索引组织数据，如果二级索引中包含查询</p><p><img src="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="img"></p><p>若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）</p><p>MyISAM使用的是非聚簇索引，<strong>非聚簇索引的两棵B+树看上去没什么不同</strong>，节点的结构完全一致只是存储的内容不同而已，<strong>主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。</strong>表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于<strong>索引树是独立的，通过辅助键检索无需访问主键的索引树</strong>。</p><p><img src="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/mysql%E9%AB%98%E7%BA%A7%5CMyISAM.jpg" alt="img"></p><h5 id="使用聚簇索引的优势"><a href="#使用聚簇索引的优势" class="headerlink" title="使用聚簇索引的优势"></a>使用聚簇索引的优势</h5><p>1.由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，<strong>访问同一数据页不同行记录时，已经把页加载到了Buffer中（缓存器），再次访问时，会在内存中完成访问，不必访问磁盘。</strong>这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p><p>2.辅助索引的叶子节点，<strong>存储主键值，而不是数据的存放地址。</strong>好处是当行数据放生变化时，索引树的节点也需要分裂变化；或者是我们需要查找的数据，在上一次IO读写的缓存中没有，需要发生一次新的IO操作时，可以避免对辅助索引的维护工作，<strong>只需要维护聚簇索引树就好了</strong>。另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。</p><p>注：我们知道一次io读写，可以获取到16K大小的资源，我们称之为读取到的数据区域为Page。而我们的B树，B+树的索引结构，叶子节点上存放好多个关键字（索引值）和对应的数据，都会在一次IO操作中被读取到缓存中，所以在访问同一个页中的不同记录时，会在内存里操作，而不用再次进行IO操作了。除非发生了页的分裂，即要查询的行数据不在上次IO操作的换村里，才会触发新的IO操作。</p><p>3.因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。（强烈的对比）</p><p>4.不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。</p><p><strong>聚簇索引需要注意的地方</strong></p><p>当使用主键为聚簇索引时，主键最好不要使用uuid，因为uuid的值太过离散，不适合排序且可能出线新增加记录的uuid，会插入在索引树中间的位置，导致索引树调整复杂度变大，消耗更多的时间和资源。</p><p>建议使用int类型的自增，方便排序并且默认会在索引树的末尾增加主键值，<strong>对索引树的结构影响最小。</strong>而且，主键值占用的存储空间越大，辅助索引中保存的主键值也会跟着变大，占用存储空间，也会影响到IO操作读取到的数据量。</p><p><strong>为什么主键通常建议使用自增id</strong></p><p><strong>聚簇索引的数据的物理存放顺序与索引顺序是一致的</strong>，即：<strong>只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的</strong>。如果主键不是自增id，那么可以想 象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。</p><h4 id="2-哈希索引"><a href="#2-哈希索引" class="headerlink" title="2. 哈希索引"></a>2. 哈希索引</h4><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h4 id="3-全文索引"><a href="#3-全文索引" class="headerlink" title="3. 全文索引"></a>3. 全文索引</h4><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h4 id="4-空间数据索引"><a href="#4-空间数据索引" class="headerlink" title="4. 空间数据索引"></a>4. 空间数据索引</h4><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ul><li>单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引</li><li>唯一索引 ：索引列的值必须唯一，但允许有空值</li><li>复合索引 ：即一个索引包含多个列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建</span><br><span class="line">CREATE [UNIQUE] INDEX  indexName ON mytable(columnname(length));</span><br><span class="line">ALTER mytable ADD [UNIQUE]  INDEX [indexName] ON(columnname(length));</span><br><span class="line">删除</span><br><span class="line">DROP INDEX [indexName] ON mytable;</span><br><span class="line">查看</span><br><span class="line">SHOW INDEX FROM table_name\G</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h4 id="1-独立的列"><a href="#1-独立的列" class="headerlink" title="1. 独立的列"></a>1. 独立的列</h4><p>在进行查询时，<strong>索引列不能是表达式的一部分，也不能是函数的参数</strong>，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</span><br></pre></td></tr></table></figure><h4 id="2-多列索引"><a href="#2-多列索引" class="headerlink" title="2. 多列索引"></a>2. 多列索引</h4><p>在需要<strong>使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。</strong>例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT film_id, actor_ id FROM sakila.film_actor</span><br><span class="line">WHERE actor_id = 1 AND film_id = 1;</span><br></pre></td></tr></table></figure><h4 id="3-索引列的顺序"><a href="#3-索引列的顺序" class="headerlink" title="3. 索引列的顺序"></a>3. 索引列的顺序</h4><p><strong>让选择性最强的索引列放在前面。</strong></p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,</span><br><span class="line">COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,</span><br><span class="line">COUNT(*)</span><br><span class="line">FROM payment;</span><br><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure><h4 id="4-前缀索引"><a href="#4-前缀索引" class="headerlink" title="4. 前缀索引"></a>4. 前缀索引</h4><p>对于 <strong>BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引</strong>，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p><h4 id="5-回表查询"><a href="#5-回表查询" class="headerlink" title="5.回表查询"></a>5.回表查询</h4><p><a href="https://www.jianshu.com/p/8991cbca3854">https://www.jianshu.com/p/8991cbca3854</a></p><p>这先要从InnoDB的索引实现说起，InnoDB有两大类索引：</p><ul><li>聚集索引(clustered index)</li><li>普通索引(secondary index)</li></ul><p>InnoDB<strong>聚集索引</strong>的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引：</p><p>InnoDB<strong>普通索引</strong>的叶子节点存储主键值。</p><p><strong>普通索引的查询过程是怎么样的呢？</strong></p><p>通常情况下，需要扫码两遍索引树。</p><img src="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/回表查询.png" alt="image-20200914201632936" style="zoom:67%;"><p>如<strong>粉红色</strong>路径，需要扫码两遍索引树：</p><p>（1）先通过普通索引定位到主键值id=5；</p><p>（2）在通过聚集索引定位到行记录；</p><h4 id="6-覆盖索引"><a href="#6-覆盖索引" class="headerlink" title="6. 覆盖索引"></a>6. 覆盖索引</h4><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（<strong>B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表</strong>）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h3 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h3><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul><h2 id="二、查询性能优化"><a href="#二、查询性能优化" class="headerlink" title="二、查询性能优化"></a>二、查询性能优化</h2><h3 id="使用-Explain-进行分析"><a href="#使用-Explain-进行分析" class="headerlink" title="使用 Explain 进行分析"></a>使用 Explain 进行分析</h3><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p><img src="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/explain.png" alt></p><p>字段有：</p><ul><li><p><strong>id</strong>:select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</p></li><li><ol><li><p>id相同，执行顺序由上至下</p></li><li><p>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p></li><li><p>id相同不同，同时存在id值越大优先级越高</p></li></ol></li></ul><pre><code>id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行衍生= DERIVED</code></pre><ul><li><strong>select_type</strong> : 查询类型，有简单查询、联合查询、子查询等</li></ul><ul><li><p><strong>type</strong>：显示查询使用了何种类型从最好到最差依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt;unique_subquery &gt; index_subquery &gt; range &gt; index &gt;ALL</p><p><strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index</strong> <strong>&gt;ALL</strong></p><p>一般来说，得保证查询<strong>至少达到range 级别</strong>，最好能达到ref。</p><ul><li>const 表示通过索引一次就找到了，const用于比较primary     key或者unique索引。因为只匹配一行数据，所以很快。如将主键至于where列表中，MySQL就能将该查询转换为一个常量</li><li>eq_ref :唯一性索引，对于每个索引键，<strong>表中只有一条记录与之匹配</strong>，常见于主键或唯一索引扫描</li><li>ref :非唯一索引扫描，<strong>返回匹配某个单独值的所有行</strong>。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</li><li>range : <strong>只检索给定范围的行</strong>，使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为他只需要开始索引的某一点，而结束语另一点，不用扫描全部索引</li><li>index ：Full Index     Scan,index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但<strong>index是从索引中读取的</strong>，而all是从硬盘中读的）</li></ul></li><li><p>possible_keys：显示可能应用在这张表中的索引,一个或多个。</p><p>查询涉及的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p></li><li><p>key : 使用的索引</p></li><li><p>rows : 扫描的行数</p></li><li><p>Extra：包含不适合在其他列中显示但十分重要的额外信息</p><ul><li>1.Using filesort：</li></ul><p>说明mysql会对数据使用一个<strong>外部的索引排序</strong>，而不是按照表内的索引顺序进行读取。</p><p>MySQL中<strong>无法利用索引完成排序操作成为“文件排序”</strong></p><ul><li>2.Using temporary：</li></ul><p>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by 和分组查询 group by</p><ul><li>3.USING index：</li></ul><p>覆盖索引（Covering Index）</p><p>代表表示相应的select 操作中使用了覆盖索引(Covering Index)，<strong>避免访问了表的数据行，效率不错！</strong></p><p>如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。</p><p>利用索引进行了排序或分</p></li></ul><h3 id="索引分析"><a href="#索引分析" class="headerlink" title="索引分析"></a>索引分析</h3><ul><li><p>当使用表连接时：</p><p><strong>左连接建右表，右连接建左表。</strong>理由：以左连接为例，左表的信息全都有，所以右表需要查找，所以建立右表index。</p><p><strong>Join语句的优化</strong></p><ul><li>尽可能减少Join语句中的NestedLoop的循环总次数：“<strong>永远用小结果集驱动大的结果集</strong>”。</li><li>优先优化NestedLoop的<strong>内层循环</strong>。</li><li>保证Join语句中被驱动表上Join条件字段<strong>已经被索引</strong>。</li><li>当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝惜JoinBuffer的设置。</li></ul></li></ul><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ol><li><p>全值匹配我最爱</p><p>SQL 中查询字段的顺序，跟使用索引中字段的顺序，没有关系。优化器会在不影响SQL 执行结果的前提下，给你自动地优化。</p></li><li><p><strong>最佳左前缀法则</strong>：</p></li></ol><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p><ol start="3"><li><p>不在索引列上作任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</p></li><li><p>存储引擎不能使用索引中<strong>范围条件右边的列</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysq1&gt; EXPLAIN SELECT* FROM staffs WHERE NAME = &#x27;Ju1y&#x27; AND age = 25 and pos=&#x27;manager&#x27;;</span><br><span class="line">#age之后索引失效</span><br><span class="line">EXPLAIN SELECT* FROM staffs WHERE NAME = &#x27; Ju1y&#x27; AND age &gt; 25 and pos= &#x27; manager&#x27; ;</span><br></pre></td></tr></table></figure></li><li><p>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</p></li><li><p>mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</p></li><li><p>is null，is not null也无法使用索引</p></li><li><p>like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作</p><ol><li><p>只要select的子弹刚好是主键，就会使用到索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select idfrom emp where ename like &#x27;%haha%&#x27;\G</span><br><span class="line">#不适应索引</span><br><span class="line">select * from empwhere ename like &#x27;%haha%&#x27;\G</span><br></pre></td></tr></table></figure></li><li><p><strong>覆盖索引法</strong>:覆盖索引是一种特殊的多列索引，<strong>当多列索引指向一个查询语句中所有的字段时，该多列索引就被称为覆盖索引</strong>。</p><p>使用覆盖索引可以解决问题！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create index index_ename_job on emp(ename,job);</span><br><span class="line"></span><br><span class="line">select id,job,ename from emp where ename like &#x27;% %&#x27;;</span><br></pre></td></tr></table></figure><p>当然，如果你想要select很多字段甚至是select*，那你可以创建一个多列索引指向所有字段</p></li></ol></li><li><p>字符串不加单引号索引失效</p></li><li><p>少用or，用它来连接时会索引失效</p><p>使用union all 或者union 来替代：</p></li></ol><h3 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h3><h4 id="1-减少请求的数据量"><a href="#1-减少请求的数据量" class="headerlink" title="1. 减少请求的数据量"></a>1. 减少请求的数据量</h4><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h4 id="2-减少服务器端扫描的行数"><a href="#2-减少服务器端扫描的行数" class="headerlink" title="2. 减少服务器端扫描的行数"></a>2. 减少服务器端扫描的行数</h4><p>最有效的方式是使用索引来覆盖查询。</p><h3 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h3><h4 id="1-切分大查询"><a href="#1-切分大查询" class="headerlink" title="1. 切分大查询"></a>1. 切分大查询</h4><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);</span><br><span class="line"></span><br><span class="line">rows_affected = 0</span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected = do_query(</span><br><span class="line">    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)</span><br><span class="line">&#125; while rows_affected &gt; 0</span><br></pre></td></tr></table></figure><h4 id="2-分解大连接查询"><a href="#2-分解大连接查询" class="headerlink" title="2. 分解大连接查询"></a>2. 分解大连接查询</h4><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag</span><br><span class="line">JOIN tag_post ON tag_post.tag_id=tag.id</span><br><span class="line">JOIN post ON tag_post.post_id=post.id</span><br><span class="line">WHERE tag.tag=&#x27;mysql&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;;</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id=1234;</span><br><span class="line">SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure><h2 id="三、存储引擎"><a href="#三、存储引擎" class="headerlink" title="三、存储引擎"></a>三、存储引擎</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p>不支持事务。</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li><li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li><li>外键：InnoDB 支持外键。</li><li>备份：InnoDB 支持在线热备份。</li><li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li><li>其它特性：MyISAM 支持压缩表和空间数据索引。</li></ul><p><img src="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AF%94%E8%BE%83.png" alt></p><h2 id="四、数据类型"><a href="#四、数据类型" class="headerlink" title="四、数据类型"></a>四、数据类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p><p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>FLOAT 和 DOUBLE 为浮点类型，<strong>DECIMAL 为高精度小数类型</strong>。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 <strong>DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</strong></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p><h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p><h4 id="1-DATETIME"><a href="#1-DATETIME" class="headerlink" title="1. DATETIME"></a>1. DATETIME</h4><p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p><p>它与时区无关。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h4 id="2-TIMESTAMP"><a href="#2-TIMESTAMP" class="headerlink" title="2. TIMESTAMP"></a>2. TIMESTAMP</h4><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p><p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p><p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><h2 id="五、切分"><a href="#五、切分" class="headerlink" title="五、切分"></a>五、切分</h2><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><p><img src="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/%E6%B0%B4%E5%B9%B3%E5%88%86%E5%89%B2.png" alt="img"></p><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p><p><img src="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/%E5%9E%82%E7%9B%B4%E5%88%86%E5%89%B2.png" alt="img"></p><h3 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h3><ul><li>哈希取模：hash(key) % N；</li><li>范围：可以是 ID 范围也可以是时间范围；</li><li>映射表：使用单独的一个数据库来存储映射关系。</li></ul><h3 id="Sharding-存在的问题"><a href="#Sharding-存在的问题" class="headerlink" title="Sharding 存在的问题"></a>Sharding 存在的问题</h3><h4 id="1-事务问题"><a href="#1-事务问题" class="headerlink" title="1. 事务问题"></a>1. 事务问题</h4><p>使用分布式事务来解决，比如 XA 接口。</p><h4 id="2-连接"><a href="#2-连接" class="headerlink" title="2. 连接"></a>2. 连接</h4><p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p><h4 id="3-ID-唯一性"><a href="#3-ID-唯一性" class="headerlink" title="3. ID 唯一性"></a>3. ID 唯一性</h4><ul><li>使用全局唯一 ID（GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ul><h2 id="六、复制"><a href="#六、复制" class="headerlink" title="六、复制"></a>六、复制</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li><li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><img src="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/主从复制.png" alt="img" style="zoom:80%;"><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><img src="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E9%AB%98%E7%BA%A7/读写分离.png" alt="img" style="zoom:80%;"><p><a href="https://my.oschina.net/xiaoyoung/blog/3046779">https://my.oschina.net/xiaoyoung/blog/3046779</a></p><ul><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a></li><li><a href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析</a></li><li><a href="https://tech.meituan.com/dianping_order_db_sharding.html">大众点评订单系统分库分表实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务和锁</title>
      <link href="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/"/>
      <url>/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><p>MySQL数据库中事务默认自动提交</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">事务提交的两种方式：</span><br><span class="line">自动提交：</span><br><span class="line">mysql就是自动提交的</span><br><span class="line">一条DML(增删改)语句会自动提交一次事务。</span><br><span class="line"></span><br><span class="line">手动提交：</span><br><span class="line">Oracle 数据库默认是手动提交事务</span><br><span class="line">需要先开启事务，再提交</span><br><span class="line"></span><br><span class="line">修改事务的默认提交方式：</span><br><span class="line">查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交 0 代表手动提交 </span><br><span class="line">修改默认提交方式： set @@autocommit = 0;</span><br></pre></td></tr></table></figure><h2 id="事务的四大特征（ACID）"><a href="#事务的四大特征（ACID）" class="headerlink" title="事务的四大特征（ACID）"></a>事务的四大特征（ACID）</h2><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p><h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对系统崩溃的情况。</li></ul><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/ACID关系.png" alt="image-20200815101847222" style="zoom: 80%;"><h4 id="Mysql怎么保证一致性的？"><a href="#Mysql怎么保证一致性的？" class="headerlink" title="Mysql怎么保证一致性的？"></a>Mysql怎么保证一致性的？</h4><p>​     从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。</p><p>​     从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据。</p><h4 id="Mysql怎么保证原子性的？"><a href="#Mysql怎么保证原子性的？" class="headerlink" title="Mysql怎么保证原子性的？"></a>Mysql怎么保证原子性的？</h4><p>　　 利用Innodb的<code>undo log</code>。 </p><p>　　　<code>undo log</code>名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。</p><p>​     例如</p><ul><li>(1)当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据</li><li>(2)当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作</li><li>(3)当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作</li></ul><p><code>undo log</code>记录了这些回滚需要的信息，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</p><p>-————————————————————————————————-</p><h4 id="Mysql怎么保证持久性的？"><a href="#Mysql怎么保证持久性的？" class="headerlink" title="Mysql怎么保证持久性的？"></a>Mysql怎么保证持久性的？</h4><p> 　利用Innodb的<code>redo log（</code>重做日志）。</p><p>　　 正如之前说的，Mysql是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。</p><p>　　 <em>怎么解决这个问题？</em> </p><p>　　简单啊，事务提交前直接把数据写入磁盘就行啊。 </p><p>　　<em>这么做有什么问题？</em></p><ul><li>只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。</li><li>毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。</li></ul><p>　　采用<code>redo log</code>解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在<code>redo log</code>中记录这次操作。当事务提交的时候，会将<code>redo log</code>日志进行刷盘(<code>redo log</code>一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将<code>redo log</code>中的内容恢复到数据库中，再根据<code>undo log</code>和<code>binlog</code>内容决定回滚数据还是提交数据。</p><p>　　<em>采用redo log的好处？</em></p><p>　　<code>redo log</code>进行刷盘比对数据页刷盘效率高，具体表现如下</p><ul><li><ul><li><code>redo log</code>体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。</li><li><code>redo log</code>是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。</li></ul><p>-————————————————————————————————-</p></li></ul><h4 id="Mysql怎么保证隔离性的？"><a href="#Mysql怎么保证隔离性的？" class="headerlink" title="Mysql怎么保证隔离性的？"></a>Mysql怎么保证隔离性的？</h4><p>　　<em>利用的是锁和MVCC机制。</em></p><p>　　MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快照数据在<code>undo log</code>中。 如果一个事务读取的行正在做DELELE或者UPDATE操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。 </p><h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/丢失修改.png" style="zoom: 80%;"><h3 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h3><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><p>一个事务，读取到另一个事务中<strong>没有提交</strong>的数据</p><p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E8%AF%BB%E8%84%8F%E6%95%B0%E6%8D%AE.png" alt="image-20200815102631015"></p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png" alt="image-20200815102810415"></p><h3 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h3><p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E5%B9%BB%E5%BD%B1%E8%AF%BB.png" alt="image-20200815102940318"></p><p>一个事务<strong>操作(DML)</strong>数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p><strong>未提交读（READ UNCOMMITTED）</strong></p><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><p><strong>提交读（READ COMMITTED）</strong></p><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><p><strong>可重复读（REPEATABLE READ）</strong></p><p>保证在同一个事务中多次读取同一数据的结果是一样的。</p><p><strong>可串行化（SERIALIZABLE）</strong></p><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p><p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png" alt="image-20200815103853857"></p><p>幻读临键锁可以解决</p><h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，<strong>写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</strong></p><p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p><p><strong>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</strong></p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><ul><li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li></ul><h3 id="Undo-日志"><a href="#Undo-日志" class="headerlink" title="Undo 日志"></a>Undo 日志</h3><p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p><p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t(id, x) VALUES(1, &quot;a&quot;);</span><br><span class="line">UPDATE t SET x=&quot;b&quot; WHERE id=1;</span><br><span class="line">UPDATE t SET x=&quot;c&quot; WHERE id=1;</span><br></pre></td></tr></table></figure><p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p><p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/Undo%E6%97%A5%E5%BF%97.png" alt="image-20200815104813509"></p><p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>MVCC 维护了一个 ReadView 结构，主要<strong>包含了当前系统未提交的事务列表</strong> TRX_IDs {TRX_ID_1, TRX_ID_2, …}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。</p><p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p><ul><li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li><li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li><li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：<ul><li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li><li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li></ul></li></ul><p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</p><h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><h4 id="1-快照读"><a href="#1-快照读" class="headerlink" title="1. 快照读"></a>1. 快照读</h4><p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table ...;</span><br></pre></td></tr></table></figure><h4 id="2-当前读"><a href="#2-当前读" class="headerlink" title="2. 当前读"></a>2. 当前读</h4><p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT;</span><br><span class="line">UPDATE;</span><br><span class="line">DELETE;</span><br></pre></td></tr></table></figure><p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE ? lock in share mode;</span><br><span class="line">SELECT * FROM table WHERE ? for update;</span><br></pre></td></tr></table></figure><h1 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h1><ul><li><p>表锁</p></li><li><p>行锁</p></li><li><p>间隙锁（Gap Locks）</p></li><li><p>临键锁（Next-key Locks）</p></li><li><p>共享锁/排他锁（Shared and Exclusive Locks）</p></li><li><p>意向共享锁/意向排他锁（Intention Shared and Exclusive Locks）</p></li><li><p>插入意向锁（Insert Intention Locks）</p></li><li><p>自增锁（Auto-inc Locks）</p></li></ul><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">动增加表锁</span><br><span class="line">lock table 表名字 read(write), 表名字2 read(write), 其他;</span><br><span class="line">查看表上加过的锁</span><br><span class="line">show open tables;</span><br><span class="line">释放表锁</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br><span class="line">线程1 加读锁 lock table 表名字 read;</span><br><span class="line">线程1不能查询它没有锁定的表，也不能更新这个锁定的表。</span><br><span class="line">其他线程可以查询该表的数据，也可以查询其他表的数据，但不能这个加锁的表进行修改，会一直等待获得锁。</span><br><span class="line"></span><br><span class="line">线程1 加写锁 lock table 表名字 write;</span><br><span class="line">线程1可以对表进行查询、更新、删除等操作</span><br><span class="line">其他线程对这个表的操作会阻塞。</span><br></pre></td></tr></table></figure><p><strong>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。</strong></p><p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E8%A1%A8%E9%94%81.png" alt="img"></p><p>表锁分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#看看哪些表被加锁了：</span><br><span class="line">show open tables;</span><br><span class="line">#检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定。</span><br><span class="line">show status like ‘table%</span><br><span class="line"></span><br><span class="line">Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1；</span><br><span class="line">Table_locks_waited：出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值加1），此值高则说明存在着较严重的表级锁争用情况。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p><h2 id="行锁-记录锁"><a href="#行锁-记录锁" class="headerlink" title="行锁(记录锁)"></a>行锁(记录锁)</h2><ul><li><p>偏向Innodb存储引擎，开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。</p></li><li><p>Innodb与MyISAM的最大不同有两点：</p></li><li><ul><li>一是支持事务（TRANSACTION）</li><li>而是采用了行级锁</li></ul></li></ul><p>行锁就是针对数据表中行记录的锁。比如事务A更新了一行，而这时候事务B也要更新同一行，则必须等事务A的操作完成后才能进行更新</p><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p><strong>一级封锁协议</strong></p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/Blog/source/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E4%B8%80%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.png" alt="image-20200815095233877"></p><p><strong>二级封锁协议</strong></p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/Blog/source/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E4%BA%8C%E7%BA%A7%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.png" alt="image-20200815095603609"></p><p><strong>三级封锁协议</strong></p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/Blog/source/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E4%B8%89%E7%BA%A7%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE.png" alt></p><h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/Blog/source/_posts/数据库/mysql事务和锁/两段锁协议.png" alt="在这里插入图片描述" style="zoom:67%;"><p>加锁和解锁分为两个阶段进行。</p><p>事务A持有的两个记录的行锁都是在commit的时候才释放的，事务B的update语句会被阻塞，直到事务A执行commit之后，事务B才能继续执行</p><p><strong>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议</strong></p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure><p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure><h3 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h3><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放**</span><br><span class="line"></span><br><span class="line">假设要实现一个电影票在线交易业务，顾客A要在影院B购买电影票。业务需要涉及到以下操作：</span><br><span class="line"></span><br><span class="line">1.从顾客A账户余额中扣除电影票价</span><br><span class="line"></span><br><span class="line">2.给影院B的账户余额增加这张电影票价</span><br><span class="line"></span><br><span class="line">3.记录一条交易日志</span><br><span class="line"></span><br><span class="line">为了保证交易的原子性，要把这三个操作放在一个事务中。如何安排这三个语句在事务中的顺序呢？</span><br><span class="line"></span><br><span class="line">如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。根据两阶段锁协议，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度</span><br></pre></td></tr></table></figure><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK In SHARE MODE;</span><br><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure><h3 id="行锁升级表锁"><a href="#行锁升级表锁" class="headerlink" title="行锁升级表锁"></a>行锁升级表锁</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Session 1</span><br><span class="line">begin;</span><br><span class="line">select * from t1 where name = &#x27;张三&#x27; for update;</span><br><span class="line"></span><br><span class="line">ROLLBACK</span><br><span class="line">COMMIT</span><br><span class="line"></span><br><span class="line">/****************************************************************************/</span><br><span class="line">Session 2</span><br><span class="line">begin;</span><br><span class="line">select * from t1 where id = 3 for update;</span><br><span class="line"></span><br><span class="line">ROLLBACK</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><p>session2 因为行锁升级为表锁一直在等待</p><p>InnoDB 行级锁是通过<strong>给索引上的索引项加锁</strong>来实现的，InnoDB行级锁只有通过索引条件检索数据，才使用行级锁;否则，InnoDB使用表锁 在不通过索引(主 键)条件查询的时候，InnoDB是表锁而不是行锁。</p><p><strong>如果在更新数据的时候出现了强制类型转换导致索引失效</strong>，使得行锁变表锁.</p><h2 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h2><p>间隙锁则锁的是若干个索引间的间隙，每个间隙都是两端开放的区间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的Next-Key Locking 算法，请务必牢记：使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;</span><br><span class="line">即所有在（1，10）区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。</span><br><span class="line"></span><br><span class="line">除了手动加锁外，在执行完某些 SQL 后，InnoDB 也会自动加间隙锁。</span><br></pre></td></tr></table></figure><p>面试常问：常考如何锁定一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表 where 某一行的条件 for update;</span><br></pre></td></tr></table></figure><h2 id="临键锁（Next-Key-Locks）"><a href="#临键锁（Next-Key-Locks）" class="headerlink" title="临键锁（Next-Key Locks）"></a>临键锁（Next-Key Locks）</h2><p>(间隙锁+行锁)</p><p>Next-Key 可以理解为一种特殊的间隙锁，也可以理解为一种特殊的算法。通过临建锁可以解决<code>幻读</code>的问题。 每个数据行上的<code>非唯一索引列</code>上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段<strong>左开右闭</strong>间的数据。需要强调的一点是，<code>InnoDB</code> 中<code>行级锁</code>是基于索引实现的，临键锁只与<code>非唯一索引列</code>有关，在<code>唯一索引列</code>（包括<code>主键列</code>）上不存在临键锁。</p><p>假设有如下表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test` (</span><br><span class="line">  `id` int(1) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(8) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `test` VALUES (&#x27;1&#x27;, &#x27;小罗&#x27;);</span><br><span class="line">INSERT INTO `test` VALUES (&#x27;5&#x27;, &#x27;小黄&#x27;);</span><br><span class="line">INSERT INTO `test` VALUES (&#x27;7&#x27;, &#x27;小明&#x27;);</span><br><span class="line">INSERT INTO `test` VALUES (&#x27;11&#x27;, &#x27;小红&#x27;);</span><br><span class="line">我们先来看看test表中存在的隐藏间隙：</span><br><span class="line">(-∞, 1]</span><br><span class="line">(1, 5]</span><br><span class="line">(5, 7]</span><br><span class="line">(7, 11]</span><br><span class="line">(11, +∞]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#SessionA</span><br><span class="line">-- 根据非唯一索引列 UPDATE 某条记录</span><br><span class="line">SELECT * FROM `test` WHERE `id` BETWEEN 5 AND 7 FOR UPDATE;</span><br><span class="line"> </span><br><span class="line">#SessionB</span><br><span class="line">/* 插入一条 id = 3，name = &#x27;小张1&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (3, &#x27;小张1&#x27;); # 正常执行</span><br><span class="line"></span><br><span class="line">/* 插入一条 id = 4，name = &#x27;小白&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (4, &#x27;小白&#x27;); # 正常执行</span><br><span class="line"></span><br><span class="line">/* 插入一条 id = 6，name = &#x27;小东&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (6, &#x27;小东&#x27;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 插入一条 id = 8， name = &#x27;大罗&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (8, &#x27;大罗&#x27;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 插入一条 id = 9， name = &#x27;大东&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (9, &#x27;大东&#x27;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 插入一条 id = 11， name = &#x27;李西&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (11, &#x27;李西&#x27;); # 阻塞</span><br><span class="line"></span><br><span class="line">/* 插入一条 id = 12， name = &#x27;张三&#x27; 的数据 */</span><br><span class="line">INSERT INTO `test` (`id`, `name`) VALUES (12, &#x27;张三&#x27;); # 正常执行</span><br></pre></td></tr></table></figure><p>那最终我们就可以得知，在根据<code>非唯一索引</code> 对记录行进行 <code>UPDATE \ FOR UPDATE \ LOCK IN SHARE MODE</code> 操作时，InnoDB 会获取该记录行的 <code>临键锁</code> ，并同时获取该记录行下一个区间的<code>间隙锁</code>。</p><p>即<code>事务 A</code>在执行了上述的 SQL 后，最终被锁住的记录区间为 <code>(5, 11]</code>。</p><h2 id="共享锁-排他锁（Shared-and-Exclusive-Locks）"><a href="#共享锁-排他锁（Shared-and-Exclusive-Locks）" class="headerlink" title="共享锁/排他锁（Shared and Exclusive Locks）"></a>共享锁/排他锁（Shared and Exclusive Locks）</h2><h3 id="共享锁-Share-Lock"><a href="#共享锁-Share-Lock" class="headerlink" title="共享锁(Share Lock)"></a>共享锁(Share Lock)</h3><p>共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。</p><p>如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure><p>在查询语句后面增加<code>LOCK IN SHARE MODE</code>，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。</p><h3 id="排他锁（eXclusive-Lock）"><a href="#排他锁（eXclusive-Lock）" class="headerlink" title="排他锁（eXclusive Lock）"></a>排他锁（eXclusive Lock）</h3><p>排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。</p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure><p>在查询语句后面增加<code>FOR UPDATE</code>，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。</p><h2 id="意向共享锁-意向排他锁（Intention-Shared-and-Exclusive-Locks）"><a href="#意向共享锁-意向排他锁（Intention-Shared-and-Exclusive-Locks）" class="headerlink" title="意向共享锁/意向排他锁（Intention Shared and Exclusive Locks）"></a>意向共享锁/意向排他锁（Intention Shared and Exclusive Locks）</h2><p>意向锁是表级锁，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。</p><p>意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存InnoDB中的两个表锁：</p><p><strong>意向共享锁（IS</strong>）：表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁</p><p><strong>意向排他锁（IX）</strong>：类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。</p><p>例子：事务A修改user表的记录r，会给记录r上一把行级的排他锁（X），同时会给user表上一把意向排他锁（IX），这时事务B要给user表上一个表级的排他锁就会被阻塞。意向锁通过这种方式实现了行锁和表锁共存且满足事务隔离性的要求。</p><p><strong>意向锁是InnoDB自动加的，不需要用户干预。</strong></p><h3 id="q1-为什么意向锁是表级锁呢？"><a href="#q1-为什么意向锁是表级锁呢？" class="headerlink" title="q1 为什么意向锁是表级锁呢？"></a>q1 为什么意向锁是表级锁呢？</h3><p>当我们需要加一个排他锁时，需要根据意向锁去判断表中有没有数据行被锁定（行锁）；</p><p>（1）如果意向锁是行锁，则需要遍历每一行数据去确认；</p><p>（2）如果意向锁是表锁，则只需要判断一次即可知道有没数据行被锁定，提升性能。</p><h3 id="q2-意向锁怎么支持表锁和行锁并存？"><a href="#q2-意向锁怎么支持表锁和行锁并存？" class="headerlink" title="q2 意向锁怎么支持表锁和行锁并存？"></a>q2 意向锁怎么支持表锁和行锁并存？</h3><p>（1）首先明确并存的概念是指数据库同时支持表、行锁，而不是任何情况都支持一个表中同时有一个事务A持有行锁、又有一个事务B持有表锁，因为表一旦被上了一个表级的写锁，肯定不能再上一个行级的锁。<br>（2）如果事务A对某一行上锁，其他事务就不可能修改这一行。这与“事务B锁住整个表就能修改表中的任意一行”形成了冲突。所以，没有意向锁的时候，让行锁与表锁共存，就会带来很多问题。于是有了意向锁的出现，如q1的答案中，数据库不需要在检查每一行数据是否有锁，而是直接判断一次意向锁是否存在即可，能提升很多性能。</p><h2 id="插入意向锁（Insert-Intention-Locks）"><a href="#插入意向锁（Insert-Intention-Locks）" class="headerlink" title="插入意向锁（Insert Intention Locks）"></a>插入意向锁（Insert Intention Locks）</h2><p>插入意向锁本质上可以看成是一个<code>Gap Lock</code></p><ul><li>普通的Gap Lock 不允许 在 （上一条记录，本记录） 范围内插入数据</li><li>插入意向锁Gap Lock 允许 在 （上一条记录，本记录） 范围内插入数据</li></ul><p>插入意向锁的作用是为了<strong>提高并发插入的性能</strong>， 多个事务 同时写入 不同数据 至同一索引范围（区间）内，并不需要等待其他事务完成，不会发生锁等待。</p><h3 id="插入的过程"><a href="#插入的过程" class="headerlink" title="插入的过程"></a>插入的过程</h3><p>假设现在有记录 10， 30， 50， 70 ；且为主键 ，需要插入记录 25 。</p><ol><li>找到 小于等于25的记录 ，这里是 10</li><li>找到 记录10的下一条记录 ，这里是 30</li><li>判断 下一条记录30 上是否有锁<br>3.1 判断 30 上面如果 没有锁 ，则可以插入<br>3.2 判断 30 上面如果有<code>Record Lock</code>，则可以插入<br>3.3 判断 30 上面如果有<code>Gap Lock</code>/<code>Next-Key Lock</code>，则无法插入，因为锁的范围是 (10, 30) /（10, 30] ；在30上增加<code>insert intention lock</code>（ 此时处于waiting状态），当 Gap Lock / Next-Key Lock 释放时，等待的事物（ transaction）将被 唤醒 ，此时 记录30 上才能获得 insert intention lock ，然后再插入 记录25</li></ol><p>注意：<strong>一个事物 insert 25 且没有提交，另一个事物 delete 25 时，记录25上会有 Record Lock</strong></p><p>开启两个会话，两个会话事务的隔离级别都设置为<code>REPEATABLE-READ</code></p><table><thead><tr><th align="center">Time</th><th align="center">会话A</th><th align="center">会话B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center">begin</td></tr><tr><td align="center">2</td><td align="center">select * from a where a&lt;=13 for update</td><td align="center"></td></tr><tr><td align="center">3</td><td align="center"></td><td align="center">insert into a values (12)  – waiting…… （被阻塞了，在这里等待）</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">此时执行show engine innodb status\G语句会看到以下结果</span><br><span class="line">---TRANSACTION 4424, ACTIVE 7 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)</span><br><span class="line">MySQL thread id 3, OS thread handle 140018685810432, query id 240 localhost root update</span><br><span class="line">--等待插入的SQL</span><br><span class="line">insert into a values(12)</span><br><span class="line">------- TRX HAS BEEN WAITING 7 SEC FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">--插入记录12的事物等待中（被终端会话A中的事物阻塞了），等待获得插入意向锁(lock_mode X locks gap before rec insert intention waiting)</span><br><span class="line">RECORD LOCKS space id 37 page no 3 n bits 72 index PRIMARY of table `test`.`a` trx id 4424 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000d; asc     ;;</span><br><span class="line"> 1: len 6; hex 000000001140; asc      @;;</span><br><span class="line"> 2: len 7; hex b400000128011c; asc     (  ;;</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">TABLE LOCK table `test`.`a` trx id 4424 lock mode IX</span><br><span class="line">RECORD LOCKS space id 37 page no 3 n bits 72 index PRIMARY of table `test`.`a` trx id 4424 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000d; asc     ;;</span><br><span class="line"> 1: len 6; hex 000000001140; asc      @;;</span><br><span class="line"> 2: len 7; hex b400000128011c; asc     (  ;;</span><br><span class="line"></span><br><span class="line">---TRANSACTION 4423, ACTIVE 55 sec</span><br><span class="line">2 lock struct(s), heap size 1136, 4 row lock(s)</span><br><span class="line">MySQL thread id 2, OS thread handle 140018686076672, query id 241 localhost root starting</span><br><span class="line">show engine innodb status</span><br><span class="line">TABLE LOCK table `test`.`a` trx id 4423 lock mode IX</span><br><span class="line">RECORD LOCKS space id 37 page no 3 n bits 72 index PRIMARY of table `test`.`a` trx id 4423 lock_mode X</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000000113f; asc      ?;;</span><br><span class="line"> 2: len 7; hex b3000001270110; asc     &#x27;  ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000b; asc     ;;</span><br><span class="line"> 1: len 6; hex 000000001140; asc      @;;</span><br><span class="line"> 2: len 7; hex b4000001280110; asc     (  ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000d; asc     ;;</span><br><span class="line"> 1: len 6; hex 000000001140; asc      @;;</span><br><span class="line"> 2: len 7; hex b400000128011c; asc     (  ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 3; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000014; asc     ;;</span><br><span class="line"> 1: len 6; hex 000000001145; asc      E;;</span><br><span class="line"> 2: len 7; hex b70000012b0110; asc     +  ;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Time</th><th align="center">会话A</th><th align="center">会话B</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">begin</td><td align="center">begin</td></tr><tr><td align="center">2</td><td align="center">select * from a where a&lt;=13 for update</td><td align="center"></td></tr><tr><td align="center">3</td><td align="center"></td><td align="center">insert into a values (12)  – waiting…… （被阻塞了，在这里等待）</td></tr><tr><td align="center">4</td><td align="center">commit</td><td align="center"></td></tr><tr><td align="center">5</td><td align="center"></td><td align="center">输出：Query OK, 1 row affected (17.40 sec) 前提条件是insert操作的锁没有超时</td></tr></tbody></table><p>此时事务B插入成功但是还未commit，再执行<code>show engine innodb status\G</code>语句，会有以下输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---TRANSACTION <span class="number">4425</span>, ACTIVE <span class="number">26</span> sec</span><br><span class="line"><span class="number">2</span> lock <span class="keyword">struct</span>(s), heap size <span class="number">1136</span>, <span class="number">1</span> row lock(s), undo log entries <span class="number">1</span></span><br><span class="line">MySQL thread id <span class="number">3</span>, OS thread handle <span class="number">140018685810432</span>, query id <span class="number">247</span> localhost root</span><br><span class="line">TABLE LOCK table <span class="string">`test`</span>.<span class="string">`a`</span> trx id <span class="number">4425</span> lock mode IX</span><br><span class="line">RECORD LOCKS space id <span class="number">37</span> page no <span class="number">3</span> n bits <span class="number">72</span> index PRIMARY of table <span class="string">`test`</span>.<span class="string">`a`</span> trx id <span class="number">4425</span> lock_mode X locks gap before rec insert intention</span><br><span class="line">Record lock, heap no <span class="number">4</span> PHYSICAL RECORD: n_fields <span class="number">3</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: <span class="built_in">len</span> <span class="number">4</span>; hex <span class="number">8000000</span>d; asc     ;;</span><br><span class="line"> <span class="number">1</span>: <span class="built_in">len</span> <span class="number">6</span>; hex <span class="number">000000001140</span>; asc      @;;</span><br><span class="line"> <span class="number">2</span>: <span class="built_in">len</span> <span class="number">7</span>; hex b400000128011c; asc     (  ;;</span><br></pre></td></tr></table></figure><p>从上面的输出可以看到在记录13上面加了一把插入意图锁（<code>lock_mode X locks gap before rec insert intention</code>）。<br> 获得插入意图锁之后，我们就可以在11-13之间并发插入记录，而不需要一个事物等待另一事物，当所有相关的插入的事物都提交后， 13上的插入意向锁 便会释放。</p><h2 id="自增锁（Auto-inc-Locks）"><a href="#自增锁（Auto-inc-Locks）" class="headerlink" title="自增锁（Auto-inc Locks）"></a>自增锁（Auto-inc Locks）</h2><p><strong>自增锁,在提交前释放,并发插入高</strong></p><p><strong>s,x等锁,在COMMIT扣释放,并发插入需要等待</strong></p><p>不能回滚到前面的值</p><p>在InnoDB中，每个含有自增列的表都有一个自增长计数器。当对含有自增长计数器的表进行插入时，首先会执行<code>select max(auto_inc_col) from t for update</code>来得到计数器的值，然后再将这个值加1赋予自增长列。我们将这种方式称之为<code>AUTO_INC Lock</code>。</p><p><code>AUTO_INC Lock</code>是一种特殊的表锁，它在完成对自增长值插入的SQL语句后立即释放，所以性能会比事务完成后释放锁要高。由于是表级别的锁，所以在并发环境下其依然存在性能问题。</p><p>从MySQL 5.1.22开始，InnoDB中提供了一种轻量级互斥量的自增长实现机制，同时InnoDB存储引擎提供了一个参数<code>innodb_autoinc_lock_mode</code>来控制自增长的模式，进而提高自增长值插入的性能。<code>innodb_autoinc_lock_mode</code>和插入类型有关，在介绍它之前，我们先来看看都有哪些插入类型</p><ul><li><p>“INSERT-like” statements</p><p>泛指所有的插入语句, 它包括 “simple-inserts”, “bulk-inserts”, 和 “mixed-mode inserts”.</p></li><li><p>“Simple inserts”</p><p>插入的记录行数是确定的：比如：insert into values，replace<br> 但是不包括： INSERT … ON DUPLICATE KEY UPDATE.</p></li><li><p>“Bulk inserts”</p><p>插入的记录行数不能马上确定的，比如： INSERT … SELECT, REPLACE … SELECT, and LOAD DATA</p></li><li><p>“Mixed-mode inserts”</p><p>这些都是simple-insert，但是部分auto increment值给定或者不给定. 例子如下(where <code>c1</code> is an <code>AUTO_INCREMENT</code> column of table <code>t1</code>):</p></li></ul>  <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO t1 (c1,c2) VALUES (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>), (<span class="literal">NULL</span>,<span class="string">&#x27;b&#x27;</span>), (<span class="number">5</span>,<span class="string">&#x27;c&#x27;</span>), (<span class="literal">NULL</span>,<span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure><p>  另外一种 “mixed-mode insert” 就是 <code>INSERT ... ON DUPLICATE KEY UPDATE</code></p><p>介绍完插入类型之后，我们再来看看锁模式，即<code>innodb_autoinc_lock_mode</code>。</p><p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/Blog/source/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/%E8%87%AA%E5%A2%9E%E9%94%81.png" alt="image-20200814235726139"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0：traditonal （每次都会产生表锁）</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">1：consecutive （会产生一个轻量锁，simple insert会获得批量的锁，保证连续插入）</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">2：interleaved （不会锁表，来一个处理一个，并发最高）</span><br></pre></td></tr></table></figure><h2 id="事务使用的几点建议"><a href="#事务使用的几点建议" class="headerlink" title="事务使用的几点建议"></a>事务使用的几点建议</h2><ul><li>控制事务大小，减少锁定的资源量和锁定时间长度。</li><li>所有的数据检索都通过索引来完成，从而避免因为无法通过索引加锁而升级为表锁。</li><li>减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的数据。</li><li>在业务条件允许下，尽量使用较低隔离级别的事务隔离。减少隔离级别带来的附加成本。</li><li>合理使用索引，让innodb在索引上面加锁的时候更加准确。</li><li>在应用中尽可能做到访问的顺序执行。</li><li>如果容易死锁，就可以考虑使用表锁来减少死锁的概率</li></ul><h1 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h1><h2 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h2><p>数据结构、数据操作、数据约束</p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><h3 id="1-第一范式-1NF"><a href="#1-第一范式-1NF" class="headerlink" title="1. 第一范式 (1NF)"></a>1. 第一范式 (1NF)</h3><p>属性不可分。</p><h3 id="2-第二范式-2NF"><a href="#2-第二范式-2NF" class="headerlink" title="2. 第二范式 (2NF)"></a>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p><strong>分解前</strong></p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td><td>课程-2</td><td>95</td></tr></tbody></table><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><strong>分解后</strong></p><p>关系-1</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th><th>Mname</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td><td>院长-1</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td><td>院长-2</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td><td>院长-2</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><table><thead><tr><th>Sno</th><th>Cname</th><th>Grade</th></tr></thead><tbody><tr><td>1</td><td>课程-1</td><td>90</td></tr><tr><td>2</td><td>课程-2</td><td>80</td></tr><tr><td>2</td><td>课程-1</td><td>100</td></tr><tr><td>3</td><td>课程-2</td><td>95</td></tr></tbody></table><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt; Grade</li></ul><h3 id="3-第三范式-3NF"><a href="#3-第三范式-3NF" class="headerlink" title="3. 第三范式 (3NF)"></a>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p><p>上面的 关系-1 中存在以下传递函数依赖：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><p>关系-11</p><table><thead><tr><th>Sno</th><th>Sname</th><th>Sdept</th></tr></thead><tbody><tr><td>1</td><td>学生-1</td><td>学院-1</td></tr><tr><td>2</td><td>学生-2</td><td>学院-2</td></tr><tr><td>3</td><td>学生-3</td><td>学院-2</td></tr></tbody></table><p>关系-12</p><table><thead><tr><th>Sdept</th><th>Mname</th></tr></thead><tbody><tr><td>学院-1</td><td>院长-1</td></tr><tr><td>学院-2</td><td>院长-2</td></tr></tbody></table><h1 id="ER-图"><a href="#ER-图" class="headerlink" title="ER 图"></a>ER 图</h1><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h3 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h3><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/ER图.png" alt="image-20200815114836972" style="zoom: 50%;"><h2 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/多对多.png" alt="image-20200815115129109" style="zoom:50%;"><h2 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/联系的多向性.png" alt="image-20200815115235884" style="zoom:50%;"><h2 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><img src="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81/表示子类.png" alt="image-20200815115400700" style="zoom:50%;"><p><a href="https://www.jianshu.com/p/dca007208a58">https://www.jianshu.com/p/dca007208a58</a></p><p><a href="https://blog.csdn.net/u010841296/article/details/87909468">https://blog.csdn.net/u010841296/article/details/87909468</a></p><p><a href="https://www.cnblogs.com/Terry-Wu/p/12219019.html">https://www.cnblogs.com/Terry-Wu/p/12219019.html</a></p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#mysql-%E9%9A%90%E5%BC%8F%E4%B8%8E%E6%98%BE%E7%A4%BA%E9%94%81%E5%AE%9A">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md#mysql-%E9%9A%90%E5%BC%8F%E4%B8%8E%E6%98%BE%E7%A4%BA%E9%94%81%E5%AE%9A</a></p><p><a href="https://www.jianshu.com/p/9ff938e3a498">ER图</a></p><p><a href="https://blog.csdn.net/qq_43255017/article/details/106442887?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/qq_43255017/article/details/106442887?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p><p><a href="https://www.cnblogs.com/CuiHongYu/p/10845354.html">https://www.cnblogs.com/CuiHongYu/p/10845354.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的in和exist区别</title>
      <link href="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%9A%84in%E5%92%8Cexist%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%9A%84in%E5%92%8Cexist%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p>确定给定的值是否与子查询或列表中的值相匹配。in在查询的时候，首<strong>先查询子查询的表，然后将内表和外表做一个笛卡尔积</strong>，然后按照条件进行筛选。<strong>所以相对内表比较小的时候，in的速度较快。</strong></p><h2 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h2><p><strong>指定一个子查询，检测行的存在。遍历循环外表，然后看外表中的记录有没有和内表的数据一样的。</strong>匹配上就将结果放入结果集中。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>1、运用情况不同</strong></p><p>sql中in适用于<strong>子查询得出的结果集记录较少</strong>，主查询中的表较大且又有索引的表,。sql中exist适用于外层的主查询记录较少，<strong>子查询中的表大</strong>，又有索引的时候。</p><p><strong>2、驱动顺序不同</strong></p><p>IN是先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。exists是<strong>以外层表为驱动表</strong>，先被访问。</p><p><strong>3、执行次数不同</strong>。</p><p>IN 语句：只执行一次，确定给定的值是否与子查询或列表中的值相匹配。in在查询的时候，首先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。</p><p>EXISTS语句：执行次数根据表的长度而定。指定一个子查询，检测行的存在。遍历循环外表，然后看外表中的记录有没有和内表的数据一样的。匹配上就将结果放入结果集中。</p><p><strong>4、对NULL值处理不同。</strong></p><p>IN不对NULL进行处理，exists会对NULL值进行处理。</p><p><strong>5、底层原理不同</strong></p><p>in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。直以来认为exists比in效率高的说法是不准确的。</p><h2 id="not-in-和not-exists"><a href="#not-in-和not-exists" class="headerlink" title="not in 和not exists"></a>not in 和not exists</h2><p>如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql必知必会</title>
      <link href="/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2020/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="第3章-使用MySQL"><a href="#第3章-使用MySQL" class="headerlink" title="第3章 使用MySQL"></a>第3章 使用MySQL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use crashcourse; #指定使用的数据库</span><br><span class="line">show databases;  # 了解数据库，返回数据库列表</span><br><span class="line">show tables;  # 返回数据库内表的列表</span><br><span class="line">show columns from customers; # 查看customers表中的所有列设置</span><br><span class="line">describe customers;  # 同上，查看customers表中的所有列设置</span><br><span class="line"></span><br><span class="line">show status; # 用于显示广泛的服务器状态信息</span><br><span class="line">show create database crashcourse; #查看创建数据库crashcourse的mysql代码语句</span><br><span class="line">show create table productnotes;  #查看创建表productnotes表的mysql代码语句</span><br><span class="line">show grants; #显示授予用户（所有用户或特定用户）的安全权限</span><br><span class="line"># show errors; # 显示服务器错误内容</span><br><span class="line"># show warnings； #显示服务器警告内容</span><br></pre></td></tr></table></figure><h2 id="第4章-检索数据"><a href="#第4章-检索数据" class="headerlink" title="第4章 检索数据"></a>第4章 检索数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># select检索单列，多列，所有列</span><br><span class="line">select prod_name from products;  # 从products表中检索prod_name 单列</span><br><span class="line">select prod_id,prod_name,prod_price from products;   # 从products表中检索prod_name，prod_name,prod_price 多列</span><br><span class="line">select * from products;   #  # 从products表中检索所有列，通常情况下，检索不需要的列会降低检索和应用程序的效率</span><br><span class="line"></span><br><span class="line"># 使用distinct 去重</span><br><span class="line">select distinct vend_id from products;  # 使用distinct关键字去重，distinc只能放在列名的前面</span><br><span class="line">select distinct vend_id,prod_price from products;  # distinct不仅对前置它的列vend_id起作用，同时也作用于prod_price，两列值有重复，才去重</span><br><span class="line"></span><br><span class="line"># 使用limit检索部分行，开始位置为行索引值，索引从0开始</span><br><span class="line">select prod_name from products limit 5; #从第 0 行开始，返回前 5 行</span><br><span class="line">select prod_name from products limit 5,5; #从第 5 行开始，检索 5 行</span><br><span class="line"># 另一种写法</span><br><span class="line">select prod_name from products limit 4 OFFSET 3; #从第 3 行开始，检索 4 行</span><br><span class="line">select prod_name from products limit 3,4; #，同上，从第 3 行开始，检索 4 行</span><br><span class="line"></span><br><span class="line"># 行数不够时，mysql只返回它能返回的那么多行</span><br><span class="line">select count(prod_name) from products; # prod_name 共14行，索引为0-13</span><br><span class="line">select prod_name from products limit 10,5; #从第 10 行开始，检索 5 行，行索引10-14，超出范围，只返回10-13共4行数据</span><br><span class="line"></span><br><span class="line"># 使用完全限定的表名</span><br><span class="line">select products.prod_name from products;</span><br><span class="line">select products.prod_name from crashcourse.products;</span><br></pre></td></tr></table></figure><h2 id="第5章-排序检索数据"><a href="#第5章-排序检索数据" class="headerlink" title="第5章 排序检索数据"></a>第5章 排序检索数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 关系型数据库设计理论认为，如果不明确规定排序顺序，</span><br><span class="line">则不应该假定检索出的数据的顺序有意义 */</span><br><span class="line"></span><br><span class="line"># order by 子句对输出排序</span><br><span class="line"># 按单列排序 </span><br><span class="line">select prod_name from products order by prod_name;   # 以字母顺序排序prod_name列 </span><br><span class="line">select prod_name from products order by prod_id;  # 使用非检索的列排序数据也是合法的，如使用prod_id顺序排列prod_name</span><br><span class="line"></span><br><span class="line"># 按多列排序 </span><br><span class="line">select prod_id, prod_price,prod_name from products order by prod_price, prod_name; #先按价格，再按产品名排序</span><br><span class="line"></span><br><span class="line"># 降序排列 desc，desc只作用于直接位于其前面的列名</span><br><span class="line">select prod_id, prod_price,prod_name from products order by prod_price desc; # 按价格降序排列</span><br><span class="line">select prod_id, prod_price,prod_name from products order by prod_price desc, prod_name; #先按价格降序排列，再按产品名升序排列 </span><br><span class="line">select prod_id, prod_price,prod_name from products order by prod_price desc, prod_name desc; #先按价格降序排列，再按产品名降序排列</span><br><span class="line"></span><br><span class="line"># 使用order by 和limit组合，找出一列中最高或最低的值</span><br><span class="line"># 顺序：order by子句必须在from子句之后，limit子句必须在order by之后</span><br><span class="line">select prod_price from products order by prod_price desc limit 1; # 最高值 </span><br><span class="line">select prod_price from products order by prod_price limit 1; # 最低值 </span><br></pre></td></tr></table></figure><h2 id="第6章-过滤数据"><a href="#第6章-过滤数据" class="headerlink" title="第6章 过滤数据"></a>第6章 过滤数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">select prod_name,prod_price from products where prod_price = 2.50;   # 价格等于2.50的产品名、产品价格</span><br><span class="line">select prod_name,prod_price from products where prod_name = &quot;fuses&quot;;  # 默认不区分大小写</span><br><span class="line">select prod_name,prod_price from products where prod_price &lt; 10; # 价格小于10的产品名、产品价格</span><br><span class="line">select prod_name,prod_price from products where prod_price &lt;=10; # 价格小于等于10的产品名、产品价格</span><br><span class="line"></span><br><span class="line"># 不匹配检查</span><br><span class="line">select vend_id,prod_name from products where vend_id &lt;&gt; 1003; # 检索不是由1003供应商制造的所有产品 </span><br><span class="line">select vend_id,prod_name from products where vend_id != 1003; # 同上，检索不是由1003供应商制造的所有产品 </span><br><span class="line"></span><br><span class="line"># 范围值检索，between A and B，包括A和B</span><br><span class="line">select prod_name,prod_price from products where prod_price between 5 and 10; # 价格 大于等于5，小于等于10 的产品名、产品价格</span><br><span class="line"></span><br><span class="line"># 空值检查</span><br><span class="line">select prod_name from products where prod_price is null;  # 返回prod_price为空值null的prod_name,无对应数据 </span><br><span class="line">select cust_id from customers where cust_email is null; # 检索cust_email为空值时的cust_id</span><br><span class="line">/* 在通过过滤选择出不具有特定值的行时，你可能希望返回具有NULL值得行。</span><br><span class="line">但是，不行。因为未知具有特殊的含义，数据库不知道他们是否匹配，所以在匹配过滤和不匹配过滤中不返回NULL。</span><br><span class="line">因此，在过滤数据时，一定要验证返回数据中确实给出了被过滤列具有NULL的行。 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="第7章-数据过滤"><a href="#第7章-数据过滤" class="headerlink" title="第7章 数据过滤"></a>第7章 数据过滤</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># and 或 or 操作符连接多个where子句 </span><br><span class="line"># AND 用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行</span><br><span class="line">select vend_id,prod_price,prod_name from products</span><br><span class="line">where vend_id = 1003 and prod_price &lt;= 10; #检索由供应商1003制造且价格小于等于10美元的产品信息</span><br><span class="line"># OR操作符，指示MySQL检索匹配任一条件的行</span><br><span class="line">select prod_name,prod_price from products </span><br><span class="line">where vend_id = 1002 or vend_id = 1003; # 检索由任一个指定供应商制造的所有产品的产品信息</span><br><span class="line"></span><br><span class="line"># and 和 or结合，and优先计算</span><br><span class="line"># 优先计算and，查找vend_id为1003且价格&gt;=10的产品，或者vend_id为1002的产品，不管价格如何  </span><br><span class="line">select prod_name,prod_price from products </span><br><span class="line">where vend_id = 1002 or vend_id = 1003 and prod_price &gt;= 10;</span><br><span class="line"># 使用圆括号明确运算顺序：查找vend_id为1002或1003，且价格&gt;=10的产品</span><br><span class="line">select prod_name,prod_price from products </span><br><span class="line">where (vend_id = 1002 or vend_id = 1003) and prod_price &gt;= 10; </span><br><span class="line"></span><br><span class="line"># IN操作符</span><br><span class="line"># IN操作符后跟由逗号分隔的合法值清单，整个清单必须括在圆括号</span><br><span class="line">select prod_name,prod_price from products</span><br><span class="line">where vend_id in (1002,1003) order by prod_name;</span><br><span class="line"># IN操作符完成与OR相同的功能</span><br><span class="line">select prod_name,prod_price from products</span><br><span class="line">where vend_id = 1002 or vend_id = 1003 order by prod_name; # 同上 </span><br><span class="line"></span><br><span class="line"># NOT操作符</span><br><span class="line"># 列出1002和1003之外的供应商生产的产品</span><br><span class="line">select prod_name,prod_price from products</span><br><span class="line">where vend_id not in (1002,1003) order by prod_name;</span><br><span class="line"># Mysql支持not对in，between，exsits子句取反 </span><br></pre></td></tr></table></figure><h2 id="第8章-用通配符进行过滤"><a href="#第8章-用通配符进行过滤" class="headerlink" title="第8章 用通配符进行过滤"></a>第8章 用通配符进行过滤</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">通配符：用来匹配值得一部分的特殊字符 </span><br><span class="line">搜索模式：由字面值、通配符或两者组合构成的搜索条件 </span><br><span class="line">Like操作符：为在搜索子句中使用通配符，必须使用like操作符。</span><br><span class="line">指示mysql，其后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。 </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">-- 通配符类型 </span><br><span class="line"># 百分号 % 通配符 ：表示任何字符（包括0个字符 ）出现任意次数 </span><br><span class="line"># 特殊：注意 % 不能匹配NULL空值！ </span><br><span class="line"># 找到所有以词jet起头的产品 </span><br><span class="line">select prod_id,prod_name from products where prod_name like &quot;jet%&quot;;</span><br><span class="line"># 通配符可以在搜索模式任意位置使用</span><br><span class="line"># 比如下方出现在头尾两处 ，匹配任意位置包含文本anvil的值 </span><br><span class="line">select prod_id,prod_name from products where prod_name like &quot;%anvil%&quot;; </span><br><span class="line"># 比如下方出现在搜索模式的中间，匹配所有以s开头e结尾的值 </span><br><span class="line">select prod_name from products where prod_name like &quot;s%e&quot;; </span><br><span class="line"></span><br><span class="line"># 下划线 _ 通配符 ：匹配一个字符，不能多不能少 </span><br><span class="line">select prod_id,prod_name from products</span><br><span class="line">where prod_name like &quot;_ ton anvil&quot;;</span><br><span class="line"></span><br><span class="line"># 技巧：把通配符至于搜索模式的开始处，搜索起来是最慢的！ </span><br></pre></td></tr></table></figure><h2 id="第9章-用正则表达式进行搜索"><a href="#第9章-用正则表达式进行搜索" class="headerlink" title="第9章 用正则表达式进行搜索"></a>第9章 用正则表达式进行搜索</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">-- 基本字符匹配 </span><br><span class="line"># 查找产品名中含有&#x27;1000&#x27;的所有行 </span><br><span class="line">select prod_name from products where prod_name regexp &quot;1000&quot;;</span><br><span class="line"># .在正则表达式中，匹配任意 一个 字符 </span><br><span class="line">select prod_name from products where prod_name regexp &quot;.000&quot;;</span><br><span class="line"></span><br><span class="line">-- like 和 正则表达式的区别 ，是否在列值中匹配 </span><br><span class="line"># like在整个列中查找，如果被匹配的文本出现在列值中，匹配不到结果，除非使用通配符 </span><br><span class="line">select prod_name from products where prod_name like &quot;1000&quot; order by prod_name;     #无返回结果 ,没有1000的</span><br><span class="line"></span><br><span class="line"># like + 通配符</span><br><span class="line">select prod_name from products where prod_name like &quot;%1000&quot; order by prod_name;    # 返回结果&#x27;JetPack 1000&#x27;</span><br><span class="line">select prod_name from products where prod_name like &quot;%000&quot; order by prod_name;     # 返回结果 &#x27;JetPack 1000&#x27; &#x27;JetPack 2000&#x27;</span><br><span class="line"># Regexp在列值中匹配</span><br><span class="line">select prod_name from products where prod_name regexp &quot;.000&quot; order by prod_name;   # 返回结果 &#x27;JetPack 1000&#x27; &#x27;JetPack 2000&#x27;</span><br><span class="line"></span><br><span class="line"># regexp如何匹配整个列，同like效果呢，使用^和$定位符即可 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 正则表达式匹配默认不分大小写，需使用BINARY区分大小写  </span><br><span class="line">select prod_name from products where prod_name regexp binary &quot;JetPack .000&quot;;</span><br><span class="line"></span><br><span class="line">-- 正则表达式的OR操作符： |</span><br><span class="line">select prod_name from products where prod_name regexp &quot;1000|2000&quot; order by prod_name;</span><br><span class="line"></span><br><span class="line">-- 正则表达式匹配几个字符之一 [ ]</span><br><span class="line">select prod_name from products where prod_name regexp &#x27;[123] Ton&#x27; order by prod_name;  # [123]匹配单一字符：1或2或3</span><br><span class="line">select prod_name from products where prod_name regexp &#x27;[1|2|3] Ton&#x27; order by prod_name;  # [1|2|3]同[123]，匹配单一字符：1或2或3</span><br><span class="line">select prod_name from products where prod_name regexp &#x27;1|2|3 ton&#x27; order by prod_name; # &#x27;1|2|3 ton&#x27;匹配1或2或&#x27;3 ton&#x27;</span><br><span class="line">select prod_name from products where prod_name regexp &#x27;[^123]&#x27; order by prod_name;  # 取反</span><br><span class="line"></span><br><span class="line">-- 正则表达式匹配范围 </span><br><span class="line">select prod_name from products where prod_name regexp &#x27;[1-5] Ton&#x27; order by prod_name;  # [1-5]匹配1,2,3,4,5</span><br><span class="line"></span><br><span class="line">-- 正则表达式匹配特殊字符，必须用\\前导，进行转义 </span><br><span class="line">-- 多数正则使用单反斜杠转义，但mysql使用双反斜杠，mysql自己解释一个，正则表达式库解释一个 </span><br><span class="line">select vend_name from vendors where vend_name regexp &quot;\\.&quot; order by vend_name; # ‘\\.&#x27;匹配字符.</span><br><span class="line">select vend_name from vendors where vend_name regexp &quot;.&quot; order by vend_name;  #  &#x27;.&#x27;匹配任意字符，每行都会被检索出来</span><br><span class="line"></span><br><span class="line">-- 正则表达式匹配字符类 </span><br><span class="line">#    [:alnum:]    任意字母和数字（同[a-zA-Z0-9]） </span><br><span class="line">#    [:alpha:]    任意字符（同[a-zA-Z]） </span><br><span class="line">#    [:blank:]    空格和制表（同[\\t]） </span><br><span class="line">#    [:cntrl:]    ASCII控制字符（ASCII 0到31和127） </span><br><span class="line">#    [:digit:]    任意数字（同[0-9]） </span><br><span class="line">#    [:graph:]    与[:print:]相同，但不包括空格 </span><br><span class="line">#    [:lower:]    任意小写字母（同[a-z]） </span><br><span class="line">#    [:print:]    任意可打印字符 </span><br><span class="line">#    [:punct:]    既不在[:alnum:]又不在[:cntrl:]中的任意字符 </span><br><span class="line">#    [:space:]    包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]） </span><br><span class="line">#    [:upper:]    任意大写字母（同[A-Z]） </span><br><span class="line">#    [:xdigit:]    任意十六进制数字（同[a-fA-F0-9]） </span><br><span class="line">select prod_name from products where prod_name regexp &#x27;[:digit:]&#x27; order by prod_name; #[:digit:]匹配任意数字 </span><br><span class="line"></span><br><span class="line">-- 匹配多个实例 </span><br><span class="line">#    *        0个或多个匹配 </span><br><span class="line">#    +        1个或多个匹配（等于&#123;1,&#125;）</span><br><span class="line">#    ?        0个或1个匹配（等于&#123;0,1&#125;）</span><br><span class="line">#     &#123;n&#125;        指定数目的匹配 </span><br><span class="line">#     &#123;n,&#125;    不少于指定数目的匹配</span><br><span class="line">#    &#123;n,m&#125;    匹配数目的范围（m不超过255）</span><br><span class="line">select prod_name from products where prod_name regexp &#x27;\\([0-9] sticks?\\)&#x27;</span><br><span class="line">order by prod_name;  # 返回了&#x27;TNT (1 stick)&#x27;和&#x27;TNT (5 sticks)&#x27;</span><br><span class="line">select prod_name from products where prod_name regexp &#x27;[[:digit:]]&#123;4&#125;&#x27;</span><br><span class="line">order by prod_name;  # [[:digit:]]&#123;4&#125;匹配连在一起的任意4位数字</span><br><span class="line"></span><br><span class="line">-- 定位符</span><br><span class="line">#    ^            文本的开始 </span><br><span class="line">#    $            文本的结尾 </span><br><span class="line">#    [[:&lt;:]]        词的开始 </span><br><span class="line">#    [[:&gt;:]]        词的结尾</span><br><span class="line">select prod_name from products where prod_name regexp &#x27;^[0-9\\.]&#x27; order by prod_name; #找出以一个数（包括以小数点开始的数）开始的所有产品</span><br><span class="line">select prod_name from products where prod_name regexp &#x27;[0-9\\.]&#x27; order by prod_name;  #找出包括小数点和数字的所有产品</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- ^的双重作用 </span><br><span class="line"># 在集合中（用[和]定义），用它来否定该集合</span><br><span class="line"># 用来指串的开始处</span><br><span class="line"></span><br><span class="line">-- 不适用数据库表进行正则表达式的测试：匹配返回1，无匹配返回0</span><br><span class="line">select &#x27;hello&#x27; regexp &#x27;[0-9]&#x27;; # 返回 0 </span><br><span class="line">select &#x27;hello&#x27; regexp &#x27;[:alnum:]&#x27;; # 返回 1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第10章-创建计算字段"><a href="#第10章-创建计算字段" class="headerlink" title="第10章 创建计算字段"></a>第10章 创建计算字段</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 拼接字段 concat()拼接串，即把多个串连接起来形成一个较长的串各个串之间用逗号分隔。</span><br><span class="line">select concat(vend_name,&#x27; (&#x27;,vend_country,&#x27;)&#x27;) from vendors order by vend_name;  </span><br><span class="line"></span><br><span class="line">-- 删除数据左侧多余空格 ltrim()</span><br><span class="line">-- 删除数据两侧多余空格 trim()</span><br><span class="line">-- 删除数据右侧多余空格 rtrim()</span><br><span class="line">select concat(rtrim(vend_name),&#x27; (&#x27;,rtrim(vend_country),&#x27;)&#x27;) from vendors order by vend_name;</span><br><span class="line"></span><br><span class="line">-- as赋予别名</span><br><span class="line">select concat(rtrim(vend_name),&#x27; (&#x27;,rtrim(vend_country),&#x27;)&#x27;) as vend_title from vendors order by vend_name;</span><br><span class="line"></span><br><span class="line">-- 执行算数计算</span><br><span class="line">select prod_id,quantity,item_price from orderitems where order_num = 20005;</span><br><span class="line"></span><br><span class="line">select prod_id,quantity,item_price,quantity * item_price as expanded_price</span><br><span class="line">from orderitems where order_num = 20005;  # 计算总价expanded_price</span><br><span class="line"></span><br><span class="line">-- 简单测试计算 </span><br><span class="line">select 2*3;</span><br><span class="line">select trim(&#x27;abc&#x27;);</span><br><span class="line">select now();  # 返回当前日期和时间</span><br></pre></td></tr></table></figure><h2 id="第11章-利用数据处理函数"><a href="#第11章-利用数据处理函数" class="headerlink" title="第11章 利用数据处理函数"></a>第11章 利用数据处理函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">-- 文本处理函数 </span><br><span class="line">#    left()            返回串左边的字符 </span><br><span class="line">#    length()        返回串的长度 </span><br><span class="line">#    locate()        找出串的一个子串 </span><br><span class="line">#    lower()            将串转换为小写</span><br><span class="line">#    ltrim()            去掉串左边的空格</span><br><span class="line">#    right()            返回串右边的字符 </span><br><span class="line">#    rtrim()            去掉串右边的空格  </span><br><span class="line">#    soundex()        返回串的soundex值</span><br><span class="line">#    substring()        返回子串的字符 </span><br><span class="line">#    upper()            将串转换为大写</span><br><span class="line"></span><br><span class="line">-- UPPER()函数 转换文本为大写 </span><br><span class="line">select vend_name, upper(vend_name) as vend_name_upcase from vendors order by vend_name;</span><br><span class="line"></span><br><span class="line"># soundex() 描述语音表示的字母数字模式的算法,对串按照发音比较而不是字母比较</span><br><span class="line">select cust_name,cust_contact from customers where cust_contact = &#x27;Y. Lie&#x27;;  # 无返回 </span><br><span class="line">select cust_name,cust_contact from customers where soundex(cust_contact) = soundex(&#x27;Y. Lie&#x27;); # 按发音搜索 </span><br><span class="line"></span><br><span class="line">-- 日期和时间处理函数 </span><br><span class="line">#    adddate()        增加一个日期（天，周等）</span><br><span class="line">#    addtime()        增加一个时间（时、分等）</span><br><span class="line">#    curdate()        返回当前日期 </span><br><span class="line">#    curtime()        返回当前时间 </span><br><span class="line">#    date()            返回日期时间的日期部分     </span><br><span class="line">#    datediff()        计算两个日期之差 </span><br><span class="line">#    date_add()        高度灵活的日期运算函数 </span><br><span class="line">#    date_format()    返回一个格式化的日期或时间串 </span><br><span class="line">#    day()            返回一个日期的天数部分     </span><br><span class="line">#    dayofweek()        对于一个日期，返回对应的星期几 </span><br><span class="line">#    hour()            返回一个时间的小时部分 </span><br><span class="line">#    minute()        返回一个时间的分钟部分 </span><br><span class="line">#    month()            返回一个日期的月份部分 </span><br><span class="line">#    now()            返回当前日期和事件 </span><br><span class="line">#    second()        返回一个时间的秒部分 </span><br><span class="line">#    time()             返回一个日期时间的时间部分 </span><br><span class="line">#    year()            返回一个日期的年份部分 </span><br><span class="line"></span><br><span class="line"># 首选的日期格式yyyy-mm-dd，避免多义性 </span><br><span class="line">select cust_id,order_num from orders where order_date = &quot;2005-09-01&quot;;</span><br><span class="line">select * from orders; # order_date为datetime数据类型，含有时间信息；如果时间信息不是00:00:00,上句查找无结果</span><br><span class="line"># 按照date()日期进行过滤信息，更可靠 </span><br><span class="line">select cust_id,order_num from orders where date(order_date) = &quot;2005-09-01&quot;;</span><br><span class="line"></span><br><span class="line"># 检索2005年9月下的订单 </span><br><span class="line">select cust_id,order_num from orders where year(order_date) = 2005 and month(order_date) = 9;</span><br><span class="line">select cust_id,order_num from orders where date(order_date) between &quot;2005-09-01&quot; and &quot;2005-09-30&quot;;</span><br><span class="line"></span><br><span class="line">-- 数值处理函数 </span><br><span class="line">#    abs()            返回一个数的绝对值</span><br><span class="line">#    cos()            返回一个角度的余弦</span><br><span class="line">#    exp()            返回一个数的指数值</span><br><span class="line">#    mod()            返回除操作的余数</span><br><span class="line">#    pi()            返回圆周率    </span><br><span class="line">#    sin()            返回一个角度的正弦 </span><br><span class="line">#    sqrt()            返回一个数的平方根 </span><br><span class="line">#    tan()            返回一个角度的正切 </span><br></pre></td></tr></table></figure><h2 id="第12章-汇总数据"><a href="#第12章-汇总数据" class="headerlink" title="第12章 汇总数据"></a>第12章 汇总数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># avg()            返回某列的平均值 </span><br><span class="line"># count()        返回某列的行数 </span><br><span class="line"># max()            返回某列的最大值 </span><br><span class="line"># min()            返回某列的最小值 </span><br><span class="line"># sum()            返回某列值之和 </span><br><span class="line"></span><br><span class="line">-- avg()</span><br><span class="line"># AVG()返回products表中所有产品的平均价格</span><br><span class="line">select avg(prod_price) as avg_price from products;</span><br><span class="line"># 返回特定供应商所提供产品的平均价格</span><br><span class="line">select avg(prod_price) as avg_price from products where vend_id = 1003;</span><br><span class="line"># avg()只能作用于单列，多列使用多个avg()</span><br><span class="line">select avg(item_price) as avg_itemprice,avg(quantity) as avg_quantity from orderitems;</span><br><span class="line"></span><br><span class="line">-- count()</span><br><span class="line"># COUNT(*)对表中行的数目进行计数，不忽略空值 </span><br><span class="line">select count(*) as num_cust from customers; </span><br><span class="line"># 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值</span><br><span class="line">select count(cust_email) as num_cust from customers;  </span><br><span class="line"></span><br><span class="line">-- max() &amp; min()</span><br><span class="line"># MAX()返回products表中最贵的物品的价格</span><br><span class="line">select max(prod_price) as max_price from products;</span><br><span class="line"># 在用于文本数据时，如果数据按相应的列排序，则MAX()返回最后一行</span><br><span class="line">select max(prod_name) from products; </span><br><span class="line"># MIN()返回products表中最便宜物品的价格</span><br><span class="line">select min(prod_price) as min_price from products;</span><br><span class="line"># 在用于文本数据时，如果数据按相应的列排序，则MIN()返回最前面一行</span><br><span class="line">select min(prod_name) from products; </span><br><span class="line"></span><br><span class="line">-- sum()</span><br><span class="line"># 检索所订购物品的总数（所有quantity值之和）</span><br><span class="line">select sum(quantity) as items_ordered from orderitems;</span><br><span class="line">select sum(quantity) as items_ordered from orderitems where order_num = 20005;</span><br><span class="line"># 订单20005的总订单金额</span><br><span class="line">select sum(quantity * item_price) as total_price from orderitems where order_num = 20005;</span><br><span class="line"></span><br><span class="line">-- 聚类不同值 distinct</span><br><span class="line"># 使用了DISTINCT参数，因此平均值只考虑各个不同的价格</span><br><span class="line">select avg(distinct prod_price) as avg_price from products where vend_id = 1003;</span><br><span class="line"># distinct 只能作用于count(),不能用于count(*)</span><br><span class="line"># distinct 同max(),min()的结合使用，没有意义 </span><br><span class="line"></span><br><span class="line">-- 组合聚类函数 </span><br><span class="line"># 4个聚集计算:物品的数目，产品价格的最高、最低以及平均值 </span><br><span class="line">SELECT </span><br><span class="line">    COUNT(*) AS num_items,</span><br><span class="line">    MIN(prod_price) AS price_min,</span><br><span class="line">    MAX(prod_price) AS price_max,</span><br><span class="line">    AVG(prod_price) AS price_avg</span><br><span class="line">FROM</span><br><span class="line">    products;</span><br></pre></td></tr></table></figure><h2 id="第13章-分组计算"><a href="#第13章-分组计算" class="headerlink" title="第13章 分组计算"></a>第13章 分组计算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-- group by 分组 </span><br><span class="line"># 按vend_id排序并分组数据</span><br><span class="line">select vend_id, count(*) as num_prods from products group by vend_id;</span><br><span class="line"># 使用WITH ROLLUP关键字，可以得到每个分组的汇总值，下述语句得到所有分组count(*)的和14 </span><br><span class="line">select vend_id, count(*) as num_prods from products group by vend_id with rollup;</span><br><span class="line"></span><br><span class="line">-- having子句 过滤分组 </span><br><span class="line"># where过滤行，having过滤分组 </span><br><span class="line"># WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤</span><br><span class="line"># COUNT(*) &gt;=2（两个以上的订单）的那些分组</span><br><span class="line">select cust_id, count(*) as orders from orders group by cust_id having count(*)&gt;=2;</span><br><span class="line"></span><br><span class="line">-- where和having组合使用 </span><br><span class="line">#列出具有2个（含）以上、价格为10（含）以上的产品的供应商</span><br><span class="line">select vend_id,count(*) as num_prods from products where prod_price &gt;=10 group by vend_id having count(*)&gt;=2;</span><br><span class="line">#不加where条件，结果不同 </span><br><span class="line">select vend_id,count(*) as num_prods from products group by vend_id having count(*) &gt;=2;</span><br><span class="line"></span><br><span class="line">-- 分组和排序 </span><br><span class="line"># 检索总计订单价格大于等于50的订单的订单号和总计订单价格</span><br><span class="line">select order_num,sum(quantity * item_price) as ordertotal from orderitems group by order_num having sum(quantity * item_price) &gt;=50;</span><br><span class="line"># 按总计订单价格排序输出</span><br><span class="line">SELECT </span><br><span class="line">    order_num, SUM(quantity * item_price) AS ordertotal</span><br><span class="line">FROM</span><br><span class="line">    orderitems</span><br><span class="line">GROUP BY order_num</span><br><span class="line">HAVING SUM(quantity * item_price) &gt;= 50</span><br><span class="line">ORDER BY ordertotal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- select子句总结及顺序 </span><br><span class="line"># 子句            说明                        是否必须使用 </span><br><span class="line"># select        要返回的列或表达式            是 </span><br><span class="line"># from            从中检索数据的表            仅在从表选择数据时使用 </span><br><span class="line"># where            行级过滤                    否 </span><br><span class="line"># group by        分组说明                    仅在按组计算聚集时使用 </span><br><span class="line"># having        组级过滤                      否 </span><br><span class="line"># order by        输出排序顺序                 否</span><br><span class="line"># limit            要检索的行数                 否 </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第14章-使用子查询"><a href="#第14章-使用子查询" class="headerlink" title="第14章 使用子查询"></a>第14章 使用子查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 利用子查询进行过滤</span><br><span class="line"># 列出订购物品TNT2的所有客户</span><br><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">                  FROM orders</span><br><span class="line">                  WHERE order_num IN (SELECT order_num</span><br><span class="line">                                      FROM orderitems</span><br><span class="line">                                      WHERE prod_id = &#x27;TNT2&#x27;));</span><br><span class="line">                                      </span><br><span class="line">                                      </span><br><span class="line">-- 作为计算字段使用子查询</span><br><span class="line"># 对客户10001的订单进行计数</span><br><span class="line">select count(order_num) from orders where cust_id = 10001;</span><br><span class="line"># 显示customers 表中每个客户的订单总数</span><br><span class="line">select cust_name,cust_state, (select count(*) from orders where orders.cust_id = customers.cust_id) as orders</span><br><span class="line">from customers order by cust_name;</span><br></pre></td></tr></table></figure><h2 id="第15章-联结表"><a href="#第15章-联结表" class="headerlink" title="第15章 联结表"></a>第15章 联结表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-- 创建联结 </span><br><span class="line"># where子句联结 </span><br><span class="line">select vend_name,prod_name,prod_price </span><br><span class="line">from vendors,products</span><br><span class="line">where vendors.vend_id = products.vend_id</span><br><span class="line">order by vend_name,prod_name;</span><br><span class="line"></span><br><span class="line">-- 笛卡尔积 / 叉联结 </span><br><span class="line">/*由没有联结条件的表关系返回的结果为笛卡尔积。</span><br><span class="line">检索出的行的数目将是第一个表中的行数乘以第二个表的行数。*/</span><br><span class="line"></span><br><span class="line"># 删除where联结条件 </span><br><span class="line"># 返回的数据用每个供应商匹配了每个产品，它包括了供应商不正确的产品</span><br><span class="line">select vend_name,prod_name,prod_price </span><br><span class="line">from vendors,products</span><br><span class="line">order by vend_name,prod_name;</span><br><span class="line"></span><br><span class="line">-- 内部联结 inner join ： 表间相等测试 </span><br><span class="line">select vend_name,prod_name,prod_price </span><br><span class="line">from vendors inner join products</span><br><span class="line">on vendors.vend_id = products.vend_id;</span><br><span class="line"></span><br><span class="line"># 编号为20005的订单中的物品及对应情况 </span><br><span class="line">select prod_name,vend_name,prod_price,quantity</span><br><span class="line">from orderitems,products,vendors</span><br><span class="line">where products.vend_id = vendors.vend_id</span><br><span class="line">and orderitems.prod_id = products.prod_id</span><br><span class="line">and order_num = 20005;</span><br><span class="line"></span><br><span class="line"># 订购产品TNT2的客户列表</span><br><span class="line">select cust_name,cust_contact</span><br><span class="line">from customers,orders,orderitems</span><br><span class="line">where customers.cust_id = orders.cust_id</span><br><span class="line">and orders.order_num =  orderitems.order_num</span><br><span class="line">and prod_id = &#x27;TNT2&#x27;;</span><br></pre></td></tr></table></figure><h2 id="第16章-创建高级联结"><a href="#第16章-创建高级联结" class="headerlink" title="第16章 创建高级联结"></a>第16章 创建高级联结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">-- 使用表别名</span><br><span class="line"># 给列名或计算字段起别名 </span><br><span class="line"> select concat(rtrim(vend_name),&#x27; (&#x27;,rtrim(vend_country),&#x27;)&#x27;) as vend_title</span><br><span class="line"> from vendors order by vend_name;</span><br><span class="line"> # 给表起别名 </span><br><span class="line"> select cust_name,cust_contact </span><br><span class="line"> from customers as c,orders as o,orderitems as oi</span><br><span class="line"> where c.cust_id = o.cust_id</span><br><span class="line"> and oi.order_num = o.order_num</span><br><span class="line"> and prod_id = &#x27;TNT2&#x27;;</span><br><span class="line"> </span><br><span class="line">-- 自联结 </span><br><span class="line"># ID为DTNTR该物品的供应商生产的其他物品</span><br><span class="line">#方法：子查询 </span><br><span class="line">select prod_id,prod_name from products</span><br><span class="line">where vend_id = (select vend_id from products where prod_id = &#x27;DTNTR&#x27;);</span><br><span class="line"> #方法：使用联结 </span><br><span class="line">select p1.prod_id,p1.prod_name</span><br><span class="line">from products as p1, products as p2</span><br><span class="line">where p1.vend_id = p2.vend_id</span><br><span class="line">and p2.prod_id = &#x27;DTNTR&#x27;;</span><br><span class="line"></span><br><span class="line">-- 自然联结</span><br><span class="line"># 自然联结使每个列只返回一次</span><br><span class="line"># 方法：通过对表使用通配符*，对所有其他表的列使用明确的子集 </span><br><span class="line">select c.*,o.order_num,o.order_date,oi.prod_id,oi.quantity,oi.item_price</span><br><span class="line">from customers as c,orders as o,orderitems as oi</span><br><span class="line">where c.cust_id = o.cust_id</span><br><span class="line">and oi.order_num = o.order_num</span><br><span class="line">and prod_id = &#x27;FB&#x27;;</span><br><span class="line"> </span><br><span class="line">-- 外部联结 </span><br><span class="line"># 检索所有客户及其订单</span><br><span class="line"># 方法： 内部联结 </span><br><span class="line">select customers.cust_id,orders.order_num</span><br><span class="line">from customers inner join orders</span><br><span class="line">on customers.cust_id = orders.cust_id;</span><br><span class="line"> </span><br><span class="line"># 检索所有客户及其订单,包括那些没有订单的客户</span><br><span class="line"># 01 ： 左外部联结</span><br><span class="line">select customers.cust_id,orders.order_num</span><br><span class="line">from customers left outer join orders</span><br><span class="line">on customers.cust_id = orders.cust_id;</span><br><span class="line"></span><br><span class="line"># 02 ：若使用 右外部联结 结果不同 </span><br><span class="line">select customers.cust_id,orders.order_num</span><br><span class="line">from customers right outer join orders</span><br><span class="line">on customers.cust_id = orders.cust_id;</span><br><span class="line"></span><br><span class="line"># 03： 若使用 右外部联结 调换两表位置 结果同01代码相同 </span><br><span class="line">select customers.cust_id,orders.order_num</span><br><span class="line">from orders right outer join customers</span><br><span class="line">on customers.cust_id = orders.cust_id;</span><br><span class="line"> </span><br><span class="line">-- 使用带聚集函数的联结 </span><br><span class="line"> # 检索所有客户分别对应的订单数，inner join </span><br><span class="line">select customers.cust_name,</span><br><span class="line">       customers.cust_id,</span><br><span class="line">       count(orders.order_num) as num_ord</span><br><span class="line">from customers inner join orders </span><br><span class="line">on customers.cust_id = orders.cust_id</span><br><span class="line">group by customers.cust_id; </span><br><span class="line"> </span><br><span class="line">  # 检索所有客户分别对应的订单数，包括没有订单的客户，left outer join </span><br><span class="line"> select customers.cust_name,</span><br><span class="line">       customers.cust_id,</span><br><span class="line">       count(orders.order_num) as num_ord</span><br><span class="line">from customers left outer join orders </span><br><span class="line">on customers.cust_id = orders.cust_id</span><br><span class="line">group by customers.cust_id; </span><br></pre></td></tr></table></figure><h2 id="第17章-组合查询"><a href="#第17章-组合查询" class="headerlink" title="第17章 组合查询"></a>第17章 组合查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-- 使用union </span><br><span class="line"># 价格小于等于5的所有物品</span><br><span class="line">select vend_id,prod_id,prod_price from products where prod_price &lt;=5;</span><br><span class="line"># 供应商1001和1002生产的所有物品</span><br><span class="line">select vend_id,prod_id,prod_price from products where vend_id in (1001,1002);</span><br><span class="line"># 价格小于等于5的所有物品的列表，而且包括供应商1001和1002生产的所有物品（不考虑价格）</span><br><span class="line"># 方法1 使用union </span><br><span class="line">select vend_id,prod_id,prod_price from products where prod_price &lt;=5</span><br><span class="line">union</span><br><span class="line">select vend_id,prod_id,prod_price from products where vend_id in (1001,1002);</span><br><span class="line"># 方法2 使用where </span><br><span class="line">select vend_id,prod_id,prod_price from products </span><br><span class="line">where prod_price &lt;=5 or vend_id in (1001,1002);</span><br><span class="line"></span><br><span class="line"># union默认自动去除重复的行 </span><br><span class="line"># union all，匹配所有行 ，不取消重复行 </span><br><span class="line">select vend_id,prod_id,prod_price from products where prod_price &lt;=5</span><br><span class="line">union all</span><br><span class="line">select vend_id,prod_id,prod_price from products where vend_id in (1001,1002);  # 有一行出现2次 </span><br><span class="line"></span><br><span class="line"># 对union组合结果进行排序</span><br><span class="line"># union组合完只能使用一条order by语句，放在最后一个select语句后面 </span><br><span class="line">select vend_id,prod_id,prod_price from products where prod_price &lt;=5</span><br><span class="line">union</span><br><span class="line">select vend_id,prod_id,prod_price from products where vend_id in (1001,1002)</span><br><span class="line">order by vend_id,prod_price;</span><br></pre></td></tr></table></figure><h2 id="第18章-全文本搜索"><a href="#第18章-全文本搜索" class="headerlink" title="第18章 全文本搜索"></a>第18章 全文本搜索</h2><ul><li>MySQL支持几种基本的数据库引擎。两个最常使用的引擎为<strong>MyISAM</strong>和<strong>InnoDB</strong>，前者支持全文本搜索，后者不支持。</li><li><strong>为什么要用全文本搜索？</strong>通配符和正则表达式存在：性能耗时、无法明确控制什么匹配什么不匹配、不能提供智能化的选择结果等问题</li><li><strong>一般在创建表时启用全文本搜索</strong>。CREATE TABLE语句接受FULLTEXT子句，给出被索引列的一个逗号分隔的列表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE productnotes</span><br><span class="line">(</span><br><span class="line">   note_id int NOT NULL AUTO_INCREMENT,</span><br><span class="line">   prod_id char(10) NOT NULL,</span><br><span class="line">   note_date datetime NOT NULL,</span><br><span class="line">   note_text text NULL , </span><br><span class="line">   PRIMARY KEY(note_id),</span><br><span class="line">   FULLTEXT(note_text)</span><br><span class="line"> ) ENGINE = MyISAM;</span><br><span class="line"></span><br><span class="line">-- 进行全文本搜索 </span><br><span class="line"># Match() 指定被搜索的列，against()指定要使用的搜索表达式 </span><br><span class="line">select note_text from productnotes where match(note_text) against(&#x27;rabbit&#x27;);</span><br><span class="line"></span><br><span class="line"># 如果用like语句 </span><br><span class="line">select note_text from productnotes where note_text like &#x27;%rabbit%&#x27;;</span><br><span class="line"></span><br><span class="line"># 演示排序如何工作 </span><br><span class="line">/*  注意：RANK (R)在mysql 8.0.2 (reserved)版本中为keyword保留字</span><br><span class="line">当字段名与MySQL保留字冲突时,可以用字符‘’将字段名括起来</span><br><span class="line">或者改为其他名字，比如as rank1等</span><br><span class="line">*/</span><br><span class="line">select note_text, match(note_text) against(&#x27;rabbit&#x27;) as &#x27;rank&#x27; from productnotes; </span><br><span class="line"></span><br><span class="line">-- 使用查询扩展 </span><br><span class="line"> # 进行一个简单的全文本搜索，没有查询扩展</span><br><span class="line"> select note_text from productnotes where match(note_text) against(&#x27;anvils&#x27;);</span><br><span class="line"> # 相同的搜索，这次使用查询扩展</span><br><span class="line"> select note_text from productnotes where match(note_text) against(&#x27;anvils&#x27; with query expansion);</span><br><span class="line"></span><br><span class="line">-- 布尔文本搜索</span><br><span class="line">-- 全文本布尔操作符 </span><br><span class="line">#    布尔操作符            说明</span><br><span class="line">#    +                包含，词必须存在 </span><br><span class="line">#    -                排除，词必须不出现</span><br><span class="line">#    &gt;                包含，而且增加等级值 </span><br><span class="line">#    &lt;                包含，且减少等级值 </span><br><span class="line">#    ()                把词组成子表达式（允许这些表达式作为一个组被包含、排除、排列等）</span><br><span class="line">#    ~                取消一个词的排序值</span><br><span class="line">#     *                词尾的通配符</span><br><span class="line">#    “ ”                定义一个短语（与单个词的列表不一样，它匹配整个短语一边包含或排除这个短语）</span><br><span class="line"></span><br><span class="line"># 全文本搜索检索包含词heavy的所有行</span><br><span class="line"># 关键字IN BOOLEAN MODE，实际上没有指定布尔操作符，其结果与没有指定布尔方式的结果相同</span><br><span class="line">select note_text from productnotes where match(note_text) against(&#x27;heavy&#x27; in boolean mode);</span><br><span class="line"># -rope* 排除包含rope*（任何以rope开始的词，包括ropes）的行</span><br><span class="line">select note_text from productnotes where match(note_text) against(&#x27;heavy -rope*&#x27; in boolean mode);</span><br><span class="line"></span><br><span class="line"># 匹配包含词rabbit和bait的行</span><br><span class="line">select note_text from productnotes where match(note_text) against(&#x27;+rabbit +bait&#x27; in boolean mode);</span><br><span class="line"></span><br><span class="line"># 不指定操作符，搜索匹配包含rabbit和bait中的至少一个词的行</span><br><span class="line">select note_text from productnotes where match(note_text) against(&#x27;rabbit bait&#x27; in boolean mode);</span><br><span class="line"></span><br><span class="line"># 搜索匹配短语rabbit bait而不是匹配两个词rabbit和bait。 </span><br><span class="line">select note_text from productnotes where match(note_text) against(&#x27;&quot;rabbit bait&quot;&#x27; in boolean mode);</span><br><span class="line"></span><br><span class="line"># 匹配rabbit和carrot，增加前者的等级，降低后者的等级</span><br><span class="line">select note_text from productnotes where match(note_text) against(&#x27;&gt;rabbit &lt;carrot&#x27; in boolean mode);</span><br><span class="line"></span><br><span class="line"># 必须匹配词safe和combination，降低后者的等级</span><br><span class="line">select note_text from productnotes where match(note_text) against(&#x27;+safe +(&lt;combination)&#x27; in boolean mode);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第19章-插入数据"><a href="#第19章-插入数据" class="headerlink" title="第19章 插入数据"></a>第19章 插入数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-- 插入完整的行 </span><br><span class="line"># 插入一个新客户到customers表</span><br><span class="line"># 简单但不安全，如果原来表列结构调整，会有问题 </span><br><span class="line">insert into customers values (null,&#x27;Pep E. LaPew&#x27;,&#x27;100 Main Street&#x27;,&#x27;Los Angeles&#x27;,&#x27;CA&#x27;,&#x27;90046&#x27;,&#x27;USA&#x27;,NULL,NULL);</span><br><span class="line"># 表明括号内明确列名，更安全，稍繁琐 </span><br><span class="line">insert into customers (cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)</span><br><span class="line">values (&#x27;Pep E. LaPew&#x27;,&#x27;100 Main Street&#x27;,&#x27;Los Angeles&#x27;,&#x27;CA&#x27;,&#x27;90046&#x27;,&#x27;USA&#x27;,NULL,NULL);</span><br><span class="line"></span><br><span class="line">-- 插入多个行 </span><br><span class="line"># 方法1： 提交多个insert 语句</span><br><span class="line">insert into customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)</span><br><span class="line">values(&#x27;Pep E. LaPew&#x27;,&#x27;100 Main Street&#x27;,&#x27;Los Angeles&#x27;,&#x27;CA&#x27;,&#x27;90046&#x27;,&#x27;USA&#x27;);</span><br><span class="line">insert into customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)</span><br><span class="line">values(&#x27;M. Martian&#x27;,&#x27;42 Galaxy Way&#x27;,&#x27;New York&#x27;,&#x27;NY&#x27;,&#x27;11213&#x27;,&#x27;USA&#x27;);</span><br><span class="line"># 方法2： 只要每条INSERT语句中的列名（和次序）相同，可以如下组合各语句</span><br><span class="line"># 单条INSERT语句有多组值，每组值用一对圆括号括起来，用逗号分隔</span><br><span class="line">insert into customers(cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)</span><br><span class="line">values(&#x27;Pep E. LaPew&#x27;,&#x27;100 Main Street&#x27;,&#x27;Los Angeles&#x27;,&#x27;CA&#x27;,&#x27;90046&#x27;,&#x27;USA&#x27;),(&#x27;M. Martian&#x27;,&#x27;42 Galaxy Way&#x27;,&#x27;New York&#x27;,&#x27;NY&#x27;,&#x27;11213&#x27;,&#x27;USA&#x27;);</span><br><span class="line"></span><br><span class="line">-- 插入检索出来的值 </span><br><span class="line"># 新建custnew表（非书本内容）</span><br><span class="line">CREATE TABLE `custnew` (</span><br><span class="line">  `cust_id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `cust_name` char(50) NOT NULL,</span><br><span class="line">  `cust_address` char(50) DEFAULT NULL,</span><br><span class="line">  `cust_city` char(50) DEFAULT NULL,</span><br><span class="line">  `cust_state` char(5) DEFAULT NULL,</span><br><span class="line">  `cust_zip` char(10) DEFAULT NULL,</span><br><span class="line">  `cust_country` char(50) DEFAULT NULL,</span><br><span class="line">  `cust_contact` char(50) DEFAULT NULL,</span><br><span class="line">  `cust_email` char(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`cust_id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"># 在表custnew中插入一行数据 （非书本内容）</span><br><span class="line">insert into custnew (cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)</span><br><span class="line">values(null,null,&#x27;mysql carsh course@learning.com&#x27;,&#x27;Y.CARY&#x27;,&#x27;BAKE WAY&#x27;,&#x27;NEW YORK&#x27;,&#x27;NY&#x27;,&#x27;112103&#x27;,&#x27;USA&#x27;);</span><br><span class="line"></span><br><span class="line"># 将custnew中内容插入到customers表中 </span><br><span class="line"># 同书本代码不同，这里省略了custs_id,这样MySQL就会生成新值。</span><br><span class="line">insert into customers (cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)</span><br><span class="line">select cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country from custnew;</span><br></pre></td></tr></table></figure><h2 id="第20章-更新和删除数据"><a href="#第20章-更新和删除数据" class="headerlink" title="第20章 更新和删除数据"></a>第20章 更新和删除数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- update语句 : 删除或更新指定列 </span><br><span class="line"># 更新： 客户10005现在有了电子邮件地址</span><br><span class="line">update customers set cust_email = &#x27;elmer@fudd.com&#x27; where cust_id = 10005;</span><br><span class="line"># 更新： 多个列 </span><br><span class="line">UPDATE customers </span><br><span class="line">SET cust_name = &#x27;The Fudds&#x27;,</span><br><span class="line">    cust_email = &#x27;elmer@fudd.com&#x27;</span><br><span class="line">WHERE cust_id = 10005;</span><br><span class="line"></span><br><span class="line"># 删除： 某个列的值，可设置它为NULL（假如表定义允许NULL值）</span><br><span class="line">update customers set cust_email = null where cust_id = 10005;</span><br><span class="line"></span><br><span class="line">-- delete 语句： 删除整行而不是某列 </span><br><span class="line"># 从customers表中删除一行</span><br><span class="line">delete from customers where cust_id = 10006;</span><br><span class="line"></span><br><span class="line">-- truncate table语句 </span><br><span class="line"># 如果想从表中删除 所有行，不要使用DELETE，可使用TRUNCATE TABLE语句</span><br><span class="line"># TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据</span><br></pre></td></tr></table></figure><h2 id="第21章-创建和操纵表"><a href="#第21章-创建和操纵表" class="headerlink" title="第21章 创建和操纵表"></a>第21章 创建和操纵表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-- 新建表 create table</span><br><span class="line"># 参书本配套文件create.sql</span><br><span class="line"></span><br><span class="line">-- 更新表 alter table </span><br><span class="line"># 给vendors表增加一个名为vend_phone的列</span><br><span class="line">alter table vendors </span><br><span class="line">add vend_phone char(20);</span><br><span class="line"># 删除刚刚添加的列</span><br><span class="line">alter table vendors</span><br><span class="line">drop column vend_phone;</span><br><span class="line"></span><br><span class="line"># ALTER TABLE的一种常见用途是定义外键</span><br><span class="line"># 以下为书本配套文件create.sql中定义外键的语句 </span><br><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_orders FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br><span class="line">ALTER TABLE orderitems ADD CONSTRAINT fk_orderitems_products FOREIGN KEY (prod_id) REFERENCES products (prod_id);</span><br><span class="line">ALTER TABLE orders ADD CONSTRAINT fk_orders_customers FOREIGN KEY (cust_id) REFERENCES customers (cust_id);</span><br><span class="line">ALTER TABLE products ADD CONSTRAINT fk_products_vendors FOREIGN KEY (vend_id) REFERENCES vendors (vend_id);</span><br><span class="line"></span><br><span class="line">-- 删除表</span><br><span class="line"># 删除customers2表（假设它存在）</span><br><span class="line">drop table customers2;</span><br><span class="line"></span><br><span class="line">-- 重命名表 </span><br><span class="line"># 使用RENAME TABLE语句可以重命名一个表 (假设存在下述表)</span><br><span class="line">rename table customers2 to customers;</span><br><span class="line"># 对多个表重命名(假设存在下述表)</span><br><span class="line">rename table backup_customers to customer,</span><br><span class="line">             backup_vendors to vendors,</span><br><span class="line">             backup_products to products;</span><br></pre></td></tr></table></figure><h2 id="第22章-使用视图"><a href="#第22章-使用视图" class="headerlink" title="第22章 使用视图"></a>第22章 使用视图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*视图提供了一种MySQL的SELECT语句层次的封装，可用来简化数据处理以及重新格式化基础数据或保护基础数据。 */ </span><br><span class="line">#视图是虚拟的表；视图只包含使用时动态检索数据的查询。</span><br><span class="line">-- 创建视图 create view</span><br><span class="line">-- 创建视图的语句 show create view viewname</span><br><span class="line">-- 删除视图 drop view viewname</span><br><span class="line">-- 更新视图 1. 先drop后create 2. 直接用create or repalce view</span><br><span class="line"></span><br><span class="line"># 创建一个名为productcustomers的视图</span><br><span class="line">create view productcustomers as</span><br><span class="line">select cust_name,cust_contact,prod_id</span><br><span class="line">from customers,orders,orderitems</span><br><span class="line">where customers.cust_id = orders.cust_id</span><br><span class="line">and orders.order_num = orderitems.order_num;</span><br><span class="line"># 检索订购了产品TNT2的客户</span><br><span class="line">select cust_name,cust_contact from productcustomers where prod_id = &#x27;TNT2&#x27;;</span><br><span class="line"></span><br><span class="line"># 用视图重新格式化检索出的数据</span><br><span class="line"># (来自第10章）在单个组合计算列中返回供应商名和位置</span><br><span class="line">select concat(rtrim(vend_name),&#x27; (&#x27;,rtrim(vend_country),&#x27;)&#x27;) as vend_title from vendors order by vend_name;</span><br><span class="line"># 若经常使用上述格式组合，可以创建视图 </span><br><span class="line">create view vendorlocations as</span><br><span class="line">select concat(rtrim(vend_name),&#x27; (&#x27;,rtrim(vend_country),&#x27;)&#x27;) as vend_title from vendors order by vend_name;</span><br><span class="line"># 检索出以创建所有邮件标签的数据</span><br><span class="line">select * from vendorlocations;</span><br><span class="line"></span><br><span class="line"># 用视图过滤不想要的数据</span><br><span class="line"># 定义customeremaillist视图，它过滤没有电子邮件地址的客户</span><br><span class="line">create view customeremaillist as </span><br><span class="line">select cust_id,cust_name,cust_email from customers</span><br><span class="line">where cust_email is not null;</span><br><span class="line">select * from customeremaillist;</span><br><span class="line"></span><br><span class="line"># 使用视图与计算字段</span><br><span class="line"># (来自第10章）检索某个特定订单中的物品，计算每种物品的总价格</span><br><span class="line">select prod_id,quantity,item_price,quantity*item_price as expanded_price from orderitems where order_num = 20005;</span><br><span class="line"># 将其转换为一个视图</span><br><span class="line">create view orderitemsexpanded as </span><br><span class="line">select order_num,prod_id,quantity,item_price,quantity*item_price as expanded_price from orderitems;</span><br><span class="line"># 创建视图的时候select添加了列名order_num,否则无法按照order_num进行过滤查找 </span><br><span class="line">select * from orderitemsexpanded where order_num = 20005;</span><br><span class="line"></span><br><span class="line"># 更新视图 </span><br><span class="line"># 视图中虽然可以更新数据，但是有很多的限制。</span><br><span class="line"># 一般情况下，最好将视图作为查询数据的虚拟表，而不要通过视图更新数据</span><br></pre></td></tr></table></figure><h2 id="第23章-使用存储过程"><a href="#第23章-使用存储过程" class="headerlink" title="第23章 使用存储过程"></a>第23章 使用存储过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">-- 创建存储过程 </span><br><span class="line"># 返回产品平均价格的存储过程</span><br><span class="line"></span><br><span class="line">create procedure productpricing()</span><br><span class="line">begin</span><br><span class="line">    select avg(prod_price) as priceaverage from products;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line"># 调用上述存储过程 </span><br><span class="line">call productpricing();</span><br><span class="line"></span><br><span class="line">-- 删除存储过程,请注意:没有使用后面的()，只给出存储过程名。</span><br><span class="line">drop procedure productpricing;</span><br><span class="line"></span><br><span class="line">-- 使用参数 out</span><br><span class="line"># 重新定义存储过程productpricing</span><br><span class="line"></span><br><span class="line">create procedure productpricing(</span><br><span class="line">    out pl decimal(8,2), out ph decimal(8,2), out pa decimal(8,2))</span><br><span class="line">begin</span><br><span class="line">    select min(prod_price) into pl from products;</span><br><span class="line">    select max(prod_price) into ph from products;</span><br><span class="line">    select avg(prod_price) into pa from products;</span><br><span class="line">end;</span><br><span class="line">/*此存储过程接受3个参数：pl存储产品最低价格，ph存储产品最高价格，pa存储产品平均价格。每个参数必须具有指定的类型，这里使用十进制值。关键词OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、OUT(从存储过程传出)和INOUT（对存储过程传入和传出）类型的参数。*/</span><br><span class="line"></span><br><span class="line"># 为调用上述存储过程，必须指定3个变量名 所有MySQL变量都必须以@开始。</span><br><span class="line">call productpricing(@pricelow,@pricehigh,@priceaverage);</span><br><span class="line"></span><br><span class="line"># 显示检索出的产品平均价格</span><br><span class="line">select @priceaverage;</span><br><span class="line"># 获得3个值</span><br><span class="line">select @pricehigh,@pricelow,@priceaverage;</span><br><span class="line"></span><br><span class="line">-- 使用参数 in 和 out</span><br><span class="line"># 使用IN和OUT参数,存储过程ordertotal接受订单号并返回该订单的合计</span><br><span class="line">delimiter //</span><br><span class="line">create procedure ordertotal(</span><br><span class="line">    in onumber int,                   # onumber定义为IN，因为订单号被传入存储过程</span><br><span class="line">    out ototal decimal(8,2)            # ototal为OUT，因为要从存储过程返回合计</span><br><span class="line">)</span><br><span class="line">begin</span><br><span class="line">    select sum(item_price*quantity) from orderitems </span><br><span class="line">    where order_num = onumber</span><br><span class="line">    into ototal;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"># 给ordertotal传递两个参数；</span><br><span class="line"># 第一个参数为订单号，第二个参数为包含计算出来的合计的变量名</span><br><span class="line">call ordertotal(20005,@total);</span><br><span class="line"># 显示此合计</span><br><span class="line">select @total;</span><br><span class="line"># 得到另一个订单的合计显示</span><br><span class="line">call ordertotal(20009,@total);</span><br><span class="line">select @total;</span><br><span class="line"></span><br><span class="line">-- 建立智能存储过程 </span><br><span class="line"># 获得与以前一样的订单合计，但只针对某些顾客对合计增加营业税</span><br><span class="line"></span><br><span class="line">-- Name:ordertotal</span><br><span class="line">-- Parameters: onumber = order number</span><br><span class="line">--                taxable = 0 if not taxable, 1 if taxable</span><br><span class="line">--                ototal  = order total variable</span><br><span class="line">delimiter //</span><br><span class="line">create procedure ordertotal(</span><br><span class="line">    in onumber int,</span><br><span class="line">    in taxable boolean,</span><br><span class="line">    out ototal decimal(8,2)</span><br><span class="line">) comment &#x27;obtain order total, optionally adding tax&#x27;</span><br><span class="line">begin</span><br><span class="line">    -- declare variable for total 定义局部变量total</span><br><span class="line">    declare total decimal(8,2);</span><br><span class="line">    -- declare tax percentage 定义局部变量税率 </span><br><span class="line">    declare taxrate int default 6;</span><br><span class="line">    -- get the order total 获得订单合计</span><br><span class="line">    SELECT SUM(item_price * quantity)</span><br><span class="line">    FROM orderitems</span><br><span class="line">    WHERE order_num = onumber INTO total;</span><br><span class="line">    -- is this taxable? 是否要增加营业税？ </span><br><span class="line">    if taxable then</span><br><span class="line">        -- Yes,so add taxrate to the total 给订单合计增加税率</span><br><span class="line">        select total+(total/100*taxrate) into total;</span><br><span class="line">    end if;</span><br><span class="line">    -- and finally,save to out variable 最后，传递给输出变量 </span><br><span class="line">    SELECT total INTO ototal;</span><br><span class="line">END //</span><br><span class="line">delimiter ;</span><br><span class="line"># 调用上述存储过程，不加税 </span><br><span class="line">call ordertotal(20005,0,@total);</span><br><span class="line">select @total;</span><br><span class="line"># 调用上述存储过程，加税 </span><br><span class="line">call ordertotal(20005,1,@total);</span><br><span class="line">select @total;</span><br><span class="line"></span><br><span class="line"># 显示用来创建一个存储过程的CREATE语句</span><br><span class="line">show create procedure ordertotal;</span><br><span class="line"></span><br><span class="line"># 获得包括何时、由谁创建等详细信息的存储过程列表</span><br><span class="line"># 该语句列出所有存储过程</span><br><span class="line">show procedure status;</span><br><span class="line"># 过滤模式 </span><br><span class="line">show procedure status like &#x27;ordertotal&#x27;;</span><br></pre></td></tr></table></figure><h2 id="第24章-使用游标"><a href="#第24章-使用游标" class="headerlink" title="第24章 使用游标"></a>第24章 使用游标</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">/*游标是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。</span><br><span class="line">游标使得用户可以根据需要滚动浏览屏幕上的数据。</span><br><span class="line"></span><br><span class="line">游标只能用于存储过程（和函数）*/</span><br><span class="line"></span><br><span class="line">-- 创建、打开、关闭游标 </span><br><span class="line"># 定义名为ordernumbers的游标，检索所有订单</span><br><span class="line">delimiter //</span><br><span class="line">create procedure processorders()</span><br><span class="line">begin</span><br><span class="line">    -- decalre the cursor 声明游标 </span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">    </span><br><span class="line">    -- open the cursor 打开游标</span><br><span class="line">    open ordernumbers;</span><br><span class="line">    -- close the cursor 关闭游标</span><br><span class="line">    close ordernumbers;</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 使用游标数据 </span><br><span class="line"># 例1：检索 当前行 的order_num列，对数据不做实际处理</span><br><span class="line">delimiter //</span><br><span class="line">create procedure processorders()</span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">    -- declare local variables 声明局部变量</span><br><span class="line">    declare o int;</span><br><span class="line">    </span><br><span class="line">    -- decalre the cursor 声明游标 </span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">    </span><br><span class="line">    -- open the cursor 打开游标</span><br><span class="line">    open ordernumbers;</span><br><span class="line">    </span><br><span class="line">    -- get order number 获得订单号 </span><br><span class="line">    fetch ordernumbers into o;</span><br><span class="line">    /*fetch检索 当前行 的order_num列（将自动从第一行开始）到一个名为o的局部声明变量中。</span><br><span class="line">    对检索出的数据不做任何处理。*/</span><br><span class="line">        </span><br><span class="line">    -- close the cursor 关闭游标</span><br><span class="line">    close ordernumbers;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"># 例2：循环检索数据，从第一行到最后一行，对数据不做实际处理</span><br><span class="line">delimiter //</span><br><span class="line">create procedure processorders()</span><br><span class="line">begin</span><br><span class="line">    -- declare local variables 声明局部变量</span><br><span class="line">    declare done boolean default 0;</span><br><span class="line">    declare o int;</span><br><span class="line">   </span><br><span class="line">    -- decalre the cursor 声明游标 </span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">   </span><br><span class="line">    -- declare continue handler</span><br><span class="line">    declare continue handler for sqlstate &#x27;02000&#x27; set done =1;</span><br><span class="line">    -- SQLSTATE &#x27;02000&#x27;是一个未找到条件，当REPEAT由于没有更多的行供循环而不能继续时，出现这个条件。</span><br><span class="line">    </span><br><span class="line">    -- open the cursor 打开游标</span><br><span class="line">    open ordernumbers;</span><br><span class="line">    </span><br><span class="line">    -- loop through all rows 遍历所有行 </span><br><span class="line">    repeat</span><br><span class="line">    </span><br><span class="line">    -- get order number 获得订单号 </span><br><span class="line">    fetch ordernumbers into o;</span><br><span class="line">    -- FETCH在REPEAT内，因此它反复执行直到done为真</span><br><span class="line">    </span><br><span class="line">    -- end of loop</span><br><span class="line">    until done end repeat;</span><br><span class="line">    </span><br><span class="line">    -- close the cursor 关闭游标</span><br><span class="line">    close ordernumbers;</span><br><span class="line"></span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 例3：循环检索数据，从第一行到最后一行，对取出的数据进行某种实际的处理</span><br><span class="line">delimiter //</span><br><span class="line">create procedure processorders()</span><br><span class="line">begin</span><br><span class="line">    -- declare local variables 声明局部变量 </span><br><span class="line">    declare done boolean default 0;</span><br><span class="line">    declare o int;</span><br><span class="line">    declare t decimal(8,2);</span><br><span class="line">    </span><br><span class="line">    -- declare the cursor 声明游标</span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line">    </span><br><span class="line">    -- declare continue handler</span><br><span class="line">    declare continue handler for sqlstate &#x27;02000&#x27; set done = 1;</span><br><span class="line">    </span><br><span class="line">    -- create a table to store the results 新建表以保存数据</span><br><span class="line">    create table if not exists ordertotals</span><br><span class="line">    (order_num int,total decimal(8,2));</span><br><span class="line">    </span><br><span class="line">    -- open the cursor 打开游标</span><br><span class="line">    open ordernumbers;</span><br><span class="line">    </span><br><span class="line">    -- loop through all rows 遍历所有行</span><br><span class="line">    repeat</span><br><span class="line">    </span><br><span class="line">    -- get order number 获取订单号</span><br><span class="line">    fetch ordernumbers into o;</span><br><span class="line">    </span><br><span class="line">    -- get the total for this order 计算订单金额</span><br><span class="line">    call ordertotal(o,1,t);  # 参见23章代码，已创建可使用</span><br><span class="line">    </span><br><span class="line">    -- insert order and total into ordertotals 将订单号、金额插入表ordertotals内</span><br><span class="line">    insert into ordertotals(order_num,total) values(o,t);</span><br><span class="line">    </span><br><span class="line">    -- end of loop</span><br><span class="line">    until done end repeat;</span><br><span class="line">    </span><br><span class="line">    -- close the cursor 关闭游标</span><br><span class="line">    close ordernumbers;</span><br><span class="line"></span><br><span class="line">end // </span><br><span class="line">delimiter ;</span><br><span class="line"># 调用存储过程 precessorders()</span><br><span class="line">call processorders();</span><br><span class="line"># 输出结果</span><br><span class="line">select * from ordertotals;</span><br></pre></td></tr></table></figure><h2 id="第25章-使用触发器"><a href="#第25章-使用触发器" class="headerlink" title="第25章 使用触发器"></a>第25章 使用触发器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-- 创建触发器 </span><br><span class="line">create trigger newproduct after insert on products for each row select &#x27;product added&#x27; into @new_pro</span><br><span class="line">#仅支持表 只有表才支持触发器,每个表最多支持6个触发器</span><br><span class="line"># mysql 5.0以上版本在TRIGGER中不能返回结果集，定义了变量 @new_pro;</span><br><span class="line">insert into products(prod_id,vend_id,prod_name,prod_price) values (&#x27;ANVNEW&#x27;,&#x27;1005&#x27;,&#x27;3 ton anvil&#x27;,&#x27;6.09&#x27;); # 插入一行 </span><br><span class="line">select @new_pro;  # 显示Product added消息</span><br><span class="line"></span><br><span class="line">-- 删除触发器 </span><br><span class="line">drop trigger newproduct;</span><br><span class="line"></span><br><span class="line">-- 使用触发器 </span><br><span class="line"># insert触发器</span><br><span class="line">create trigger neworder </span><br><span class="line">after insert on orders for each row select new.order_num into @order_num;</span><br><span class="line">insert into orders(order_date,cust_id) values (now(),10001);</span><br><span class="line">select @order_num;</span><br><span class="line"></span><br><span class="line"># delete触发器</span><br><span class="line"># 使用OLD保存将要被删除的行到一个存档表中 </span><br><span class="line">delimiter //</span><br><span class="line">create trigger deleteorder before delete on orders for each row</span><br><span class="line">begin</span><br><span class="line">    insert into archive_orders(order_num,order_date,cust_id)</span><br><span class="line">    values(old.order_num,old.order_date,old.cust_id); # 引用一个名为OLD的虚拟表，访问被删除的行</span><br><span class="line">end //</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"># update触发器</span><br><span class="line"># 在更新vendors表中的vend_state值时，插入前先修改为大写格式 </span><br><span class="line">create trigger updatevendor before update on vendors </span><br><span class="line">for each row set new.vend_state = upper(new.vend_state);</span><br><span class="line"># 更新1001供应商的州为china</span><br><span class="line">update vendors set vend_state = &#x27;china&#x27; where vend_id =1001;</span><br><span class="line"># 查看update后数据，1001供应商对应的vend_state自动更新为大写的CHINA</span><br><span class="line">select * from vendors;</span><br></pre></td></tr></table></figure><h2 id="第26章-管理事务处理"><a href="#第26章-管理事务处理" class="headerlink" title="第26章 管理事务处理"></a>第26章 管理事务处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">-- 事务 transaction 指一组sql语句</span><br><span class="line">-- 回退 rollback 指撤销指定sql语句的过程</span><br><span class="line">-- 提交 commit 指将未存储的sql语句结果写入数据库表</span><br><span class="line">-- 保留点 savepoint 指事务处理中设置的临时占位符，可以对它发布回退（与回退整个事务处理不同）</span><br><span class="line"></span><br><span class="line">-- 控制事务处理</span><br><span class="line"># 开始事务及回退 </span><br><span class="line">select * from ordertotals;   # 查看ordertotals表显示不为空</span><br><span class="line">start transaction;           # 开始事务处理 </span><br><span class="line">delete from ordertotals;     # 删除ordertotals表中所有行</span><br><span class="line">select * from ordertotals;   # 查看ordertotals表显示 为空</span><br><span class="line">rollback;                     # rollback语句回退 </span><br><span class="line">select * from ordertotals;   # rollback后，再次查看ordertotals表显示不为空</span><br><span class="line"></span><br><span class="line"># commit 提交 </span><br><span class="line">start transaction;</span><br><span class="line">delete from orderitems where order_num = 20010;</span><br><span class="line">delete from orders where order_num = 20010;</span><br><span class="line">commit;   # 仅在上述两条语句不出错时写出更改 </span><br><span class="line"></span><br><span class="line"># savepoint 保留点 </span><br><span class="line"># 创建保留点</span><br><span class="line">savepoint delete1;</span><br><span class="line"># 回退到保留点 </span><br><span class="line">rollback to delete1;</span><br><span class="line"># 释放保留点 </span><br><span class="line">release savepoint delete1;</span><br><span class="line"></span><br><span class="line">-- 更改默认的提交行为 </span><br><span class="line">set autocommit = 0;  # 设置autocommit为0（假）指示MySQL不自动提交更改</span><br></pre></td></tr></table></figure><h2 id="第27章-全球化和本地化"><a href="#第27章-全球化和本地化" class="headerlink" title="第27章 全球化和本地化"></a>第27章 全球化和本地化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-- 字符集和校对顺序</span><br><span class="line"># 查看所支持的字符集完整列表</span><br><span class="line">show character set;</span><br><span class="line"># 查看所支持校对的完整列表,以及它们适用的字符集</span><br><span class="line">show collation;</span><br><span class="line"># 确定所用系统的字符集和校对</span><br><span class="line">show variables like &#x27;character%&#x27;;</span><br><span class="line">show variables like &#x27;collation%&#x27;;</span><br><span class="line"># 使用带子句的CREATE TABLE，给表指定字符集和校对</span><br><span class="line">create table mytable</span><br><span class="line">(</span><br><span class="line">    column1 int,</span><br><span class="line">    column2 varchar(10)</span><br><span class="line">) default character set hebrew </span><br><span class="line">  collate hebrew_general_ci;</span><br><span class="line"># 除了能指定字符集和校对的表范围外，MySQL还允许对每个列设置它们</span><br><span class="line">create table mytable</span><br><span class="line">(</span><br><span class="line">    column1 int,</span><br><span class="line">    column2 varchar(10),</span><br><span class="line">    column3 varchar(10) character set latin1 collate latin1_general_ci</span><br><span class="line">)default character set hebrew </span><br><span class="line"> collate hebrew_general_ci;</span><br><span class="line"># 校对collate在对用ORDER BY子句排序时起重要的作用</span><br><span class="line"># 如果要用与创建表时不同的校对顺序排序,可在SELECT语句中说明 </span><br><span class="line">select * from customers order by lastname,firstname collate latin1_general_cs;</span><br></pre></td></tr></table></figure><h2 id="第28章-安全管理"><a href="#第28章-安全管理" class="headerlink" title="第28章 安全管理"></a>第28章 安全管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- 管理用户</span><br><span class="line"># 需要获得所有用户账号列表时</span><br><span class="line"># mysql数据库有一个名为user的表，它包含所有用户账号。user表有一个名为user的列</span><br><span class="line">use mysql;</span><br><span class="line">select user from user;</span><br><span class="line"></span><br><span class="line">-- 创建用户账号 </span><br><span class="line"># 使用create user</span><br><span class="line">create user ben identified by &#x27;p@$$w0rd&#x27;;</span><br><span class="line"># 重命名一个用户账号</span><br><span class="line">rename user ben to bforta;</span><br><span class="line"># 删除用户账号 </span><br><span class="line">drop user bforta;</span><br><span class="line"># 查看赋予用户账号的权限</span><br><span class="line">show grants for bforta;</span><br><span class="line"># 允许用户在（crashcourse数据库的所有表）上使用SELECT，只读</span><br><span class="line">grant select on crashcourse.* to bforta;</span><br><span class="line"># 重新查看赋予用户账号的权限，发生变化 </span><br><span class="line">show grants for bforta;</span><br><span class="line"># 撤销特定的权限</span><br><span class="line">revoke select on crashcourse.* from bforta;</span><br><span class="line"># 简化多次授权</span><br><span class="line">grant select,insert on crashcourse.* to bforta;</span><br><span class="line"></span><br><span class="line">-- 更改口令</span><br><span class="line"></span><br><span class="line"># 原来课本中使用的password()加密函数，在8.0版本中已经移除 </span><br><span class="line"># password() :This function was removed in MySQL 8.0.11.</span><br><span class="line">set password for bforta = &#x27;n3w p@$$w0rd&#x27;;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 如果不指定用户名，直接修改当前登录用户的口令 </span><br><span class="line">set password = &#x27;n3w p@$$w0rd&#x27;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-常见面试题</title>
      <link href="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="1-什么是操作系统"><a href="#1-什么是操作系统" class="headerlink" title="1. 什么是操作系统"></a>1. 什么是操作系统</h2><p>操作系统是运行在计算机.上最重要的一种软件，它管理计算机的资源和进程以及所有的硬件和软件。它为计算机硬件和软件提供了一种中间层。</p><p>通常情况下，计算机上会运行着许多应用程序，他们都需要对内存和CPU进行交互，操作系统就是为了保证这些访问和交互能够准确无误的进行。</p><h2 id="2-操作系统的主要目的是什么"><a href="#2-操作系统的主要目的是什么" class="headerlink" title="2. 操作系统的主要目的是什么"></a>2. 操作系统的主要目的是什么</h2><p>操作系统是-种软件，它的主要目的有三种</p><ul><li>管理计算机资源，这些资源包括CPU、内存、磁盘驱动器、打印机等。</li><li>提供一种图形界面，就像我们前面描述的那样，它提供了用户和计算机之间的桥梁。</li><li>为其他软件提供服务，操作系统与软件进行交互，以便为其分配运行所需的任何必要资源。</li></ul><h2 id="3-什么是按需分页"><a href="#3-什么是按需分页" class="headerlink" title="3. 什么是按需分页"></a>3. 什么是按需分页</h2><p>在操作系统中，进程是以页为单位加载到内存中的，按需分页是一种虛拟内存的管理方式。在使用请求分页的系统中，只有在尝试访问页面所在的磁盘并且该须面尚未在内存中时，也就发生了缺页异常，操作系统才会将磁盘页面复制到内存中。</p><h2 id="4-多处理系统的优势"><a href="#4-多处理系统的优势" class="headerlink" title="4. 多处理系统的优势"></a>4. 多处理系统的优势</h2><p>随着处理器的不断增加，我们的计算机系统由单机系统变为了多处理系统，多处理系统的吞吐量比较高，多处理系统拥有多个并行的处理器，这些处理器共享时钟、内存、总线、外围设备等。</p><h2 id="5-什么是内核"><a href="#5-什么是内核" class="headerlink" title="5. 什么是内核"></a>5. 什么是内核</h2><p>在计算机中，内核是-个计算机程序,它是操作系统的核心，可以控制操作系统中所有的内容。内核通常是在boot loader装载程序之前加载的第一个程序。</p><p>boot loader又被称为引导加载程序，它是一个程序，能够将计算机的操作系统放入内存中。在电源通电或者计算机重启时，BIOS 会执行一-些初始测试，然后将控制权转移到引导加载程序所在的主引导记录(MBR)。</p><h2 id="6-什么是实时系统"><a href="#6-什么是实时系统" class="headerlink" title="6. 什么是实时系统"></a>6. 什么是实时系统</h2><p>实时操作系统对时间做出了严格的要求，实时操作系统分为两种:硬实时和软实时<br><strong>硬实时操作系统</strong>规定某个动作必须在规定的时刻内完成或发生，比如汽车生产车间，焊接机器必须在某一时刻内完成焊接，焊接的太早或者太晚都会对汽车造成永久性伤害。<br><strong>软实时操作系统</strong>虽然不希望偶尔违反最终的时限要求，但是仍然可以接受。并且不会引起任何永久性伤害。比如数字音频、多媒体、手机都是属于软实时操作系统。<br>你可以简单理解硬实时和软实时的两个指标:<strong>是否在时刻内必须完成以及是否造成严重损害。</strong></p><h2 id="7-什么是虚拟内存"><a href="#7-什么是虚拟内存" class="headerlink" title="7. 什么是虚拟内存"></a>7. 什么是虚拟内存</h2><p>虛拟内存是一种<strong>内存分配方案，是一项可以用来辅助内存分配的机制。</strong>我们知道，应用程序是按页装载进内存中的。但并不是所有的页都会装载到内存中，计算机中的硬件和软件会将数据从RAM临时传输到磁盘中来弥补内存的不足。如果没有虚拟内存的话，一旦你将计算机内存填满后，计算机会对你说呃，不，<strong>对不起，您无法再加载任何应用程序，请关闭另一个应用程序以加载新的应用程序。</strong>对于虚拟内存，计算机可以执行操作是查看内存中最近未使用过的区域，然后将其复制到硬盘上。虚拟内存通过复制技术实现了妹子，你快来看哥哥能装这么多程序的资本。复制是自动进行的，你无法感知到它的左在。</p><h2 id="8-什么是进程和进程表"><a href="#8-什么是进程和进程表" class="headerlink" title="8. 什么是进程和进程表"></a>8. 什么是进程和进程表</h2><p>进程就是正在执行程序的实例，比如说Web程序就是一个进程，shell 也是一个进程，文章编辑器typora也是一个进程。<br>操作系统负责管理所有正在运行的进程，操作系统会为每个进程分配特定的时间来占用CPU,操作系统还会为每个进程分配特定的资源。<br>操作系统为了跟踪每个进程的活动状态,维护了一个进程表。在进程表的内部，列出了每个进程的状态以及每个进程使用的资源等。<br><a href="http://courses.cs.vt.edu/csonline/OS/Lessons/Processes/index.html这个网站上面有一个关于进程状态轮转的动画，做的真是太好了。">http://courses.cs.vt.edu/csonline/OS/Lessons/Processes/index.html这个网站上面有一个关于进程状态轮转的动画，做的真是太好了。</a></p><h2 id="9-什么是线程，线程和进程的区别"><a href="#9-什么是线程，线程和进程的区别" class="headerlink" title="9. 什么是线程，线程和进程的区别"></a>9. 什么是线程，线程和进程的区别</h2><p>这又是一道老生常谈的问题了，从操作系统的角度来回答一下吧。<br>我们上面说到进程是正在运行的程序的实例，而线程其实就是进程中的单条流向，因为线程具有进程中某些属性，所以线程又被称为轻量级的进程。浏览器如果是一个进程的话，那么浏览器下面的每个tab页可以看作是一个个的线程。<br>下面是线程和进程持有资源的区别</p><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/线程与进程.png" alt="image-20200813222928103" style="zoom:67%;"><p>线程不像进程那样具有很强的独立性，线程之间会共享数据。<br>创建线程的开销要比进程小很多，因为创建线程仅仅需要<strong>堆栈指针和程序计数器</strong>就可以了，而创建进<br>程需要操作系统分配新的地址空间，数据资源等，这个开销比较大。</p><h2 id="10-什么是RR调度算法"><a href="#10-什么是RR调度算法" class="headerlink" title="10 什么是RR调度算法"></a>10 什么是RR调度算法</h2><p><strong>RR(round-robin)</strong>调度算法主要针对分时系统，RR的调度算法会把时间片以相同的部分并循环的分配给每个进程，RR调度算法没有优先级的概念。这种算法的实现比较简单，而且每个线程都会占有时间片，并不存在线程饥饿的问题。</p><h2 id="11-导致系统出现死锁的情况"><a href="#11-导致系统出现死锁的情况" class="headerlink" title="11 导致系统出现死锁的情况"></a>11 导致系统出现死锁的情况</h2><p>死锁的出现需要同时满足下面四个条件</p><ul><li><strong>互斥(Mutual Exclusion)</strong> : 一次只能有一个进程使用资源。如果另一个进程请求该资源，则必须延迟请求进程，直到释放该资源为止。</li><li><strong>保持并等待(Hold and Wait)</strong> :必须存在一个进程，该进程至少持有一个资源，并且正在等待获取其他进程当前所持有的资源。</li><li><strong>无抢占(No Preemption)</strong> :资源不能被抢占，也就是说，在进程完成其任务之后，只能由拥有它的进程自动释放资源。</li><li><strong>循环等待(Circular Wait)</strong> :必须存在一组 {p0，p1, …. pn}的等待进程，使p0等待p1持有的资源，p1等待由p2持有的资源，pn-1 正在等待由pn持有的资源，而pn正在等待由p0持有的资源。</li></ul><h2 id="12-什么是DMA"><a href="#12-什么是DMA" class="headerlink" title="12 什么是DMA"></a>12 什么是DMA</h2><p>DMA的中文名称是<strong>直接内存访问</strong>，它意味着CPU授予I/O模块权限在不涉及CPU的情况下读取或写入内存。也就是DMA可以不需要CPU的参与。这个过程由称为DMA控制器(DMAC) 的芯片管理。<strong>由于DMA设备可以直接在内存之间传输数据，而不是使用CPU作为中介，因此可以缓解总线上的拥塞。DMA通过允许CPU执行任务，同时DMA系统通过系统和内存总线传输数据来提高系统并发性。</strong></p><h2 id="13-多线程编程的好处是什么"><a href="#13-多线程编程的好处是什么" class="headerlink" title="13 多线程编程的好处是什么"></a>13 多线程编程的好处是什么</h2><p>为了提高程序的并行能力了。多线程在<strong>某些情况下</strong>能够使你程序运行的更快，这也是为什么多核CPU会出现，但是多核CPU的出现会导致数据的一致性问题，不过这些问题程序员就能解决。另一个角度来说，多线程编程能够提高程序员的编程能力和编程思维。同时也能提高程序员的管理能力。 </p><p> Doug Lea大佬开发的JUC工具包。</p><h2 id="14-进程间的通信方式"><a href="#14-进程间的通信方式" class="headerlink" title="14 进程间的通信方式"></a>14 进程间的通信方式</h2><p><strong>通信概念</strong><br>进程间的通信方式比较多，首先你需要理解下面这几个概念</p><ul><li><p>竞态条件:即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为<strong>竟态条件(race condition)</strong> 。</p></li><li><p>临界区:不仅<strong>共享资源</strong>会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢?或许一句话可以概括说明:<strong>禁止一个或多个进程在同一时刻对共享资源(包括共享内存、共享文件等)进行读写。</strong>换句话说，我们需要一种<strong>互斥</strong>(mutual exclusion) 条件, 这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事(访问统一资源)。<br>一个好的解决方案，应该包含下面四种条件</p><ol><li>任何时候两个进程不能同时处于临界区</li><li>不应对 CPU的速度和数量做任何假设</li><li>位于临界区外的进程不得阻塞其他进程</li><li>不能使任何进程无限 等待进入临界区</li></ol></li><li><p>忙等互斥:当一个进程在对资源进行修改时，其他进程必须进行等待，进程之间要具有互斥性,我们讨论的解决方案其实都是基于忙等互斥提出的。</p></li></ul><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/进程通信方式.png" alt="image-20200813230006014" style="zoom:67%;"><ul><li>消息传递:消息传递是进程间实现通信和同步等待的机制，使用消息传递，进程间的交流不需要共享变量，直接就可以进行通信;消息传递分为发送方和接收方</li><li>先进先出队列:先进先出队列指的是两个不相关联进程间的通信，两个进程之间可以彼此相互进程通信，这是一种全双工通信方式</li><li>管道:管道用于两个相关进程之间的通信，这是一种半双工的通信方式，如果需要全双工，需要另外一个管道。</li><li>直接通信:在这种进程通信的方式中，进程与进程之间只存在一条链接，进程间要明确通信双方的命名。</li><li>间接通信:间接通信是通信双方不会直接建立连接，而是找到一个中介者，这个中介者可能是个对象等等，进程可以在其中放置消息，并且可以从中删除消息，以此达到进程间通信的目的。</li><li>消息队列:消息队列是内核中存储消息的链表，它由消息队列标识符进行标识，这种方式能够在不同的进程之间提供全双工的通信连接。</li><li>共享内存:共享内存是使用所有进程之间的内存来建立连接，这种类型需要同步进程访问来相互保护。</li></ul><h2 id="15-进程间状态模型"><a href="#15-进程间状态模型" class="headerlink" title="15 进程间状态模型"></a>15 进程间状态模型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat chapter1 chapter2 chapter3 I grep tree</span><br></pre></td></tr></table></figure><p>第一个进程是<code>cat</code> ，将三个文件级联并输出。第二个进程是<code>grep</code> ,它从输入中选择具有包含关键字<code>tree</code>的内容，根据这两个进程的相对速度(这取决于两个程序的相对复杂度和各自所分配到的CPU时间片)，可能会发生下面这种情况，grep 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞grep进程，直到输入完毕。<br>当一个进程开始运行时，它可能会经历下面这几种状态</p><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/进程状态.png" alt="image-20200813230402249" style="zoom:67%;"><ol><li><strong>运行态</strong> ，运行态指的就是进程实际占用CPU时间片运行时</li><li><strong>就绪态</strong>，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li><li><strong>阻塞态</strong>，除非某种外部事件发生，否则进程不能运行</li></ol><p>逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程可运行，但是第二种情况没有获得CPU时间分片。第三种状态与前两种状态不同的原因是这个进程不能运行，CPU空闲时也不能运行。</p><p>三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生<strong>状态1</strong>的轮转，在某些统中进程执行系统调用，例如pause ，来获取一个阻塞的状态。在其他系统中包括UNIX,当进程从管道或特殊文件(例如终端)中读取没有可用的输入时，该进程会被自动终止。</p><p>转换2和转换3都是由进程调度程序(操作系统的一部分)引起的，进程本身不知道调度程序的存在。转换2的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行CPU时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得CPU时间片的时候了，就会发生转换3。</p><blockquote><p>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p></blockquote><p>当进程等待的一个外部事件发生时(如从外部输入-些数据后)，则发生转换4。如果此时没有其他进程在运行，则立刻触发转换3,该进程便开始运行，否则该进程会处于就绪阶段，等待CPU空闲后再轮到它运行。</p><h2 id="16-调度算法都有哪些"><a href="#16-调度算法都有哪些" class="headerlink" title="16 调度算法都有哪些"></a>16 调度算法都有哪些</h2><p>调度算法分为三大类:批处理中的调度、交互系统中的调度、实时系统中的调度</p><p>批处理中的调度</p><ol><li>先来先服务</li><li>最短作业优先</li><li>最短剩余时间优先</li></ol><p>交互系统中的调度</p><ol><li>轮询调度</li><li>优先级</li><li>最短进程调度</li></ol><h2 id="17-页面置换算法"><a href="#17-页面置换算法" class="headerlink" title="17 页面置换算法"></a>17 页面置换算法</h2><ul><li>FIFO先进先出</li><li>LRU 最少使用</li><li>时钟 </li></ul><h2 id="18-影响调度程序的指标是什么"><a href="#18-影响调度程序的指标是什么" class="headerlink" title="18 影响调度程序的指标是什么"></a>18 影响调度程序的指标是什么</h2><p>会有下面几个因素决定调度程序的好坏</p><ul><li>CPU使用率:<br>CPU正在执行任务(即不处于空闲状态)的时间百分比。</li><li>等待时间<br>这是进程轮流执行的时间，也就是进程切换的时间</li><li>吞吐量<br>单位时间内完成进程的数量</li><li>响应时间<br>这是从提交流程到获得有用输出所经过的时间。</li><li>周转时间<br>从提交流程到完成流程所经过的时间。</li></ul><h2 id="19-什么是僵尸进程"><a href="#19-什么是僵尸进程" class="headerlink" title="19 什么是僵尸进程"></a>19 什么是僵尸进程</h2><p>僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。僵尸进程通常发生在父子关系的进程中，由于父进程仍需要读取其子进程的退出状态所造成的。</p><h2 id="20-用户态和内核态是什么，切换的方式"><a href="#20-用户态和内核态是什么，切换的方式" class="headerlink" title="20 用户态和内核态是什么，切换的方式"></a>20 用户态和内核态是什么，切换的方式</h2><p>内核态（Kernel Mode）：运行操作系统程序，操作硬件</p><p>用户态（User Mode）：运行用户程序</p><p><strong>特权级别</strong></p><p>特权指令：只能由操作系统使用、用户程序不能使用的指令。 举例：启动I/O 内存清零 修改程序状态字 设置时钟 允许/禁止终端 停机</p><p>非特权指令：用户程序可以使用的指令。 举例：控制转移 算数运算 取数指令 <strong>访管指令</strong>（使用户程序从用户态陷入内核态）</p><p><strong>特权级别</strong></p><p><strong>特权环：R0、R1、R2和R3</strong></p><p>R0相当于内核态，R3相当于用户态；</p><p>不同级别能够运行不同的指令集合；</p><p>1）用户态切换到内核态的3种方式</p><p>a. 系统调用</p><p>​    这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p><p>b. 异常</p><p>​    当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p><p>c. 外围设备的中断</p><p>​    当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p><p>这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-设备管理</title>
      <link href="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/"/>
      <url>/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h2 id="一、I-O系统"><a href="#一、I-O系统" class="headerlink" title="一、I/O系统"></a>一、I/O系统</h2><h3 id="1-1设备分类"><a href="#1-1设备分类" class="headerlink" title="1.1设备分类"></a>1.1设备分类</h3><p>按设备的共享属性分类：</p><ul><li>独占设备：在<strong>一段时间</strong>内<strong>只允许一个用户进程使用</strong>的设备。</li><li>共享设备：在<strong>一段时间</strong>内<strong>允许多个进程使用</strong>的设备。</li><li>虚拟设备：指通过虚拟技术将<strong>一台独占设备</strong>改造成<strong>若干台逻辑设备</strong>，<strong>供若干个用户进程同时使用</strong>。通常把这种经过虚拟技术处理后的设备称为虚拟设备。</li></ul><p>按信息交换单位分类：</p><ul><li>块设备：处理信息的<strong>基本单位是字符块</strong>。一般块的大小为512B～4KB，如磁盘、磁带等是块设备。</li><li>字符设备：处理信息的<strong>基本单位是字符</strong>。如键盘、打印机和显示器是字符设备。</li></ul><h3 id="1-2-I-O控制方式"><a href="#1-2-I-O控制方式" class="headerlink" title="1.2 I/O控制方式"></a>1.2 I/O控制方式</h3><p>I/O控制方式发展过程中始终贯穿的宗旨是<strong>尽量减少主机对I/O控制的干预</strong>。常用的输入/输出控制方式有下述几种：</p><ul><li>程序直接控制方式</li><li>中断控制方式</li><li>直接存储器访问控制方式</li><li>通道控制方式</li></ul><h4 id="1-2-1-程序直接控制方式"><a href="#1-2-1-程序直接控制方式" class="headerlink" title="1.2.1 程序直接控制方式"></a>1.2.1 程序直接控制方式</h4><p><strong>早期</strong>计算机系统中无中断机构，设备控制<strong>采用程序直接控制方式</strong>。程序直接控制方式<strong>也称为轮询方式</strong>。即定期对设备状态进行查询，然后做出相应的处理。</p><p>以输入为例，其过程为：<br><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/%E7%9B%B4%E6%8E%A5%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="img"><br>程序直接控制方式特点：工作方式简单，但CPU的利用率低。</p><h4 id="1-2-2-中断控制方式"><a href="#1-2-2-中断控制方式" class="headerlink" title="1.2.2 中断控制方式"></a>1.2.2 中断控制方式</h4><p>现代计算机系统中对设备的控制<strong>广泛采用了中断控制方式</strong>。以输入为例，其过程为：<br><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="img">中断控制方式特点：<br><strong>CPU与设备并行工作</strong>，仅当I/O结束时才需CPU<strong>花费极短时间做中断处理</strong>。CPU利用率大大提高。</p><h4 id="1-2-3-DMA控制方式"><a href="#1-2-3-DMA控制方式" class="headerlink" title="1.2.3 DMA控制方式"></a>1.2.3 DMA控制方式</h4><p>中断方式<strong>以字节为单位中断</strong>CPU，<strong>对块设备其效率极低</strong>，为此引入了DMA。DMA控制方式的思想是——在外设与内存之间<strong>开辟直接的数据交换通路</strong>，在控制器的控制下，设备和内存之间可以成批地进行数据交换。</p><p>为实现<strong>主机与控制器之间</strong>成块数据的直接交换，必须在DMA控制器中设置如下寄存器：</p><ul><li>命令/状态寄存器 <code>CR</code> ：存放命令及状态</li><li>内存地址寄存器 <code>MAR</code> ：存放内存起始地址</li><li>数据寄存器 <code>DR</code> ：存放传输的数据</li><li>数据计数器 <code>DC</code> ：存放要读写的字（节）数</li></ul><p>DMA控制器的组成如下图：<br><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/DMA控制中断的方式.png" alt="img" style="zoom:67%;">DMA工作过程：<br><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/DMA%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B.png" alt="img"><br>DMA方式与中断方式的主要区别：</p><ul><li>中断控制方式在<strong>每个数据传送完成后中断CPU</strong>，而DMA控制方式则是在<strong>所要求传送的一批数据全部传送结束时中断CPU</strong>；</li><li>中断控制方式的数据传送是在中断处理时<strong>由CPU控制</strong>完成，而DMA控制方式则是<strong>在DMA控制器的控制</strong>下完成。</li></ul><h4 id="1-2-4-通道控制方式"><a href="#1-2-4-通道控制方式" class="headerlink" title="1.2.4 通道控制方式"></a>1.2.4 通道控制方式</h4><p>通道控制方式是DMA控制方式的<strong>发展</strong>，所需的CPU干预更少。因此，通道控制方式与DMA方式类似，也是一种<strong>以内存为中心</strong>，实现<strong>设备与内存直接交换数据</strong>的控制方式。</p><p>在通道控制方式中，CPU<strong>只需发出启动指令</strong>，指出要求通道<strong>执行的操作</strong>和<strong>使用的I/O设备</strong>，该指令就可以启动通道并使该通道从内存中调出相应的通道程序执行。以输入为例，其通道工作过程为：<br><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F.png" alt="img"></p><h3 id="1-3-中断技术"><a href="#1-3-中断技术" class="headerlink" title="1.3 中断技术"></a>1.3 中断技术</h3><p>中断是现代操作系统的常用技术之一，是实现多道程序的必要条件。</p><h4 id="1-3-1-中断的基本概念"><a href="#1-3-1-中断的基本概念" class="headerlink" title="1.3.1 中断的基本概念"></a>1.3.1 中断的基本概念</h4><p>中断：指计算机系统内发生了某个<strong>急需处理的事件</strong>，使CPU<strong>暂停当前正在执行的程序，转去处理相应的事件处理程序</strong>，待处理完毕后又返回原来被中断处继续执行。</p><h4 id="1-3-2-中断处理过程"><a href="#1-3-2-中断处理过程" class="headerlink" title="1.3.2 中断处理过程"></a>1.3.2 中断处理过程</h4><p>一旦CPU响应中断，系统就开始进行中断处理。中断处理过程如下：</p><ul><li>保护被中断进程现场。</li><li>分析中断原因，转去执行<strong>相应的中断处理程序</strong>。</li><li>恢复被中断进程的现场，CPU继续执行原来被中断的进程。</li></ul><h3 id="1-4-缓冲技术管理"><a href="#1-4-缓冲技术管理" class="headerlink" title="1.4 缓冲技术管理"></a>1.4 缓冲技术管理</h3><p>提高<strong>处理机与外设</strong>并行速度的另一项技术是<strong>缓冲技术</strong>。</p><h4 id="1-4-1-缓存的引入"><a href="#1-4-1-缓存的引入" class="headerlink" title="1.4.1 缓存的引入"></a>1.4.1 缓存的引入</h4><p>引入缓冲(<code>Buffering</code>)的主要原因有：</p><ul><li>缓和CPU与I/O设备间<strong>速度不匹配</strong>的矛盾；</li><li>提高CPU与I/O设备并行操作的程度；</li><li><strong>减少设备对CPU的中断频率</strong>，放宽CPU对中断响应时间的限制。</li></ul><p>缓冲的实现方法：</p><ul><li>硬件缓冲器：如I/O控制器中的数据缓冲寄存器，但<strong>成本太高</strong>。</li><li>软件缓冲：一片<strong>内存区域</strong>，用来<strong>临时存放输入输出数据</strong>。</li></ul><p>缓冲技术分为：</p><ul><li>单缓冲</li><li>双缓冲</li><li>循环缓冲</li><li>缓冲池</li></ul><h4 id="1-4-2-单缓冲"><a href="#1-4-2-单缓冲" class="headerlink" title="1.4.2 单缓冲"></a>1.4.2 单缓冲</h4><p>单缓冲是在设备和处理机之间设置一个缓冲区。</p><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/单缓冲.png" alt="image-20200813174012072" style="zoom: 80%;"><p>单缓冲执行过程：</p><ul><li>在<strong>块设备输入</strong>时，先<strong>从磁盘</strong>把<strong>一块数据</strong>输入至<strong>缓冲区</strong>，然后OS将缓冲区中的数据<strong>送到用户区</strong>；</li><li>在<strong>块设备输出</strong>时，先将要输出的数据<strong>从用户区复制到缓冲区</strong>，然后再将缓冲区中的数据<strong>写到设备</strong>。</li><li>在<strong>字符设备输入</strong>时，缓冲区用于<strong>暂存</strong>用户<strong>输入的一行数据</strong>。在输入期间，<strong>用户进程阻塞</strong>以<strong>等待</strong>一行数据输入完毕；</li><li>在<strong>字符设备输出</strong>时，用户进程<strong>将一行数据送入缓冲区后</strong>继续执行计算。当用户进程<strong>已有第二行数据要输出</strong>时，若第一行数据<strong>尚未输出完毕</strong>，则<strong>用户进程阻塞</strong>。</li></ul><h4 id="1-4-3-双缓冲"><a href="#1-4-3-双缓冲" class="headerlink" title="1.4.3 双缓冲"></a>1.4.3 双缓冲</h4><p>引入双缓冲，可以进一步提高处理机与设备的并行操作程度。<br><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/双缓冲.png" alt="image-20200813174127592" style="zoom:80%;"><br>双缓冲的过程：</p><ul><li>在块设备输入时，可<strong>先将第一个缓冲区装满</strong>，之后便<strong>装填第二个缓冲区</strong>，与此同时OS可<strong>将第一个缓冲区中的数据传到用户区</strong>；当第一个缓冲区中的数据处理完后，若第二个缓冲区已装满，则处理机又可处理第二个缓冲区中的数据，而设备又可装填第一个缓冲区。输出与此类似。</li><li>在字符设备输入时，若采用<strong>行输入方式</strong>和双缓冲，则用户<strong>在输入完第一行后</strong>，CPU执行第一行中的命令，而用户可以<strong>继续向第二个缓冲区中输入一行数据</strong>。</li></ul><h4 id="1-4-4-循环缓冲"><a href="#1-4-4-循环缓冲" class="headerlink" title="1.4.4 循环缓冲"></a>1.4.4 循环缓冲</h4><p>若<strong>输入输出速度与数据处理速度相当，则双缓冲能获得较好的效果</strong>；若速度<strong>相差较大</strong>，则可以通过<strong>增加缓冲区的数量</strong>来改善性能。<br><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/%E5%BE%AA%E7%8E%AF%E7%BC%93%E5%86%B2.png" alt="image-20200813174224794"><br>循环缓冲的组成：</p><ul><li>循环缓冲中包含<strong>多个大小相等</strong>的<strong>缓冲区</strong>，每个缓冲区中<strong>有一个指针指向下一个缓冲区</strong>，最后一个缓冲区的指针指向第一个缓冲区，由此构成一个环形。</li><li>循环缓冲用于输入/输出时，还<strong>需要两个指针</strong> <code>in</code> 和 <code>out</code> 。</li><li>对于输入而言，<code>in</code> 指向<strong>下一个可用的空缓冲区</strong>，<code>out</code> 指向<strong>下一个可以提取数据的满缓冲区</strong>。显然，对输出而言正好相反。</li></ul><h4 id="1-4-5-缓冲池"><a href="#1-4-5-缓冲池" class="headerlink" title="1.4.5 缓冲池"></a>1.4.5 缓冲池</h4><p>循环缓冲<strong>适用于合作进程</strong>，当<strong>系统较大</strong>且<strong>共享缓冲区的进程较多</strong>时，这要<strong>消耗大量内存</strong>。目前广泛使用的是公用缓冲池。</p><p>缓冲池由多个缓冲区组成，其中的<strong>缓冲区可供多个进程共享，既能用于输入又能用于输出</strong>。</p><h2 id="二、设备分配"><a href="#二、设备分配" class="headerlink" title="二、设备分配"></a>二、设备分配</h2><p>当<strong>进程提出I/O请求</strong>时，<strong>设备分配程序</strong>便按照<strong>一定的策略</strong>为其<strong>分配设备</strong>，同时还应<strong>分配相应的控制器和通道</strong>，以保证CPU与设备之间的通信。</p><h3 id="2-1-设备分配中的数据结构"><a href="#2-1-设备分配中的数据结构" class="headerlink" title="2.1 设备分配中的数据结构"></a>2.1 设备分配中的数据结构</h3><p>设备分配依据的主要数据结构有：</p><ul><li>设备控制表（<code>DCT</code>）：系统为<strong>每个设备</strong>配置<strong>一张设备控制表</strong>，用于<strong>记录设备的特性</strong>及与<strong>I/O控制器连接的情况</strong>。</li><li>控制器控制表（COCT）：控制器控制表也是<strong>每个控制器一张</strong>，它反映<strong>I/O控制器的使用状态</strong>以及<strong>和通道的连接情况</strong>。</li><li>通道控制表（CHCT）：<strong>每个通道</strong>都配有<strong>一张通道控制表</strong>，它反映<strong>通道的使用状态</strong>。</li><li>系统设备表（SDT）：系统设备表<strong>整个系统一张</strong>，它记录了系统中<strong>所有物理设备的情</strong>况，每个物理设备占一个表目。</li></ul><h4 id="2-2设备分配策"><a href="#2-2设备分配策" class="headerlink" title="2.2设备分配策"></a>2.2设备分配策</h4><ul><li>先来先服务：根据进程对某设备<strong>发出请求的先后次序</strong>，将它们排成<strong>一个设备请求队列</strong>，设备分配程序总是把设备首先分配给队首进程。</li><li>优先级高者优先：按对某设备提出I/O请求的进程<strong>优先级由高到低排队</strong>，对优先级相同的I/O请求，按先来先服务的算法排队，设备分配程序总是把设备首先分配给队首进程。</li></ul><h4 id="2-3-Spooling系统"><a href="#2-3-Spooling系统" class="headerlink" title="2.3 Spooling系统"></a>2.3 Spooling系统</h4><p>Spooling技术是将<strong>独占设备改造为共享设备</strong>的技术。</p><p>Spooling是 <code>Simultaneous Peripheral Operating On-Line</code> 的缩写，意思是<strong>外部设备同时联机操作</strong>，又称<strong>假脱机操作</strong>。</p><p>在Spooling系统中，用一道程序<strong>模拟脱机输入时</strong>的<strong>外围控制机功能</strong>，把低速输入设备上的数据传送到高速磁盘上；再用另一道程序来<strong>模拟脱机输出时</strong>的<strong>外围控制机功能</strong>，把数据从磁盘传送到低速输出设备上。</p><p>Spooling系统组成图：<br><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/Spooling.png" alt="image-20200813175004301"><br>共享打印机：<br>打印机是<strong>常用的独享设备</strong>，但利用Spooling技术可以将它<strong>改造成供多个用户共享的设备</strong>。<br>当用户进程请求打印输出时，Spooling系统同意为它打印，但<strong>不将打印机真正分配给它，而只为它做两件事</strong>：</p><ul><li>由输出进程在<strong>输出井</strong>中为之<strong>申请一空闲磁盘区</strong>，并将要打印的数据送入其中；</li><li>输出进程<strong>再为用户进程</strong>申请一张空白的用户请求打印表，并将用户的<strong>打印要求填入其中</strong>，再<strong>将该表挂到请求打印队列上</strong>。</li><li>如果打印机空闲，输出进程将从打印队列队首取出一张请求打印表，根据表中的要求将要打印的数据<strong>从输出井传送到内存缓冲区</strong>，再<strong>由打印机进行打印</strong>。</li><li>打印完后，再取下一张表，直至请求队列为空。此时，<strong>输出进程阻塞</strong>，当再有打印请求时，才将输出进程唤醒。</li></ul><h2 id="三、磁盘"><a href="#三、磁盘" class="headerlink" title="三、磁盘"></a>三、磁盘</h2><h3 id="3-1磁盘结构"><a href="#3-1磁盘结构" class="headerlink" title="3.1磁盘结构"></a>3.1磁盘结构</h3><ul><li>盘面（Platter）：一个磁盘有多个盘面；</li><li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li><li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li><li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li><li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li><li>主轴（Spindle）：使整个盘面转动。</li></ul><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/磁盘结构.png" alt="image-20200813175246441" style="zoom:67%;"><h3 id="3-1磁盘调度算法"><a href="#3-1磁盘调度算法" class="headerlink" title="3.1磁盘调度算法"></a>3.1磁盘调度算法</h3><p>读写一个磁盘块的时间的影响因素有：</p><ul><li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li><li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li><li>实际的数据传输时间</li></ul><p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p><h4 id="1-先来先服务"><a href="#1-先来先服务" class="headerlink" title="1. 先来先服务"></a>1. 先来先服务</h4><blockquote><p>FCFS, First Come First Served</p></blockquote><p>按照磁盘请求的顺序进行调度。</p><p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p><h4 id="2-最短寻道时间优先"><a href="#2-最短寻道时间优先" class="headerlink" title="2. 最短寻道时间优先"></a>2. 最短寻道时间优先</h4><blockquote><p>SSTF, Shortest Seek Time First</p></blockquote><p>优先调度与当前磁头所在磁道距离最近的磁道。</p><p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p><p><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4.png" alt="image-20200813175352349"></p><h4 id="3-电梯算法"><a href="#3-电梯算法" class="headerlink" title="3. 电梯算法"></a>3. 电梯算法</h4><blockquote><p>SCAN</p></blockquote><p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</p><p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p><p>因为考虑了移动方向，因此所有的磁盘,请求都会被满足，解决了 SSTF 的饥饿问题。</p><p><img src="/2020/08/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E5%A4%87/%E7%94%B5%E6%A2%AF%E7%AE%97%E6%B3%95.png" alt="电梯算法"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-内存管理</title>
      <link href="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/"/>
      <url>/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="一、内存的连续分配"><a href="#一、内存的连续分配" class="headerlink" title="一、内存的连续分配"></a>一、内存的连续分配</h2><h3 id="1-1-单一连续分配方式"><a href="#1-1-单一连续分配方式" class="headerlink" title="1.1 单一连续分配方式"></a>1.1 单一连续分配方式</h3><p>内存在此方式下分为<strong>系统区</strong>和<strong>用户区</strong></p><p><strong>系统区</strong>仅提供给<strong>操作系统</strong>使用，通常在<strong>低地址</strong>部分</p><p><strong>用户区</strong>是为<strong>用户</strong>提供的、除系统区之外的内存空间</p><p><strong>优点</strong>：简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持</p><p><strong>缺点</strong>：只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低</p><h3 id="1-2-固定分区分配"><a href="#1-2-固定分区分配" class="headerlink" title="1.2 固定分区分配"></a>1.2 固定分区分配</h3><p>固定分区分配是最简单的一种多道程序存储管理方式。</p><p>将用户内存空间划分为若干个<strong>固定大小</strong>的区域，每个分区只装入一道作业。</p><p>当有空闲分区时，便可以再从外存的后备作业队列中,选择适当大小的作业装入该分区，如此循环。</p><p><strong>划分分区方法</strong>：</p><ol><li>分区大小相等</li><li>分区大小不等</li></ol><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA.png" alt="img"></p><p><strong>存在的问题</strong>：</p><ul><li><strong>程序可能太大</strong>而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间</li><li><strong>主存利用率低</strong>，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，产生<strong>内部碎片</strong></li></ul><h3 id="1-3-动态分区分配"><a href="#1-3-动态分区分配" class="headerlink" title="1.3 动态分区分配"></a>1.3 动态分区分配</h3><p>又称为<strong>可变分区分配</strong>，这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小<strong>动态地建立分区</strong>，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。</p><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA.png" alt="img"></p><p><strong>动态分区分配算法</strong></p><p><strong>首次适应(First Fit)算法</strong>：空闲分区以地址递增的次序链接。分配内存时<strong>顺序查找</strong>，找到大小能满足要求的<strong>第一个空闲分区</strong>。</p><p><strong>最佳适应(Best Fit)算法</strong>：空闲分区<strong>按容量递增</strong>形成分区链，找到<strong>第一个</strong>能满足要求的空闲分区。</p><p><strong>最坏适应(Worst Fit)算法</strong>：又称<strong>最大适应(Largest Fit)算法</strong>，空闲分区以<strong>容量递减</strong>的次序链接。找到<strong>第一个</strong>能满足要求的空闲分区，也就是挑选出最大的分区。</p><p><strong>临近适应算法(Next fit)算法</strong>：从<strong>当前位置</strong>开始，搜索<strong>第一个</strong>能满足进程要求的内存空间</p><p><strong>动态分区的缺点</strong></p><p>随着时间的推移，内存中会产生越来越多的<strong>外部碎片</strong>，<strong>内存的利用率</strong>随之下降。</p><h2 id="二、内存的非连续分配"><a href="#二、内存的非连续分配" class="headerlink" title="二、内存的非连续分配"></a>二、内存的非连续分配</h2><h3 id="2-1-页式存储"><a href="#2-1-页式存储" class="headerlink" title="2.1 页式存储"></a>2.1 页式存储</h3><h4 id="2-1-1-基本概念"><a href="#2-1-1-基本概念" class="headerlink" title="2.1.1 基本概念"></a>2.1.1 基本概念</h4><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/页式存储.png" alt="img" style="zoom:67%;"><p><strong>基本思想</strong>：用户程序的<strong>地址空间</strong>被划分成若干固定大小的区域，称为“<strong>页</strong>”，相应地，<strong>内存空间</strong>分成若干个<strong>物理块或页帧（</strong>Page Frame<strong>）</strong>，页和块的<strong>大小相等</strong>。可将用户程序的任一页放在内存的任一块中，实现了离散分配：物理块不一定连续。每个页对应一个物理块。</p><p><strong>逻辑地址结构</strong>：地址结构包含两部分：前一部分为<strong>页号P</strong>，后一部分为<strong>页内偏移量W。</strong>如果是32位地址，则0<del>11位为页内地址，即每页大小为4KB；12</del>31位为页号，地址空间最多允许有2<sup>20</sup>页</p><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80.png" alt="img"></p><p><strong>页表</strong>：因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从<strong>页号到物理块号</strong>的映射</p><blockquote><p>每个进程也以块为单位进行划分。每一个进程都拥有一个自己的页表，PCB表中有指针指向页表。</p><p>分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为<strong>基本分页存储</strong>管理方式和<strong>请求分页存储</strong>管理方式。</p></blockquote><h4 id="2-1-2-地址变换"><a href="#2-1-2-地址变换" class="headerlink" title="2.1.2 地址变换"></a>2.1.2 地址变换</h4><p>地址变换的任务是将<strong>逻辑地址转换为内存中物理地址</strong>，地址变换是借助于页表实现的</p><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E9%A1%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="img"></p><p>当进程执行时，将页表始址和长度存入<strong>页表寄存器</strong></p><p>设页大小为<strong>L</strong>（一般为4K），<strong>逻辑地址A</strong>到<strong>物理地址E</strong>的变换过程如下：</p><ol><li>计算页号P(P=A/L)和页内偏移量W (W=A%L)，这里的P取整</li><li>比较页号P和页表长度M，若P &gt;= M，则产生越界中断，否则继续执行</li><li>页表中页号P对应的页表项地址 = 页表起始地址F + 页号P * 页表项长度（一般为4B），取出该页表项内容b，即为物理块号</li><li>计算E=b*L+W，用得到的物理地址E去访问内存</li></ol><h4 id="2-1-3-分页管理方式存在的问题"><a href="#2-1-3-分页管理方式存在的问题" class="headerlink" title="2.1.3 分页管理方式存在的问题"></a>2.1.3 分页管理方式存在的问题</h4><ul><li>每次访存操作都需要进行逻辑地址到物理地址的转换，<strong>地址转换</strong>过程必须足够快，否则<strong>访存速度</strong>会降低</li><li>每个进程引入了<strong>页表</strong>，用于存储映射机制，页表不能太大，否则<strong>内存利用率</strong>会降低</li></ul><h4 id="2-1-4-具有快表的地址变换机构"><a href="#2-1-4-具有快表的地址变换机构" class="headerlink" title="2.1.4 具有快表的地址变换机构"></a><strong>2.1.4 具有快表的地址变换机构</strong></h4><p>若页表全部放在内存中，则存取一个数据或一条指令至少要<strong>访问两次内存</strong>：</p><ol><li>从内存中<strong>访问页表</strong>，从中找到指定的物理块号，加上页内偏移<strong>得到实际物理地址</strong></li><li>根据第一次得到的物理地址<strong>访问内存取出数据</strong></li></ol><p>为提高地址变换速度，增设一个具有并行查询能力的特殊<strong>高速缓冲存储器</strong>，称为<strong>“联想存储器</strong>”或“<strong>快表”</strong>，存放当前访问的页表项。与此对应，主存中的页表也常称为慢表。</p><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt="img"></p><p>这样由逻辑地址的页号P直接在快表里查找：</p><ol><li>若查找到，则得到对应的块号，直接转换成物理地址，这样，存取数据<strong>仅一次访问内存</strong>便可实现。</li><li>若不存在，则访问主存中的页表，在读出页表项后，应同时将其<strong>存入快表</strong></li></ol><p>理论依据：<strong>局部性原理</strong></p><blockquote><p><strong>局部性原理：</strong></p><p>时间上的局部性：最近被访问的页在不久的将来还会被访问</p><p>空间上的局部性：内存中被访问的页周围的页也很可能被访问</p></blockquote><h4 id="2-1-5-二级页表"><a href="#2-1-5-二级页表" class="headerlink" title="2.1.5 二级页表"></a><strong>2.1.5 二级页表</strong></h4><p>如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。</p><p>为了解决这个问题，可以采用<strong>两级页表或者多级页表</strong>的方法：外层页表一次性调入内存且连续存放，内层页表离散存放。</p><p>所以一共需要访问内存<strong>3次</strong>才可以读取一次数据：访问顶级页表-&gt;访问二级页表-&gt;访问内存中的数据</p><h3 id="2-2-段式存储"><a href="#2-2-段式存储" class="headerlink" title="2.2 段式存储"></a>2.2 段式存储</h3><p>分页是为了提高内存利用率，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明</p><p>而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</p><h4 id="2-2-1-基本概念"><a href="#2-2-1-基本概念" class="headerlink" title="2.2.1 基本概念"></a>2.2.1 基本概念</h4><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt="img"></p><p><strong>基本思想</strong>：将用户程序地址空间分成若干个大<strong>小不等的段</strong>，<strong>每段</strong>可以定义一组<strong>相对完整的逻辑信息</strong>，每个<strong>段内部从0开始编址</strong>。存储分配时，以段为单位，每个<strong>段内部连续分配</strong>内存，段与段在内存中可以不相邻接，也实现了离散分配。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段。</p><p><strong>逻辑地址结构</strong>：<strong>段号S</strong>与<strong>段内偏移量W</strong>两部分组成。如果是32位地址，段号为16位，段内偏移量为16位，则一个作业最多可有2<sup>16</sup>个段，最大段长为65536B即64KB</p><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%81%8F%E7%A7%BB.png" alt="img"></p><blockquote><p><strong>页式</strong>系统中，<strong>逻辑地址</strong>的页号和页内偏移量对用户是<strong>透明</strong>的，但在<strong>段式</strong>系统中，段号和段内偏移量必须由<strong>用户显示提供</strong>，在髙级程序设计语言中，这个工作由<strong>编译程序</strong>完成</p></blockquote><p><strong>段表</strong>：每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个<strong>段表项</strong>对应进程的一个段。</p><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E6%AE%B5%E8%A1%A8.png" alt="img"></p><p>访问内存的时候根据<strong>段号</strong>和<strong>段表项的长度</strong>计算当前访问段在<strong>段表中的位置</strong>，然后访问段表，得到该<strong>段的物理地址</strong>，根据该物理地址以及<strong>段内偏移量</strong>就可以得到需要访问的内存。</p><h4 id="2-2-2-地址变换"><a href="#2-2-2-地址变换" class="headerlink" title="2.2.2 地址变换"></a>2.2.2 地址变换</h4><p>为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了<strong>段表寄存器</strong></p><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E6%AE%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt="img"></p><p>段表寄存器存了段表始址<strong>F</strong>和段表长度<strong>M，</strong>从<strong>逻辑地址A</strong>到<strong>物理地址E</strong>之间的地址变换过程如下：</p><ol><li>从逻辑地址A中取出前几位为<strong>段号S</strong>，后几位为<strong>段内偏移量W</strong></li><li>比较段号S和段表长度M，若S多M，则产生<strong>越界中断</strong>，否则继续执行</li><li>段表中<strong>段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度</strong>，取出该段表项的前几位得到段长C。若段内偏移量&gt;=C，则产生越界中断，否则继续执行</li><li>取出段表项中该段的<strong>起始地址b</strong>，计算 <strong>E = b + W</strong>，用得到的物理地址E去访问内存</li></ol><h4 id="2-2-3-段的共享"><a href="#2-2-3-段的共享" class="headerlink" title="2.2.3 段的共享"></a>2.2.3 段的共享</h4><p>段的共享是通过两个作业的<strong>段表中相应表项指向被共享的段的同一个物理副本</strong>来实现的</p><p>不能修改的代码称为<strong>纯代码</strong>或<strong>可重入代码</strong>（它不属于临界资源)，这样的代码和不能修改的数据是<strong>可以共享</strong>的</p><p>而<strong>可修改</strong>的代码和数据则<strong>不能共享</strong></p><h3 id="2-3-分页与分段的区别"><a href="#2-3-分页与分段的区别" class="headerlink" title="2.3 分页与分段的区别"></a>2.3 分页与分段的区别</h3><p><strong>段式管理</strong></p><ul><li><strong>优点</strong>：没有内部碎片（因为段大小可变，改变段大小来消除内碎片）。</li><li><strong>缺点</strong>：段换入换出时，会产生外部碎片（比如4k的段换5k的段，会产生1k的外碎片）</li></ul><p><strong>页式管理</strong></p><ul><li><strong>优点</strong>：没有外部碎片（因为页的大小固定），</li><li><strong>缺点</strong>：会产生内部碎片（一个页可能填充不满）</li></ul><p><strong>分页与分段的区别</strong></p><ul><li><p><strong>目的不同</strong>：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</p></li><li><p><strong>大小不同</strong>：页的大小固定且由系统决定（一般为4k），而段的长度却不固定，由其所完成的功能决定；</p></li><li><p><strong>地址空间不同</strong>： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；一个段在物理空间是连续的内存。</p></li><li><p><strong>信息共享</strong>：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</p></li><li><p><strong>内存碎片</strong>：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。<br> 2.4 段页式存储</p><p>页式存储管理能有效地提高<strong>内存利用率</strong>，而分段存储管理能反映程序的<strong>逻辑结构并有利于段的共享</strong>。</p><p>如果将这两种存储管理方法结合起来，就形成了<strong>段页式存储管理</strong>方式</p></li></ul><h3 id="2-4-段页式存储"><a href="#2-4-段页式存储" class="headerlink" title="2.4 段页式存储"></a>2.4 段页式存储</h3><p>页式存储管理能有效地提高<strong>内存利用率</strong>，而分段存储管理能反映程序的<strong>逻辑结构并有利于段的共享</strong>。</p><p>如果将这两种存储管理方法结合起来，就形成了<strong>段页式存储管理</strong>方式</p><h3 id="2-4-1-基本概念"><a href="#2-4-1-基本概念" class="headerlink" title="2.4.1 基本概念"></a>2.4.1 基本概念</h3><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/E:%5CBlog%5Csource_posts%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%5C%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8.png" alt="img"></p><p><strong>基本思想</strong>：</p><ul><li>作业的地址空间首先被分成若干个<strong>逻辑段</strong>，每段都有自己的段号</li><li>再将<strong>每一段分成</strong>若干个<strong>大小固定的页</strong></li><li>对<strong>内存空间</strong>的管理仍然和分页存储管理一样，将其<strong>分成</strong>若干个和页面大小相同的<strong>块</strong>，对内存的分配以块为单位</li></ul><p><strong>逻辑地址结构</strong>：段号S、页号P和页内偏移量W。</p><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="img"></p><p>每个进程建立<strong>一张段表</strong>，而每个分段有<strong>一张页表</strong></p><h3 id="2-4-2-地址变换"><a href="#2-4-2-地址变换" class="headerlink" title="2.4.2 地址变换"></a>2.4.2 地址变换</h3><p>为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了<strong>段表寄存器</strong></p><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="img"></p><p>进行一次访问实际需要<strong>三次访问</strong>内存</p><ol><li>首先利用<strong>段号S</strong>，将它与段表长TL进行比较。若S&lt;TL，表示未越界</li><li>根据<strong>段表始址F</strong>和<strong>段号S</strong>来求出该段所对应的<strong>段表项</strong>在段表中的位置，从中得到该段的<strong>页表始址</strong></li><li>根据<strong>段内页号P</strong>来获得对应页的<strong>页表项位置</strong>，从中读出该页所在的<strong>物理块号b</strong></li><li>利用块号b和页内地址来构成<strong>物理地址</strong></li></ol><h2 id="三、虚拟内存"><a href="#三、虚拟内存" class="headerlink" title="三、虚拟内存"></a>三、虚拟内存</h2><p>虚拟内存的<strong>基本思想</strong>是：在程序装入时，可以将程序的<strong>一部分装入内存</strong>，而将<strong>其余部分留在外存</strong>，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分<strong>调入内存,</strong>然后继续执行程序。</p><p>虚拟内存容量：<strong>内存+外存</strong></p><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt="img"><br>理论依据：<strong>局部性原理</strong></p><p>与传统存储器比较虚拟存储器有以下三个<strong>主要特征</strong>：</p><ul><li>多次性，是指无需在作业运行时一次性地全部装入内存，而是允许被分成多<strong>次调入内存运行</strong>。</li><li>对换性，是指无需在作业运行时一直常驻内存，而是允许在作业的运行过程中，进行<strong>换进和换出</strong>。</li><li>虚拟性，是指从逻辑上扩充内存的容量，使用户所看到的内存容量，远<strong>大于实际的内存容量</strong>。</li></ul><p>虚拟内存的实现有以下两种方式：</p><ul><li><strong>请求分页存储管理</strong></li><li>请求分段存储管理</li><li>请求段页式存储管理</li></ul><h3 id="3-1-请求分页存储管理"><a href="#3-1-请求分页存储管理" class="headerlink" title="3.1 请求分页存储管理"></a>3.1 请求分页存储管理</h3><p>将当前需要的<strong>一部分页面</strong>装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过<strong>调页功能</strong>将其调入，同时还可以通过置换功能将暂时不用的页面<strong>换出到外存</strong>上，以便腾出内存空间</p><h4 id="3-1-1-地址变换"><a href="#3-1-1-地址变换" class="headerlink" title="3.1.1 地址变换"></a>3.1.1 地址变换</h4><p>请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的</p><p>请求分页系统中，每当所要访问的页面不在内存时，便产生一个<strong>缺页中断</strong>，请求操作系统将所缺的页调入内存</p><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png" alt="img"></p><p>缺页中断处理中：</p><ul><li>如果内存中有<strong>空闲块</strong>，则分配一个块，将要调入的<strong>页装入该块</strong></li><li>若此时内存中<strong>没有空闲块</strong>，则要<strong>淘汰某页</strong></li><li>若被<strong>淘汰页</strong>在内存期间<strong>被修改过</strong>，则要将其<strong>写回外存</strong></li></ul><h3 id="3-2-页面置换算法"><a href="#3-2-页面置换算法" class="headerlink" title="3.2 页面置换算法"></a>3.2 页面置换算法</h3><p>进程运行时，若其访问的<strong>页面</strong>不在内存而需将其<strong>调入</strong>，但<strong>内存已无空闲</strong>空间时，就需要从<strong>内存中调出一页</strong>程序或数据，送入磁盘的对换区。</p><p>选择调出页面的算法就称为<strong>页面置换算法</strong></p><ul><li><strong>最优页面置换算法</strong></li></ul><p>最理想的状态下，所选择的被淘汰页面将是<strong>最长时间内不再被访问</strong>的页面，当然，这样的算法<strong>不可能实现</strong>，因为不确定一个页面在何时会被用到。</p><ul><li><strong>先进先出页面置换算法（FIFO）</strong></li></ul><p>这种算法的思想和队列是一样的，该算法总是<strong>淘汰最先进入内存的页面</strong>，即选择在内存中驻留时间最久的页面予淘汰。</p><p>实现简单，把一个进程已调入内存的页面按先后次序链接成一个队列，并且设置一个指针总是指向最老的页面。</p><p><strong>缺点</strong>：对于有些经常被访问的页面如含有全局变量、常用函数、例程等的页面，不能保证这些不被淘汰。</p><ul><li><strong>最近最久未使用页面置换算法LRU（Least Recently Used）</strong></li></ul><p>根据页面调入内存后的使用情况做出决策。LRU置换算法是选择<strong>最近最久未使用</strong>的页面进行淘汰。</p><p><strong>实现</strong>：</p><p>1.为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰</p><p>2.利用一个特殊的栈保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。因此，栈顶永远是最新被访问的页面号，栈底是最近最久未被访问的页面号。</p><ul><li><strong>时钟置换算法(Clock Page Replacement Algorithm)</strong></li></ul><p><img src="https://img-blog.csdnimg.cn/20190128191216276.png" alt="img"></p><p>把所有的页面都保存在一个类似钟面的<strong>环形结构</strong>中</p><p>每一个页面增加一个<strong>使用位</strong></p><ol><li>当某一页<strong>首次装入主存</strong>时，该帧的使用位设<strong>置为1</strong>，当该页随后再<strong>被访问</strong>到时，它的使用位也被<strong>置为1</strong></li><li>当需要<strong>替换</strong>一页时，操作系统扫描缓冲区，以<strong>查找使用位被置为0</strong>的一帧，每当遇到一个<strong>使用位为1</strong>的帧时，操作系统就将该位<strong>重新置为0</strong></li><li>如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换</li><li>如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页</li></ol><h3 id="3-3-页面抖动（-颠簸）"><a href="#3-3-页面抖动（-颠簸）" class="headerlink" title="3.3 页面抖动（ 颠簸）"></a><strong>3.3</strong> 页面<strong>抖动（</strong> <strong>颠簸）</strong></h3><p>颠簸本质上是指频繁的页面调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，<strong>其他所有的页都在使用</strong>，它置换一个页，但又立刻再次需要这个页。因此，会<strong>不断产生缺页中断</strong>，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）</p><p>内存颠簸的<strong>解决策略</strong>包括：</p><ul><li>如果是因为页面替换策略失误，可以<strong>修改替换算法来</strong>解决这个问题；</li><li>如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要<strong>降低多道程序的数量</strong>；</li><li><strong>终止该进程</strong>或<strong>增加物理内存容量</strong>。</li></ul><h3 id="3-4-驻留集大小"><a href="#3-4-驻留集大小" class="headerlink" title="3.4 驻留集大小"></a>3.4 驻留集大小</h3><p><strong>驻留集</strong>：对于分页式的虚拟内存，不需要把一个进程的所有页都读取到主存，操作系统必须决定<strong>读取多少页</strong>。也就是说，给特定的进程<strong>分配多大的主存空间</strong>，这就是驻留集。</p><p>主要考虑以下几点：</p><ul><li>分配给一个进程的<strong>存储量越小</strong>，在任何时候驻留在主存中的<strong>进程数就越多</strong>，从而可以提高<strong>处理机的时间利用效率</strong></li><li>如果分配给一个进程的<strong>存储量太小</strong>，尽管有局部性原理，<strong>页错误率</strong>仍然会相对较高</li><li>如果<strong>存储量太大，</strong>页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响</li></ul><p>操作系统通常釆用三种策略：</p><ul><li><strong>固定分配局部置换</strong></li></ul><p>为每个进程分配<strong>一定数目的物理块</strong>，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面</p><ul><li><strong>可变分配全局置换</strong></li></ul><p>为系统中的每个进程分配<strong>一定数目的物理块</strong>,操作系统自身也保持一个<strong>空闲物理块队列</strong>。</p><p>当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块<strong>分配</strong>给该进程，并将欲调入的页装入其中。</p><ul><li><strong>可变分配局部置换</strong></li></ul><p>为每个进程分配<strong>一定数目的物理块</strong></p><p>当某进程发生<strong>缺页</strong>时，只允许从该进程在内存的页面中<strong>选出一页换出</strong>，这样就不会影响其他进程的运行</p><p>如果进程在运行中<strong>频繁地缺页</strong>，系统再为该进程<strong>分配若干物理块</strong>，直至该进程缺页率趋于适当程度</p><p> 反之，若进程在运行中<strong>缺页率特别低</strong>，则可适当<strong>减少分配</strong>给该进程的物理块</p><h3 id="3-5-调入页面的时机"><a href="#3-5-调入页面的时机" class="headerlink" title="3.5 调入页面的时机"></a>3.5 调入页面的时机</h3><p>为确定系统将进程运行时所缺的页面调入内存的时机，可釆取以下两种调页策略</p><ul><li><strong>预调页策略</strong></li></ul><p>根据局部性原理，一次调入若干个相邻的页可能会比一次调入一页更高效。但如果调入的一批页面中大多数都未被访问，则又是低效的。所以就需要釆用<strong>以预测为基础的预调</strong>页策略，将<strong>预计在不久之后便会被访问的页面预先调</strong>入内存</p><ul><li><strong>请求调页策略</strong></li></ul><p>进程在运行中需要访问的页面不在内存而提出请求，由系统<strong>将所需页面调入</strong>内存。</p><p>由这种策略调入的页一定会被访问，且这种策略比较易于实现，故在目前的虚拟存储器中大多釆用此策略。</p><p><strong>缺点</strong>在于每次只调入一页，调入调出页面数多时会<strong>花费过多的I/O开销</strong></p><h3 id="3-6-从何处调入页面"><a href="#3-6-从何处调入页面" class="headerlink" title="3.6 从何处调入页面"></a>3.6 从何处调入页面</h3><p>请求分页系统中的<strong>外存</strong>分为两部分：</p><ol><li>用于存放文件的<strong>文件区，</strong>釆用连续分配方式</li><li>用于存放对换页面的<strong>对换区，</strong>釆用离散分配方式</li></ol><p>故对换区的磁盘I/O速度比文件区的更快，这样从何处调入页面有三种情况：</p><ul><li><strong>系统拥有足够的对换区空间</strong></li></ul><p>可以<strong>全部从对换区调入所需页面</strong>，以提髙调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区</p><ul><li><strong>系统缺少足够的对换区空间</strong></li></ul><p>凡<strong>不会被修改的文件</strong>都直接从<strong>文件区</strong>调入，而当换出这些页面时，由于它们未被修改而不必再将它们换出。</p><p>对于那些<strong>可能被修改</strong>的部分，在将它们<strong>换出时须调到对换区</strong>，以后需要时再从对换区调入。</p><ul><li><strong>UNIX方式</strong></li></ul><p>与进程有关的文件都放在文件区，故<strong>未运行过的页面</strong>，都应从<strong>文件区</strong>调入</p><p>曾经运<strong>行过但又被换出</strong>的页面，由于是被放在<strong>对换区</strong>，因此下次调入时应从对换区调入</p><p>进程请求的<strong>共享页面若被其他进程调入内存</strong>，则无需再从对换区调入</p><p><a href="https://blog.csdn.net/ChaunceyChen/article/details/86672415">https://blog.csdn.net/ChaunceyChen/article/details/86672415</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-进程管理</title>
      <link href="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/"/>
      <url>/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h2><h3 id="1-1-进程定义"><a href="#1-1-进程定义" class="headerlink" title="1.1 进程定义"></a>1.1 进程定义</h3><p>进程是对正在运行中程序的一种抽象，操作系统所有的内容都是围绕进程展开。</p><p>在许多多道程序系统中，CPU会在<strong>进程</strong>间快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU只能运行一个进程，然而我们如果把时间定位为1秒内的话，它可能运行多个进程。这样就会让我们产生<strong>并行</strong>的错觉。有时候人们说的<strong>伪并行</strong>(pseudoparallelism)就是这种情况，以此来区分多处理器系统(该系统由两个或多个CPU来共享同一个物理内存)</p><p>进程实体=程序段+相关数据段+PCB(进程控制块)</p><p><strong>进程是资源分配的基本单位。</strong></p><p><strong>进程控制块</strong> (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/进程.png" alt="image-20200812213749012" style="zoom:67%;"><p>在一个给定的时间只有一个线程在运行</p><h3 id="1-2-进程的执行"><a href="#1-2-进程的执行" class="headerlink" title="1.2 进程的执行"></a>1.2 进程的执行</h3><h4 id="1-2-1-顺序执行"><a href="#1-2-1-顺序执行" class="headerlink" title="1.2.1 顺序执行"></a>1.2.1 顺序执行</h4><ul><li><strong>顺序性</strong>。 每个操作都必须在前一个操作结束后才能开始</li><li><strong>封闭性</strong>。 程序一旦开始运行，其运行结果不会受到外界因素的影响</li><li><strong>可再现性</strong>。 程序运行结果仅由初始结果和程序本身的操作决定</li></ul><h4 id="1-2-2-并发执行"><a href="#1-2-2-并发执行" class="headerlink" title="1.2.2 并发执行"></a>1.2.2 并发执行</h4><p>在计算机引入<strong>通道和中断</strong>机制后，就使得CPU和外部设备之间，以及外部设备与外部设备之间可以并行操作，使得多道程序设计成为可能。</p><p>在同一时刻，有的程序占用CPU运行，有的程序通过外部设备传递数据。<strong>从宏观上看是多个设备同时运行，从微观上来看它们是在交替运行。</strong></p><p>因此，程序并发执行环境下的计算机资源，已不再被某一个用户程序所独占，而是由多个并发执行的程序所共享。虽然提高了资源的利用率，但在另外一方面却<strong>引发了多个并发程序对资源的竞争导致了程序执行环境与运行速度的改变，从而可能产生程序运行结果不唯</strong></p><ul><li><strong>间断性</strong></li><li><strong>无封闭性</strong></li><li><strong>不可再现性</strong></li></ul><h3 id="1-3-进程特点"><a href="#1-3-进程特点" class="headerlink" title="1.3 进程特点"></a>1.3 进程特点</h3><ul><li>动态性。 进程具有生命期，具有“创建-运行-消亡”这样一个过程</li><li>并发性。 多个进程能够在一段时间内并发执行</li><li>独立性。 每个进程都是一个独立运行的基本单位，也是<strong>系统进行资源分配和调度的基本单位</strong></li><li>异步性。 任何时刻只能有一个进程占用CPU，具有“执行-暂停-执行”这种间断性规律</li><li>结构性。 由程序段、相关数据段、PCB三部分组成</li></ul><h3 id="1-4-进程和程序的区别"><a href="#1-4-进程和程序的区别" class="headerlink" title="1.4 进程和程序的区别"></a>1.4 进程和程序的区别</h3><p>程序是静态的，进程是动态的</p><p>两这不是一一对应关系，一个程序对应多个进程，一个进程可以保护多个程序</p><h3 id="1-5-进程状态"><a href="#1-5-进程状态" class="headerlink" title="1.5 进程状态"></a>1.5 进程状态</h3><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/进程状态.png" alt="image-20200812214701603" style="zoom:67%;"><ol><li>新建<br>当需要创建一个新进程时，系统为该进程分配一个进程控制块PCB，并为该进程分配内存空间，且装入该进程对应的程序和有关数据。</li><li>就绪<br><strong>进程得到除了CPU之外的所需资源，一旦得到CPU资源既可以立即投入运行</strong>。</li><li>运行<br>进程获得了CUP和其他所需要的资源，目前正在CPU上运行</li><li>阻塞<br><strong>进程 运行 过程中发生了某种等待事件（比如发生了I/O操作）而暂时不能运行的状态</strong>。即使把CPU资源分配给它也不能够运行。</li><li>结束<br>系统逐步释放为为其分配的资源，最后释放其PCB.</li></ol><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源(如I/O资源)</li></ul><p>注意</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h2 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h2><h3 id="2-1线程的定义"><a href="#2-1线程的定义" class="headerlink" title="2.1线程的定义"></a>2.1线程的定义</h3><p>在引入进程后，由于进程此时是资源分配的基本单位也是独立调度独立运行的基本单位。同时扮演连个角色，导致进程的并发执行产生了很大空间开销。因此引入了线程。将一个进程分解为多个线程。</p><ul><li>线程属于轻型实体，<strong>基本不拥有系统资源</strong></li><li><strong>线程是独立调度和分配的基本单位，也是能够独立运行的基本单位</strong></li><li>同一个进程的所有线程共享该进程的所拥有的全部资源</li><li>线程的并发执行程度高，<strong>不但同一进程的多个线程可以并发执行，甚至属于不同进程的多个线程也可以并发执行</strong></li></ul><p>与进程类似，线程也有生命周期，也存在 执行、就绪和阻塞这三种基本状态，这是因为线程完全继承了进程的运行属性，因此<strong>线程的三种状态含义和转换关系与进程相同</strong>。由于线程不是资源的拥有单位，因此<strong>挂起状态对单个线程没有意义</strong>。</p><p>为了使并发的多个线程能够有条不紊地运行，操作系统必须提供用于线程间互斥和同步的机制：</p><ul><li><strong>互斥锁</strong>，每次只允许一个线程来执行特定的代码或访问特定的数据。</li><li><strong>读写锁</strong>，对受保护的共享资源进行并发读取和独占写入。</li><li><strong>条件变量</strong>，一直阻塞线程，直到特定的条件为真。</li><li><strong>奇数信号量</strong>，用来协调对资源的访问，达到指定的计数时信号将阻塞。</li></ul><h3 id="2-2-与进程的区别"><a href="#2-2-与进程的区别" class="headerlink" title="2.2 与进程的区别"></a>2.2 与进程的区别</h3><p>Ⅰ 拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p><p>Ⅱ 调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p><p>Ⅲ 系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p><p>Ⅳ 通信方面</p><p>线程间可以通过直接读写同一进程中的数据进行通信，但是<strong>进程通信需要借助 IPC</strong>。</p><h2 id="三、进程间通信"><a href="#三、进程间通信" class="headerlink" title="三、进程间通信"></a>三、进程间通信</h2><p>进程间通信ICP</p><h3 id="3-1-临界资源与临界区"><a href="#3-1-临界资源与临界区" class="headerlink" title="3.1 临界资源与临界区"></a>3.1 临界资源与临界区</h3><p><strong>把同一时刻只允许一个进程使用的资源成为临界资源。</strong></p><p>对临界资源的访问必须互斥进行，即各个进程对同一临界资源进行先从操作的程序段也应互斥进行，只有这样才能保证对临界资源的互斥访问。<strong>把进程中访问临界资源的代码称为临界区。</strong></p><p>对于临界资源的访问必须互斥进行，<strong>所以进程在进入临界区时首先判断是否有其他进程在使用此临界资源，如果有，则该进程必须等待；如果没有，则该进程才能进入临界区执行临界区代码，同时还要关闭临界区以防止其他进程进入。当进程使用完临界资源时，要开放临界区以便其他进程进入。</strong></p><p>临界资源是数据结构，临界区是访问该数据结构的代码片段</p><h3 id="3-2-同步与互斥"><a href="#3-2-同步与互斥" class="headerlink" title="3.2 同步与互斥"></a>3.2 同步与互斥</h3><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h3 id="3-3-互斥访问临界资源的方法"><a href="#3-3-互斥访问临界资源的方法" class="headerlink" title="3.3 互斥访问临界资源的方法"></a>3.3 互斥访问临界资源的方法</h3><h4 id="3-3-1-从软件角度来看"><a href="#3-3-1-从软件角度来看" class="headerlink" title="3.3.1 从软件角度来看"></a>3.3.1 从软件角度来看</h4><p>单标志变量(有些同学不信邪)<br>勉强能用的两标志法<br>聪明人才能想出的三标志法(扩展性不行)</p><h4 id="3-3-2-依靠系统支持"><a href="#3-3-2-依靠系统支持" class="headerlink" title="3.3.2 依靠系统支持"></a>3.3.2 依靠系统支持</h4><h5 id="关中断大法-时间停止大法"><a href="#关中断大法-时间停止大法" class="headerlink" title="关中断大法(时间停止大法)"></a>关中断大法(时间停止大法)</h5><p>又称硬件锁，进程在进入临界区之前，先执行“关中断”指令来屏蔽掉所有中断，进程完成所有临界区的任务后，再执行“开中断”指令将中断打开。</p><p><strong>缺点</strong>：开关中断时间过长会导致系统效率降低。</p><h5 id="加锁法"><a href="#加锁法" class="headerlink" title="加锁法"></a>加锁法</h5><p>锁不是一般的标志变量(否则锁本身就成了临界资源)<br>lock/unlock要做成原语<br>“关中断……关中断”做原语的方式是不行的，得固化成指令<br><strong>缺点</strong>：忙等</p><h3 id="3-4-信号量（重点）"><a href="#3-4-信号量（重点）" class="headerlink" title="3.4 信号量（重点）"></a>3.4 信号量（重点）</h3><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><p>信号量的初值是一个非负整数，随着不断分配，value的值的情况：</p><ul><li>value&gt;0，代表该类资源当前的可用数量</li><li>value=0，表示该资源为空</li><li>value&lt;0，<strong>其绝对值代表因等待该资源而阻塞的进程数量</strong></li></ul><ul><li><p><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进入阻塞队列中，等待信号量大于 0；</p></li><li><p><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</p></li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>  如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><p>P、V信号量<strong>解决了进程主动进行循环测试消耗系统资源的问题</strong>。因为这种协调的本质是当出现资源竞争的冲突时，就将原来并发执行的多个进程在P、V操作的协调下变为<strong>依次顺序执行</strong>，<strong>当资源冲突结束后又恢复为并发执行。</strong></p><h4 id="使用信号量实现生产者-消费者问题"><a href="#使用信号量实现生产者-消费者问题" class="headerlink" title="使用信号量实现生产者-消费者问题"></a><strong>使用信号量实现生产者-消费者问题</strong></h4><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><p>因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。</p><p>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，<strong>这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</strong></p><p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，<strong>不能先执行 down(mutex) 再执行 down(empty)。</strong>如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</p><h3 id="3-5-互斥量"><a href="#3-5-互斥量" class="headerlink" title="3.5 互斥量"></a>3.5 互斥量</h3><p>如果不需要信号量的计数能力时，可以使用信号量的一个简单版本，称为<strong>mutex(互斥量)</strong> 。互斥量的优势就在于在一-些共享资源和一段代码中保持互斥。由于互斥的实现既简单又有效，这使得互斥量在实现用户空间线程包时非常有用。<br>互斥量是一个处于两种状态之一的共享变量:解锁(unlocked)和加锁(locked) 。这样，只需要一个二进制位来表示它，不过一般情况下，通常会用一个整形(integer) 来表示。 0表示解锁，其他所有的值表示加锁，比1大的值表示加锁的次数。</p><h3 id="3-6-管程"><a href="#3-6-管程" class="headerlink" title="3.6 管程"></a>3.6 管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><h3 id="3-7-进程同步问题"><a href="#3-7-进程同步问题" class="headerlink" title="3.7 进程同步问题"></a>3.7 进程同步问题</h3><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><h3 id="3-8-进程通信"><a href="#3-8-进程通信" class="headerlink" title="3.8 进程通信"></a>3.8 进程通信</h3><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><h4 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h4><p>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><p>它具有以下限制：</p><ul><li>只支持半双工通信（单向交替传输）；</li><li>只能在父子进程或者兄弟进程中使用。</li></ul><h4 id="2-FIFO"><a href="#2-FIFO" class="headerlink" title="2. FIFO"></a>2. FIFO</h4><p>也称为命名管道，去除了管道只能在父子进程中使用的限制。</p><p>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</p><h4 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h4><p>相比于 FIFO，消息队列具有以下优点：</p><ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。</li></ul><h4 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4. 信号量"></a>4. 信号量</h4><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h4 id="5-共享存储"><a href="#5-共享存储" class="headerlink" title="5. 共享存储"></a>5. 共享存储</h4><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p><h4 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6. 套接字"></a>6. 套接字</h4><p>与其它通信机制不同的是，它可用于不同机器间的进程通信。</p><h2 id="四、调度"><a href="#四、调度" class="headerlink" title="四、调度"></a>四、调度</h2><h3 id="4-1-批处理系统"><a href="#4-1-批处理系统" class="headerlink" title="4.1 批处理系统"></a>4.1 批处理系统</h3><p>批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。</p><p><strong>1.1 先来先服务 first-come first-serverd（FCFS）</strong></p><p>非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><p><strong>1.2 短作业优先 shortest job first（SJF）</strong></p><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><p><strong>1.3 最短剩余时间优先 shortest remaining time next（SRTN）</strong></p><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h3 id="4-2-交互式系统"><a href="#4-2-交互式系统" class="headerlink" title="4.2 交互式系统"></a>4.2 交互式系统</h3><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><p><strong>4.2.1 时间片轮转</strong></p><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：</p><ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。</li><li>而如果时间片过长，那么实时性就不能得到保证。</li></ul><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC.png" alt="img"></p><p><strong>4.2.2 优先级调度</strong></p><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><p><strong>4.2.3 多级反馈队列</strong></p><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97.png" alt="img"></p><h3 id="3-实时系统"><a href="#3-实时系统" class="headerlink" title="3. 实时系统"></a>3. 实时系统</h3><p>实时系统要求一个请求在一个确定时间内得到响应。</p><p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p><p>参考</p><p><a href="https://notecc.ink/posts/eefe591f.html">线程与进程</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-认识</title>
      <link href="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" alt="image-20200812174809179"></p><span id="more"></span><h2 id="认识操作系统"><a href="#认识操作系统" class="headerlink" title="认识操作系统"></a>认识操作系统</h2><p>程序员不会直接和这些硬件打交道，而且每位程序员不可能会掌握所有计算机系统的细节，这样我们就不用再编写代码了，所以在硬件的基础之.上，计算机安装了一层软件，这层软件能够通过响应用户输入的指令达到控制硬件的效果，从而满足用户需求，这种软件称之为<strong>操作系统</strong>，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。</p><p>面对一般用户，通过（<strong>操作命令</strong>）方式控制操作系统；面对编程人员，通过（<strong>系统调用</strong>）控制。</p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/操作系统部件.png" alt="image-20200812173603374" style="zoom:67%;"><p>这是一个操作系统的简化图，最下面的是硬件，，在硬件之上是软件。大部分计算机有两种运行模式<strong>:内核态</strong> 和<strong>用户态</strong>，软件中最基础的部分是操作系统，它<strong>运行在内核态</strong>中， 内核态也称为管态和核心态，它们都是操作系统的运行状态，只不过是不同的叫法而已。<strong>操作系统具有硬件的访问权</strong>，可以执行机器能够运行的任何指令。软件的其余部分运行在用户态下。</p><p><code>用户接口程序(shell或者GUI)</code> 处于用户态中，并且它们位于用户态的最低层，允许用户运行其他程序，例如Web浏览器、电子邮件阅读器、音乐播放器等。而且，越靠近用户态的应用程序越容易编写，如果你不喜欢某个电子邮件阅读器你可以重新写一个或者换一-个，但你不能自行写一个操作系统或者是中断处理程序。这个程序由硬件保护，防止外部对其进行修改。</p><h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h3><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p><h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h3><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p><h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h3><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p><h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h3><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><h3 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1. 进程管理"></a>1. 进程管理</h3><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p><h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h3><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p><h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3. 文件管理"></a>3. 文件管理</h3><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p><h3 id="4-设备管理"><a href="#4-设备管理" class="headerlink" title="4. 设备管理"></a>4. 设备管理</h3><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><img src="/2020/08/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/系统调用.png" alt="image-20200812174329900" style="zoom:67%;"><p>Linux 的系统调用主要有以下这些：</p><table><thead><tr><th>Task</th><th>Commands</th></tr></thead><tbody><tr><td>进程控制</td><td>fork(); exit(); wait();</td></tr><tr><td>进程通信</td><td>pipe(); shmget(); mmap();</td></tr><tr><td>文件操作</td><td>open(); read(); write();</td></tr><tr><td>设备操作</td><td>ioctl(); read(); write();</td></tr><tr><td>信息维护</td><td>getpid(); alarm(); sleep();</td></tr><tr><td>安全</td><td>chmod(); umask(); chown();</td></tr></tbody></table><h2 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h2><h3 id="1-大内核"><a href="#1-大内核" class="headerlink" title="1. 大内核"></a>1. 大内核</h3><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p><p>由于各模块共享信息，因此有很高的性能。</p><h3 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h3><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p><p>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。</p><p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p><h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h3><p>由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p><h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p><h3 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h3><p>在用户程序中使用系统调用。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java集合-HashMap</title>
      <link href="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/"/>
      <url>/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>数组+链表  （jdk7及之前)</p><p>数组+链表+红黑树 （jdk 8)</p><h2 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;K1&quot;</span>, <span class="string">&quot;V1&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K2&quot;</span>, <span class="string">&quot;V2&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;K3&quot;</span>, <span class="string">&quot;V3&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>新建一个 HashMap，默认大小为 16；</li><li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li><li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li><li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，在用equals比较是否相同<ul><li>不相同，插在 &lt;K2,V2&gt; 前面。</li><li>相同，用key,value替换。</li></ul></li></ul><p>应该注意到链表的插入是以<strong>头插法</strong>方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p><p>查找需要分成两步进行：</p><ul><li>计算键值对所在的桶；</li><li>在链表上顺序查找，时间复杂度显然和链表的长度成正比</li></ul><h3 id="hash函数"><a href="#hash函数" class="headerlink" title="hash函数"></a>hash函数</h3><h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;：带符号右移。正数右移高位补<span class="number">0</span>，负数右移高位补<span class="number">1</span></span><br><span class="line">&gt;&gt;&gt;：无符号右移。无论是正数还是负数，高位通通补<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">以下代码可以判断两个数的符号是否相等</span><br><span class="line"><span class="keyword">return</span> ((a &gt;&gt; <span class="number">31</span>) ^ (b &gt;&gt; <span class="number">31</span>)) == <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt;存储</span><br></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 序列号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;    </span><br><span class="line"><span class="comment">// 默认的初始容量是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;   </span><br><span class="line"><span class="comment">// 最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; </span><br><span class="line"><span class="comment">// 默认的填充因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line"><span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class="line"><span class="comment">// 存放具体元素的集 ，键值对缓存，如果外部操作导致key改变，还是可以通过这个找到映射关系</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;   </span><br><span class="line"><span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ul><li><p><strong>loadFactor加载因子</strong></p><p>loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p></li><li><p><strong>threshold</strong></p><p><strong>threshold = capacity * loadFactor</strong>，<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p></li></ul><p>空参构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带参构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put-操作"><a href="#put-操作" class="headerlink" title="put 操作"></a>put 操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">简单来说：</span><br><span class="line">判断数组是否为空，空数组进行初始</span><br><span class="line">key为null，处理null值，程序结束</span><br><span class="line">计算hash值</span><br><span class="line">根据hash值定位要插入的位置</span><br><span class="line">循环遍历这个位置，判断是否存在hash相同 key也相同的元素存在，</span><br><span class="line">存在，把value替换返回旧的value,程序结束，</span><br><span class="line">不存在,则一直遍历到尾部。O（n）的时间复杂度</span><br><span class="line">modCount++ 修改值加1</span><br><span class="line">头插法插入这个位置</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法是有返回值的，返回的的是：如果key相同覆盖的是之前key的value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判读数组是不是为空的，初始化</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//key为null，hashmap可以为null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//计算出hash</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//根据hash和数组长度 计算出数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"><span class="comment">//循环 从这个数组位置的链表头结点开始 ，直到他不为null</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//判断，这个hash相等或key值相等</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value; <span class="comment">//获取</span></span><br><span class="line">            e.value = value; <span class="comment">//赋值新值</span></span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);  <span class="comment">//这个方法在linkedHashMap实现</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;<span class="comment">//结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头插法效率不一定高。并且会导致一系列问题。</p><p>JDK8改为尾插法。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化，为什么一定要一个2的幂次方数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize 找到一个大于等于toSize的2的幂次方数</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//初始化数组</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么一定要一个2的幂次方数？</strong></p><p>为了方便后面判断数组中存放位置进行&amp;运行，效率更高。</p><h5 id="找2幂次方数"><a href="#找2幂次方数" class="headerlink" title="找2幂次方数"></a>找2幂次方数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>-<span class="number">16</span></span><br><span class="line"><span class="number">6</span>-<span class="number">16</span></span><br><span class="line"><span class="number">1</span>---<span class="number">0000</span> <span class="number">0001</span></span><br><span class="line"><span class="number">2</span>---<span class="number">0000</span> <span class="number">0010</span></span><br><span class="line"><span class="number">4</span>---<span class="number">0000</span> <span class="number">0100</span></span><br><span class="line">返回二进制，判断是不是只有一位是<span class="number">1</span></span><br><span class="line">Integer.highestOneBit(i)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// HD, Figure 3-1</span></span><br><span class="line">        i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">假设这个数字</span><br><span class="line">        <span class="number">001</span>* ****</span><br><span class="line">        &gt;&gt;<span class="number">1</span><span class="number">0001</span> ****</span><br><span class="line">|<span class="number">0011</span> ****</span><br><span class="line">        &gt;&gt;<span class="number">2</span> <span class="number">0000</span> <span class="number">11</span>**</span><br><span class="line">        |<span class="number">0011</span> <span class="number">11</span>**</span><br><span class="line">        最终将最高位之后的数字变成<span class="number">1</span> 在移位相减</span><br><span class="line">        <span class="number">0011</span> <span class="number">1111</span></span><br><span class="line">        -<span class="number">0001</span> <span class="number">1111</span> </span><br><span class="line">这个函数调用。使用的第一感觉就是这个函数是干什么用的，通过查看文档得知，这个函数的作用是取 i 这个数的二进制形式最左边的最高一位且高位后面全部补零，最后返回<span class="keyword">int</span>型的结果。找到小于等于的幂次方数</span><br><span class="line"><span class="number">10</span> - <span class="number">8</span></span><br><span class="line"><span class="number">16</span> - <span class="number">16</span></span><br><span class="line"><span class="number">6</span>  - <span class="number">4</span></span><br><span class="line">如果这个值为 <span class="number">0</span> 返回<span class="number">1</span>；</span><br><span class="line">如果这个值不为<span class="number">0</span></span><br><span class="line">        则判断他<span class="number">1</span>的位数，只有<span class="number">1</span>位，就直接返回这个数。</span><br><span class="line">        多余一位就对rounded 左移，得到他<span class="number">2</span>倍的数。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到一个大于等于toSize的2的幂次方数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="keyword">int</span> rounded = number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">        ? MAXIMUM_CAPACITY</span><br><span class="line">        : (rounded = Integer.highestOneBit(number)) != <span class="number">0</span></span><br><span class="line">            ? (Integer.bitCount(number) &gt; <span class="number">1</span>) ? rounded &lt;&lt; <span class="number">1</span> : rounded</span><br><span class="line">            : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rounded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如果key为null"><a href="#如果key为null" class="headerlink" title="如果key为null"></a>如果key为null</h5><p>null值固定是存在第0个位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历第0个位置</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">/*写死  hash 0</span></span><br><span class="line"><span class="comment">       key null</span></span><br><span class="line"><span class="comment">       value value </span></span><br><span class="line"><span class="comment">       位置 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="找到在数组中的位置"><a href="#找到在数组中的位置" class="headerlink" title="找到在数组中的位置"></a>找到在数组中的位置</h5><p>要平均。这个使用的是&amp;操作，两个都为1，才是1，这个的效率比除法高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h &amp; (length-1)</span><br><span class="line">h0101 0101</span><br><span class="line">15 0000 1111</span><br><span class="line">&amp;0000 0101</span><br><span class="line">这个最后的取值结果是这个长度的低位</span><br></pre></td></tr></table></figure><p><strong>但是这个没有用到高位的hashcode，这样是不是没有用了？</strong><br>不是这个h是根据hashcode移位算出的，最高位其实也参加了运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="存放"><a href="#存放" class="headerlink" title="存放"></a>存放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判读是否超出阈值，这里还判断是否为null</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;<span class="comment">//进行扩容，后面会讲。</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取这个位置原有的对象，然后创建对象，插入这个位置，头插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传入一个新的参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;<span class="comment">//记录老数组</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;<span class="comment">//判断老数组有没有大于阈值，最大就不在进行扩容。</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建新数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">//转移</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新数组，标记</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length; <span class="comment">//取出长度</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123; <span class="comment">//将旧数组的元素存入新数组</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//JDK8没有，从新生成hash</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);<span class="comment">//得到新的数组下标</span></span><br><span class="line">            <span class="comment">//头插法</span></span><br><span class="line">            e.next = newTable[i]; <span class="comment">//这个元素的下一个节点</span></span><br><span class="line">            newTable[i] = e; <span class="comment">//把这个元素放入新的数组</span></span><br><span class="line">            e = next;<span class="comment">//下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个方法会使链表的数据倒置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span> <span class="number">0101</span> <span class="number">0101</span></span><br><span class="line"><span class="number">15</span> <span class="number">0000</span> <span class="number">1111</span></span><br><span class="line">&amp;  <span class="number">0000</span> <span class="number">0101</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">16</span> <span class="number">0101</span> <span class="number">0101</span></span><br><span class="line"><span class="number">32</span> <span class="number">0001</span> <span class="number">1111</span></span><br><span class="line">&amp;  <span class="number">0001</span> <span class="number">0101</span>   </span><br><span class="line"><span class="number">5</span>+<span class="number">16</span></span><br><span class="line"><span class="number">1.</span> 数组下标不发生变化</span><br><span class="line"><span class="number">2.</span> 数组下标发生变化 新的下标 = 旧的下标 + 旧数组长度</span><br></pre></td></tr></table></figure><h4 id="在多线程的情况下回出现循环链表，死锁"><a href="#在多线程的情况下回出现循环链表，死锁" class="headerlink" title="在多线程的情况下回出现循环链表，死锁"></a>在多线程的情况下回出现循环链表，死锁</h4><p>这是1.7的主要问题</p><ol><li><p>两个线程都处于复制初始化阶段。</p></li><li><p>当第一个线程执行完复制操作之后.第二个线程刚开始复制这个这个位置的数指针的情况。</p></li></ol><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/Blog/source/_posts/Collection和Map/死锁执行1.png" alt="image-20200808195513024" style="zoom:50%;"><ol start="3"><li>第二个线程开始执行,执行完第一次赋值之后的情况。</li></ol><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/Blog/source/_posts/Collection和Map/死锁执行2.png" alt="image-20200808202810761" style="zoom: 50%;"><ol start="4"><li>第二个线程第二次执行</li></ol><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/Blog/source/_posts/Collection和Map/死锁执行3.png" alt="image-20200808203259666" style="zoom: 67%;"><ol start="5"><li>第二个线程第三次执行。此时形成循环链表</li></ol><p><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/Blog/source/_posts/Collection%E5%92%8CMap/%E6%AD%BB%E9%94%81%E6%89%A7%E8%A1%8C4.png" alt="image-20200808203601057"></p><p>原因：头插法导致数据顺序发生变化。</p><p>解决：</p><p>1.控制hashmap的阈值。防止他扩容</p><p>hash种子可能改变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</span><br><span class="line">    <span class="keyword">if</span> (switching) &#123;</span><br><span class="line">        hashSeed = useAltHashing</span><br><span class="line">            ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</span><br><span class="line">            : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> switching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fail-fast机制"><a href="#fail-fast机制" class="headerlink" title="fail-fast机制"></a>fail-fast机制</h3><p>先看一段简单的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String key:map.keySet())&#123;</span><br><span class="line">        <span class="keyword">if</span> (key==<span class="string">&quot;2&quot;</span>)&#123;</span><br><span class="line">            map.remove(key);<span class="comment">//modcount++</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.HashMap$HashIterator.nextEntry(HashMap.java:<span class="number">926</span>)</span><br><span class="line">at java.util.HashMap$KeyIterator.next(HashMap.java:<span class="number">960</span>)</span><br><span class="line">at com.lq.offer.JZ13.main(JZ13.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>就是防止在迭代的时候进行修改。容错机制。</p><p>如果2个线程，一个线程在遍历，另一个线程在删除，会出现并发的问题。</p><p><strong>推荐使用迭代器的remove方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String,String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    Iterator&lt;String&gt; iterator = map.keySet().iterator();</span><br><span class="line">    <span class="keyword">if</span> (iterator.hasNext())&#123;</span><br><span class="line">        String key = iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key==<span class="string">&quot;2&quot;</span>)&#123;</span><br><span class="line">            iterator.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    Object k = current.key;</span><br><span class="line">    current = <span class="keyword">null</span>;</span><br><span class="line">    HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</span><br><span class="line">    expectedModCount = modCount;<span class="comment">//每次回重新赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h2><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ol><li>new HashMap():底层没创建一个长度为16的数组</li><li>jdk 8底层的数组是：Node[],而非Entry[]</li><li>首次调用put()方法时，底层创建长度为16的数组</li><li>jdk7底层结构只：数组+链表。jdk8中底层结构：数组+链表+红黑树。<br>4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）<br>4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</li></ol><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>由于链表在很长的时候查询效率会变低。所以jdk8中采用了红黑树来代替链表过长的情况。</p><p>定义</p><ol><li>每个节点都是红色，或黑色</li><li>根节点是黑色</li><li>每个叶子节点是黑色</li><li>如果一个节点是红色，它儿子节点都是黑色</li><li>对每个节点，从该节点到子孙节点的所有路径上包含相同数目的黑节点</li></ol><p>新节点为红色，在插入的过程中节点会进行变色。</p><p>插入新节点：</p><p>根节点之间插入</p><p>父节点是黑色不需要调整</p><p>父节点是红色</p><p>​        1叔叔是空的或者为黑色，插入节点为左 ，旋转+变色。</p><p>​                1.1插入左子树</p><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/Blog\source\_posts\HashMap\插入情况1_1.png" alt="img" style="zoom:67%;"><p>​                1.2插入右子树</p><img src="HashMap//插入情况1_2.png" alt="img" style="zoom: 67%;"><p>​        2.叔叔是红色，父节点+叔叔节点变黑色，祖父节点变为红色。</p><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/Blog\source\_posts\HashMap\插入情况2.png" alt="img" style="zoom:67%;"><p>​        3.叔叔是空的或者为黑色，插入节点为右，旋转+变色。与情况1类似</p><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/插入情况3_1.png" alt="img" style="zoom:67%;"><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/插入情况3_2.png" alt="img" style="zoom:67%;"><h4 id="hashmap中的实现"><a href="#hashmap中的实现" class="headerlink" title="hashmap中的实现"></a>hashmap中的实现</h4><p>红黑树节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion 双向链表</span></span><br><span class="line">    <span class="keyword">boolean</span> red; <span class="comment">//颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>红黑树插入</p><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/红黑树示意图.png" alt="image-20200810145906002" style="zoom: 67%;"><p><strong>这个算法的左右旋对应的节点不相同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根节点、要插入的数</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.red = <span class="keyword">true</span>;  <span class="comment">//插入节点默认为红色</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    xp:插入节点的父节点</span></span><br><span class="line"><span class="comment">    xpp:祖父节点</span></span><br><span class="line"><span class="comment">    xppl:xpp的左孩子节点，xppr表示右孩子节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="comment">//查看新节点的父节点是否为null,是不是第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//父节点是黑色 或者 他的父节点就是根节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">       <span class="comment">//插入节点的父节点等于 祖父节点的左节点</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="comment">//xpp的右节点不为null,并且为红色，这里针对第1个情况</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                <span class="comment">//父节点和叔叔节点变黑，祖父节点变红</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//然后将祖父节点变成要插入的节点，循环调整整颗子树</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有叔叔节点 或者 叔叔节点是黑色 1情况</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//情况1</span></span><br><span class="line">                <span class="comment">//如果这个节点是 父节点的右孩子</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    <span class="comment">//左旋，对xp进行左旋</span></span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    <span class="comment">//对节点重新赋值，变成下面的那种情况</span></span><br><span class="line">                    <span class="comment">//相当于xp当成插入节点x,x当成xp，看图</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//右旋</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//父节点先变色</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//祖父节点不为空史，对xpp进行右旋</span></span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入节点的父节点等于 祖父节点的右节点，情况3，与上面类似</span></span><br><span class="line">        <span class="comment">//左右旋传入的节点不同</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//xpp的左节点不为null,并且为红色，这里针对第1个情况</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p><strong>左旋时p必须存在右孩子节点</strong></p><p>在r存在左孩子节点时（这里所有的root都是pp）</p><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/左旋.png" alt="image-20200810161759635" style="zoom:67%;"><p><strong>当旋转节点的父节点为空时，r直接为根节点，进行旋转 情况1</strong></p><p><strong>旋转的节点是pp的左节点（rl节点和rr节点可以为null）情况2</strong></p><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/左旋2.png" alt="image-20200810164354975" style="zoom: 67%;"><p><strong>旋转的节点是pp的右节点（rl节点和rr节点可以为null）情况3</strong></p><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/左旋3.png" alt="image-20200810164605813" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法是把p这个节点左转 ，传入节点为插入节点的父节点</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="comment">//需要选择的节点不为null 并且右孩子节点不为空，左旋右孩子节点不能是空</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//在r.left存在的情况下  给p.right重新赋值</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;<span class="comment">//关系rl的父节点</span></span><br><span class="line">        <span class="comment">//在p的父节点为null时，直接旋转，相当于p就是根节点。</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//p有父节点，并且p是pp的左节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p>与左旋相同 ，右旋也是三种情况</p><p><strong>当旋转节点的父节点为空时，r直接为根节点，进行旋转 情况1</strong></p><p><strong>旋转的节点是pp的右节点（ll节点和lr节点可以为null）情况2</strong></p><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/右旋2.png" alt="image-20200810170657482" style="zoom:67%;"><p><strong>旋转的节点是pp的左节点（ll节点和lr节点可以为null）情况3</strong></p><img src="/2020/08/10/java%E5%9F%BA%E7%A1%80/HashMap/右旋3.png" alt="image-20200810170830334" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk1.8底层采用红黑树，所以对数据散列性的需求并没有jdk1.7那么高，所以对hash函数进行了简化，但在数据的散列性上可能不如jdk1.7。</p><p>相比于jdk1.8 的 hash 方法 ，jdk1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><h3 id="存储结构-1"><a href="#存储结构-1" class="headerlink" title="存储结构"></a>存储结构</h3><p>内部包含了一个 实现Entry 的Node类型的数组 table。Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h3><p>空参构造器</p><p>这里与jdk不同，没有创建一个默认大小的，而是创造了一个空的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//根据传入的数算出一个阈值</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面这个操作与jdk7中求容量类似，通过移位或运算</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//evict在LinkHashMap中才有用</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//jdk8在插入时才对table初始化，如果为空表示第一次使用</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;<span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">//这个数组的位置没有放过</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//这个数组的位置已经存在，有3中情况 1.第一个一个元素 2.链表 3.红黑树</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//查看第一个节点的key是不是和要赋值的key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//查看不是吧一个红黑树节点</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//链表</span></span><br><span class="line">            <span class="comment">//binCount阈值，是不是大于8,大于8转换成红黑树</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//没有这个节点，就创建一个新的节点插入链表尾部,尾插法</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//是否要转红黑树，这里与是否加入新节点没有关系，只是遍历到8个节点就改变长度</span></span><br><span class="line">                    <span class="comment">//所以在转红黑树的时候链表上已经有9个节点了</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">//找到一个相等的key，直接跳出</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果e已经存在</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改值+1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//ListedHashMap才有用</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">put流程：</span><br><span class="line">1.检查数组是否为null,初始化数组</span><br><span class="line">2.判断这个要插入的地方有没有值</span><br><span class="line">2.1没有节点，直接插入</span><br><span class="line">2.2有值，判断这个节点存在的可能性</span><br><span class="line">2.2.1这个节点的key等于了要插入的，break</span><br><span class="line">2.2.2如果这个节点是一颗树 ，插入一颗树的节点</span><br><span class="line">2.2.3这里是一个链表,遍历链表，不存在key相同的节点就尾插法插入节点，并且判断链表的长度是否为8</span><br><span class="line">大于等于8个元素，就对链表转换成红黑树。这里的长度与要插入的节点无关，只要到了8个就转。</span><br><span class="line">然后判断是否存在一样key的节点是否存在，存在就替换，并返回旧值</span><br><span class="line">3.判断是否需要扩容</span><br></pre></td></tr></table></figure><h4 id="转换红黑树"><a href="#转换红黑树" class="headerlink" title="转换红黑树"></a>转换红黑树</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//数组是否为null，或数组的长度是否为64 对对数组进行扩容 ,对数组进行扩容会间接的减少链表上的值</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//遍历链表的每一个元素，把节点编程TreeNode，并生成双向链表。</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)<span class="comment">//第一个节点不为null</span></span><br><span class="line">            hd.treeify(tab);<span class="comment">//把第一个节点传入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真正转换的方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//遍历链表，把每一个元素插入到红黑树中</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;<span class="comment">//记录next</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">//第一个节点是黑色</span></span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;  <span class="comment">//x表示要插入的节点</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>; <span class="comment">//key的类型</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="comment">//比较hash值，判断是左右子树</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)  <span class="comment">//左边</span></span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)  <span class="comment">//右边</span></span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//这里是在hash值相同的时候判断key的大小，判断有没有实现类的比较器</span></span><br><span class="line">                <span class="comment">//实现了就去调用这个比较的方法区比较对象的大小</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          <span class="comment">//返回key是否实现了Comparable接口</span></span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//如果方向的节点为null,就把节点放入</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//插入节点的过程，包括平衡。这个在上面有写。</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把红黑树传入tab</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比较的方法：</span><br><span class="line">hash值</span><br><span class="line">compareto()方法</span><br><span class="line">getClass().getName()类名</span><br><span class="line">System.identityHashCode()获得没有被重写的hashcode值</span><br></pre></td></tr></table></figure><p>转换红黑树之后的pre、next节点的值并没有发生变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为在转换红黑树时，第一个节点不一定是根节点，所以需要把根节点放到第一个节点</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;  <span class="comment">//根节点不等于第一个节点，这里把根节点放入双向链表的第一个位置</span></span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            tab[index] = root;</span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个地方是用于验证，需要控制台打开。</span></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也就是为什么这个链表采用双向链表的原因。</p><h3 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h3><p>这里包括对数组的扩容和初始化、</p><p><strong>扩容是一个特别耗性能的操作，所以当程序员在使用 HashMap，正确估算 map 的大小，初始化的时候给一个大致的数值，避免 map 进行频繁的扩容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//数组是否为0</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断旧数组是否大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//翻倍扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//？</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化容量时有阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//使用默认</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">//新数组为0</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">//这里是初始化和扩容</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//旧数组不为null,，扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;<span class="comment">//遍历数组的每个元素</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;  <span class="comment">//数组不为空</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)  <span class="comment">//当前这个位置只要一个元素，直接放入旧的数组</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">//红黑树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order   //链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">//低头结点，低尾结点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">//高头结点，高尾结点</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;<span class="comment">//遍历链表</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                         <span class="comment">//扩容的地方只有2个要么是原位置，要么是原位置+原数组长度</span></span><br><span class="line">                        <span class="comment">//这里把原链表分成2个链表，在进行转移</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;<span class="comment">//只于oldCap那一位有关，这里与7的代码类似</span></span><br><span class="line">                           <span class="comment">//低的</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)<span class="comment">//这个链表没有值，就放入第一个</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123; <span class="comment">//类似</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//把两个链表放入新的数组</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">流程：</span><br><span class="line">1.进行扩容或初始化的准备工作</span><br><span class="line">2.初始化数组，或扩容数组</span><br><span class="line">3.判断旧的数组是否为null，不为null就是扩容</span><br><span class="line">3.1只有一个元素，直接赋值</span><br><span class="line">3.2红黑树，进行红黑树的扩容方法</span><br><span class="line">3.3链表，遍历生成2个链表，在放入新的数组中</span><br></pre></td></tr></table></figure><h4 id="红黑树的扩容"><a href="#红黑树的扩容" class="headerlink" title="红黑树的扩容"></a>红黑树的扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//看红黑树的节点能否变成2个链表</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    <span class="comment">//与链表类似</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;  </span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>; <span class="comment">//统计两个链表的个数</span></span><br><span class="line">    <span class="comment">//这里节点去遍历链表，与前面类似</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果链表的个数小于6，就把链表转换成红黑树</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            <span class="comment">//把树节点变成链表节点</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//还是一个红黑树</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="comment">//这里如果高位的链表是null，就说明只有一颗树，低位链表就是全部的节点，不需要重新生成红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified) </span></span><br><span class="line">                loHead.treeify(tab); <span class="comment">//这个方法与put时的方法相同，是转换成红黑树的方法。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历链表，把treenode变成node 返回一个单向链表</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>移除的原理也是相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">//找到要移除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//树节点</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//链表节点</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行移除</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) <span class="comment">//这里比较关键</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在移除树节点的时候，需要判断这个树上的元素是不是小于等于6个，但是代码中并没有出现6个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是判断转为链表的代码,这里说明了这棵树最多有6个</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">    || (movable</span><br><span class="line">        &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">            || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">            || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">    tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>JDK7:数组+链表</p><p>JDK8：数组+链表+红黑树（在链表时期使用了单向链表，在红黑树，为了方便找到头结点，使用了双向链表,双向链表主要方便操作，在、插入，扩容、红黑树转链表，链表转红黑树的过程中都有操作链表）</p><h3 id="为什么使用红黑树"><a href="#为什么使用红黑树" class="headerlink" title="为什么使用红黑树"></a>为什么使用红黑树</h3><p>在元素大于一个阈值时，元素的查询效率要低于红黑树，此阈值在JDK8中为8</p><h3 id="什么时候转换成红黑树"><a href="#什么时候转换成红黑树" class="headerlink" title="什么时候转换成红黑树"></a>什么时候转换成红黑树</h3><p>当链表中元素的个数大于8之后，会判断一下当前的长度，如果数组小于64，就不会转换成红黑树，而是进行扩容到64，只有当前链表个数为8，并且数组元素大于等于64时才会将链表转换红黑树。</p><h3 id="PUT操作流程"><a href="#PUT操作流程" class="headerlink" title="PUT操作流程"></a>PUT操作流程</h3><p>上面</p><h3 id="GET操作流程"><a href="#GET操作流程" class="headerlink" title="GET操作流程"></a>GET操作流程</h3><p>1.根据key生成hashcode<br>2.如果数组为空,则直接返回空<br>3.如果数组不为空，则利用hashcode和数组长度通过逻辑 与操作算出key所对应的数组下标i<br>4.如果数组的第i个位置上没有元素，则直接返回空<br>5.如果数组的第1个位上的元素的key等于get方法所传进来的key,则返回该元素，并获取该元素的value<br>6.如果不等于则判断该元素还有没有下一个元素，如果没有，返回空<br>7.如果有则判断该元素的类型是链表结点还是红黑树结点<br>        a.如果是链表则遍历链表<br>        b.如果是红黑树则遍历红黑树<br>8.找到即返回元素，没找到的则返回空</p><h3 id="JDK7和JD8中的HashMap不同"><a href="#JDK7和JD8中的HashMap不同" class="headerlink" title="JDK7和JD8中的HashMap不同"></a>JDK7和JD8中的HashMap不同</h3><ol><li>JDK8中使用了红黑树</li><li>JDK7中链表的插入使用的头插法(扩容转移元素的时候也是使用的头插法，头插法速度更快，无需遍历链表，<br>但是在多线程扩容的情况下使用头插法会出现循环链表的问题，导致CPU飙升)，JDK8中链表使用的尾插法<br>(JDK8中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法)</li><li>JDK7的Hash算法比JDK8中的更复杂，Hash算法越复杂，生成的hashcode则更散列，那么hashmap中的元<br>素则更散列，更散列则hashmap的查询性能更好，JDK7中没有红黑树,所以只能优化Hash算法使得元素更散<br>列，而JDK8中增加了红黑树，查询性能得到了保障，所以可以简化-下Hash算法， 毕竟Hash算法越复杂就越<br>消耗CPU</li><li>扩容的过程中JDK7中有可能会重新对key进行哈希(重新Hash跟哈希种子有关系)，而JDK8中没有这部分逻<br> 辑</li><li>JDK8中扩容的条件和JDK7中不一样，除开判断size是否大于阈值之外, JDK7中还判断了tab[i]是否为空，不<br> 为空的时候才会进行扩容，而JDK8中则没有该条件了</li><li>JDK8中还多了一个API: putIfAbsent(key,value)</li><li>JDK7和JDK8扩容过程中转移元素的逻辑不一样, JDK7是每次转移-个元素，JDK8是先算出来当前位置上哪<br> 些元素在新数组的低位上，哪些在新数组的高位上，然后在- -次性转移</li></ol><p>参考</p><p>红黑树<a href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合-ConcurrentHashMap</title>
      <link href="/2020/08/09/java%E5%9F%BA%E7%A1%80/ConcurrentHashMap/"/>
      <url>/2020/08/09/java%E5%9F%BA%E7%A1%80/ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="ConcurrentHashMap1-7"><a href="#ConcurrentHashMap1-7" class="headerlink" title="ConcurrentHashMap1.7"></a>ConcurrentHashMap1.7</h1><p>如果对于hashmap中添加元素，如果加锁，会导致如果2个元素放的不是同一个位置上也会进行阻塞。</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><img src="/2020/08/09/java%E5%9F%BA%E7%A1%80/ConcurrentHashMap/ConcurrentHashMap.png" alt="image-20200809114648367" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap </span><br><span class="line">Segment[] table;</span><br><span class="line">每一个中table包含多个个HashEntry[] tab  </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123; <span class="comment">//与hashmap相似</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。Segment 继承自 ReentrantLock。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>与HashMap同理，只是多了一个并发级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与hashmap参数相同，只是多了一些关于并发的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认容量大大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//并发级别,也就是说默认创建 16 个 Segment。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//每个块最小的值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RETRIES_BEFORE_LOCK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> <span class="keyword">int</span> hashSeed = randomHashSeed(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Shift value for indexing within segments.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The segments, each of which is a specialized hash table.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt; keySet;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//限制</span></span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;  <span class="comment">//segment数组大小</span></span><br><span class="line">    <span class="comment">//循环移位直到ssize大于concurrencyLevel 2的n次方</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;  <span class="comment">//这个是2的n次冥，就是左移次数</span></span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;<span class="comment">//长度</span></span><br><span class="line">    <span class="comment">//判断是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;  <span class="comment">//获得分块的数量</span></span><br><span class="line">    <span class="comment">//向上取整 除法没有小数位，假如 ssize为16，initialCapacity为17， c为1，需要对c进行+1</span></span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; <span class="comment">//获得分块最小值 为2</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)   <span class="comment">//如果c比最小的小，直接使用cap作为数组大小。这里和hashmap相同都是需要2的次方</span></span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// create segments and segments[0]</span></span><br><span class="line">    <span class="comment">//加载因子，阈值，数组， 每次扩容都只是扩Segment 2 -&gt; 4,并不是对最外面的进行扩容</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">     <span class="comment">//创建一个固定大小的Segment，不会发生改变</span></span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    <span class="comment">//放入 ，方便未来新插入数值时，这个segment为null,方便取到 加载因子和阈值，相当于原型模式</span></span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建的步骤：</span><br><span class="line">1.判断越界</span><br><span class="line">2.初始化ssize 这个值要比concurrencyLevel大 并且是2的幂次方</span><br><span class="line">3.计算每个Segment里面各自的容量：为传入容量/ssize ,并且判断是否这个值比最小的容量小，小就为最小容量。</span><br><span class="line">4.创建一个Segment，其中的hashEntry大小为刚刚计算的大小。</span><br><span class="line">5.创建Segment数组，这数组的长度为ssize，扩容时不改变。</span><br><span class="line">6.将刚创建的一个Segment放入,方便未来新插入数值时，这个segment为null,方便取到 加载因子和阈值，相当于原型模式</span><br></pre></td></tr></table></figure><h2 id="Segment对象-可重入"><a href="#Segment对象-可重入" class="headerlink" title="Segment对象  可重入"></a>Segment对象  可重入</h2><p>每个segment相当于hashmap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><h2 id="Put操作"><a href="#Put操作" class="headerlink" title="Put操作"></a>Put操作</h2><p>key不能为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个新的Segment</span></span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//计算hash,key不能为null</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//与hashmap类似，移位与操作获得位置，只去最高几位进行计算。</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">//这个segment第j个位置是否为null,不为null 这里使用了CAS</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">         <span class="comment">//这里就是去数组中第j个位置元素</span></span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">        <span class="comment">//这个位置为null,生成一个新的</span></span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="comment">//然后调用这Segment的put操作</span></span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里hash使用高位进行计算，在每一个Segment中我们使用低位。</p><h3 id="计算hash"><a href="#计算hash" class="headerlink" title="计算hash"></a>计算hash</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hashSeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != h) &amp;&amp; (k <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h ^= k.hashCode();<span class="comment">//key不能为null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spread bits to regularize both segment and index locations,</span></span><br><span class="line">    <span class="comment">// using variant of single-word Wang/Jenkins hash.</span></span><br><span class="line">    h += (h &lt;&lt;  <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">3</span>);</span><br><span class="line">    h ^= (h &gt;&gt;&gt;  <span class="number">6</span>);</span><br><span class="line">    h += (h &lt;&lt;   <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态方法块"><a href="#静态方法块" class="headerlink" title="静态方法块"></a>静态方法块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ss, ts;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class tc = HashEntry[].class;</span><br><span class="line">            Class sc = Segment[].class;</span><br><span class="line">            TBASE = UNSAFE.arrayBaseOffset(tc);</span><br><span class="line">            SBASE = UNSAFE.arrayBaseOffset(sc);</span><br><span class="line">            ts = UNSAFE.arrayIndexScale(tc);</span><br><span class="line">            ss = UNSAFE.arrayIndexScale(sc);</span><br><span class="line">            HASHSEED_OFFSET = UNSAFE.objectFieldOffset(</span><br><span class="line">                ConcurrentHashMap.class.getDeclaredField(<span class="string">&quot;hashSeed&quot;</span>));</span><br><span class="line">            SEGSHIFT_OFFSET = UNSAFE.objectFieldOffset(</span><br><span class="line">                ConcurrentHashMap.class.getDeclaredField(<span class="string">&quot;segmentShift&quot;</span>));</span><br><span class="line">            SEGMASK_OFFSET = UNSAFE.objectFieldOffset(</span><br><span class="line">                ConcurrentHashMap.class.getDeclaredField(<span class="string">&quot;segmentMask&quot;</span>));</span><br><span class="line">            SEGMENTS_OFFSET = UNSAFE.objectFieldOffset(</span><br><span class="line">                ConcurrentHashMap.class.getDeclaredField(<span class="string">&quot;segments&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ss &amp; (ss-<span class="number">1</span>)) != <span class="number">0</span> || (ts &amp; (ts-<span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">        SSHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(ss);</span><br><span class="line">        TSHIFT = <span class="number">31</span> - Integer.numberOfLeadingZeros(ts);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法会返回最高位的1前面的个数，例如</span></span><br><span class="line">Integer.numberOfLeadingZeros(<span class="number">1</span>); <span class="comment">//31 </span></span><br><span class="line"><span class="comment">//因为这个数组是2的幂次方</span></span><br></pre></td></tr></table></figure><h3 id="生成Segment"><a href="#生成Segment" class="headerlink" title="生成Segment"></a>生成Segment</h3><p>这里会出现并发冲突</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="comment">//取到这个key能放位置</span></span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    <span class="comment">//生成的对象</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="comment">//这里获得CAS，判断这里的值是否一样</span></span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//原型模式</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length; <span class="comment">//获得长度</span></span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor; <span class="comment">//加载因子</span></span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);<span class="comment">//阈值</span></span><br><span class="line">        <span class="comment">//创建</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="comment">//判断这个位置还不是吧空，双重检查</span></span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">            <span class="comment">//创建这个对象</span></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">//自旋锁，直到把这个值放到这个位置，这里与原子类相同，保证只有一个线程能对这个null赋值</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//获取到就对对象进行更新，如果为false说明有另外的线程对这个u位置进行了更新</span></span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里多次判断是为了提高效率</p><h3 id="Segment-put方法"><a href="#Segment-put方法" class="headerlink" title="Segment put方法"></a>Segment put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁，这里继承了可重入锁，</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">        scanAndLockForPut(key, hash, value);<span class="comment">//这个方法的目的也是获取锁</span></span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取table</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">//计算hash</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">//获取第一个值</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="comment">//这里和hashmap类似，判断key和hash是否相同，就是遍历，查看是否存在已有的值</span></span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;<span class="comment">//标记是否为true ，是就连值都不需要改变</span></span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//这个位置没有元素</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>) <span class="comment">//色哥结点在等待的时候已经创建好了，就直接插入</span></span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//创建一个新的值，使用头插法。</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;<span class="comment">//count表示这个Segment存了多少元素</span></span><br><span class="line">                <span class="comment">//达到阈值，进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//将新生成的节点设置到node</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount; <span class="comment">//fast-fail</span></span><br><span class="line">                count = c;  <span class="comment">//元素了加1</span></span><br><span class="line">                oldValue = <span class="keyword">null</span>; <span class="comment">//旧元素为空</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">基本流程：</span><br><span class="line">1.获取锁,非阻塞</span><br><span class="line">2.计算出要放的位置，获得这个位置的第一个元素</span><br><span class="line">3.循环判断这位置是否为null</span><br><span class="line">3.1不为null，循环判断是否已经存在key相同的值，存在退出返回旧值，直到为null,进入3.2</span><br><span class="line">3.2 null</span><br><span class="line"></span><br><span class="line">创建一个新的节点，存储个数+1，查看是否需要进行扩容。将元素放入，打破循环。</span><br></pre></td></tr></table></figure><p>获取这个方法也是获取内存的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">HashEntry&lt;K,V&gt; <span class="title">entryAt</span><span class="params">(HashEntry&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (tab == <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">        (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">        (tab, ((<span class="keyword">long</span>)i &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>放入操作也是用的UNSAFE类，保证修改的是内存中的值，而不是当前线程的值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setEntryAt</span><span class="params">(HashEntry&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   HashEntry&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    UNSAFE.putOrderedObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; TSHIFT) + TBASE, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是如果存在这个key就直接不放入,也是传入标记为true的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>加锁的机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tryLock() <span class="comment">//判断这把锁我能不能获取到,能就返回true，不能就返回false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个方法会消耗cpu资源</span></span><br><span class="line">    <span class="keyword">while</span>(!lock.trylock())&#123;</span><br><span class="line">        <span class="comment">//做其他事情</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//线程获得到了锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">lock() <span class="comment">//这把锁获取到时就会去加锁，获取不到就会阻塞</span></span><br><span class="line">    这个方法不怎么消耗</span><br></pre></td></tr></table></figure><p><strong>获取不到锁的时候就会执行这个方法，在获取锁的时候做其他事情 。</strong>这里做的事情就是创建一个HashEntry对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取hash值下标，不确定是否为null</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//循环次数，当到达一定次数时，直接调用lock()阻塞方法</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="comment">//每次循环会进一个分支,每次遍历都是会判断有没有获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123; <span class="comment">//遍历完</span></span><br><span class="line">                <span class="comment">//假如头结点改变，这个值也就不需要new了</span></span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有key相等的，就不用new，</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key)) </span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//下一个</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先加再比较，达到一定次数直接调用lock()，退出，这个值取cpu的核心数 </span></span><br><span class="line">        <span class="comment">// cpu核心&gt;1 取64 </span></span><br><span class="line">        <span class="comment">// =1 取1  </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在偶数次重试的中间，判断这个位置的值还是否是first，就是判断其他线程有没有放入这个位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            <span class="comment">//发生改变重新赋值，并重新遍历链表</span></span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>这里的扩容只是针对每一个Segment内部的数组进行扩容，而不是对最外面的数组进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>; <span class="comment">///扩容</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//算阈值</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];<span class="comment">//新数组</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;  <span class="comment">//放去余</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123; <span class="comment">//遍历原数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;  <span class="comment">//新数组的下标</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">//这里是把后面所有放入同一个节点的数找出</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;  <span class="comment">//从下一个节点开始遍历</span></span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask; <span class="comment">//计算这个节点的下标</span></span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123; <span class="comment">//查看这个下标是否相同</span></span><br><span class="line">                        lastIdx = k;      <span class="comment">//不相同就重新赋值</span></span><br><span class="line">                        lastRun = last;   <span class="comment">//把这个节点也记录 </span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//优化了最后几个节点的插入</span></span><br><span class="line">                <span class="comment">//这个节点之后的数全部放入同一个位置</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="comment">//从头节点开始</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">官方解释</span><br><span class="line">    将每个列表中的节点重新分类为新表。因为我们使用的是<span class="number">2</span>的幂展开，所以每个bin中的元素必须要么保持在相同的索引上，要么以两个幂的偏移量移动。我们通过捕捉由于下一个字段不更改而可以重用旧节点的情况来消除不必要的节点。统计上，在默认阈值下，当表翻倍时，只有大约六分之一需要克隆。它们替换的节点一旦不再被并发遍历表中的任何读线程引用，就会变成垃圾可选的节点。入口访问使用明文数组索引，因为它们后面跟着可挥发的写操作。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我的理解：</span><br><span class="line">1.传入一个新的node节点</span><br><span class="line">2.根据旧表的长度，扩容2倍，生成一个新的表</span><br><span class="line">3.遍历旧的数组，看这个节点是否位null,不为null,就遍历这个链表</span><br><span class="line">4.当遍历到链表最后几个节点要插入的位置相同时，进行记录。</span><br><span class="line">5.将刚才遍历得到的最后几个直接插入到表中，再遍历链表，循环插入。</span><br><span class="line">6.在将这个节点插入表中</span><br></pre></td></tr></table></figure><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p><p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p><p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p><p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">    <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//对每一个Segment加锁，第一次循环不会进入</span></span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//统计每一个Segment的长度，size表示这一次循环内的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ConcurrentHashMap1-8"><a href="#ConcurrentHashMap1-8" class="headerlink" title="ConcurrentHashMap1.8"></a>ConcurrentHashMap1.8</h1><h2 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h2><ol><li><p>没有1.7中的Segment数组，也就是没有分段锁了，使用synchronize来控制</p></li><li><p>JDK8中的扩容性能更高，支持多线程扩容，JDK7中也支持，因为7中是扩容单个Segment，但是性能没有JDK8的高，因为在JDK8中任意线程都可以帮助扩容</p></li><li><p>JDK8中元素个数的统计也不一样了，JDK8中增加了CounterCell来帮助计数，</p></li></ol><p>这里使用treeBin存储红黑树</p><p>扩容 1.7对应的是每个Segment对象进行扩容</p><h2 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    volatile TreeNode&lt;K,V&gt; first;</span><br><span class="line">    volatile Thread waiter;</span><br><span class="line">    volatile int lockState;</span><br><span class="line">    // values for lockState</span><br><span class="line">    static final int WRITER = 1; // set while holding write lock</span><br><span class="line">    static final int WAITER = 2; // set when waiting for write lock</span><br><span class="line">    static final int READER = 4; // increment value for setting read lock</span><br></pre></td></tr></table></figure><p>TreeBin是记录红黑树的类，不在像hashmap中一样只使用节点，因为在多线程进行操作的时候，红黑树的根节点会发生变化，这里就需要这个类来记录这颗红黑树的属性。这里是对这个表节点对象进行加锁，如果这个对象已经不存在了，其他线程就可以得到这个位置的锁。而利用这个类就可以得到这个节点所有的信息，其他线程是无法获取到的。</p><h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><p>参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示正在转移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示已经转换成树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="comment">//默认没初始化的数组，用来保存元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="comment">//转移的时候用的数组</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来控制表初始化和扩容的，默认值为0，当在初始化的时候指定了大小，这会将这个大小保存在sizeCtl中，大小为数组的0.75</span></span><br><span class="line"><span class="comment">     * 当为负的时候，说明表正在初始化或扩张，</span></span><br><span class="line"><span class="comment">     *     -1表示初始化</span></span><br><span class="line"><span class="comment">     *     -(1+n) n:表示活动的扩张线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure><p>无参构造方法，这里与1.7不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class="comment">//这里每次获取新的数组，万一有的线程完成了转移</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//这里用到UnSafe操作，直接从内存中获取值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过CAS的方式从内存中设置值，如果失败，就继续循环判断值是否已经改变</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这f已经有值了 node对象，有线程对这个tab对这个表进行扩容，帮助他进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; <span class="comment">//这里对node节点加锁，这里没有在用分段锁</span></span><br><span class="line">                <span class="comment">//判断f有没有被其他线程修改，还是不是头节点</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">//链表上面的一个节点</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//这里就是循环链表，看有没有相同key的，并且统计链表个数</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                           <span class="comment">//尾插法</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//树上面的一个节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">//把这就节点放入红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果这个链表大于这个阈值，就把它转化成红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对size加1</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化表"><a href="#初始化表" class="headerlink" title="初始化表"></a>初始化表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//这里使用CAS堆sc进行修改，为-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);<span class="comment">//这里是取0.75</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl; </span><br><span class="line"><span class="keyword">volatile</span>保证内存的可见性，保证得到的值是最新的</span><br><span class="line">开始sizeCtl = <span class="number">0</span> ，对数组初始化时sizeCtl变成-<span class="number">1</span> ，最后sizeCtl =  阈值</span><br><span class="line">    在sizeCtl是-<span class="number">1</span>时，一个线程对其进行扩容</span><br><span class="line">    另一个线程 Thread.yield()，让出cpu资源，在进行竞争，避免线程一直<span class="keyword">while</span></span><br></pre></td></tr></table></figure><p>这3个操作是利用CAS的方式保证数据的一致行性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树化"><a href="#红黑树化" class="headerlink" title="红黑树化"></a>红黑树化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="comment">//判断最小转成红黑树的值 默认64</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//如果b的值不为null,并且hash大于0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123; <span class="comment">//对数组这个位置加锁</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//修改成双向链表</span></span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        <span class="comment">//创建树节点</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//把这颗红黑树设置到这个数组index的位置，这个TreeBin就是红黑树的创建过程</span></span><br><span class="line">                    <span class="comment">//这里红黑树的创建过程</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd))    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元素个数加减"><a href="#元素个数加减" class="headerlink" title="元素个数加减"></a>元素个数加减</h3><p>先看看这个如何获取到这个map中总的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计每一个cell的值，最终返回</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="元素个数加和扩容"><a href="#元素个数加和扩容" class="headerlink" title="元素个数加和扩容"></a>元素个数加和扩容</h4><p>当多个线程竞争baseCount，并发冲突大，这里缓解了压力。使用了数组分块加，并且判断要不要进行扩容。</p><p>扩容：这里是根据步长进行元素转移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x：加的个数</span></span><br><span class="line"><span class="comment">//check:是否需要扩容 在remove的情况下就为-1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//如果这个数组是空的直接进入 或 数组不为null再利用CAS修改baseCount 为b + x的长度失败，会进入</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//如果这个数组为空，或长度小于0</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">//每个线程生成随机数&amp;数组的长度 生成在数组的位置，如果这个位置不是空的进入下一个判断</span></span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">//用CAS操作数组中的数字进行加x ，如果失败，就进入方法体</span></span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            <span class="comment">//cell数组的初始化，或者直接+1  //uncontended用于判断CAS有没有失败</span></span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//计算总的值</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是扩容</span></span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">//判断当前的个数是不是大于这个阈值 &amp;&amp; 数组是不是不为null &amp;&amp; 数组的容量小于最大值</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;  <span class="comment">//小于0说明已经在扩容</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一个线程获得了，成功的扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这里用到了LongAdder中的思路</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;<span class="comment">//个数</span></span><br><span class="line"></span><br><span class="line">CounterCell计数格子</span><br><span class="line">    每个线程算出一个随机值&amp; cell的长度 算出在在cell的位置，如何对这个位置的数进行加</span><br></pre></td></tr></table></figure><h4 id="添加计数"><a href="#添加计数" class="headerlink" title="添加计数"></a>添加计数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要加减的数量，   有没有CAS失败</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//拿到线程hash值</span></span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="comment">//判断数组是否为null</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//不为null,判断 这个位置是不是null</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//是null,如果这个数组不忙</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create创建一个</span></span><br><span class="line">                    <span class="comment">//如果这个数组还不忙，就用CAS的方式设置为忙</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;<span class="comment">//标准位</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="comment">//在加完锁的情况下再检查一遍</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;<span class="comment">//放入</span></span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果进方法之前CAS过冲突，重新计算hash,重新走一遍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">//没有发生CAS冲突 ,对这个cell进行+1，如果修改成功，就跳出循环，结束</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果这个线程判断这里的cell已经被修改就把collide置位false重新循环，并且现在数组的大小</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="comment">//目的未来重新hash,如何重新尝试能否CAS成功</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果重新hash还是失败 ，在此判断这个数组是不是忙，不忙就进行修改成忙</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//达到这里说明这个数组的长度不足以对抗这个并发度，就对这个数组进行扩容，每次扩容1倍</span></span><br><span class="line">                <span class="comment">//然后转移原数组</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//生成一个新的hash值</span></span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个数组为null 判断这个数组是不是忙 ，然后CAS设置这个数组为忙</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123; <span class="comment">//如果这个数组还是没有改变，创建大小为2的数组进行复制</span></span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;<span class="comment">//忙</span></span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)<span class="comment">//初始化完成直接退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个数组在忙，就一直对着basecount进行改变，看能不能成功</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">这段代码的说明：</span><br><span class="line">操作数组必须判断这个数组是否是忙碌状态</span><br><span class="line">1.拿到这个线程的hash值  collide=false</span><br><span class="line">2.循环</span><br><span class="line">判断这个数组是否为null</span><br><span class="line">        不为null 判断这个要加的数组位置有没有发出冲突</span><br><span class="line">        没有发生冲突，就判断数组是否有别的线程进行加，没有就把这个数组设置为忙碌，进行修改，跳出循环</span><br><span class="line">        位置发生冲突，</span><br><span class="line">        判断wasUncontended是不是false CAS有没有冲突，如果有，重新走一次循环把标准,并且置为true</span><br><span class="line">        CAS尝试修改这个cell成功就跳出，不成功，就继续走一次循环</span><br><span class="line">        </span><br><span class="line">        到这里如果这个线程判断这里的cell已经被扩容就把collide置位false重新循环，或者数组已经到达最大值， 不会进行扩容</span><br><span class="line">        </span><br><span class="line">                上面的操作都不成功，判断collide是否为false ,修改collide为true在去循环</span><br><span class="line">                如果重新hash都失败的情况下 判断数组是否是忙碌状态，不是就对数组进行扩容，并把collide置位false再次进行循环。</span><br><span class="line">                </span><br><span class="line">            这个操作每次都会改变hash值</span><br><span class="line">        </span><br><span class="line">        null 判断这个数组是否在忙碌状态，也就是有没有其他线程在创建这个数组，</span><br><span class="line">        不忙碌，就用CAS加锁创建数组，把要改的值放入</span><br><span class="line">        忙碌，尝试一次CAS修改baseCount，修改成功退出循环，不成功，继续循环</span><br><span class="line"></span><br><span class="line">3.</span><br></pre></td></tr></table></figure><h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><p>帮助扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;<span class="comment">//sc+1表示+1个线程进行库容</span></span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">//每个线程转移的步长最小的是16</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating创建新数组</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>]; <span class="comment">//创建</span></span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n; <span class="comment">//默认等于数组大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//创建一个对象，用于转移完后放置在旧数组的位置</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>; <span class="comment">//线程转移完步长，是否需要转移其他的</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab 当前线程的扩容是否完成</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123; <span class="comment">//i和bound表示转移的长度</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123; <span class="comment">//控制区域</span></span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)<span class="comment">//判断是否换在转移过程 --i表示下一个数组位置 或 是否完成</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123; <span class="comment">//每次循环重新取值</span></span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断步长和数组大小谁大，将2个的差值赋给nextbound，然后修改内存中的transferIndex为nextbound，这里有2个用处，一是帮一个线程找到转移元素位置，如果这个线程已经完成，再继续从这里取一段进行扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">//相当于 数组长64 nextbound = 48 i = 63 找出线程要扩容的数组，退出循环</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里判断现在要转移的元素已经全部转移完成</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;<span class="comment">//这里在所有工作都完成的情况下，由最后一个线程进行把新数组赋值</span></span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里是帮助线程，别的线程帮助完成 每多一个线程 sc+1</span></span><br><span class="line">            <span class="comment">//这里减少</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//这里如果sc不是初始值的话，说明这个线程不是最后一个转移的线程</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) </span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>; <span class="comment">//所有的线程都扩容完毕，就赋值为true</span></span><br><span class="line">                i = n; <span class="comment">// recheck before commit 从新检查</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果数组这个位置为null ,直接在这个位置放一个fwd</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) <span class="comment">//如果这个位置已经是fwd节点，就跳出这个循环</span></span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果这里有节点加锁转移</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123; <span class="comment">//对这个位置加锁，不能put</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;<span class="comment">//是一个链表</span></span><br><span class="line">                        <span class="comment">//这里与1.7concurremt的相似，就是找出链表最后面放入同一个位置的链表</span></span><br><span class="line">                        <span class="comment">//也与1.8的hashmap类似</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//把最后的链表放入一个位置</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//然后形成高位和低位的链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//把链表放入，设置fwd</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//红黑树，与1.8的红黑树转移相同</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">//找到这2条链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//判断红黑树需不需要改成链表，不需要的情况下判断另一个链表是不是为空，如果为空，表示树没有发生改变，否则从新生成红黑树。</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">判断新数组是不是null,是就创建一个新的数组</span><br><span class="line">循环</span><br><span class="line">while advance有没有找到自己要转移的位置,这里找位置是从右向左进行</span><br><span class="line">        判断i--是不是还在线程要转移的里面 或者以及完成转移，就跳出这个循环</span><br><span class="line">        取到transferIndex，还没有转移的数组位置，如果已经没有，就跳出循环</span><br><span class="line">        每个线程用CAS找到自己的i和bound 自己要转移数组的位置，或者以及完成自己线程步长的转移，再找到下一个元素的转移位置</span><br><span class="line">     </span><br><span class="line">    这里判断现在要转移的元素已经全部转移完成，所有线程退出，直到最后一个线程的工作是把新数组赋值给旧数组。</span><br><span class="line">        </span><br><span class="line">    根据找到位置判断这里是不是null，是就置为fwd</span><br><span class="line">    如果这里是fwd，就进行下次循环</span><br><span class="line">    如果这里不为null,就说明有元素，判断类型</span><br><span class="line">    链表的转移方式 找尾链，如何分高低链进行转移 与1.7的concurrent和1.8的hashmap类似</span><br><span class="line">    红黑树的转移方式 与1.8的hashmap类似 </span><br></pre></td></tr></table></figure><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><h2 id="JDK7中的ConcurrentHashMap是怎么保证并发安全的"><a href="#JDK7中的ConcurrentHashMap是怎么保证并发安全的" class="headerlink" title="JDK7中的ConcurrentHashMap是怎么保证并发安全的?"></a>JDK7中的ConcurrentHashMap是怎么保证并发安全的?</h2><p>主要利用Unsafe操作+ ReentrantLock+分段思想。<br>主要使用了Unsafe操作中的:</p><ol><li><p>compareAndSwapObject:通过cas的方式修改对象的属性</p></li><li><p>putOrderedObject:并发安全的给数组的某个位置赋值</p></li><li><p>getObjectVolatile: 并发安全的获取数组某个位置的元素</p></li></ol><p>分段思想是为了提高ConcurrentHashMap的并发量，分段数越高则支持的最大并发量越高，程序员可以通过concurrencyLevel参数来指定并发量。ConcurrentHashMap的内部类 Segment就是用来表示某- -个段的。</p><p>每个Segment就是一个小型的HashMap的，当调用ConcurrentHashMap的put方法是，最终会调用到Segment的put方法，而Segment类 继承了ReentrantLock,所以Segment自带可重入锁，当调用到Segment的put方法时，会先利用可重入锁加锁，加锁成功后再将待插入的key,value插入到小型HashMap中，插入完成后解锁。</p><h2 id="JDK8中的ConcurrentHashMap是怎么保证并发安全的"><a href="#JDK8中的ConcurrentHashMap是怎么保证并发安全的" class="headerlink" title="JDK8中的ConcurrentHashMap是怎么保证并发安全的?"></a>JDK8中的ConcurrentHashMap是怎么保证并发安全的?</h2><p>主要利用Unsafe操作+synchronized关键字。</p><ul><li>Unsafe操作的使用仍然和JDK7中的类似，主要负责并发安全的修改对象的属性或数组某个位置的值。</li><li>synchronized主要负责在需要操作某个位置时进行加锁(该位置不为空)，比如向某个位置的链表进行插入结点，向某个位置的红黑树插入结点。</li></ul><p>JDK8中其实仍然有分段锁的思想，只不过JDK7中段数是可以控制的，而JDK8中是数组的每一个位置 都有一把锁。</p><p>当向ConcurrentHashMap中put-个key,value时 ，</p><ol><li><p>首先根据key计算对应的数组下标i,如果该位置没有元素，则通过自旋的方法去向该位置赋值。</p></li><li><p>如果该位置有元素，则sInchronized会 加锁</p></li><li><p>加锁成功之后，在判断该元素的类型</p><pre><code>a.如果是链表节点则进行添加节点到链表中b.如果是红黑树则添加节点到红黑树</code></pre></li><li><p>.添加成功后，判断是否需要进行树化</p></li><li><p>addCount,这个方法的意思是ConcurrentHashMap的元素个数加1，但是这个操作也是需要并发安全的，并且元素个数加1成功后，会继续判断是否要进行扩容，如果需要，则会进行扩容,所以这个方法很重要。</p></li><li><p>同时一个线程在put时如果发现当前ConcurrentHashMap正在进行扩容则会去帮助扩容。</p></li></ol><h2 id="JDK7和JDK8中的ConcurrentHashMap的不同点"><a href="#JDK7和JDK8中的ConcurrentHashMap的不同点" class="headerlink" title="JDK7和JDK8中的ConcurrentHashMap的不同点"></a>JDK7和JDK8中的ConcurrentHashMap的不同点</h2><p>这两个的不同点太多了…既包括了HashMap中的不同点，也有其他不同点，比如:</p><ol><li>JDK8中没有分段锁了，而是使用synchronized来 进行控制</li><li>JDK8中的扩容性能更高，支持多线程同时扩容，实际上JDK7中也支持多线程扩容，因为JDK7中的扩 容是针对每个Segment的，所以也可能多线程扩容，但是性能没有JDK8高，因为JDK8中对于任意-个线程都可以去帮助扩容</li><li>JDK8中的元素个数统计的实现也不一样了，JDK8中增加了CounterCell来帮助计数，而JDK7中没有， JDK7中是put的时候每个Segment内部计数，统计的时候是遍历每个Segment对象加锁统计(当然有-点点小小的优化措施，看视频吧..。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora美化</title>
      <link href="/2020/08/08/%E6%8F%92%E4%BB%B6/typora%E7%BE%8E%E5%8C%96/"/>
      <url>/2020/08/08/%E6%8F%92%E4%BB%B6/typora%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="幕布-typora自动生成思维导图"><a href="#幕布-typora自动生成思维导图" class="headerlink" title="幕布+typora自动生成思维导图"></a>幕布+typora自动生成思维导图</h2><p>哔哩哔哩的指导视频</p><p><a href="https://www.bilibili.com/video/av969076674">https://www.bilibili.com/video/av969076674</a></p><p>pandoc下载</p><p><a href="https://pandoc.org/installing.html">https://pandoc.org/installing.html</a></p><p><a href="https://blog.csdn.net/qq_43741748/article/details/105454719">https://blog.csdn.net/qq_43741748/article/details/105454719</a></p><p>幕布</p><p><a href="https://mubu.com/apps">https://mubu.com/apps</a></p>]]></content>
      
      
      <categories>
          
          <category> 插件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java集合-Collection和Map</title>
      <link href="/2020/08/05/java%E5%9F%BA%E7%A1%80/Collection%E5%92%8CMap/"/>
      <url>/2020/08/05/java%E5%9F%BA%E7%A1%80/Collection%E5%92%8CMap/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="数组的弊端"><a href="#数组的弊端" class="headerlink" title="数组的弊端"></a>数组的弊端</h2><ul><li><blockquote><p>一旦初始化以后，其长度就不可修改。</p></blockquote></li><li><blockquote><p>数组中提供的方法非常限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</p></blockquote></li><li><blockquote><p>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</p></blockquote></li><li><blockquote><p>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</p></blockquote></li></ul><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表</p><p>Collection接口：单列数据，定义了存取一组对象的方法的集合</p><ul><li><p>List：元素有序、可重复的集合 </p></li><li><p>Set：元素无序、不可重复的集合</p></li></ul><p>Map接口：双列数据，保存具有映射关系“key-value对”的集合</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><img src="/2020/08/05/java%E5%9F%BA%E7%A1%80/Collection%E5%92%8CMap/Collection.png" alt="image-20200805211029113" style="zoom:67%;"><p>Collection:单列集合</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(Object obj),addAll(Collection coll),size(),isEmpty(),clear();</span><br><span class="line">contains(Object obj),containsAll(Collection coll),remove(Object obj),removeAll(Collection coll),retainsAll(Collection coll),equals(Object obj);</span><br><span class="line">hasCode(),toArray(),iterator();</span><br></pre></td></tr></table></figure><p>使用Collection集合存储对象，要求对象所属的类满足：<br>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().</p><p>集合复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h3><p>Set接口：</p><p>无序: <strong>不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。</strong></p><p>不可重复：保证添加的元素照equals()判断时，不能返回true.同时他们的hashCode方法返回的值不能相等 。即：相同的元素只能添加一个。必须重写这2个方法。</p><ul><li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，<strong>HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</strong></li><li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。<strong>可以存null</strong></li><li>LinkedHashSet：HashSet子类，具有 HashSet 的查找效率，<strong>并且内部使用双向链表维护元素的插入顺序</strong>。LinkedHashSet插入性能略低于 HashSet</li></ul><h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><p>List:无序的、可重复的数据。</p><ul><li>ArrayList：基于动态数组实现，支持随机访问。</li><li>Vector：和 ArrayList 类似，但它是线程安全的。</li><li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul><h3 id="3-Queue"><a href="#3-Queue" class="headerlink" title="3. Queue"></a>3. Queue</h3><ul><li>LinkedList：可以用它来实现双向队列。</li><li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>双列数据，存储key-value对的数据</p><p><img src="/2020/08/05/java%E5%9F%BA%E7%A1%80/Collection%E5%92%8CMap/Collection%E5%92%8CMap%5CMap.png" alt="image-20200806091811241"></p><ul><li>TreeMap：基于红黑树实现。</li><li>HashMap：基于哈希表实现。可以存储null的key和value</li><li>HashTable：不能存储null ,和 HashMap 类似，但它是线程安全的，就是在方法上加入synchronize这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li><li>Properties：HashTable的子类常用来处理配置文件。key和value都是String类型</li><li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。频繁的遍历操作。</li></ul><h1 id="二、容器中的设计模式"><a href="#二、容器中的设计模式" class="headerlink" title="二、容器中的设计模式"></a>二、容器中的设计模式</h1><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p><p><strong>提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</strong></p><p>Iterator 仅用于遍历集合，I<strong>terator 本身并不提供承装对象的能力。</strong>如果需要创建Iterator 对象，则必须有一个被迭代的集合。</p><p><strong>集合对象每次调用iterator()方法都得到一个全新的迭代器对象</strong>，默认游标都在集合的第一个元素之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator iter = coll.iterator();<span class="comment">//回到起点</span></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    Object obj = iter.next();</span><br><span class="line">    <span class="keyword">if</span>(obj.equals(<span class="string">&quot;Tom&quot;</span>))&#123;</span><br><span class="line">    iter.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator可以删除集合的元素，但是是<strong>遍历过程中通过迭代器对象的remove方 法，不是集合对象的remove方法。</strong> </p><p><strong>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException</strong>。</p><p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p><p>遍历集合的底层调用Iterator完成操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListIterator"><a href="#ListIterator" class="headerlink" title="ListIterator"></a>ListIterator</h3><p>ListIterator是一个功能更加强大的, 它继承于Iterator接口,只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。</p><p>(1)双向移动（向前/向后遍历）.</p><p>(2)产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引.</p><p>(3)可以使用set()方法替换它访问过的最后一个元素.</p><p>(4)可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestListIterator</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;String&gt; a = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       a.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">       a.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">       a.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;Before iterate : &quot;</span> + a);</span><br><span class="line">       ListIterator&lt;String&gt; it = a.listIterator();</span><br><span class="line">       <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">           System.out.println(it.next() + <span class="string">&quot;, &quot;</span> + it.previousIndex() + <span class="string">&quot;, &quot;</span> + it.nextIndex());</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">while</span> (it.hasPrevious()) &#123;</span><br><span class="line">            System.out.print(it.previous() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        it = a.listIterator(<span class="number">1</span>);<span class="comment">//调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。</span></span><br><span class="line">       <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            String t = it.next();</span><br><span class="line">            System.out.println(t);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;ccc&quot;</span>.equals(t)) &#123;</span><br><span class="line">                it.set(<span class="string">&quot;nnn&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                it.add(<span class="string">&quot;kkk&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;After iterate : &quot;</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Before iterate : [aaa, bbb, ccc]</span><br><span class="line">aaa, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">bbb, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">ccc, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">ccc bbb aaa </span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">After iterate : [aaa, bbb, kkk, nnn]</span><br></pre></td></tr></table></figure><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span></span></span><br></pre></td></tr></table></figure><p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure><p>也可以使用以下方式调用 asList()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><h2 id="iterator-1"><a href="#iterator-1" class="headerlink" title="iterator"></a>iterator</h2><p>ArrayList中的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// 指向下一个要被迭代的元素</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;  <span class="comment">// 指向当前元素</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;<span class="comment">// 将modCount赋值给expectedModCount </span></span><br><span class="line"></span><br><span class="line">   Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一个重点，<strong>modCount</strong></p><p>modCount顾名思义就是修改次数，每次对ArrayList内容的修改都将增加这个值</p><h3 id="Fail-Fast-机制"><a href="#Fail-Fast-机制" class="headerlink" title="Fail-Fast 机制"></a><strong>Fail-Fast 机制</strong></h3><p>modCount主要是为了防止在迭代过程中通过List的方法（非迭代器）改变了原集合，导致出现不可预料的情况，从而提前抛出并发修改异常，注意是“提前“，这可能也是Fail-Fast机制命名的由来。在可能出现错误的情况下提前抛出异常终止操作，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            arrayList.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Iterator iterator = arrayList.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    arrayList.remove(<span class="number">1</span>);</span><br><span class="line">    iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码最终会抛出ConcurrentModificationException</p><p>原因是因为，在迭代器进行遍历的时候，如果 iterator.next（）选择了需要遍历的下一个目标时（假设这个目标为坐标3的数），<br><img src="/2020/08/05/java%E5%9F%BA%E7%A1%80/Collection%E5%92%8CMap/iterator1.png" alt="img" style="zoom:67%;"><br>我却调用了arrayList.remove(1)将坐标1给删了，那么这时候它就会遍历成原本坐标为4的数字4，却没有遍历数字3了，如果是LinkedList，会直接找不到目标<br><img src="/2020/08/05/java%E5%9F%BA%E7%A1%80/Collection%E5%92%8CMap/iterator2.png" alt="img" style="zoom:67%;"><br>为了防止这种情况，在迭代器初始化过程中会将modCount赋给迭代器的 expectedModCount。在迭代过程中，判断 modCount 跟 expectedModCount 是否相等，如果不相等就表示通过其他方法修改了 ArrayList的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它在每一次删除之后都会将cursor（下一项）的位置设置为当前位置，也就是将cursor往前移动了一位，之后再将modCount赋值给expectedModCount使它们保持相等。</p><p>这里把lastRet设为-1的目的是为了阻止程序员在没有进行next()的情况下连续去remove()，只有再次执行next()之后，lastRet完成刷新，remove()方法才知道应该删除哪个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(consumer);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">            consumer.accept((E) elementData[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">        cursor = i;</span><br><span class="line">        lastRet = i - <span class="number">1</span>;</span><br><span class="line">        checkForComodification();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="ListIterator-1"><a href="#ListIterator-1" class="headerlink" title="ListIterator"></a>ListIterator</h2><p>ArrayList中的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.add(i, e);</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他在添加完成后将cursor的位置向后移动，不会遍历到已经添加的那个值</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h2><p>ArrayList的JDK1.8之前与之后的实现区别？</p><ul><li><p>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组</p></li><li><p>JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</p></li></ul><p>Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>数组的默认大小为 10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有长度的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//默认为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是不是第一次添加，是就为默认的容量 10</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;  <span class="comment">//记录底层</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//扩容1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  <span class="comment">//新的容量不够</span></span><br><span class="line">        newCapacity = minCapacity;    </span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取整形最大值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure><p>transient用来表示一个域不是该对象序行化的一部分，当一个对象被序行化的时候，transient修饰的变量的值是不包括在序行化的表示中的。但是ArrayList又是可序行化的类，elementData是ArrayList具体存放元素的成员，用transient来修饰elementData，岂不是反序列化后的ArrayList丢失了原先的元素？</p><p>这段主要是这2个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"> </span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ArrayList在序列化的时候会调用writeObject，<strong>直接将size和element写入ObjectOutputStream</strong>；反序列化时调用readObject，从ObjectInputStream获取size和element，再恢复到elementData。<br>    为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？原因在于<strong>elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。</strong></p><h3 id="Fail-Fast"><a href="#Fail-Fast" class="headerlink" title="Fail-Fast"></a>Fail-Fast</h3><p>modCount 用来记录 ArrayList 结构发生变化的次数。<strong>结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</strong></p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。代码参考上节序列化中的 writeObject() 方法。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testListRemove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    updateList(list);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">    <span class="comment">//list.remove(2);删除的是索引的2</span></span><br><span class="line">    list.remove(<span class="keyword">new</span> Integer(<span class="number">2</span>));<span class="comment">//自动装箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。<br>在扩容方面，默认扩容为原来的数组长度的2倍。</p><p>他有一个子类Stack</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加了synchronized保证同步</p><h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement。如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍。</p><h3 id="与-ArrayList-的比较"><a href="#与-ArrayList-的比较" class="headerlink" title="与 ArrayList 的比较"></a>与 ArrayList 的比较</h3><ul><li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li><li>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍。</li></ul><h3 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h3><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p><strong>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</strong></p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：</p><ul><li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li><li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>基于双向链表实现，使用 Node 存储链表节点信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个链表存储了 first 和 last 指针：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与-ArrayList-的比较-1"><a href="#与-ArrayList-的比较-1" class="headerlink" title="与 ArrayList 的比较"></a>与 ArrayList 的比较</h3><p>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。ArrayList 和 LinkedList 的区别可以归结为数组和链表的区别：</p><ul><li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素；</li><li>链表不支持随机访问，但插入删除只需要改变指针。</li></ul><p><strong>但在少量元素的情况下，链表需要定位元素，在插入，ArrayList可以直接插入。效率其实没有什么不同。</strong></p><p>速度不能根据底层决定。</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质是一个HashMap 只不过是一个value相同的</p><h3 id="元素添加过程"><a href="#元素添加过程" class="headerlink" title="元素添加过程"></a>元素添加过程</h3><p>哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置，判断（存放位置一样但哈希值不一样）<br>数组此位置上是否已经元素：</p><ul><li>如果此位置上没其他元素，则元素a添加成功。 —&gt;情况1 </li><li>如果此位置上其他元素b(或以链表形式存在的多个元素，则比较元素a与元素b的hash值：     <ul><li>如果hash值不相同，则元素a添加成功。—&gt;情况2</li><li>如果hash值相同，进而需要调用元素a所在类的equals()方法：<ul><li>quals()返回true,元素a添加失败</li><li>equals()返回false,则元素a添加成功。—&gt;情况2</li></ul></li></ul></li></ul><p>对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。<br>jdk 7 :元素a放到数组中，指向原来的元素。<br>jdk 8 :原来的元素在数组中，指向元素a<br>总结：七上八下</p><h3 id="hashCode和equals的重写"><a href="#hashCode和equals的重写" class="headerlink" title="hashCode和equals的重写"></a>hashCode和equals的重写</h3><p>(01) 若某个类没有覆盖hashCode()方法，当它的通过hashCode()比较两个对象时，实际上是比较两个对象是不是同一个对象。这时，等价于通过“==”去比较这两个对象，即两个对象的<strong>内存地址</strong>是否相同。</p><p>(02) 我们可以覆盖类的hashCode()方法，来让hashCode()通过其它方式比较两个对象是否相等。通常的做法是：若两个对象的<strong>内容</strong>相等，则hashCode()方法返回true；否则，返回fasle。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> ==  o) <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">//比较指针</span></span><br><span class="line">    <span class="keyword">if</span> ( o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">//传入对象为空后加载类不同</span></span><br><span class="line">    Student student = (Student) o;  </span><br><span class="line">    <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name) ; <span class="comment">//值比较年龄和姓名</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@Override</span>  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name,  age) ; <span class="comment">//通过name和age计算新的hash</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么用Eclipse-IDEA复写hashCode方法，有31这个数字？"><a href="#为什么用Eclipse-IDEA复写hashCode方法，有31这个数字？" class="headerlink" title="为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？"></a>为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</h4><p>Objects.hash()底层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.hashCode(values);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object element : a)</span><br><span class="line">        result = <span class="number">31</span> * result + (element == <span class="keyword">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。</p></li><li><p>并且31只占用5bits,相乘造成数据溢出的概率较小</p></li><li><p>31可以 由<strong>i*31== (i&lt;&lt;5)-1</strong>来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）</p></li><li><p>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)</p></li></ul><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>不能添加不同类的对象</p><p>自然排序（实现Comparable接口 )和 定制排序（Comparator）</p><p>1.自然排序中，<strong>比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().</strong><br>2.定制排序中，<strong>比较两个对象是否相同的标准为：compare()返回0.不再是equals().</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以传入一个比较器，完成定制排序</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>单独分出</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>单独分出</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty-Netty源码</title>
      <link href="/2020/08/05/%E6%A1%86%E6%9E%B6/Netty4/"/>
      <url>/2020/08/05/%E6%A1%86%E6%9E%B6/Netty4/</url>
      
        <content type="html"><![CDATA[<p>在 io.netty.example 包下，有很多Netty源码案例，可以用来分析</p><h2 id="Netty-启动过程源码剖析"><a href="#Netty-启动过程源码剖析" class="headerlink" title="Netty 启动过程源码剖析"></a>Netty 启动过程源码剖析</h2><p>Netty 调用doBind方法， 追踪到 NioServerSocketChannel的doBind<br>并且要Debug 程序到 NioEventLoop类 的run代码 ，无限循环，在服务器端运行。</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer</title>
      <link href="/2020/08/05/leetcode/%E5%89%91%E6%8C%87offer/"/>
      <url>/2020/08/05/leetcode/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<p>所有题按照leetcode</p><h2 id="JZ3-数组中重复数字"><a href="#JZ3-数组中重复数字" class="headerlink" title="JZ3 数组中重复数字"></a>JZ3 数组中重复数字</h2><p>数组中重复的数字</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure><p>1.<strong>遍历数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> repeat = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!set.add(num))&#123;</span><br><span class="line">        repeat = num;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> repeat;</span><br></pre></td></tr></table></figure><p>2.先排序在查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.空间换时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        arr[nums[i]]++;</span><br><span class="line">        <span class="keyword">if</span>(arr[nums[i]] &gt; <span class="number">1</span>) <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ4-二维数组的查找"><a href="#JZ4-二维数组的查找" class="headerlink" title="JZ4 二维数组的查找"></a>JZ4 二维数组的查找</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = array.length; <span class="comment">//行</span></span><br><span class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length ;<span class="comment">//列</span></span><br><span class="line">        <span class="comment">//从右上角开始</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, c = col-<span class="number">1</span>;  <span class="comment">//r表示那一行，c表示那一列</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt;= row-<span class="number">1</span> &amp;&amp; c &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (target == array[r][c])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( target &lt; array[r][c])&#123;</span><br><span class="line">                c--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ5-替换空格"><a href="#JZ5-替换空格" class="headerlink" title="JZ5 替换空格"></a>JZ5 替换空格</h2><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.toString().replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ6-输入一个链表，按链表从尾到头的顺序返回一个ArrayList"><a href="#JZ6-输入一个链表，按链表从尾到头的顺序返回一个ArrayList" class="headerlink" title="JZ6 输入一个链表，按链表从尾到头的顺序返回一个ArrayList"></a>JZ6 输入一个链表，按链表从尾到头的顺序返回一个ArrayList</h2><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>1.递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[]  reversePrint(ListNode head) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ret = printListFromTailToHead(head.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[ret.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;ret.size();i++)&#123;</span><br><span class="line">        res[i] = ret.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ret.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">        ret.add(listNode.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">    Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ListNode temp = head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(temp);</span><br><span class="line">        temp = temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = stack.size();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        res[i] = stack.pop().val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.不用栈也不用递归</p><p>先遍历获取长度，得到数组，在从最后开始赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reversePrint3(ListNode head) &#123;</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        nums[i] = node.val;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ7-重建二叉树"><a href="#JZ7-重建二叉树" class="headerlink" title="JZ7 重建二叉树"></a>JZ7 重建二叉树</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p><strong>递归</strong></p><p>前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。</p><ul><li>前序遍历的首个元素即为根节点 root 的值；</li><li>在中序遍历中搜索根节点 root 的索引 ，可将中序遍历划分为 [ 左子树 | 根节点 | 右子树 ] 。</li><li>根据中序遍历中的左（右）子树的节点数量，可将前序遍历划分为 [ 根节点 | 左子树 | 右子树 ] 。</li></ul><p>左子树： 根节点索引为 pre_root + 1 ，中序遍历的左右边界分别为 in_left 和 i - 1。<br>右子树： 根节点索引为pre_root+i-in_left+1（即：根节点索引 + 左子树长度 + 1），中序遍历的左右边界分别为 i + 1 和 in_right。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,Integer&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//保存中序遍历</span></span><br><span class="line"><span class="keyword">int</span> []po;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || pre.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    po=pre;</span><br><span class="line">    <span class="comment">//放入中序遍历的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;in.length;i++)&#123;</span><br><span class="line">        dic.put(in[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recur(<span class="number">0</span>,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> pre_root,<span class="keyword">int</span> in_left ,<span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in_left&gt;in_right) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//不存在</span></span><br><span class="line"></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(po[pre_root]);</span><br><span class="line">    <span class="keyword">int</span> i = dic.get(po[pre_root]);<span class="comment">//分为2半</span></span><br><span class="line">    root.left = recur(pre_root+<span class="number">1</span>,in_left,i-<span class="number">1</span>);</span><br><span class="line">    root.right = recur(pre_root+i-in_left+<span class="number">1</span>,i+<span class="number">1</span>,in_right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> pre[] = &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> in[] = &#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>&#125;;</span><br><span class="line">   <span class="keyword">new</span> JZ7().buildTree(pre, in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈</strong></p><p>前序遍历挨着的两个值比如m和n，他们会有下面两种情况之一的关系。</p><p>1，<strong>n是m左子树节点的值</strong>。</p><p>2，<strong>n是m右子树节点的值或者是m某个祖先节点的右节点的值。</strong></p><p>对于第一个知识点我们很容易理解，如果m的左子树不为空，那么n就是m左子树节点的值。</p><p>对于第二个问题，如果一个结点没有左子树只有右子树，那么n就是m右子树节点的值，如果一个结点既没有左子树也没有右子树，那么n就是m某个祖先节点的右节点，我们只要找到这个祖先节点就好办了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  TreeNode <span class="title">buildTree2</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span> || pre.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//创建根节点</span></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i&lt;pre.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val != in[j])&#123; <span class="comment">//第一种情况</span></span><br><span class="line">            cur.left = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">            s.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;  <span class="comment">//第二种情况</span></span><br><span class="line">            j++;</span><br><span class="line">            <span class="comment">//找到合适的cur，每个子树都出战，直到找到合适的。</span></span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp;s.peek().val == in[j])&#123;</span><br><span class="line">                cur = s.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//给cur添加右节点</span></span><br><span class="line">            cur = cur.right = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ9-两个栈来实现一个队列"><a href="#JZ9-两个栈来实现一个队列" class="headerlink" title="JZ9 两个栈来实现一个队列"></a>JZ9 两个栈来实现一个队列</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ5</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();  <span class="comment">//in</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();  <span class="comment">//out</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inToOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty())&#123;   <span class="comment">//必须stack2出栈完成后才能继续进栈</span></span><br><span class="line">            <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        inToOut();</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ10-1-斐波那契数列"><a href="#JZ10-1-斐波那契数列" class="headerlink" title="JZ10-1 斐波那契数列"></a>JZ10-1 斐波那契数列</h2><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZJ10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> constant = <span class="number">1000000007</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = list.get(i-<span class="number">1</span>)+list.get(i-<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= constant)</span><br><span class="line">                res = res - constant;</span><br><span class="line">            list.add(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ10-2-青蛙跳台阶问题"><a href="#JZ10-2-青蛙跳台阶问题" class="headerlink" title="JZ10-2 青蛙跳台阶问题"></a>JZ10-2 青蛙跳台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>青蛙可从低一阶的台阶上，也可以从低2阶的台阶上去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZJ10_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i]&gt;<span class="number">1000000007</span>)&#123;</span><br><span class="line">                dp[i] -= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ11-旋转数组的最小值"><a href="#JZ11-旋转数组的最小值" class="headerlink" title="JZ11 旋转数组的最小值"></a>JZ11 旋转数组的最小值</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 </p><p><strong>遍历数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> min = numbers[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (min &gt; numbers[i])</span><br><span class="line">        min = numbers[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min;</span><br></pre></td></tr></table></figure><p><strong>二分法查找</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray2</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = numbers.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numbers[mid] &gt; numbers[right])&#123; <span class="comment">//如果中间值大于最右边的值，说明旋转之后最小的数字肯定在mid的右边</span></span><br><span class="line">            left = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid]&lt;numbers[left])&#123; <span class="comment">//中间数比左边小</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果中间值等于最后一个元素的值，我们是没法确定最小值是</span></span><br><span class="line">            <span class="comment">// 在mid的前面还是后面，但我们可以缩小查找范围，让right</span></span><br><span class="line">            <span class="comment">// 减1，因为即使right指向的是最小值，但因为他的值和mid</span></span><br><span class="line">            <span class="comment">// 指向的一样，我们这里并没有排除mid，所以结果是不会有影响的。</span></span><br><span class="line">            <span class="comment">//比如[3，1，3，3，3，3，3]和[3，3，3，3，3，1，3],中间的值</span></span><br><span class="line">            <span class="comment">//等于最右边的值，但我们没法确定最小值是在左边还是右边</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[right];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ12-矩阵中的路径"><a href="#JZ12-矩阵中的路径" class="headerlink" title="JZ12 矩阵中的路径"></a>JZ12 矩阵中的路径</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p>回溯算法</p><p>遍历数组，有4个方向的走法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(board,words,i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> board</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> words</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i  座标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index  到字符串第几个了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">char</span>[] words,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; board.length-<span class="number">1</span> || i&lt;<span class="number">0</span> || j &gt; board[<span class="number">0</span>].length-<span class="number">1</span> || j&lt;<span class="number">0</span> || board[i][j] != words[index])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//已经完成</span></span><br><span class="line">    <span class="keyword">if</span> (index == words.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> tmp = board[i][j]; <span class="comment">//保存这个值</span></span><br><span class="line">    board[i][j] = <span class="string">&#x27;/&#x27;</span>; <span class="comment">//将这个值置位</span></span><br><span class="line">    <span class="comment">//四种走法</span></span><br><span class="line">    <span class="keyword">boolean</span> res = dfs(board, words, i + <span class="number">1</span>, j, index + <span class="number">1</span>) || dfs(board, words, i - <span class="number">1</span>, j, index + <span class="number">1</span>) ||</span><br><span class="line">            dfs(board, words, i, j + <span class="number">1</span>, index + <span class="number">1</span>) || dfs(board, words, i , j - <span class="number">1</span>, index + <span class="number">1</span>);</span><br><span class="line">    board[i][j]= tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用一个另外的数组来记录是否已经被访问。</p><h2 id="JZ13-机器人的运动范围"><a href="#JZ13-机器人的运动范围" class="headerlink" title="JZ13 机器人的运动范围"></a>JZ13 机器人的运动范围</h2><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><p>使用深度优先搜索（Depth First Search，DFS）方法进行求解。</p><p>结论： 根据可达解的结构，易推出机器人可 仅通过向右和向下移动，访问所有可达解 。<br><img src="/2020/08/05/leetcode/%E5%89%91%E6%8C%87offer/JZ13.png" alt="image-20200810223637880" style="zoom:67%;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, m, n, k, visited);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> visited</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">boolean</span> visited[][])</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断出界， 判断这个位置的值有没有超过k,这个位置有没有访问过</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || (i/<span class="number">10</span> + i%<span class="number">10</span> + j/<span class="number">10</span> + j%<span class="number">10</span>) &gt; k || visited[i][j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//计算2个方法走的总和</span></span><br><span class="line">    <span class="keyword">return</span>  dfs(i + <span class="number">1</span>, j, m, n, k, visited)+dfs(i, j + <span class="number">1</span>, m, n, k, visited)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ14-1-剪绳子"><a href="#JZ14-1-剪绳子" class="headerlink" title="JZ14-1 剪绳子"></a>JZ14-1 剪绳子</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br><span class="line"></span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure><p>动态规划</p><p>建立一维动态数组 dp：</p><p>边界条件：dp[1] = dp[2] = 1，表示长度为 2 的绳子最大乘积为 1；<br>状态转移方程：dp[i] = max(dp[i], max((i - j) * j, j * dp[i - j]))，可以这样理解：</p><img src="/2020/08/05/leetcode/%E5%89%91%E6%8C%87offer/JZ14_1.png" alt="14.jpg" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];<span class="comment">//新建一个动态规划的数组</span></span><br><span class="line">    <span class="comment">/*真正的dp[1] = 0,dp[2] = 1,dp[3] = 2</span></span><br><span class="line"><span class="comment">    但是当n=4时，4=2+2 2*2=4 而dp[2]=1是不对的</span></span><br><span class="line"><span class="comment">            也就是说当n=1/2/3时，分割后反而比没分割的值要小，当大问题用到dp[j]时，说明已经分成了一个j一个i-j，这两部分又可以再分，但是再分不能比他本身没分割的要小，如果分了更小还不如不分</span></span><br><span class="line"><span class="comment">    所以在这里指定大问题用到的dp[1],dp[2],dp[3]是他本身</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>;i &lt;= n;i++)&#123; <span class="comment">//计算每一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">2</span>;j&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i],dp[i-j]*dp[j]); <span class="comment">//判断哪个分割值最大</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ14-2-剪绳子2"><a href="#JZ14-2-剪绳子2" class="headerlink" title="JZ14-2 剪绳子2"></a>JZ14-2 剪绳子2</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><p>贪心算法</p><p>认为一份为3是最大的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p=(<span class="keyword">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="comment">//贪心算法</span></span><br><span class="line">    <span class="keyword">while</span> (n&gt;<span class="number">4</span>)&#123;</span><br><span class="line">        res = res*<span class="number">3</span>%p;</span><br><span class="line">        n -= <span class="number">3</span>; <span class="comment">//认为3是最大的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环结果有3中 n=2 n=3 n=4</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (res*n%p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ15-二进制中1的个数"><a href="#JZ15-二进制中1的个数" class="headerlink" title="JZ15 二进制中1的个数"></a>JZ15 二进制中1的个数</h2><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p><p>与运算</p><p>根据 与运算 定义，设二进制数字 n ，则有：<br>若 n &amp; 1 = 0，则 n 二进制 最右一位 为 00 ；<br>若 n &amp; 1 = 1 ，则 n 二进制 最右一位 为 11 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ15</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (n != <span class="number">0</span>)&#123;</span><br><span class="line">          res +=  n&amp;<span class="number">1</span>; <span class="comment">//与运输</span></span><br><span class="line">          n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ16-数值的整次方"><a href="#JZ16-数值的整次方" class="headerlink" title="JZ16 数值的整次方"></a>JZ16 数值的整次方</h2><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p>我的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            res *= x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> temp = <span class="number">1</span> / x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; Math.abs(n) ;i++)&#123;</span><br><span class="line">            res *= temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">        res = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        res = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.00000 -2147483648 结果为0</p><p>因为int的取值范围是-2147483648到2147483647…所以java的Math.abs(n)在这个时候返回的还是-2147483648</p><p>递归求解</p><p>使用long类型不会溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 特判，也可以认为是递归终止条件</span></span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / myPow(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> myPow(x, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指数是奇数还是偶数进行分类讨论</span></span><br><span class="line">    <span class="comment">// 使用位运算的 与 运算符代替了求余数运算</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分治思想：分</span></span><br><span class="line">        <span class="keyword">double</span> square = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 分治思想：合，下面同理</span></span><br><span class="line">        <span class="keyword">return</span> square * square;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是奇数的时候</span></span><br><span class="line">        <span class="keyword">double</span> square = myPow(x, (n - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> square * square * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> N = n;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        N *= -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((N % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res *= x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x *= x;</span><br><span class="line">        N /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">。</span><br></pre></td></tr></table></figure><h2 id="JZ17-从-11-至最大的-n位数的列表"><a href="#JZ17-从-11-至最大的-n位数的列表" class="headerlink" title="JZ17 从 11 至最大的 n位数的列表"></a>JZ17 从 11 至最大的 n位数的列表</h2><p>题目要求打印 “从 11 至最大的 n位数的列表” ，因此需考虑以下两个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> end = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>,n)-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[end];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;end  ; i++)&#123;</span><br><span class="line">        res[i] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上</p><p>由于存在大数问题，结果不能放入int数组中，故这里采用剑指offer原题的直接打印输出的模式。<br>increment函数，若发生进位则一直进行for循环，直到不产生进位则break。如果i为0（即到了最高位）还发生了进位，则设置isOverflow为true，并返回至主函数的while判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// 将str初始化为n个&#x27;0&#x27;字符组成的字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        str.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!increment(str))&#123;</span><br><span class="line">        <span class="comment">// 去掉左侧的0</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; str.length() &amp;&amp; str.charAt(index) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(str.toString().substring(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increment</span><span class="params">(StringBuilder str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isOverflow = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">char</span> s = (<span class="keyword">char</span>)(str.charAt(i) + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果s大于&#x27;9&#x27;则发生进位</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            str.replace(i, i + <span class="number">1</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                isOverflow = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没发生进位则跳出for循环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            str.replace(i, i + <span class="number">1</span>, String.valueOf(s));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOverflow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ18-删除链表的节点"><a href="#JZ18-删除链表的节点" class="headerlink" title="JZ18 删除链表的节点"></a>JZ18 删除链表的节点</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: head = [4,5,1,9], val = 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: head = [4,5,1,9], val = 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="keyword">if</span> (p.val == val)&#123;</span><br><span class="line">        <span class="keyword">return</span> p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode q = p;</span><br><span class="line">    p = p.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( p!=<span class="keyword">null</span> )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.val == val)&#123;</span><br><span class="line">            q.next = p.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q=p;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题中，输入的类型为：head: ListNode, val: int，即 val 的类型是整形；<br>在《剑指offer》中，默认输入为 head: ListNode, val: ListNode，即 val 的类型是链表。</p><p>假如 head 为 4 -&gt; 5 -&gt; 1 -&gt; 9，val 为 5 -&gt; 1 -&gt; 9，表示我们要删除结点 5，这时我们使用信息交换，把 val 改为 1 -&gt; 9的信息就行了。</p><p>为什么呢？因为我们把待删除节点的后一个元素赋值给待删除节点，也就相当于删除了当前元素。</p><p>但是聪明的你一定会举出反例：如果 val 的值是最后一个元素 9 呢？我们无法找到 9 的后一个元素（因为没有），只能重头开始找待删除元素 9，这样的话时间复杂度再次变成了 O(N)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个不通过，仅供参考</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || val == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (val.next != <span class="keyword">null</span>)&#123;   <span class="comment">// 待删除节点不是尾节点</span></span><br><span class="line">        ListNode next = val.next;</span><br><span class="line">        val.val = next.val;</span><br><span class="line">        val.next = next.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head == val)&#123;   <span class="comment">// 待删除节点只有一个节点，此节点为头节点</span></span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// 待删除节点为尾节点</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != val)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JZ19-正则表达式匹配"><a href="#JZ19-正则表达式匹配" class="headerlink" title="JZ19 正则表达式匹配"></a>JZ19 正则表达式匹配</h2><p>请实现一个函数用来匹配包含’. ‘和’ * ‘的正则表达式。模式中的字符’.’表示任意一个字符，而’ * ‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入:</span><br><span class="line">s = &quot;aa&quot;</span><br><span class="line">p = &quot;a*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line">输入:</span><br><span class="line">s = &quot;ab&quot;</span><br><span class="line">p = &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line">输入:</span><br><span class="line">s = &quot;aab&quot;</span><br><span class="line">p = &quot;c*a*b&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br><span class="line"></span><br><span class="line">示例 5:</span><br><span class="line">输入:</span><br><span class="line">s = &quot;mississippi&quot;</span><br><span class="line">p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JZ21-调整数组顺序使奇数位于偶数前面"><a href="#JZ21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="JZ21 调整数组顺序使奇数位于偶数前面"></a>JZ21 调整数组顺序使奇数位于偶数前面</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure><p>我的思路 类似于快速排序</p><p>从两边开始查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>,r = nums.length-<span class="number">1</span>,temp;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">             <span class="keyword">while</span> (l&lt;r &amp;&amp; (nums[l]&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l&lt;r &amp;&amp; (nums[r]&amp;<span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l&lt;r)&#123;</span><br><span class="line">                temp = nums[l];</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">                nums[r] = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="JZ22-链表中倒数第k个节点"><a href="#JZ22-链表中倒数第k个节点" class="headerlink" title="JZ22 链表中倒数第k个节点"></a>JZ22 链表中倒数第k个节点</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode pre = head , tail = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tail.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= k)&#123;</span><br><span class="line">        pre = pre .next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快慢指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd2</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode pre = head, tail = head;</span><br><span class="line">    <span class="keyword">while</span> (tail != <span class="keyword">null</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        tail = tail.next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (tail != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        pre = pre.next;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ24-反转链表"><a href="#JZ24-反转链表" class="headerlink" title="JZ24 反转链表"></a>JZ24 反转链表</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>头插法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode newhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode node = head.next;</span><br><span class="line">        head.next = newhead.next;</span><br><span class="line">        newhead.next = head;</span><br><span class="line">        head = node ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newhead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode node = head.next;</span><br><span class="line">    ListNode newhead = reverseList2(node); <span class="comment">//递归</span></span><br><span class="line">    node.next = head;  <span class="comment">//反转</span></span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newhead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ25-合并两个有序节点"><a href="#JZ25-合并两个有序节点" class="headerlink" title="JZ25 合并两个有序节点"></a>JZ25 合并两个有序节点</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure><p>迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode node = head;</span><br><span class="line">    <span class="keyword">while</span> (l1!=<span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val&lt;l2.val)&#123;</span><br><span class="line">            node.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            node.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        node.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        node.next = l2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1.val&lt;l2.val)&#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next,l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JZ26 树的子结构</p><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p><p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定的树 A:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line">给定的树 B：</span><br><span class="line">   4 </span><br><span class="line">  /</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure><p>返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p><p><strong>解题思路：</strong></p><p>若树 B 是树 A 的子结构，则子结构的根节点可能为树 AA的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p><ol><li>先序遍历树 A 中的每个节点 n<del>A</del>  ；（对应函数 isSubStructure(A, B)）</li><li>判断树 A 中 以 n<del>A</del> 为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到A节点和B节点值相同的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="keyword">null</span> || A == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A.val == B.val &amp;&amp; recur(A,B))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSubStructure(A.left,B) || isSubStructure(A.right,B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断A树是不是B树的子树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode a, TreeNode b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//b为null说明b已经匹配完成</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a树为null 或节点值不相等说明匹配失败</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.val!=b.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recur(a.left,b.left) &amp;&amp; recur(a.right,b.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ27-二叉树镜像"><a href="#JZ27-二叉树镜像" class="headerlink" title="JZ27 二叉树镜像"></a>JZ27 二叉树镜像</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p><p>使用递归的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ27</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left =  mirrorTree(root.right);</span><br><span class="line">        root.right = mirrorTree(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>辅助栈</p><ol><li><strong>特例处理</strong>： 当 root 为空时，直接返回 null ；</li><li><strong>初始化</strong>： 栈（或队列），本文用栈，并加入根节点 root。</li><li><strong>循环交换</strong>： 当栈 stack 为空时跳出；<ol><li>出栈： 记为 node ；</li><li>添加子节点： 将 node 左和右子节点入栈；</li><li>交换： 交换 node 的左 / 右子节点。</li></ol></li><li><strong>返回值</strong>： 返回根节点 root 。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="comment">//循环交换</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) stack.add(node.left);</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) stack.add(node.right);</span><br><span class="line">        TreeNode tmp = node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ28-对称的二叉树"><a href="#JZ28-对称的二叉树" class="headerlink" title="JZ28 对称的二叉树"></a>JZ28 对称的二叉树</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p><strong>解题思路：</strong><br>对称二叉树定义： 对于树中 任意两个对称节点 L 和 R ，一定有：</p><ul><li>L.val = R.val ：即此两对称节点值相等。</li><li>L.left.val = R.right.val：即 L 的 左子节点 和 R的 右子节点 对称；</li><li>L.right.val = R.left.val：即 L 的 右子节点 和 R的 左子节点 对称。</li></ul><p><strong>isSymmetric(root)</strong> ：</p><ul><li><p>特例处理： 若根节点 root 为空，则直接返回 true。</p></li><li><p>返回值： 即 recur(root.left, root.right) ;</p></li></ul><p><strong>recur(L, R) ：</strong></p><p>终止条件：</p><ul><li>当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true；</li><li>当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false；</li><li>当节点 L值 ≠节点 R 值： 此树不对称，因此返回 false ；</li></ul><p>递推工作：</p><ul><li><p>判断两节点 L.left 和 R.right是否对称，即 recur(L.left, R.right) ；</p></li><li><p>判断两节点 L.right和 R.left是否对称，即 recur(L.right, R.left) ；</p></li><li><p>返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 &amp;&amp; 连接。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> recur(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="keyword">null</span> || right == <span class="keyword">null</span> || left.val!= right.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> recur(left.left,right.right) &amp;&amp; recur(left.right,right.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ29-顺时针打印矩阵"><a href="#JZ29-顺时针打印矩阵" class="headerlink" title="JZ29 顺时针打印矩阵"></a>JZ29 顺时针打印矩阵</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>根据题目示例 matrix = [[1,2,3],[4,5,6],[7,8,9]] 的对应输出 [1,2,3,6,9,8,7,4,5] 可以发现，顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。</p><h4 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h4><ol><li>空值处理： 当 matrix 为空时，直接返回空列表 [] 即可。</li><li>初始化： 矩阵 左、右、上、下 四个边界 l , r , t , b ，用于打印的结果列表 res 。</li><li>循环打印： “从左向右、从上向下、从右向左、从下向上” 四个方向循环，每个方向打印中做以下三件事 （各方向的具体信息见下表） ；<ol><li>根据边界打印，即将元素按顺序添加至列表 res 尾部；</li><li>边界向内收缩 1 （代表已被打印）；</li><li>判断是否打印完毕（边界是否相遇），若打印完毕则跳出。</li></ol></li><li>返回值： 返回 res 即可。</li></ol><table><thead><tr><th>打印方向</th><th>1. 根据边界打印</th><th>2. 边界向内收缩</th><th>3. 是否打印完毕</th></tr></thead><tbody><tr><td>从左向右</td><td>左边界l ，右边界 r</td><td>上边界 t 加 1</td><td>是否 t &gt; b</td></tr><tr><td>从上向下</td><td>上边界 t ，下边界b</td><td>右边界 r 减 1</td><td>是否 l &gt; r</td></tr><tr><td>从右向左</td><td>右边界 r ，左边界l</td><td>下边界 b 减 1</td><td>是否 t &gt; b</td></tr><tr><td>从下向上</td><td>下边界 b ，上边界t    1</td><td>左边界 l 加 1</td><td>是否 l &gt; r</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ29</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//横向向左</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;=r ; i++)&#123;</span><br><span class="line">                res[x++] = matrix[t][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//竖向向下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= b ; i++)&#123;</span><br><span class="line">                res[x++] = matrix[i][r];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//横向向右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; i--)&#123;</span><br><span class="line">                res[x++] = matrix[b][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--b &lt; t) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i &gt;=t ; i--)&#123;</span><br><span class="line">                res[x++] = matrix[i][l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ30-包含min函数的栈"><a href="#JZ30-包含min函数的栈" class="headerlink" title="JZ30 包含min函数的栈"></a>JZ30 包含min函数的栈</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p>使用2个栈，一个存放数据，一个存放最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ30</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    Stack&lt;Integer&gt; stack , min;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JZ30</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        min = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span> (min.empty() || x &lt;= min())&#123;</span><br><span class="line">            min.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果出栈的值等于最小值，说明栈中的最小值</span></span><br><span class="line">        <span class="comment">//已经出栈了，因为min中的栈顶元素存放的</span></span><br><span class="line">        <span class="comment">//就是最小值，所以stack2栈顶元素也要出栈</span></span><br><span class="line">        <span class="keyword">if</span> (stack.pop() == min())&#123;</span><br><span class="line">            min.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ31-栈的弹出压入"><a href="#JZ31-栈的弹出压入" class="headerlink" title="JZ31 栈的弹出压入"></a>JZ31 栈的弹出压入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ31</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    遍历push放入栈中，</span></span><br><span class="line"><span class="comment">    遍历压栈序列，循环弹出</span></span><br><span class="line"><span class="comment">    如果这个栈是正确的流程,栈就为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:pushed)&#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[i])&#123; <span class="comment">//模拟栈的出栈顺序</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ32-从上到下打印二叉树"><a href="#JZ32-从上到下打印二叉树" class="headerlink" title="JZ32 从上到下打印二叉树"></a>JZ32 从上到下打印二叉树</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用队列控制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">        res[i] = list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从上到下打印二叉树，每一层打印一行</span></span><br><span class="line"><span class="comment">//用一个临时数组表示当前层的节点</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder2(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt;<span class="number">0</span>; i--)&#123;<span class="comment">//将这一层节点子节点加入到队列中.出队固定长度</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            tmp.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</span></span><br><span class="line"><span class="comment">//使用双端队列</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder3(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//false左向右打印，true反向打印</span></span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = queue.size(); i &gt;<span class="number">0</span>; i--)&#123;<span class="comment">//将这一层节点子节点加入到队列中.出队固定长度</span></span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (res.size()%<span class="number">2</span>==<span class="number">0</span>) tmp.addLast(node.val); <span class="comment">//偶数层 队列尾部</span></span><br><span class="line">            <span class="keyword">else</span> tmp.addFirst(node.val);<span class="comment">//奇数层，队列头部</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-二叉搜索树的后序遍历的"><a href="#33-二叉搜索树的后序遍历的" class="headerlink" title="33 二叉搜索树的后序遍历的"></a>33 二叉搜索树的后序遍历的</h2><p>后序遍历定义： [ 左子树 | 右子树 | 根节点 ] ，即遍历顺序为 “左、右、根” 。<br>二叉搜索树定义： 左子树中所有节点的值 &lt;&lt;根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。</p><p>递归分治</p><p>根据二叉搜索树的定义，可以通过递归，判断所有子树的 正确性 （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。</p><ul><li><strong>终止条件</strong>： 当i≥j ，说明此子树节点数量≤1 ，无需判别正确性，因此直接返回 true ；</li><li><strong>递推工作</strong>：<ol><li>划分左右子树： 遍历后序遍历的 [i, j] 区间元素，寻找 <strong>第一个大于根节点 的节点</strong>，索引记为 m 。此时，可划分出左子树区间 [i,m-1]、右子树区间 [m, j - 1]、根节点索引 j 。</li><li>判断是否为二叉搜索树：<br>左子树区间 [i, m - 1]内的所有节点都应 &lt; postorder[j]。而第 1.划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。<br>右子树区间 [m, j-1]内的所有节点都应 &gt; postorder[j]。实现方式为遍历，当遇到 ≤postorder[j] 的节点则跳出；则可通过 p = j判断是否为二叉搜索树。</li></ol></li><li><strong>返回值</strong>： 所有子树都需正确才可判定正确，因此使用 与逻辑符 &amp;&amp;&amp;&amp; 连接。<br>   p = j： 判断 <strong>此树</strong> 是否正确。<br>   recur(i, m - 1)： 判断 此树的左子树 是否正确。<br>   recur(m, j - 1 )： 判断 此树的右子树 是否正确。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recur(postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>); <span class="comment">//第一棵树从根节点开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&gt;j)&#123; <span class="comment">//遍历完这棵树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p=i;</span><br><span class="line">    <span class="keyword">while</span> (postorder[p]&lt;postorder[j]) p++; <span class="comment">//找到第一个小于根节点的值的节点 ，划分左右</span></span><br><span class="line">    <span class="keyword">int</span> m = p; <span class="comment">//索引</span></span><br><span class="line">    <span class="keyword">while</span> (postorder[p]&gt;postorder[j]) p++; <span class="comment">//检查右子树是不是小于</span></span><br><span class="line">    <span class="keyword">return</span> p == j &amp;&amp; recur(postorder,i,m-<span class="number">1</span>) &amp;&amp; recur(postorder,m,j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ35-二叉树中值为某一值的路径"><a href="#JZ35-二叉树中值为某一值的路径" class="headerlink" title="JZ35 二叉树中值为某一值的路径"></a>JZ35 二叉树中值为某一值的路径</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//返回值结果</span></span><br><span class="line">LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//临时变量</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    recur(root,sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *节点为null直接返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 当前节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sum 当前计算值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    tmp.add(node.val);</span><br><span class="line">    sum = sum - node.val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>)&#123; <span class="comment">//sum为0并且左右节点为null</span></span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList&lt;&gt;(tmp)); <span class="comment">//新的</span></span><br><span class="line">    &#125;</span><br><span class="line">    recur(node.left,sum);  <span class="comment">//左节点</span></span><br><span class="line">    recur(node.right,sum);  <span class="comment">//右节点</span></span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    tmp.removeLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ35-复杂链表的复制"><a href="#JZ35-复杂链表的复制" class="headerlink" title="JZ35 复杂链表的复制"></a>JZ35 复杂链表的复制</h2><p>利用hashmap来存储数据key是旧的值，value是新的值，通过旧值来构造一个新的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Node node = head;</span><br><span class="line">    HashMap&lt;Node,Node&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.put(node,<span class="keyword">new</span> Node(node.val));</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    node = head;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        map.get(node).next = map.get(node.next);</span><br><span class="line">        map.get(node).random = map.get(node.random);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ36-二叉搜索树与双向链表"><a href="#JZ36-二叉搜索树与双向链表" class="headerlink" title="JZ36 二叉搜索树与双向链表"></a>JZ36 二叉搜索树与双向链表</h2><p>输入一颗二叉搜索树将它转化成一个双向链表。</p><ol><li>排序链表：利用”<strong>中序遍历</strong>“从小到大访问树的节点</li><li>双向链表：在构建相邻节点（前驱pre,当前节点cur）,pre.right = cur也应cur.left = pre.</li><li>循环链表：head.left = tail 和tail.right = head</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JZ36</span> </span>&#123;</span><br><span class="line">    Node pre,head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dfs(root);<span class="comment">//递归成为一个</span></span><br><span class="line">        head.left = pre; <span class="comment">//将头结点和尾结点连接起来</span></span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//深度遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) pre.right = cur; <span class="comment">//不是第一个节点，就对讲节点进行连接</span></span><br><span class="line">        <span class="keyword">else</span> head = cur;                <span class="comment">//是第一个节点就将head指向这个节点</span></span><br><span class="line">        cur.left = pre; <span class="comment">//两个节点连接起来</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        dfs(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ37-序列化和反序列化"><a href="#JZ37-序列化和反序列化" class="headerlink" title="JZ37 序列化和反序列化"></a>JZ37 序列化和反序列化</h2><p>实现序列化和反序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.append(node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> res.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">    res.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data.equals(<span class="string">&quot;[]&quot;</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String[] vals = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[<span class="number">0</span>]));</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(vals[i]));</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty-Netty进阶</title>
      <link href="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty3/"/>
      <url>/2020/08/03/%E6%A1%86%E6%9E%B6/Netty3/</url>
      
        <content type="html"><![CDATA[<h2 id="Netty-核心模块组件"><a href="#Netty-核心模块组件" class="headerlink" title="Netty 核心模块组件"></a>Netty 核心模块组件</h2><h3 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a>Bootstrap、ServerBootstrap</h3><p>Bootstrap 意思是引导，<strong>一个 Netty 应用通常由一个 Bootstrap 开始</strong>，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类</p><p>常见的方法有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span>，该方法用于服务器端，用来设置两个 EventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span> ，该方法用于客户端，用来设置一个 EventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span>，该方法用来设置一个服务器端的通道实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span>，用来给 ServerChannel 添加配置 y</span></span><br><span class="line"><span class="function">    用来设置bossGroup的通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; ServerBootstrap <span class="title">childOption</span><span class="params">(ChannelOption&lt;T&gt; childOption, T value)</span>，用来给接收到的通道添加配置 设置workGroup的通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span>，该方法用来设置业务处理类（自定义的 handler）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> ，该方法用于服务器端，用来设置占用的端口号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span> ，该方法用于客户端，用来连接服务器端</span></span><br></pre></td></tr></table></figure><p>.handler 对应bossGroup </p><p>.childHandler对应workGroup</p><h3 id="Future、ChannelFuture"><a href="#Future、ChannelFuture" class="headerlink" title="Future、ChannelFuture"></a>Future、ChannelFuture</h3><p> Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Channel <span class="title">channel</span><span class="params">()</span>，返回当前正在进行 IO 操作的通道</span></span><br><span class="line"><span class="function">ChannelFuture <span class="title">sync</span><span class="params">()</span>，等待异步操作执行完毕，把异步变成同步</span></span><br></pre></td></tr></table></figure><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ul><li>Netty 网络通信的组件，能够用于执行网络 I/O 操作。</li><li>通过Channel 可获得当前网络连接的通道的状态</li><li>通过Channel 可获得 网络连接的配置参数 （例如接收缓冲区大小）</li><li>Channel 提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，<strong>异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成</strong></li><li>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NioSocketChannel，异步的客户端 TCP Socket 连接。</span><br><span class="line">NioServerSocketChannel，异步的服务器端 TCP Socket 连接。</span><br><span class="line">NioDatagramChannel，异步的 UDP 连接。</span><br><span class="line">NioSctpChannel，异步的客户端 Sctp 连接。</span><br><span class="line">NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</span><br></pre></td></tr></table></figure><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。<br>当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel </p><h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><p>ChannelHandler 是一个接口，<strong>处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</strong><br>ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</p><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty3/ChannelHandle.png" alt="image-20200803225828835" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChannelInboundHandler 用于处理入站 I/O 事件。</span><br><span class="line">ChannelOutboundHandler 用于处理出站 I/O 操作。</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器</span></span><br><span class="line">ChannelInboundHandlerAdapter 用于处理入站 I/O 事件。</span><br><span class="line">ChannelOutboundHandlerAdapter 用于处理出站 I/O 操作。</span><br><span class="line">ChannelDuplexHandler 用于处理入站和出站事件。</span><br></pre></td></tr></table></figure><p>相对于客户端为例</p><p>事件的运动方向是客户端到服务器端，出站</p><p>我们经常需要自定义一个 Handler 类去继承 ChannelInboundHandlerAdapter，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelInboundHandler</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelInboundHandlerAdapter</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;        ctx.fireChannelRegistered();    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;        ctx.fireChannelUnregistered();   &#125;    </span><br><span class="line">    <span class="comment">//通道就绪事件  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;        ctx.fireChannelActive();    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;        ctx.fireChannelInactive();    &#125;</span><br><span class="line">    <span class="comment">//通道读取数据事件   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;        ctx.fireChannelRead(msg);    &#125;    </span><br><span class="line">    <span class="comment">//数据读取完毕事件    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;        ctx.fireChannelReadComplete();    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;        ctx.fireUserEventTriggered(evt);    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;        ctx.fireChannelWritabilityChanged();    &#125;   </span><br><span class="line">    <span class="comment">//通道发生异常事件   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;      ctx.fireExceptionCaught(cause);    &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Pipeline-和-ChannelPipeline"><a href="#Pipeline-和-ChannelPipeline" class="headerlink" title="Pipeline 和 ChannelPipeline"></a>Pipeline 和 ChannelPipeline</h3><p>ChannelPipeline 是一个 Handler 的集合，<strong>它负责处理和拦截 inbound 或者 outbound 的事件和操作</strong>，相当于一个贯穿 Netty 的链。(也可以这样理解：ChannelPipeline 是 保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作)</p><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty3/Pipeline.png" alt="image-20200803230749583" style="zoom:67%;"><p><strong>每个 Channel 都有且仅有一个 ChannelPipeline 与之对应</strong></p><ul><li>一个 Channel 包含了一个 ChannelPipeline，而 C<strong>hannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler</strong></li><li><strong>入站事件和出站事件在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ChannelPipeline <span class="title">addFirst</span><span class="params">(ChannelHandler... handlers)</span>，把一个业务处理类（handler）添加到链中的第一个位置</span></span><br><span class="line"><span class="function">ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler... handlers)</span>，把一个业务处理类（handler）添加到链中的最后一个位置</span></span><br></pre></td></tr></table></figure><h3 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h3><p>保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象<br>即ChannelHandlerContext 中 包 含 一 个 具 体 的 事 件 处 理 器 ChannelHandler ， 同 时ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler进行调用.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ChannelFuture <span class="title">close</span><span class="params">()</span>，关闭通道</span></span><br><span class="line"><span class="function">ChannelOutboundInvoker <span class="title">flush</span><span class="params">()</span>，刷新</span></span><br><span class="line"><span class="function">ChannelFuture <span class="title">writeAndFlush</span><span class="params">(Object msg)</span> ， 将 数 据 写 到 ChannelPipeline 中 当 前</span></span><br><span class="line"><span class="function">ChannelHandler 的下一个 ChannelHandler 开始处理（出站）</span></span><br></pre></td></tr></table></figure><h3 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h3><p>Netty 在创建 Channel 实例后,一般都需要设置 ChannelOption 参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ChannelOption.SO_BACKLOG</span><br><span class="line">对应 TCP/IP 协议 listen 函数中的 backlog 参数，用来初始化服务器可连接队列大小。服</span><br><span class="line">务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户</span><br><span class="line">端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog 参数指定</span><br><span class="line">了队列的大小。</span><br><span class="line"></span><br><span class="line">ChannelOption.SO_KEEPALIVE</span><br><span class="line">一直保持连接活动状态</span><br></pre></td></tr></table></figure><h3 id="EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="EventLoopGroup 和其实现类 NioEventLoopGroup"></a>EventLoopGroup 和其实现类 NioEventLoopGroup</h3><p>EventLoopGroup 是一组 EventLoop 的抽象，Netty 为了更好的利用多核 CPU 资源，一般会有多个 EventLoop 同时工作，每个 EventLoop 维护着一个 Selector 实例。</p><p>EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop来处理任务。在 Netty 服务器端编程中，我们一般都需要提供两个 EventLoopGroup，例如：BossEventLoopGroup 和 WorkerEventLoopGroup。</p><p>服务端口即一个 <strong>ServerSocketChannel对应一个Selector 和一个EventLoop线程。</strong>BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示</p><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty3/Blog\source\_posts\Netty3\EventLoop.png" alt="image-20200803233129359" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. BossEventLoopGroup 通常是一个单线程的 EventLoop，EventLoop 维护着一个注册了ServerSocketChannel 的 Selector 实例BossEventLoop 不断轮询 Selector 将连接事件分离出来</span><br><span class="line">2. 通常是 OP_ACCEPT 事件，然后将接收到的 SocketChannel 交给 WorkerEventLoopGroup</span><br><span class="line">3. WorkerEventLoopGroup 会由 next 选择其中一个 EventLoop来将这个 SocketChannel 注册到其维护的 Selector 并对其后续的 IO 事件进行处理</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span>，构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;?&gt; <span class="title">shutdownGracefully</span><span class="params">()</span>，断开连接，关闭线程</span></span><br></pre></td></tr></table></figure><h3 id="Unpooled-类"><a href="#Unpooled-类" class="headerlink" title="Unpooled 类"></a>Unpooled 类</h3><p>Netty 提供一个专门用来操作缓冲区(即Netty的数据容器)的工具类</p><p>通过给定的数据和字符编码返回一个 ByteBuf 对象（类似于 NIO 中的 ByteBuffer 但有区别）<br>public static ByteBuf copiedBuffer(CharSequence string, Charset charset)</p><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty3/Unpooled.png" alt="image-20200804103159601" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//创建一个ByteBuf</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 创建 对象，该对象包含一个数组arr , 是一个byte[10]</span></span><br><span class="line">        <span class="comment">//2. 在netty 的buffer中，不需要使用flip 进行反转</span></span><br><span class="line">        <span class="comment">//   底层维护了 readerindex 和 writerIndex</span></span><br><span class="line">        <span class="comment">//3. 通过 readerindex 和  writerIndex 和  capacity， 将buffer分成三个区域</span></span><br><span class="line">        <span class="comment">// 0---readerindex 已经读取的区域</span></span><br><span class="line">        <span class="comment">// readerindex---writerIndex ， 可读的区域</span></span><br><span class="line">        <span class="comment">// writerIndex -- capacity, 可写的区域</span></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;capacity=&quot;</span> + buffer.capacity());<span class="comment">//10</span></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line"><span class="comment">//        for(int i = 0; i&lt;buffer.capacity(); i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(buffer.getByte(i));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            System.out.println(buffer.readByte());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建ByteBuf</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello,world!&quot;</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用相关的方法</span></span><br><span class="line">        <span class="keyword">if</span>(byteBuf.hasArray()) &#123; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] content = byteBuf.array();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将 content 转成字符串</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(content, Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;byteBuf=&quot;</span> + byteBuf);</span><br><span class="line"></span><br><span class="line">            System.out.println(byteBuf.arrayOffset()); <span class="comment">// 0</span></span><br><span class="line">            System.out.println(byteBuf.readerIndex()); <span class="comment">// 0</span></span><br><span class="line">            System.out.println(byteBuf.writerIndex()); <span class="comment">// 12</span></span><br><span class="line">            System.out.println(byteBuf.capacity()); <span class="comment">// 36</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.out.println(byteBuf.readByte()); //</span></span><br><span class="line">            System.out.println(byteBuf.getByte(<span class="number">0</span>)); <span class="comment">// 104</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = byteBuf.readableBytes(); <span class="comment">//可读的字节数  12</span></span><br><span class="line">            System.out.println(<span class="string">&quot;len=&quot;</span> + len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用for取出各个字节</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>) byteBuf.getByte(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按照某个范围读取</span></span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">0</span>, <span class="number">4</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line">            System.out.println(byteBuf.getCharSequence(<span class="number">4</span>, <span class="number">6</span>, Charset.forName(<span class="string">&quot;utf-8&quot;</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Netty群聊系统"><a href="#Netty群聊系统" class="headerlink" title="Netty群聊系统"></a>Netty群聊系统</h2><ul><li>编写一个 Netty 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)</li></ul><p>服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理客户端的请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端启动对象</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//使用链式编程进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup,workGroup)<span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)  <span class="comment">//使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>) <span class="comment">//设置线程队列得到的连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="comment">//创建一个通道初始化对象</span></span><br><span class="line">                        <span class="comment">//给pipeline设置处理器</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//用个几个管理Socketchannel ,再推送消息时，可以将业务加入到各个channel对应的NIOEventLoop的TaskQueue</span></span><br><span class="line">                            <span class="comment">// 或者scheduleTaskQueue</span></span><br><span class="line">                            <span class="comment">//向pipeline解码器</span></span><br><span class="line"></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> StringDecoder()); <span class="comment">//增加处理器</span></span><br><span class="line">                            <span class="comment">//编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">//给workGroup 个Event对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;netty 服务器启动&quot;</span>);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(port).sync();</span><br><span class="line">            <span class="comment">//监听关闭</span></span><br><span class="line">            <span class="comment">//对关闭通道进行更新</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatServer(<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个channel组，管理所有的channel</span></span><br><span class="line">    <span class="comment">//GlobalEventExecutor 是全局的事件执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line"></span><br><span class="line">    SimpleDateFormat sdf =  <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MMM-dd HHH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当连接建立 第一个执行</span></span><br><span class="line">    <span class="comment">//将当前channel加入到 channelGroup</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//将该客户加入聊天的信息推送给其他在线的客户端</span></span><br><span class="line">        <span class="comment">//该方法会将所有的channel遍历，并发送</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span>+ channel.remoteAddress()+<span class="string">&quot;加入聊天&quot;</span>+sdf.format(<span class="keyword">new</span> java.util.Date()));</span><br><span class="line"></span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示channel处于一个活动的状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;上线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非活动状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;离线了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//断开连接，当前的channel会自动移除</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span>+ channel.remoteAddress()+<span class="string">&quot;离开了\n&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;channelGroup size=&quot;</span> + channelGroup.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取channel</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">//遍历，根据不同的情况，回送不同的信息</span></span><br><span class="line"></span><br><span class="line">        channelGroup.forEach(ch-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != ch )&#123; <span class="comment">//不是当前的</span></span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[客户]&quot;</span>+ channel.remoteAddress()+<span class="string">&quot;发送了消息:&quot;</span>+msg+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//自己发送的消息</span></span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[自己]发送了消息:&quot;</span>+msg+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//得到</span></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> StringDecoder()); <span class="comment">//增加处理器</span></span><br><span class="line">                            <span class="comment">//编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();</span><br><span class="line"></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;-------------&quot;</span>+channel.localAddress()+<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">            <span class="comment">//客户端需要输入信息</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="comment">//发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GroupChatClient(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7000</span>).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提升方法：单对单</p><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty3/群聊系统.png" alt="image-20200804150251534" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用一个hashmap管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Channel&gt; channelHashMap= <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="Netty心跳检测机制案例"><a href="#Netty心跳检测机制案例" class="headerlink" title="Netty心跳检测机制案例"></a>Netty心跳检测机制案例</h3><p> 当服务器超过3秒没有读时，就提示读空闲<br>当服务器超过5秒没有写操作时，就提示写空闲<br>实现当服务器超过7秒没有读或者写操作时，就提示读写空闲</p><p><strong>用来检测客户端在不知道的情况下出现了异常，服务器不知道，保证存活</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端启动对象</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//使用链式编程进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup,workGroup)<span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)  <span class="comment">//使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO)) <span class="comment">//增加一个日志处理器</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="comment">//创建一个通道初始化对象</span></span><br><span class="line">                        <span class="comment">//给pipeline设置处理器</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//用个几个管理Socketchannel ,再推送消息时，可以将业务加入到各个channel对应的NIOEventLoop的TaskQueue</span></span><br><span class="line">                            <span class="comment">// 或者scheduleTaskQueue</span></span><br><span class="line">                            <span class="comment">//向pipeline解码器</span></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//防止客户端异常退出，服务器无法感知</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line">                            <span class="comment">//加入一个netty 提供 IdleStateHandler</span></span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            说明</span></span><br><span class="line"><span class="comment">                            1. IdleStateHandler 是netty 提供的处理空闲状态的处理器</span></span><br><span class="line"><span class="comment">                            2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                            3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                            4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                            5. 文档说明</span></span><br><span class="line"><span class="comment">                            triggers an &#123;@link IdleStateEvent&#125; when a &#123;@link Channel&#125; has not performed</span></span><br><span class="line"><span class="comment">         * read, write, or both operation for a while.</span></span><br><span class="line"><span class="comment">         *                  6. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个handler去处理</span></span><br><span class="line"><span class="comment">         *                  通过调用(触发)下一个handler 的 userEventTiggered , 在该方法中去处理 IdleStateEvent(读空闲，写空闲，读写空闲)</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="comment">//加入一个对空闲检测进一步处理的handler(自定义)</span></span><br><span class="line"></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">//给workGroup 个Event对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;netty 服务器启动&quot;</span>);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            <span class="comment">//监听关闭</span></span><br><span class="line">            <span class="comment">//对关闭通道进行更新</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt 事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            <span class="comment">//向下转型</span></span><br><span class="line">            IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">            String eventType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (event.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    eventType = <span class="string">&quot;读写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;---超时事件是：&quot;</span>+eventType);</span><br><span class="line">            <span class="comment">//服务器做相应处理</span></span><br><span class="line">            <span class="comment">//如果发生空闲，我们关闭通道</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocket编程"><a href="#WebSocket编程" class="headerlink" title="WebSocket编程"></a>WebSocket编程</h2><p>Netty 通过WebSocket编程实现服务器和客户端长连接</p><ul><li>Http协议是无状态的, 浏览器和服务器间的请求响应一次，下一次会重新创建连接.</li><li>要求：实现基于webSocket的长连接的全双工的交互</li><li>改变Http协议多次请求的约束，实现长连接了， 服务器可以发送消息给浏览器</li><li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端启动对象</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//使用链式编程进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup,workGroup)<span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)  <span class="comment">//使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO)) <span class="comment">//增加一个日志处理器</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="comment">//创建一个通道初始化对象</span></span><br><span class="line">                        <span class="comment">//给pipeline设置处理器</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//用个几个管理Socketchannel ,再推送消息时，可以将业务加入到各个channel对应的NIOEventLoop的TaskQueue</span></span><br><span class="line">                            <span class="comment">// 或者scheduleTaskQueue</span></span><br><span class="line">                            <span class="comment">//向pipeline解码器</span></span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">//防止客户端异常退出，服务器无法感知</span></span><br><span class="line"></span><br><span class="line">                            <span class="comment">//基于http ,使用http的编码解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                            <span class="comment">//以块的方式写，添加chunkedWrite处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            说明</span></span><br><span class="line"><span class="comment">                            1.http的数据传输过程中是分段的，将多个段会聚合</span></span><br><span class="line"><span class="comment">                            2.为什么当浏览器发送大量数据时，会发出多次http请求</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            1.数据以帧（frame）的形式传递</span></span><br><span class="line"><span class="comment">                            2.webSocketFrame下面有6个子类</span></span><br><span class="line"><span class="comment">                            3.浏览器请求时 ws://localhost:7000/xxx 表示请求的url</span></span><br><span class="line"><span class="comment">                            4.核心功能将http协议升级为ws协议 ，保证长连接</span></span><br><span class="line"><span class="comment">                            5. 是通过一个 状态码 101</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line">                            <span class="comment">//自定义</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> MyTestWebSocketFrameHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">//给workGroup 个Event对应的管道设置处理器</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;netty 服务器启动&quot;</span>);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line">            <span class="comment">//监听关闭</span></span><br><span class="line">            <span class="comment">//对关闭通道进行更新</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TextWebSocketFrame表示一个文本帧</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTestWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接后会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//id表示唯一值 longText 唯一的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved 被调用&quot;</span> + ctx.channel().id().asLongText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常发生&quot;</span>+cause.getMessage());</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到消息 &quot;</span>+msg.text());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回复浏览器</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;服务器时间&quot;</span>+ LocalDateTime.now()+<span class="string">&quot; 返回&quot;</span>+msg.text()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> socket;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//判断当前浏览器是否支持websocket</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="built_in">window</span>.WebSocket) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//go on</span></span></span><br><span class="line"><span class="javascript">        socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:7000/hello&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//相当于channelReado, ev 收到服务器端回送的消息</span></span></span><br><span class="line"><span class="javascript">        socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> rt = <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="javascript">            rt.value = rt.value + <span class="string">&quot;\n&quot;</span> + ev.data;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//相当于连接开启(感知到连接开启)</span></span></span><br><span class="line"><span class="javascript">        socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> rt = <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="javascript">            rt.value = <span class="string">&quot;连接开启了..&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">//相当于连接关闭(感知到连接关闭)</span></span></span><br><span class="line"><span class="javascript">        socket.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> rt = <span class="built_in">document</span>.getElementById(<span class="string">&quot;responseText&quot;</span>);</span></span><br><span class="line"><span class="javascript">            rt.value = rt.value + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;连接关闭了..&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&quot;当前浏览器不支持websocket&quot;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//发送消息到服务器</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">message</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(!<span class="built_in">window</span>.socket) &#123; <span class="comment">//先判断socket是否创建好</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(socket.readyState == WebSocket.OPEN) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">//通过socket 发送消息</span></span></span><br><span class="line"><span class="javascript">            socket.send(message)</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;连接没有开启&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;发生消息&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;responseText&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 300px; width: 300px&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清空内容&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;document.getElementById(&#x27;responseText&#x27;).value=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编码和解码"><a href="#编码和解码" class="headerlink" title="编码和解码"></a>编码和解码</h2><p>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码</p><p>codec(编解码器) 的组成部分有两个：decoder(解码器)和 encoder(编码器)。encoder 负责把业务数据转换成字节码数据，decoder 负责把字节码数据转换成业务数据</p><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty3/编码和解码.png" alt="image-20200804194920583" style="zoom:67%;"><p>Netty 提供的编码器</p><ul><li>StringEncoder，对字符串数据进行编码</li><li>ObjectEncoder，对 Java 对象进行编码</li></ul><p>Netty 提供的解码器</p><ul><li><p>StringDecoder, 对字符串数据进行解码    </p></li><li><p>ObjectDecoder，对 Java 对象进行解码</p></li></ul><p><strong>Netty 本身自带的 ObjectDecoder 和 ObjectEncoder 可以用来实现 POJO 对象或各种业务对象的编码和解码，底层使用的仍是 Java 序列化技术 , 而Java 序列化技术本身效率就不高</strong></p><p>存在如下问题</p><ul><li><p>无法跨语言</p></li><li><p>序列化后的体积太大，是二进制编码的 5 倍多。</p></li><li><p>序列化性能太低<br>引出 新的解决方案 [Google 的 Protobuf]</p></li></ul><h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p> Google Protocol Buffers，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC[远程过程调用  remote procedure call ] 数据交换格式 。</p><p>http+json  tcp+protobuf</p><p>使用 protobuf 编译器能自动生成代码，Protobuf 是将类的定义使用.proto 文件进行描述。说明，在idea 中编写 .proto 文件时，会自动提示是否下载 .ptotot 编写插件. 可以让语法高亮。</p><h4 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h4><p>客户端可以发送一个Student  PoJo 对象到服务器 (通过 Protobuf 编码)<br>服务端能接收Student PoJo 对象，并显示信息(通过 Protobuf 解码)</p><p>1.导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.protobuf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Netty编解码器和handler的调用机制"><a href="#Netty编解码器和handler的调用机制" class="headerlink" title="Netty编解码器和handler的调用机制"></a>Netty编解码器和handler的调用机制</h2><p>netty的组件设计：Netty的主要组件有Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe等</p><p>ChannelHandler充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现ChannelInboundHandler接口（或ChannelInboundHandlerAdapter），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从ChannelInboundHandler冲刷数据。业务逻辑通常写在一个或者多个ChannelInboundHandler中。ChannelOutboundHandler原理一样，只不过它是用来处理出站数据的</p><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty3/handler.png" alt="image-20200804224334039" style="zoom:67%;"><p>ChannelPipeline提供了ChannelHandler链的容器。以客户端应用程序为例，<strong>如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过pipeline中的一系列ChannelOutboundHandler，并被这些Handler处理，</strong>反之则称为入站的</p><p><strong>出站和入站是对应不同端的</strong></p><h3 id="编码解码器"><a href="#编码解码器" class="headerlink" title="编码解码器"></a>编码解码器</h3><p>当Netty发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如java对象）；如果是出站消息，它会被编码成字节。</p><p>Netty提供一系列实用的编解码器，他们都实现了<strong>ChannelInboundHadnler或者ChannelOutboundHandler</strong>接口。在这些类中，channelRead方法已经被重写了。以入站为例，对于每个从入站Channel读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的decode()方法进行解码，并将已经解码的字节转发给ChannelPipeline中的下一个ChannelInboundHandler。</p><p>ByteToMessageDecoder解码器</p><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty3/ByteToMessageDecoder.png" alt="image-20200804225826086" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            out.add(in.readInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次入站从ByteBuf中读取4字节，将其解码为一个int，然后将它添加到下一个List中。当没有更多元素可以被添加到该List中时，它的内容将会被发送给下一个ChannelInboundHandler。int在被添加到List中时，会被自动装箱为Integer。在调用readInt()方法前必须验证所输入的ByteBuf是否具有足够的数据</p><h3 id="Netty的handler链的调用机制"><a href="#Netty的handler链的调用机制" class="headerlink" title="Netty的handler链的调用机制"></a>Netty的handler链的调用机制</h3><p>使用自定义的编码器和解码器来说明Netty的handler 调用机制<br>客户端发送long -&gt; 服务器<br>服务端发送long -&gt; 客户端</p><p>解码器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *decode 会根据数据被调用多次，直到确定每一新的元素添加到list ,或者ByteBuf没有可读</span></span><br><span class="line"><span class="comment">     * 如果list 不为空就传递给下一个channelinboundhandler  处理器也会调用多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 入站的ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out 集合 将解码后的数据传给下一个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;decode调用&quot;</span>);</span><br><span class="line">        <span class="comment">//Long 8 个字节</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; MyLongToByteEncoder encode 被调用&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;msg = &quot;</span>+msg);</span><br><span class="line">        out.writeLong(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建bossGroup和WorkerGroup</span></span><br><span class="line">        <span class="comment">//创建2个线程组 bossGroup处理连接请求，workGroup处理客户端业务处理</span></span><br><span class="line">        <span class="comment">//两个都是无限循环</span></span><br><span class="line">        <span class="comment">//boss和worker含有的子线程个数 默认CPU核数*2</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端启动对象</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup,workGroup)<span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)  <span class="comment">//使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyServerInitializer()); <span class="comment">//自定义初始化类</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器 is ready&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并同步</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行更新</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个netty提供的 codec =&gt;[coder - decoder]</span></span><br><span class="line">        <span class="comment">//入站的handler解码MyByteToLongDecoder</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder());</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line">        <span class="comment">//2.增加一个自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器业务处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;从客户端读取到&quot;</span>+ctx.channel().remoteAddress()+<span class="string">&quot;读取到long：&quot;</span>+msg);</span><br><span class="line">        <span class="comment">//给客户发送一Long</span></span><br><span class="line">        ctx.writeAndFlush(<span class="number">98765L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//客户端需要一个事件</span></span><br><span class="line">        NioEventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(eventExecutors) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">//设置客户端通道的实现类</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> MyClientInitializer());</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 ok..&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端连接</span></span><br><span class="line">            <span class="comment">//涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端处理器链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个出站的编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line">        <span class="comment">//入站的解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义handler 处理业务逻辑</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端业务处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;得到服务器ip=&quot;</span>+ctx.channel().remoteAddress()+<span class="string">&quot;：收到的消息为&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyClientHandler 发送数据&quot;</span>);</span><br><span class="line">        ctx.writeAndFlush(<span class="number">12345L</span>); <span class="comment">//发送的是一个Long</span></span><br><span class="line">        <span class="comment">//1.字符串是16个字节</span></span><br><span class="line">        <span class="comment">//2.处理器的前一个handler 是MyLongByteHandler</span></span><br><span class="line">        <span class="comment">//3.MyLongByteHandler 的父类是 MessageToByteEncoder</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</span></span><br><span class="line"><span class="comment">        ByteBuf buf = null;</span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            if (acceptOutboundMessage(msg)) &#123; //判断当前msg是不是我应该编码的类型 是我就处理</span></span><br><span class="line"><span class="comment">                @SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="comment">                I cast = (I) msg;</span></span><br><span class="line"><span class="comment">                buf = allocateBuffer(ctx, cast, preferDirect);</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    encode(ctx, cast, buf);</span></span><br><span class="line"><span class="comment">                &#125; finally &#123;</span></span><br><span class="line"><span class="comment">                    ReferenceCountUtil.release(cast);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                if (buf.isReadable()) &#123;</span></span><br><span class="line"><span class="comment">                    ctx.write(buf, promise);</span></span><br><span class="line"><span class="comment">                &#125; else &#123;</span></span><br><span class="line"><span class="comment">                    buf.release();</span></span><br><span class="line"><span class="comment">                    ctx.write(Unpooled.EMPTY_BUFFER, promise);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                buf = null;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                ctx.write(msg, promise);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125; catch (EncoderException e) &#123;</span></span><br><span class="line"><span class="comment">            throw e;</span></span><br><span class="line"><span class="comment">        &#125; catch (Throwable e) &#123;</span></span><br><span class="line"><span class="comment">            throw new EncoderException(e);</span></span><br><span class="line"><span class="comment">        &#125; finally &#123;</span></span><br><span class="line"><span class="comment">            if (buf != null) &#123;</span></span><br><span class="line"><span class="comment">                buf.release();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;abcdabcdefghefgh&quot;,CharsetUtil.UTF_8));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不论解码器handler 还是 编码器handler 即接收的消息类型必须与待处理的消息类型一致，否则该handler不会被执行</strong></p><p><strong>在解码器 进行数据解码时，需要判断 缓存区(ByteBuf)的数据是否足够 ，否则接收到的结果会期望结果可能不一致</strong></p><h3 id="解码器-ReplayingDecoder"><a href="#解码器-ReplayingDecoder" class="headerlink" title="解码器-ReplayingDecoder"></a>解码器-ReplayingDecoder</h3><p><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></p><p>ReplayingDecoder扩展了ByteToMessageDecoder类，<strong>使用这个类，我们不必调用readableBytes()方法</strong>。参数S指定了用户状态管理的类型，其中Void代表不需要状态管理</p><ul><li>并不是所有的 ByteBuf 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 UnsupportedOperationException。</li><li>ReplayingDecoder 在某些情况下可能稍慢于 ByteToMessageDecoder，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li></ul><h2 id="TCP-粘包和拆包"><a href="#TCP-粘包和拆包" class="headerlink" title="TCP 粘包和拆包"></a>TCP 粘包和拆包</h2><p><strong>TCP是面向连接的，面向流的，提供高可靠性服务</strong>。收发两端（客户端和服务器端）都要有一一成对的socket，因此，<strong>发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。</strong>这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为<strong>面向流的通信是无消息保护边界的</strong></p><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty3/TCP粘包.png" alt="image-20200805115555729" style="zoom:67%;"><ul><li>服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包</li><li>服务端一次接受到了两个数据包，D1和D2粘合在一起，称之为TCP粘包</li><li>服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为TCP拆包</li><li>服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。</li></ul><h3 id="TCP-粘包和拆包解决方案"><a href="#TCP-粘包和拆包解决方案" class="headerlink" title="TCP 粘包和拆包解决方案"></a>TCP 粘包和拆包解决方案</h3><p>使用自定义协议 + 编解码器 来解决<br>关键就是要解决 <strong>服务器端每次读取数据长度的问题,</strong> 这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的TCP 粘包、拆包 。</p><p>协议包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLen</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.len = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getContent() &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(<span class="keyword">byte</span>[] content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建bossGroup和WorkerGroup</span></span><br><span class="line">        <span class="comment">//创建2个线程组 bossGroup处理连接请求，workGroup处理客户端业务处理</span></span><br><span class="line">        <span class="comment">//两个都是无限循环</span></span><br><span class="line">        <span class="comment">//boss和worker含有的子线程个数 默认CPU核数*2</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端启动对象</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用链式编程进行设置</span></span><br><span class="line">            bootstrap.group(bossGroup,workGroup)<span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)  <span class="comment">//使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyServerInitializer()); <span class="comment">//自定义初始化类</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器 is ready&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并同步</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行更新</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageDecoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.增加一个自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyMessageDecoder decode 被调用&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        in.readBytes(content);</span><br><span class="line">        <span class="comment">//封装</span></span><br><span class="line">        MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">        messageProtocol.setContent(content);</span><br><span class="line">        messageProtocol.setLen(len);</span><br><span class="line">        out.add(messageProtocol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">        byte[] bytes = new byte[msg.readableBytes()];</span></span><br><span class="line"><span class="comment">        msg.readBytes(bytes);</span></span><br><span class="line"><span class="comment">        //将buffer</span></span><br><span class="line"><span class="comment">        String message = new String(bytes, Charset.forName(&quot;utf-8&quot;));</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;服务器接收到数据:&quot;+message);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;服务器接收到消息量:&quot;+(++this.count));</span></span><br><span class="line"><span class="comment">        //回送一个随机id</span></span><br><span class="line"><span class="comment">        ByteBuf byteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString()+&quot; &quot;, CharsetUtil.UTF_8);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ctx.writeAndFlush(byteBuf);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = msg.getLen();</span><br><span class="line">        <span class="keyword">byte</span>[] content = msg.getContent();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端接收到 &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;长度=&quot;</span>+len);</span><br><span class="line">        System.out.println(<span class="string">&quot;内容=&quot;</span>+<span class="keyword">new</span> String(content,CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器接收到消息量:&quot;</span>+(++<span class="keyword">this</span>.count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//客户端需要一个事件</span></span><br><span class="line">        NioEventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(eventExecutors) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">//设置客户端通道的实现类</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> MyClientInitializer());</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 ok..&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端连接</span></span><br><span class="line">            <span class="comment">//涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">7000</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyMessageEncoder());</span><br><span class="line">        <span class="comment">//自定义handler 处理业务逻辑</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyMessageEncoder encode 被调用&quot;</span>);</span><br><span class="line">        out.writeInt(msg.getLen());</span><br><span class="line">        out.writeBytes(msg.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用客户端发10条数据</span></span><br><span class="line">        String msg = <span class="string">&quot;今天天气冷，吃火锅&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] content = msg.getBytes(Charset.forName(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="keyword">int</span> len = msg.getBytes(Charset.forName(<span class="string">&quot;utf-8&quot;</span>)).length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建协议包</span></span><br><span class="line">            MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">            messageProtocol.setLen(len);</span><br><span class="line">            messageProtocol.setContent(content);</span><br><span class="line">            ctx.writeAndFlush(messageProtocol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">        byte[] buffer = new byte[msg.readableBytes()];</span></span><br><span class="line"><span class="comment">        msg.readBytes(buffer);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        String message = new String(buffer, Charset.forName(&quot;utf-8&quot;));</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;客户端接收到数据:&quot;+message);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;客户端接收到消息量:&quot;+(++this.count));</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty-Netty入门</title>
      <link href="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty2/"/>
      <url>/2020/08/03/%E6%A1%86%E6%9E%B6/Netty2/</url>
      
        <content type="html"><![CDATA[<h2 id="NIO存在的问题"><a href="#NIO存在的问题" class="headerlink" title="NIO存在的问题"></a>NIO存在的问题</h2><ul><li>NIO 的类库和 API 繁杂，使用麻烦：需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。<br>需要具备其他的额外技能：要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 NIO 程序。</li><li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。</li><li>JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。直到 JDK 1.7 版本该问题仍旧存在，没有被根本解决。</li></ul><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty2/Netty.png" alt="image-20200803083949686" style="zoom:67%;"><p>Netty 可以帮助你快速、简单的开发出一个网络应用，相当于简化和流程化了 NIO 的开发过程</p><p>Netty 是目前最流行的 NIO 框架，Netty 在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，知名的 Elasticsearch 、Dubbo 框架内部都采用了 Netty</p><p>netty 下载地址： <a href="https://bintray.com/netty/downloads/netty/">https://bintray.com/netty/downloads/netty/</a>  </p><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><ul><li><p>目前存在的线程模型有：</p><ul><li>传统阻塞 I/O 服务模型 </li><li>Reactor 模式</li></ul></li><li><p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现</p><ul><li>单 Reactor 单线程；</li><li>单 Reactor 多线程；</li><li>主从 Reactor 多线程 </li></ul></li><li><p>Netty 线程模式(Netty 主要基于主从 Reactor 多线程模型做了一定的改进，其中主从 Reactor 多线程模型有多个 Reactor)</p></li></ul><h3 id="传统阻塞-I-O-服务模型"><a href="#传统阻塞-I-O-服务模型" class="headerlink" title="传统阻塞 I/O 服务模型"></a>传统阻塞 I/O 服务模型</h3><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty2/传统IO模型.png" alt="image-20200803084923869" style="zoom:67%;"><p>黄色的框表示对象, 蓝色的框表示线程, 白色的框表示方法(API)</p><p>特点：</p><ul><li>采用阻塞IO模式获取输入的数据</li><li>每个连接都需要独立的线程完成数据的输入，业务处理,数据返回</li></ul><p>问题：</p><ul><li>当并发数很大，就会创建大量的线程，占用很大系统资源</li><li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read 操作，造成线程资源浪费</li></ul><h3 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h3><p>解决传统IO方法</p><p>基于 I/O 复用模型：<strong>多个连接共用一个阻塞对象</strong>，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。Reactor 对应的叫法: 1. 反应器模式 2. 分发者模式(Dispatcher) 3. 通知者模式(notifier)</p><p><strong>基于线程池复用线程资源</strong>：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</p><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty2/Reactor模型.png" alt="image-20200803085913369" style="zoom:67%;"><ul><li>Reactor 模式，通过一个或多个输入同时传递给服务处理器的模式(基于事件驱动)</li><li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程， 因此Reactor模式也叫 Dispatcher模式</li><li>Reactor 模式使用IO复用监听事件, 收到事件后，分发给某个线程(进程), 这点就是网络服务器高并发处理关键</li></ul><p>Reactor 模式中 核心组成：</p><ul><li>Reactor：<strong>Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。</strong> 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li><li>Handlers：<strong>处理程序执行 I/O 事件要完成的实际事件</strong>，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。</li></ul><h4 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h4><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty2/单Reactor单线程.png" alt="image-20200803090933171" style="zoom:67%;"><ol><li>Select 是前面 I/O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求</li><li>Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发</li><li>如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理</li><li>如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应</li><li>Handler 会完成 Read→业务处理→Send 的完整业务流程</li></ol><p><strong>优点</strong>：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成<br><strong>缺点</strong>：</p><ul><li>性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li><li>可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li></ul><p><strong>使用场景:</strong> 客户端的数量有限，业务处理非常快速，比如 Redis在业务处理的时间复杂度 O(1) 的情况</p><h4 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h4><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty2/单Reactor多线程.png" alt="image-20200803091842039" style="zoom:67%;"><ol><li>Reactor 对象通过select 监控客户端请求事件, 收到事件后，通过dispatch进行分发</li><li>如果建立连接请求, 则右Acceptor 通过accept 处理连接请求, 然后创建一个Handler对象处理完成连接后的各种事件</li><li>如果不是连接请求，则由reactor分发调用连接对应的handler 来处理</li><li><strong>handler 只负责响应事件</strong>，不做具体的业务处理, 通过read 读取数据后，会分发给后面的worker线程池的某个线程处理业务</li><li><strong>worker 线程池会分配独立线程完成真正的业务</strong>，并将结果返回给handler</li><li>handler收到响应后，通过send 将结果返回给client</li></ol><p><strong>优点</strong>：可以充分的利用多核cpu 的处理能力<br><strong>缺点</strong>：多线程数据共享和访问比较复杂， reactor 处理所有的事件的监听和响应，在单线程运行， 在高并发场景容易出现性能瓶颈.</p><h4 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h4><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty2/主从Reactor多线程.png" alt="image-20200803102053186" style="zoom:67%;"><ol><li>Reactor主线程 MainReactor 对象通过select 监听连接事件, 收到事件后，通过Acceptor 处理连接事件</li><li>当 Acceptor  处理连接事件后，MainReactor 将连接分配给SubReactor </li><li>subreactor 将连接加入到连接队列进行监听,并创建handler进行各种事件处理</li><li>当有新事件发生时， subreactor 就会调用对应的handler处理</li><li>handler 通过read 读取数据，分发给后面的worker 线程处理</li><li>worker 线程池分配独立的worker 线程进行业务处理，并返回结果</li><li>handler 收到响应的结果后，再通过send 将结果返回给client</li><li>Reactor 主线程可以对应多个Reactor 子线程, 即MainRecator 可以关联多个SubReactor</li></ol><p>优点：</p><ul><li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li><li>父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</li></ul><p>缺点：编程复杂度较高</p><h2 id="Netty模型"><a href="#Netty模型" class="headerlink" title="Netty模型"></a>Netty模型</h2><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty2/Netty模型.png" alt="image-20200803104427704" style="zoom:67%;"><ul><li>BossGroup 线程维护Selector , 只关注Accecpt</li><li>当接收到Accept事件，获取到对应的SocketChannel, 封装成 NIOScoketChannel并注册到Worker 线程(事件循环), 并进行维护</li><li>当Worker线程监听到selector 中通道发生自己感兴趣的事件后，就进行处理(就由handler)， 注意handler 已经加入到通道</li></ul><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty2/Netty模型进阶版.png" alt="image-20200803105335883" style="zoom:67%;"><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty2/Netty详细版.png" alt="image-20200803105550687" style="zoom:67%;"><ol><li><p>Netty抽象出两组线程池 <strong>BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写</strong>,BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup</p></li><li><p><strong>NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环</strong> ，每一个事件循环是 NioEventLoop</p></li><li><p>NioEventLoop <strong>表示一个不断循环的执行处理任务的线程</strong>， 每个NioEventLoop 都有一个selector , 用于监听绑定在其上的socket的网络通讯</p></li><li><p>NioEventLoopGroup 可以有多个线程, 即可以含有多个NioEventLoop</p></li><li><p>每个Boss NioEventLoop 循环执行的步骤有3步</p><ul><li><p>轮询accept 事件</p></li><li><p>处理accept 事件 , 与client建立连接 , 生成NioScocketChannel , 并将其注册到某个worker IOEventLoop 上的 selector </p></li><li><p>处理任务队列的任务 ， 即 runAllTasks</p></li></ul></li><li><p>每个 Worker NIOEventLoop 循环执行的步骤</p><ul><li><p>轮询read, write 事件</p></li><li><p>处理i/o事件， 即read , write 事件，在对应NioScocketChannel 处理</p></li><li><p>处理任务队列的任务 ， 即 runAllTasks</p></li></ul></li><li><p>每个Worker NIOEventLoop  处理业务时，<strong>会使用pipeline(管道), pipeline 中包含了 channel , 即通过pipeline 可以获取到对应通道, 管道中维护了很多的 处理器</strong></p></li></ol><h2 id="Netty入门案例"><a href="#Netty入门案例" class="headerlink" title="Netty入门案例"></a>Netty入门案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建bossGroup和WorkerGroup</span></span><br><span class="line">        <span class="comment">//创建2个线程组 bossGroup处理连接请求，workGroup处理客户端业务处理</span></span><br><span class="line">        <span class="comment">//两个都是无限循环</span></span><br><span class="line">        <span class="comment">//boss和worker含有的子线程个数 默认CPU核数*2</span></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//创建服务器端启动对象</span></span><br><span class="line">           ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//使用链式编程进行设置</span></span><br><span class="line">           bootstrap.group(bossGroup,workGroup)<span class="comment">//设置两个线程组</span></span><br><span class="line">                   .channel(NioServerSocketChannel.class)  <span class="comment">//使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                   .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>) <span class="comment">//设置线程队列得到的连接个数</span></span><br><span class="line">                   .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line">                   .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                       <span class="comment">//创建一个通道初始化对象</span></span><br><span class="line">                       <span class="comment">//给pipeline设置处理器</span></span><br><span class="line">                       <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                           ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler()); <span class="comment">//增加处理器</span></span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;); <span class="comment">//给workGroup 个Event对应的管道设置处理器</span></span><br><span class="line">           System.out.println(<span class="string">&quot;服务器 is ready&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//绑定一个端口并同步</span></span><br><span class="line">           ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//对关闭通道进行更新</span></span><br><span class="line">           cf.channel().closeFuture().sync();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           bossGroup.shutdownGracefully();</span><br><span class="line">           workGroup.shutdownGracefully();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.z4自定义一个handler ,需要继承netty规定好的适配器</span></span><br><span class="line"><span class="comment"> * 2.这是我们自定义的Handler,才能称为一个handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取数据事件，读取客户端发送的信息</span></span><br><span class="line">    <span class="comment">//上下文对象 ChannelHandlerContext  管道pipeline 业务逻辑，通道 读写</span></span><br><span class="line">    <span class="comment">// msg客户端发送的消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;server ctx = &quot;</span> +ctx);</span><br><span class="line">        <span class="comment">//将msg转成buffer ByteBuf 是Netty提供的， 不是NIO</span></span><br><span class="line">        ByteBuf byteBuf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送的消息是：&quot;</span>+byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端地址：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将数据写入缓存并刷新，一般将都要编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常，一般需要关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//客户端需要一个事件</span></span><br><span class="line">        NioEventLoopGroup eventExecutors = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            bootstrap.group(eventExecutors) <span class="comment">//设置线程组</span></span><br><span class="line">                    .channel(NioSocketChannel.class) <span class="comment">//设置客户端通道的实现类</span></span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());<span class="comment">//加入自己的处理器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端 ok..&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端连接</span></span><br><span class="line">            <span class="comment">//涉及到netty的异步模型</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//给关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通道有读取事件时会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息：&quot;</span>+buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器地址：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当通道就序就会触发该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client &quot;</span> +ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,server&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ctx包含了很多东西</p><p>channel和pipeline互相包含 一个对应一个</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><ul><li>用户程序自定义的普通任务 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取数据事件，读取客户端发送的信息</span></span><br><span class="line">    <span class="comment">//上下文对象 ChannelHandlerContext  管道pipeline 业务逻辑，通道 读写</span></span><br><span class="line">    <span class="comment">// msg客户端发送的消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//解决方案一</span></span><br><span class="line">        <span class="comment">//获取</span></span><br><span class="line">        ctx.channel().eventLoop().execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端2&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送异常&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ctx.channel().eventLoop().execute(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);  <span class="comment">//5+10s才发送</span></span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端3&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送异常&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//都是同一个线程在休眠的基础了在休眠</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;go on ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将数据写入缓存并刷新，一般将都要编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端1&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常，一般需要关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用户自定义定时任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取数据事件，读取客户端发送的信息</span></span><br><span class="line">    <span class="comment">//上下文对象 ChannelHandlerContext  管道pipeline 业务逻辑，通道 读写</span></span><br><span class="line">    <span class="comment">// msg客户端发送的消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//解决方案二 用户自定义定时任务 任务提交到 scheduleTaskQueue</span></span><br><span class="line">        ctx.channel().eventLoop().schedule(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);  <span class="comment">//5+10s才发送</span></span><br><span class="line">                ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端4&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送异常&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(<span class="string">&quot;go on ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据读取完毕</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将数据写入缓存并刷新，一般将都要编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端1&quot;</span>,CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理异常，一般需要关闭通道</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个任务会在5秒后开始 ，经过10秒结束</p><ul><li><p>非当前 Reactor 线程调用 Channel 的各种方法</p><p>例如在<strong>推送系统</strong>的业务线程里面，根据<strong>用户的标识</strong>，找到对应的 <strong>Channel 引用</strong>，然后调用 Write 类方法向该用户推送消息，就会进入到这种场景。最终的 Write 会提交到任务队列中后被<strong>异步消费</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用链式编程进行设置</span></span><br><span class="line">bootstrap.group(bossGroup,workGroup)<span class="comment">//设置两个线程组</span></span><br><span class="line">        .channel(NioServerSocketChannel.class)  <span class="comment">//使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">        .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>) <span class="comment">//设置线程队列得到的连接个数</span></span><br><span class="line">        .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>) <span class="comment">//设置保持活动连接状态</span></span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="comment">//创建一个通道初始化对象</span></span><br><span class="line">            <span class="comment">//给pipeline设置处理器</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;客户socketchannel hashcode= &quot;</span>+ch.hashCode());</span><br><span class="line">                <span class="comment">//用个几个管理Socketchannel ,再推送消息时，可以将业务加入到各个channel对应的NIOEventLoop的TaskQueue</span></span><br><span class="line">                <span class="comment">// 或者scheduleTaskQueue</span></span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler()); <span class="comment">//增加处理器</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;); <span class="comment">//给workGroup 个Event对应的管道设置处理器</span></span><br></pre></td></tr></table></figure><h2 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h2><ul><li><p>当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</p></li><li><p>Netty 中的 I/O 操作是异步的，包括 Bind、Write、Connect 等操作会简单的返回一个 ChannelFuture。</p></li><li><p><strong>调用者并不能立刻获得结果，而是通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果</strong></p></li><li><p>Netty 的异步模型是建立在 <strong>future 和 callback</strong> 的之上的。callback 就是回调。重点说 Future，它的核心思想是：假设一个方法 fun，计算过程可能非常耗时，等待 fun返回显然不合适。那么可以在调用 fun 的时候，立马返回一个 Future，后续可以通过 Future去监控方法 fun 的处理过程(即 ： Future-Listener 机制)</p></li></ul><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><ol><li>表示异步的执行结果, 可以通过它提供的方法来检测执行是否完成，比如检索计算等等.</li><li>ChannelFuture 是一个接口 ： <code>public interface ChannelFuture extends Future&lt;Void&gt;</code>我们可以添加监听器，当监听的事件发生时，就会通知到监听器. 案例说明</li></ol><img src="/2020/08/03/%E6%A1%86%E6%9E%B6/Netty2/异步模型.png" alt="image-20200803205525878" style="zoom:67%;"><p>在使用 Netty 进行编程时，拦截操作和转换出入站数据只需要您提供 callback 或利用future 即可。这使得<strong>链式操作简单、高效, 并有利于编写可重用的、通用的代码。</strong><br>Netty 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来</p><h3 id="Future-Listener-机制"><a href="#Future-Listener-机制" class="headerlink" title="Future-Listener 机制"></a>Future-Listener 机制</h3><p><strong>当 Future 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态，</strong>注册监听函数来执行完成后的操作。</p><ul><li>通过 isDone 方法来判断当前操作是否完成；</li><li>通过 isSuccess 方法来判断已完成的当前操作是否成功；</li><li>通过 getCause 方法来获取已完成的当前操作失败的原因；</li><li>通过 isCancelled 方法来判断已完成的当前操作是否被取消；</li><li>通过 addListener 方法来注册监听器，当操作已完成(isDone 方法返回完成)，将会通知指定的监听器；如果 Future 对象已完成，则通知指定的监听器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span>(future.isSuccess()) &#123;</span><br><span class="line">           System.out.println(newDate() + <span class="string">&quot;: 端口[&quot;</span>+ port + <span class="string">&quot;]绑定成功!&quot;</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           System.err.println(<span class="string">&quot;端口[&quot;</span>+ port + <span class="string">&quot;]绑定失败!&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p><p>相比传统阻塞 I/O，执行 I/O 操作后线程会被阻塞住, 直到操作完成；异步处理的好处是不会造成线程阻塞，线程在 I/O 操作期间可以执行别的程序，在高并发情形下会更稳定和更高的吞吐量</p><h2 id="HTTP服务-入门案例"><a href="#HTTP服务-入门案例" class="headerlink" title="HTTP服务 入门案例"></a>HTTP服务 入门案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端启动对象</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//使用链式编程进行设置</span></span><br><span class="line">            serverBootstrap.group(bossGroup,workGroup)<span class="comment">//设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)  <span class="comment">//使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> TestServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">7001</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行更新</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向管道加入处理器</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入一个netty提供的httpServerCodec codec =&gt;[coder - decoder]</span></span><br><span class="line">        <span class="comment">//1.netty提供的 httpServerCodec的编码解码器</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyHttpServerCodec&quot;</span>,<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        <span class="comment">//2.增加一个自定义的handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyTestHttpServerHandler&quot;</span>,<span class="keyword">new</span> TestHttpServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.SimpleChannelInboundHandler是ChannelInboundHandler的自来</span></span><br><span class="line"><span class="comment"> * 2.HttpObject表示客户端和服务器端相互通信的数据封装成HttpObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//当有读取事件时会触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//判断http是不是一个request请求</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;msg 类型=&quot;</span>+msg.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端的地址=&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取到</span></span><br><span class="line">            HttpRequest httpRequest = (HttpRequest) msg;</span><br><span class="line">            <span class="comment">//获取URL</span></span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(httpRequest.uri());</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath()))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;请求了图标不做相应&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回复信息给浏览器</span></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;hello,我是服务器&quot;</span>,CharsetUtil.UTF_8);</span><br><span class="line">            <span class="comment">//构造一个http响应 httpresponse</span></span><br><span class="line">            FullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/plain;charset=utf-8&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将构建好的response返回</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个请求一个handler</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-代理模式</title>
      <link href="/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h2><p>代理模式：为一个对象<strong>提供一个替身</strong>，以控制对这个对象的访问。即通过代理对象访问目标对象.这样做的<strong>好处是</strong>:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。</p><p>被代理的对象可以是<strong>远程对象</strong>、<strong>创建开销大的对</strong>象或<strong>需要安全控制的对象</strong></p><p>代理模式有不同的形式, 主要有三种 <strong>静态代理、动态代理 (JDK代理、接口代理)和 Cglib代理 (可以在内存动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴) 。</strong></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类 </p><ol><li><p>抽象角色：通过接口或抽象类声明真实角色实现的业务方法。</p></li><li><p>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。</p></li><li><p>真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p></li></ol><img src="/2020/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/角色关系.png" alt="image-20200801103924826" style="zoom:67%;"><ol><li><p>接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建目标对象和代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师授课中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理对象，静态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDaoProxy</span> <span class="keyword">implements</span> <span class="title">ITeacherDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ITeacherDao target; <span class="comment">//目标对象，通过接口来聚合</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TeacherDaoProxy</span><span class="params">(ITeacherDao target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理对象开始代理。。。&quot;</span>);</span><br><span class="line">        target.teach();</span><br><span class="line">        System.out.println(<span class="string">&quot;提交。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建调用类</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        TeacherDao teacherDao = <span class="keyword">new</span> TeacherDao();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理对象</span></span><br><span class="line">        TeacherDaoProxy teacherDaoProxy = <span class="keyword">new</span> TeacherDaoProxy(teacherDao);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过代理对象，调用被代理对象的方法</span></span><br><span class="line">        teacherDaoProxy.teach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*代理对象开始代理。。。</span></span><br><span class="line"><span class="comment">老师授课中</span></span><br><span class="line"><span class="comment">提交。。。。*/</span></span><br></pre></td></tr></table></figure><p><strong>静态代理的优缺点</strong></p><p><strong>优点</strong>：</p><ol><li><p>真实角色类（业务类）<strong>只需要关注业务逻辑本身</strong>，这是代理模式的共有优点；</p></li><li><p>代理类可以在调用业务类的处理方法之前和之后做一些增强性的操作，比如记录日志、管理事务等，这也是代理模式共有的优点。</p></li></ol><p><strong>缺点</strong>：</p><ol><li><p>代理类和业务类实现了相同的接口，并且实现了相同的方法，代码冗余。如果接口增加一个方法，所有的代理类和所有的实现类都需要增加这个方法的实现，不易维护；</p></li><li><p>代理对象只能代理同一种类型的对象，如果要对多种类型的对象进行代理，就要写多个代理类，这就会大大增加类文件的数量，不适合在大规模程序中使用。</p></li></ol><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>动态代理的代理类是在程序运行的时候由<strong>Java反射机制动态生成的</strong>。我们在上面静态代理的例子中，代理类是自己定义好的，在程序运行之前就已经编译完成。我们先来看下如何实现JDK的动态代理。</p><p>Java的 java.lang.reflect 包下提供了一个Proxy类和一个InvocationHandler接口，JDK动态代理的实现主要依靠这两个对象实现。</p><ol><li><p>接口和目标对象的创建如上</p></li><li><p>创建代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化target</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before invoke &quot;</span>  + method.getName());</span><br><span class="line">        Object invoke = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After invoke &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理类调用</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建被代理对象</span></span><br><span class="line">        ITeacherDao teacherDao = <span class="keyword">new</span> TeacherDao();</span><br><span class="line"></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> ProxyHandler(teacherDao);</span><br><span class="line"></span><br><span class="line">        ITeacherDao proxy = (ITeacherDao) Proxy.newProxyInstance(</span><br><span class="line">                teacherDao.getClass().getClassLoader(),</span><br><span class="line">                teacherDao.getClass().getInterfaces(),</span><br><span class="line">                handler);</span><br><span class="line"></span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line">        proxy.teach();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class com.sun.proxy.$Proxy0</span></span><br><span class="line"><span class="comment">Before invoke teach</span></span><br><span class="line"><span class="comment">老师授课中</span></span><br><span class="line"><span class="comment">After invoke teach</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Proxy.newProxyInstance()</span></span><br><span class="line"><span class="comment">//1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定</span></span><br><span class="line"><span class="comment">//2. Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型</span></span><br><span class="line"><span class="comment">//3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入,也可以用匿名内部类。</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="动态代理底层实现"><a href="#动态代理底层实现" class="headerlink" title="动态代理底层实现"></a>动态代理底层实现</h4><ol><li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li><li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li><li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li><li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li></ol><p>Proxy类的静态方newProxyInstance源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      InvocationHandler h)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     * 获取接口的代理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Throwable t = e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一行比较关键的代码，通过getProxyClass0()方法生成代理类Proxy的Class对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxyClassCache.get 方法就是通过工厂动态生成代理类文件，并将其放到缓存中</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>JDK为我们生成了一个“$Proxy0”的代理类，其中0代表编号，如果有多个代理类会依次递增。这个类继承了Proxy类，并且实现了我们定义的ITeacher接口，所以它会实现我们接口中定义的 teach 方法，在这个方法中，会调用 InvocationHandler 类中的 invoke 方法，通过上面分析我们知道，InvocationHandler 的 invoke 方法会通过反射调用被代理对象 target 的 method 方法，这就是代理类调用的真相。<strong>这个文件生成之后是放在内存中的，我们在创建代理类对象的时候，就是通过反射获得这个类文件的构造方法，然后创建代理实例。</strong></p><p>我们可以把 InvocationHandler 看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。</p><p>代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。</p><h3 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h3><p>静态代理和JDK代理模式都<strong>要求目标对象是实现一个接口</strong>,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候可<strong>使用目标对象子类来实现 代理-这就是Cglib代理</strong></p><ul><li>Cglib代理也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功</li></ul><p>能扩展, 有些书也将<strong>Cglib代理归属到动态代理</strong>。</p><ul><li>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接 口.它广泛的被许多AOP的框架使用,例如Spring AOP，实现方法拦截</li><li>在AOP编程中如何选择代理模式：<ul><li>目标对象需要实现接口，用JDK代理</li><li>目标对象不需要实现接口，用Cglib代理</li></ul></li></ul><p>5) Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类</p><ol><li>导入jar包 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.2</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>代理的类不能是final类</li><li>目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方</li></ul><ol start="2"><li><p>创建代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">teach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老师授课中,cglib代理不需要实现接口&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写方法拦截器。这个拦截器实现了MethodInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个代理对象，是target对象的代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxyInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个工具类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.设置父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3.设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//4.返回子类对象，即代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写intercept方法，会调用目标对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib代理开始&quot;</span>);</span><br><span class="line">        Object returnVal = method.invoke(target, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;Cglib代理结束&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建目标对象</span></span><br><span class="line">        TeacherDao target = <span class="keyword">new</span> TeacherDao();</span><br><span class="line">        <span class="comment">//获取到代理对象，并且将目标对象传递给代理对象</span></span><br><span class="line">        TeacherDao proxyInstance = (TeacherDao)<span class="keyword">new</span> ProxyFactory(target).getProxyInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行代理对象的方法，触发intecept 方法，从而实现 对目标对象的调用</span></span><br><span class="line">        String res = proxyInstance.teach();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Cglib代理开始</span></span><br><span class="line"><span class="comment"> 老师授课中  ， 我是cglib代理，不需要实现接口 </span></span><br><span class="line"><span class="comment">Cglib代理结束</span></span><br><span class="line"><span class="comment">res=hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="CGLib动态代理原理"><a href="#CGLib动态代理原理" class="headerlink" title="CGLib动态代理原理"></a>CGLib动态代理原理</h4><p>要实现CGLib的动态代理，我们必须要实现一个MethodInterceptor（方法拦截器）接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">intercept</span><span class="params">(Object var1, Method var2, Object[] var3, MethodProxy var4)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.第一个参数表示增强的对象，也就是实现这个接口的类的一个对象。</p><p>2.第二个参数表示要被拦截的方法。</p><p>3.第三个参数表示要被拦截的方法的参数。</p><p>4.第四个参数表示要触发父类的方法对象。</p><p>另外一个比较重要的对象是Enhancer。通过上面的例子我们看到，我们的代理类是通过Enhancer的create()方法生成的：通过反射生成代理对象</p><h3 id="JDK动态代理与CGLib动态代理的区别"><a href="#JDK动态代理与CGLib动态代理的区别" class="headerlink" title="JDK动态代理与CGLib动态代理的区别"></a>JDK动态代理与CGLib动态代理的区别</h3><p><strong>JDK动态代理</strong>：代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理，只能够代理实现了接口的委托类，底层使用反射机制进行方法的调用。</p><p><strong>CGLib动态代理</strong>：代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理。不能对final类以及final方法进行代理，底层将方法全部存入一个数组中，通过数组索引直接进行方法。</p><p>参考</p><p><a href="https://www.jianshu.com/p/9bcac608c714">https://www.jianshu.com/p/9bcac608c714</a><br><a href="https://baijiahao.baidu.com/s?id=1662496882632642298&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1662496882632642298&amp;wfr=spider&amp;for=pc</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty-NIO</title>
      <link href="/2020/07/31/%E6%A1%86%E6%9E%B6/Netty/"/>
      <url>/2020/07/31/%E6%A1%86%E6%9E%B6/Netty/</url>
      
        <content type="html"><![CDATA[<h2 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h2><p>Netty是一个<strong>异步</strong>、基于<strong>事件驱动</strong>的网络应用框架。<br>主要针对在TCP协议下面向Client端的高并发应用。<br>是一个NIO框架，适用于服务器。</p><img src="/2020/07/31/%E6%A1%86%E6%9E%B6/Netty/netty关系.png" alt="image-20200801221405273" style="zoom:67%;"><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>分布式系统中各节点远程过程调用（RPC：Dubbo）</li><li>游戏服务器</li><li>Hadoop通信</li></ul><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>用什么样的通道进行数据的发送和接收</p><ul><li>BIO：<strong>同步并阻塞</strong>(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</li><li>NIO：<strong>同步非阻塞</strong>，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理 </li><li>AIO：<strong>异步非阻塞</strong>，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。（没有得到应用）</li></ul><h3 id="BIO、NIO、AIO适用场景"><a href="#BIO、NIO、AIO适用场景" class="headerlink" title="BIO、NIO、AIO适用场景"></a>BIO、NIO、AIO适用场景</h3><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</p><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。</p><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>Java BIO（blocking I/O） 就是传统的java io 编程，其相关的类和接口在 java.io </p><h3 id="BIO编程简单流程"><a href="#BIO编程简单流程" class="headerlink" title="BIO编程简单流程"></a>BIO编程简单流程</h3><ul><li>服务器端启动一个ServerSocket</li><li>客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯</li><li>客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</li><li>如果有响应，客户端线程会等待请求结束后，在继续执行</li></ul><p>实例：</p><ol><li>编写一个简单的BIO服务器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建一个线程池</span></span><br><span class="line">        <span class="comment">//2.如果有客户连接就创建一个线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一线程池</span></span><br><span class="line">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//等待客户端连接</span></span><br><span class="line">            <span class="keyword">final</span> Socket accept = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line">            <span class="comment">//创建一个线程，与之通讯</span></span><br><span class="line">            newCachedThreadPool.execute( () -&gt; &#123;</span><br><span class="line">                <span class="comment">//重写Runable 和客户端通讯</span></span><br><span class="line">                handler(accept);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一个可以和客户端通讯的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程信息 id=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;名字&quot;</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//获取输入流</span></span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">int</span> read;</span><br><span class="line">            <span class="keyword">while</span> ((read = is.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span> ,read));  <span class="comment">//客户端发送的数据</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭socket&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>使用windos的telnet进行调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 6666</span><br><span class="line"></span><br><span class="line">ctrl+]</span><br><span class="line"></span><br><span class="line">seng msg</span><br></pre></td></tr></table></figure><img src="/2020/07/31/%E6%A1%86%E6%9E%B6/Netty/BIO运行.png" alt="image-20200801232001047" style="zoom: 67%;"></li></ol><ul><li>每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。</li><li>当并发数较大时，<strong>需要创建大量线程来处理连接</strong>，系统资源占用较大。</li><li><strong>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费</strong></li></ul><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>Non-Blocking IO：<strong>同步非阻塞</strong>，一个请求一个线程，但连接请求都是先注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程处理。</p><p>NIO 有三大核心部分：<strong>Channel(通道)，Buffer(缓冲区), Selector(选择器)</strong> </p><p><strong>NIO是 面向缓冲区 ，或者面向块编程的。</strong>数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络</p><img src="/2020/07/31/%E6%A1%86%E6%9E%B6/Netty/NIO.png" alt="image-20200801233632653" style="zoom: 50%;"><ul><li>一个Channel对应一个Buffer，一个Selector管理多个Channel，一个线程对应一个Selector</li><li>程序切换到哪个Channel由事件决定，Event</li><li>Buffer就是一个内存块，底层是数组。Client通过Buffer进行数据的读写，NIO中的Buffer是双向的，BIO中的输入流、输出流不是双向的。</li><li>Channel也是双向的</li></ul><p>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</p><h3 id="NIO-和-BIO-的比较"><a href="#NIO-和-BIO-的比较" class="headerlink" title="NIO 和 BIO 的比较"></a>NIO 和 BIO 的比较</h3><ul><li><strong>BIO 以流的方式处理数据,而 NIO 以块的方式处理数据</strong>,块 I/O 的效率比流 I/O 高很多</li><li>BIO 是阻塞的，NIO 则是非阻塞的</li><li><strong>BIO基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作</strong>，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道 </li></ul><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，<strong>可以理解成是一个容器对象(含数组)</strong>，该对象<strong>提供了一组方法</strong>，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer</p><p>四个属性</p><ul><li>mark ： 标记</li><li>position ： 位置，下一次要读写的元素的位置。</li><li>limit ： 缓冲区的终点，不能超过缓冲区的最大位置，可以修改</li><li>capacity ：容量，缓冲区创建时指定,不能改变</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//buffer使用</span></span><br><span class="line">        IntBuffer intBuffer = IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intBuffer.capacity(); i++)&#123;</span><br><span class="line">            intBuffer.put(i*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从buffer读取数据,读写切换</span></span><br><span class="line">        intBuffer.flip();</span><br><span class="line">        <span class="keyword">while</span> (intBuffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据存放在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储数据的数组</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] hb;                  <span class="comment">// Non-null only for heap buffers</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="comment">// 是否只读</span></span><br><span class="line">    <span class="keyword">boolean</span> isReadOnly;</span><br></pre></td></tr></table></figure><p>读数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intBuffer.flip();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        limit = position;</span><br><span class="line">        position = <span class="number">0</span>;</span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h4><p>最常用的自然是ByteBuffer 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">( )</span></span>;<span class="comment">//从当前位置position上get，get之后，position会自动+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;<span class="comment">//从绝对位置get</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">byte</span> b)</span></span>;<span class="comment">//从当前位置上添加，put之后，position会自动+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span> <span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;<span class="comment">//从绝对位置上put</span></span><br></pre></td></tr></table></figure><h4 id="clear-、rewind-、flip"><a href="#clear-、rewind-、flip" class="headerlink" title="clear()、rewind()、flip()"></a>clear()、rewind()、flip()</h4><p>clear()方法<strong>用于写模式</strong>，其作用为情况Buffer中的内容，所谓清空是指写上限与Buffer的真实容量相同，即limit==capacity,同时将当前写位置置为最前端下标为0处。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123; </span><br><span class="line">         position = <span class="number">0</span>; <span class="comment">//设置当前下标为0</span></span><br><span class="line">         limit = capacity; <span class="comment">//设置写越界位置与和Buffer容量相同</span></span><br><span class="line">         mark = -<span class="number">1</span>; <span class="comment">//取消标记</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>rewind()在读写模式下都可用，它单纯的将当前位置置0，同时取消mark标记，仅此而已；</strong>也就是说写模式下limit仍保持与Buffer容量相同，只是重头写而已；读模式下limit仍然与rewind()调用之前相同，也就是为flip()调用之前写模式下的position的最后位置，flip()调用后此位置变为了读模式的limit位置，即越界位置，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        position = <span class="number">0</span>; </span><br><span class="line">        mark = -<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>flip()函数的作用是将写模式转变为读模式</strong>，即将写模式下的Buffer中内容的最后位置变为读模式下的limit位置，作为读越界位置，同时将当前读位置置为0，表示转换后重头开始读，同时再消除写模式下的mark标记，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        limit = position; </span><br><span class="line">        position = <span class="number">0</span>; </span><br><span class="line">        mark = -<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲:</li><li><code>public interface Channel extends Closeable&#123;&#125;</code></li><li>常用的 Channel 类有：FileChannel、DatagramChannel、ServerSocketChannel 和 SocketChannel。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</li></ul><h4 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h4><p>本地文件写数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E:\\java\\NettyPro\\src\\main\\java\\com\\lq\\nio\\file01.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对应的FileChannel</span></span><br><span class="line">        FileChannel channel = fileOutputStream.getChannel();</span><br><span class="line">        <span class="comment">//创建一个缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//将String写入buffer</span></span><br><span class="line">        byteBuffer.put(str.getBytes());</span><br><span class="line">        <span class="comment">//对buffer进行flip</span></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="comment">//将buffer数据写入channel</span></span><br><span class="line">        channel.write(byteBuffer);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel是FileOutputStream一个属性。</p><p>本地文件读数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\java\\NettyPro\\src\\main\\java\\com\\lq\\nio\\file02.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//创建输入流</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">//获取对应的FileChannel</span></span><br><span class="line">        FileChannel fileChannel = fileInputStream.getChannel();</span><br><span class="line">        <span class="comment">//创建一个缓冲区</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate((<span class="keyword">int</span>) file.length());</span><br><span class="line">        <span class="comment">//将通道数去读入到buffer中</span></span><br><span class="line">        fileChannel.read(byteBuffer);</span><br><span class="line">        <span class="comment">//对buffer的字节转换成String</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(byteBuffer.array()));</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个Buffer完成文件读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">&quot;E:\\java\\NettyPro\\src\\main\\java\\com\\lq\\nio\\file02.txt&quot;</span>);</span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">&quot;E:\\java\\NettyPro\\src\\main\\java\\com\\lq\\nio\\file03.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line">        FileChannel fileChannel01 = fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file2);</span><br><span class="line">        FileChannel fileChannel02 = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">//循环读取</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里有一个重要的操作，一定不要忘了</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             public final Buffer clear() &#123;</span></span><br><span class="line"><span class="comment">                position = 0;</span></span><br><span class="line"><span class="comment">                limit = capacity;</span></span><br><span class="line"><span class="comment">                mark = -1;</span></span><br><span class="line"><span class="comment">                return this;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            byteBuffer.clear(); <span class="comment">//清空buffer</span></span><br><span class="line">            <span class="keyword">int</span> read = fileChannel01.read(byteBuffer);</span><br><span class="line">            System.out.println(<span class="string">&quot;read =&quot;</span> + read);</span><br><span class="line">            <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123; <span class="comment">//表示读完</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将buffer 中的数据写入到 fileChannel02</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            fileChannel02.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭相关的流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝文件transferFrom 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">&quot;E:\\java\\NettyPro\\src\\main\\java\\com\\lq\\nio\\图片1.png&quot;</span>);</span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">&quot;E:\\java\\NettyPro\\src\\main\\java\\com\\lq\\nio\\图片2.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line">        FileChannel sourceCh = fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file2);</span><br><span class="line">        FileChannel destCh = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用trransfrom完成拷贝</span></span><br><span class="line">        destCh.transferFrom(sourceCh,<span class="number">0</span>,sourceCh.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭相关的流</span></span><br><span class="line">        sourceCh.close();</span><br><span class="line">        destCh.close();;</span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Buffer和Channel注意事项"><a href="#Buffer和Channel注意事项" class="headerlink" title="Buffer和Channel注意事项"></a>Buffer和Channel注意事项</h4><ul><li>ByteBuffer 支持类型化的put 和 get, put 放入的是什么数据类型，get就应该使用相应的数据类型来取出，<strong>否则可能有 BufferUnderflowException 异常。</strong></li><li>可以将一个普通Buffer 转成只读Buffer </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只读Buffer，不可写，否则会报ReadOnlyBufferException</span></span><br><span class="line">ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();</span><br></pre></td></tr></table></figure><ul><li><p>MappedByteBuffer可以直接在内存（堆外内存）中修改，操作系统不需要拷贝一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;E:\\java\\NettyPro\\src\\main\\java\\com\\lq\\nio\\file01.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//获取对应通道</span></span><br><span class="line">        FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1： 读写模式</span></span><br><span class="line"><span class="comment">         * 参数2： 0可以直接修改的起始位置</span></span><br><span class="line"><span class="comment">        * 参数3： 映射到内存的大小，将文件的多少个自己映射到内存，最多修改5个字节</span></span><br><span class="line"><span class="comment">         * 实际位置DirectByteBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        mappedByteBuffer.put(<span class="number">0</span>,(<span class="keyword">byte</span>)<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">        mappedByteBuffer.put(<span class="number">3</span>,(<span class="keyword">byte</span>)<span class="string">&#x27;L&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        randomAccessFile.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>NIO支持多个Buffer的Scatting和Gathering</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scattering：将数据写入到buffer时，可以采用buffer数组，依次写入  [分散]</span></span><br><span class="line"><span class="comment"> * Gathering: 从buffer读取数据时，可以采用buffer数组，依次读</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScatteringAndGatheringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span></span><br><span class="line"></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">7000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定端口到socket ，并启动</span></span><br><span class="line">        serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建buffer数组</span></span><br><span class="line">        ByteBuffer[] byteBuffers = <span class="keyword">new</span> ByteBuffer[<span class="number">2</span>];</span><br><span class="line">        byteBuffers[<span class="number">0</span>] = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">        byteBuffers[<span class="number">1</span>] = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等客户端连接(telnet)</span></span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">        <span class="keyword">int</span> messageLength = <span class="number">8</span>;   <span class="comment">//假定从客户端接收8个字节</span></span><br><span class="line">        <span class="comment">//循环的读取</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> byteRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (byteRead &lt; messageLength ) &#123;</span><br><span class="line">                <span class="keyword">long</span> l = socketChannel.read(byteBuffers);</span><br><span class="line">                byteRead += l; <span class="comment">//累计读取的字节数</span></span><br><span class="line">                System.out.println(<span class="string">&quot;byteRead=&quot;</span> + byteRead);</span><br><span class="line">                <span class="comment">//使用流打印, 看看当前的这个buffer的position 和 limit</span></span><br><span class="line">                Arrays.asList(byteBuffers).stream().map(buffer -&gt; <span class="string">&quot;postion=&quot;</span> + buffer.position() + <span class="string">&quot;, limit=&quot;</span> + buffer.limit()).forEach(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将所有的buffer进行flip</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将数据读出显示到客户端</span></span><br><span class="line">            <span class="keyword">long</span> byteWirte = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (byteWirte &lt; messageLength) &#123;</span><br><span class="line">                <span class="keyword">long</span> l = socketChannel.write(byteBuffers); <span class="comment">//</span></span><br><span class="line">                byteWirte += l;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将所有的buffer 进行clear</span></span><br><span class="line">            Arrays.asList(byteBuffers).forEach(buffer-&gt; &#123;</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;byteRead:=&quot;</span> + byteRead + <span class="string">&quot; byteWrite=&quot;</span> + byteWirte + <span class="string">&quot;, messagelength&quot;</span> + messageLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个buffer不够是可以使用多个buffer进行聚合</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><ul><li><p><strong>Selector 能够检测多个注册的通道上是否有事件发生(注意:多个Channel以事件的方式可以注册到同一个Selector)，</strong>如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。</p></li><li><p>只有通道真正有读写事件发生时，才会进行读写。减少了创建的线程数，降低了系统开销</p></li><li><p>减少了上下文的切换，用户态和系统态的切换</p></li><li><p>线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。<br>由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Selector implements Closeable &#123; </span><br><span class="line">    public static Selector open();//得到一个选择器对象</span><br><span class="line">    public int select(long timeout);//监控所有注册的通道，当其中有 IO 操作可以进行时，将</span><br><span class="line">    对应的 SelectionKey 加入到内部集合中并返回，参数用来设置超时时间</span><br><span class="line">    public Set&lt;SelectionKey&gt; selectedKeys();//从内部集合中得到所有的 SelectionKey</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SelectionKey 判断这个key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract SelectableChannel channel();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">api</span><br><span class="line">selector.select()<span class="comment">//阻塞</span></span><br><span class="line">selector.select(<span class="number">1000</span>);<span class="comment">//阻塞1000毫秒，在1000毫秒后返回</span></span><br><span class="line">selector.wakeup();<span class="comment">//唤醒selector</span></span><br><span class="line">selector.selectNow();<span class="comment">//不阻塞，立马返还</span></span><br></pre></td></tr></table></figure><img src="/2020/07/31/%E6%A1%86%E6%9E%B6/Netty/网络编程相关.png" alt="image-20200802165116084" style="zoom:67%;"><p>对图片的说明</p><ol><li>当客户端连接时，会通过ServerSocketChannel 得到 SocketChannel</li><li>Selector 进行监听  select 方法, 返回有事件发生的通道的个数.</li><li>将socketChannel注册到Selector上, register(Selector sel, int ops), 一个selector上可以注册多个SocketChannel</li><li>注册后返回一个 SelectionKey, 会和该Selector 关联(集合)</li><li>进一步得到各个 SelectionKey (有事件发生)</li><li>在通过 SelectionKey  反向获取 SocketChannel , 方法 channel()</li><li>可以通过  得到的 channel  , 完成业务处理</li></ol><p>一个简单的服务器客户程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//創建</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//得到一個select对象</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//绑定端口</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//设为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把serverSocketChannel注册到 selector 关心事件为OP_ACCEPT</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环获取客户连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">1000</span>) == <span class="number">0</span>)&#123; <span class="comment">//阻塞1s没有时间发生</span></span><br><span class="line">                System.out.println(<span class="string">&quot;服务器等了1秒&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有事件,获取到selectionKey集合</span></span><br><span class="line">            <span class="comment">//1.返回&gt;0，表示获取到关注的事件</span></span><br><span class="line">            <span class="comment">//2.selector.selectedKeys 获取返回的事件集合 反向获取通道</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//使用迭代器</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext())&#123;</span><br><span class="line">                <span class="comment">//获取selectKey</span></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="comment">//获取对应的时间</span></span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123; <span class="comment">//如果是 OP_ACCEPT, 有新的客户端连接</span></span><br><span class="line">                    <span class="comment">//该该客户端生成一个 SocketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接成功 生成了一个 socketChannel &quot;</span> + socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将  SocketChannel 设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">//将socketChannel 注册到selector, 关注事件为 OP_READ， 同时给socketChannel</span></span><br><span class="line">                    <span class="comment">//关联一个Buffer</span></span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;客户端连接后 ，注册的selectionkey 数量=&quot;</span> + selector.keys().size()); <span class="comment">//2,3,4..</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(key.isReadable()) &#123;  <span class="comment">//发生 OP_READ</span></span><br><span class="line">                    <span class="comment">//通过key 反向获取到对应channel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取到该channel关联的buffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer)key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;form 客户端 &quot;</span> + <span class="keyword">new</span> String(buffer.array()));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//手动从集合中移除selectionKey，防止重复操作</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的ip和端口</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span> (!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">            <span class="keyword">while</span> (!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;因为连接需要时间，客户端不会阻塞，可以做其它工作.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接成功发数据</span></span><br><span class="line">        <span class="comment">//...如果连接成功，就发送数据</span></span><br><span class="line">        String str = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">        <span class="comment">//Wraps a byte array into a buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line">        <span class="comment">//发送数据，将 buffer 数据写入 channel</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h4><p>表示 Selector 和网络通道的注册关系, 共四种:</p><p>int OP_ACCEPT：有新的网络连接可以 accept，值为 16<br>int OP_CONNECT：代表连接已经建立，值为 8<br>int OP_READ：代表读操作，值为 1<br>int OP_WRITE：代表写操作，值为 4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">源码中：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>selector.keys()获取所有注册的key</p><p>selector.selectedKeys() 获取发送事件的key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class SelectionKey &#123;</span><br><span class="line">     public abstract Selector selector();//得到与之关联的 Selector 对象</span><br><span class="line">public abstract SelectableChannel channel();//得到与之关联的通道</span><br><span class="line">public final Object attachment();//得到与之关联的共享数据</span><br><span class="line">public abstract SelectionKey interestOps(int ops);//设置或改变监听事件</span><br><span class="line">public final boolean isAcceptable();//是否可以 accept</span><br><span class="line">public final boolean isReadable();//是否可以读</span><br><span class="line">public final boolean isWritable();//是否可以写</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h4><p><strong>在服务器端监听新的客户端 Socket 连接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span>   <span class="keyword">implements</span> <span class="title">NetworkChannel</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span>，得到一个 ServerSocketChannel 通道</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span>，设置服务器端端口号</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span>，设置阻塞或非阻塞模式，取值 <span class="keyword">false</span> 表示采用非阻塞模式</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span>，接受一个连接，返回代表这个连接的通道对象</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span>，注册一个选择器并设置监听事件</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p><strong>要在Selector上注册必须是非阻塞的，否则会抛出异常</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置非阻塞</span><br><span class="line">listenChannel.configureBlocking(false);</span><br></pre></td></tr></table></figure><h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><p>SocketChannel，网络 IO 通道，<strong>具体负责进行读写操作</strong>。NIO 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannel</span> <span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span>  <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">NetworkChannel</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span></span>;<span class="comment">//得到一个 SocketChannel 通道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span>;<span class="comment">//设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress remote)</span></span>;<span class="comment">//连接服务器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span></span>;<span class="comment">//如果上面的方法连接失败，接下来就要通过该方法完成连接操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span></span>;<span class="comment">//往通道里写数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span></span>;<span class="comment">//从通道里读数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span>;<span class="comment">//注册一个选择器并设置监听事件，最后一个参数可以设置共享数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;<span class="comment">//关闭通道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="群聊系统"><a href="#群聊系统" class="headerlink" title="群聊系统"></a>群聊系统</h3><ol><li><p>写一个 NIO 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</p></li><li><p>实现多人群聊</p></li><li><p>服务器端：可以监测用户上线，离线，并实现消息转发功能</p></li><li><p>客户端：通过channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(有服务器转发得到)</p></li></ol><ol><li><p>先编写服务器端</p><p>1.1服务器启动并监听6667</p><p>1.2服务器接收客户端消息并实现转发（转发时排除自己）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//注册</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环监听</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;<span class="comment">//有事件处理</span></span><br><span class="line">                    <span class="comment">//遍历得到的selectionKey集合</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                        <span class="comment">//取出</span></span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="comment">//监听accept</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                            SocketChannel sc = listenChannel.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="keyword">false</span>);<span class="comment">//设置非阻塞</span></span><br><span class="line">                            sc.register(selector,SelectionKey.OP_READ);</span><br><span class="line">                            <span class="comment">//设置非阻塞</span></span><br><span class="line">                            System.out.println(sc.getRemoteAddress()+ <span class="string">&quot;上线&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable())&#123; <span class="comment">//通道可读的状态</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//当前的key删除，防止重复操作</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端消息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义一个SocketChannel</span></span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建缓冲</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> count = channel.read(buffer);</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//把缓冲区的数据转成字符串</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                <span class="comment">//输出</span></span><br><span class="line">                System.out.println(<span class="string">&quot;from 客户端：&quot;</span> + msg.trim());</span><br><span class="line">                <span class="comment">//向其他客户端发送信息</span></span><br><span class="line">                sendInfoToOtherClient(msg,channel);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress()+ <span class="string">&quot;离线了&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.channel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给客户（通道）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoToOtherClient</span><span class="params">(String msg, SocketChannel self)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器转发消息&quot;</span>);</span><br><span class="line">        <span class="comment">//所有注册到selector的</span></span><br><span class="line">        Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : keys) &#123;</span><br><span class="line">            <span class="comment">//取出对应的channel</span></span><br><span class="line">            Channel targetChannel = key.channel();</span><br><span class="line">            <span class="comment">//排除自己的  先排除服务器的，在排除自己的</span></span><br><span class="line">            <span class="keyword">if</span> (targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp;targetChannel != self)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//转型</span></span><br><span class="line">                SocketChannel dest = (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">//将msg存储buffer</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">                <span class="comment">//将buffer数据写入通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建服务器对象</span></span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>客户端</p><p>2.1 连接服务器</p><p>2.2 发送消息</p><p>2.3接收消息</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成初始化工作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        socketChannel = socketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST,PORT));</span><br><span class="line">        <span class="comment">//非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//祖册</span></span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        <span class="comment">//得到username</span></span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username+ <span class="string">&quot; is ok ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String info)</span></span>&#123;</span><br><span class="line">        info = username + <span class="string">&quot;说：&quot;</span> +info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes()));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reaInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> select = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (select &gt; <span class="number">0</span>)&#123; <span class="comment">//有事件发生的通道</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">//得到一个buffer</span></span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把缓冲区的数据转换成字符串</span></span><br><span class="line">                        String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//启动客户端</span></span><br><span class="line">        GroupChatClient chatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动一个线程,每隔3秒，读取从服务器发送的数据</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                chatClient.reaInfo();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine())&#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>idea开启 parallel run可以同时启动多个</p><h3 id="NIO与零拷贝"><a href="#NIO与零拷贝" class="headerlink" title="NIO与零拷贝"></a>NIO与零拷贝</h3><p>零拷贝是网络编程的关键，很多性能优化都离不开。</p><p>在 Java 程序中，常用的零拷贝有 mmap(内存映射) 和 sendFile。那么，他们在 OS 里，到底是怎么样的一个的设计？我们分析 mmap 和 sendFile 这两个零拷贝</p><h4 id="传统IO数据读写"><a href="#传统IO数据读写" class="headerlink" title="传统IO数据读写"></a>传统IO数据读写</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">raf.read(arr);</span><br><span class="line"></span><br><span class="line">Socket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure><p><img src="/2020/07/31/%E6%A1%86%E6%9E%B6/Netty/%E4%BC%A0%E7%BB%9FIO.png" alt="image-20200802230755611"></p><p>DMA: direct memory access直接内存拷贝(不使用CPU)</p><p>4次拷贝 3次切换</p><h4 id="mmap-优化"><a href="#mmap-优化" class="headerlink" title="mmap 优化"></a>mmap 优化</h4><p>将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户控件的拷贝次数。</p><p><img src="/2020/07/31/%E6%A1%86%E6%9E%B6/Netty/mmap%E4%BC%98%E5%8C%96.png" alt="image-20200802231233781"></p><p>3次拷贝 3次切换</p><h4 id="sendFile-优化"><a href="#sendFile-优化" class="headerlink" title="sendFile 优化"></a>sendFile 优化</h4><p>Linux 2.1 版本 提供了 sendFile 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换</p><p><img src="/2020/07/31/%E6%A1%86%E6%9E%B6/Netty/sendFile.png" alt="image-20200802231357878"></p><p><strong>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的</strong>（只有 kernel buffer 有一份数据）。</p><p>Linux 在 2.4 版本中，做了一些修改，避免了从内核缓冲区拷贝到 Socket buffer 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。</p><p><img src="/2020/07/31/%E6%A1%86%E6%9E%B6/Netty/sendFile%E4%BC%98%E5%8C%96.png" alt="image-20200802231618573"></p><p>这里其实有 一次cpu 拷贝kernel buffer -&gt; socket buffer,但是，拷贝的信息很少，比如lenght , offset , 消耗低，可以忽略</p><p>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 CPU 缓存伪共享以及无 CPU 校验和计算。</p><h4 id="mmap-和-sendFile-的区别"><a href="#mmap-和-sendFile-的区别" class="headerlink" title="mmap 和 sendFile 的区别"></a>mmap 和 sendFile 的区别</h4><ul><li>mmap 适合小数据量读写，sendFile 适合大文件传输。</li><li>mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最少 2 次数据拷贝。</li><li>sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。</li></ul><h4 id="普通IO案例"><a href="#普通IO案例" class="headerlink" title="普通IO案例"></a>普通IO案例</h4><p>1.服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">7001</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(socket.getInputStream());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> readCount = dataInputStream.read(byteArray, <span class="number">0</span>, byteArray.length);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> == readCount) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>);</span><br><span class="line"></span><br><span class="line">        String fileName = <span class="string">&quot;protoc-3.6.1-win32.zip&quot;</span>;</span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line"></span><br><span class="line">        DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">        <span class="keyword">long</span> readCount;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((readCount = inputStream.read(buffer)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            total += readCount;</span><br><span class="line">            dataOutputStream.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;发送总字节数： &quot;</span> + total + <span class="string">&quot;, 耗时： &quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送总字节数： 6574851, 耗时： 53</p><h4 id="NIO拷贝案例"><a href="#NIO拷贝案例" class="headerlink" title="NIO拷贝案例"></a>NIO拷贝案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This method is potentially much more efficient than a simple loop that reads from <span class="keyword">this</span> channel and writes to the target channel.  Many operating systems can transfer bytes directly from the filesystem cache to the target channel without actually copying them. </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        String filename = <span class="string">&quot;E:\\java\\NettyPro\\src\\main\\java\\com\\lq\\nio\\zerocopy\\webmagic资料.zip&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个文件channel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(filename).getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在linux下一个transferTo 方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在windows 下 一次调用 transferTo 只能发送8m , 就需要分段传输文件, 而且要主要</span></span><br><span class="line">        <span class="comment">//传输时的位置 =》 课后思考...</span></span><br><span class="line">        <span class="comment">//transferTo 底层使用到零拷贝</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;发送的总的字节数 =&quot;</span> + transferCount + <span class="string">&quot; 耗时:&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">        String filename = <span class="string">&quot;E:\\java\\NettyPro\\src\\main\\java\\com\\lq\\nio\\zerocopy\\webmagic资料.zip&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个文件channel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(filename).getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在linux下一个transferTo 方法就可以完成传输</span></span><br><span class="line">        <span class="comment">//在windows 下 一次调用 transferTo 只能发送8m , 就需要分段传输文件, 而且要主要</span></span><br><span class="line">        <span class="comment">//传输时的位置 =》 课后思考...</span></span><br><span class="line">        <span class="comment">//transferTo 底层使用到零拷贝</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;发送的总的字节数 =&quot;</span> + transferCount + <span class="string">&quot; 耗时:&quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        fileChannel.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送的总的字节数 =6574851 耗时:9</p><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><ul><li>JDK 7 引入了 Asynchronous I/O，即 AIO。在进行 I/O 编程中，常用到两种模式：Reactor和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理</li><li>AIO 即 NIO2.0，叫做异步不阻塞的 IO。AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li></ul><p>Netty 也是基于NIO, 而不是AIO</p><p> <a href="http://www.52im.net/thread-306-1-1.html">http://www.52im.net/thread-306-1-1.html</a> </p><table><thead><tr><th></th><th><strong>BIO</strong></th><th><strong>NIO</strong></th><th><strong>AIO</strong></th></tr></thead><tbody><tr><td>IO 模型</td><td>同步阻塞</td><td>同步非阻塞（多路复用）</td><td>异步非阻塞</td></tr><tr><td>编程难度</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>可靠性</td><td>差</td><td>好</td><td>好</td></tr><tr><td>吞吐量</td><td>低</td><td>高</td><td>高</td></tr></tbody></table><ul><li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li><li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li><li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li></ul>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/2020/07/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><ul><li><p>简单工厂模式是属于创建型模式，是工厂模式的一种。<strong>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</strong>。简单工厂模式是工厂模式家族中最简单实用的模式</p></li><li><p>简单工厂模式：定义了一个创建对象的类，由这个类来<strong>封装实例化对象的行为</strong>(代码)</p></li><li><p>在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.</p><p>1.创建产品接口和对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共同的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建简单工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">create</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">&quot;ProductA&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str.equals(<span class="string">&quot;ProductB&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory.create(<span class="string">&quot;ProductA&quot;</span>);</span><br><span class="line">        Factory.create(<span class="string">&quot;ProductB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ProductA</span></span><br><span class="line"><span class="comment">ProductB</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><img src="/2020/07/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/简单工厂模式.png" alt="image-20200731162814104" style="zoom: 67%;"><p><strong>应用实例：</strong></p><p>1、您需要一辆汽车，可以直接从工厂里面提货，<strong>而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现</strong></p><p>2、Hibernate 换数据库只需换方言和驱动就可以</p><p><strong>优点：</strong></p><p>1、一个调用者想创建一个对象，<strong>只要知道其名称就可以了</strong></p><p>2、扩展性高，<strong>如果想增加一个产品，只要扩展一个工厂类就可以</strong></p><p>3、屏蔽产品的具体实现，<strong>调用者只关心产品的接口</strong></p><p><strong>缺点：</strong></p><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，<strong>在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖</strong></p><p>这并不是什么好事</p><p><strong>使用场景：</strong></p><p>1、<strong>日志记录器</strong>：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方</p><p>2、<strong>数据库访问</strong>，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时</p><p>3、<strong>设计一个连接服务器的框架</strong>，需要三个协议，”<strong>POP3</strong>″、”<strong>IMAP</strong>”、”<strong>HTTP</strong>”，可以把这三个<strong>作为产品类，共同实现一个接口</strong></p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>所有工厂模式都用来封装对象创建，工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p><p><strong>工厂方法模式</strong>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，<strong>工厂方法让类把实例化推迟到子类</strong></p><ol><li><p>创建产品接口和产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共同的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建工厂接口，具体产品的工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Product <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Factory factory;</span><br><span class="line">       factory = <span class="keyword">new</span> FactoryA();</span><br><span class="line">       factory.create();</span><br><span class="line">       factory = <span class="keyword">new</span> FactoryB();</span><br><span class="line">       factory.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*ProductA</span></span><br><span class="line"><span class="comment">ProductB*/</span></span><br></pre></td></tr></table></figure></li></ol><img src="/2020/07/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/工厂方法模式.png" alt="image-20200731163709008" style="zoom:67%;"><p>简单工厂和工厂方法之间的差异？</p><p>简单工厂是在一个地方把所有的事都处理完了，然而工厂方法却是创建一个框架，让子类决定要如何实现。简单工厂的做法，可以将对象的创建封装起来，但是简单工厂不具备工厂方法的弹性，因为简单工厂不能变更正在创建的产品。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><strong>抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类</strong></p><ul><li>抽象工厂模式可以将<strong>简单工厂模式</strong>和<strong>工厂方法模式</strong>进行整合。</li><li>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。 将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以</li><li>根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了<strong>工厂簇</strong>，更利于代码的维护和扩展。</li></ul><p>案例</p><ol><li><p>创建Product产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共同的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Gift产品类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Gift</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiftA</span> <span class="keyword">implements</span> <span class="title">Gift</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GiftA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;GiftA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiftB</span> <span class="keyword">implements</span> <span class="title">Gift</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GiftB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;GiftB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建抽象工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gift <span class="title">createGift</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建A,B两个工厂实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gift <span class="title">createGift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GiftA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gift <span class="title">createGift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GiftA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Factory factory;</span><br><span class="line">        factory = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        factory.createProduct();</span><br><span class="line">        factory.createGift();</span><br><span class="line">        factory = <span class="keyword">new</span> FactoryB();</span><br><span class="line">        factory.createProduct();</span><br><span class="line">        factory.createGift();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*ProductA</span></span><br><span class="line"><span class="comment">GiftA</span></span><br><span class="line"><span class="comment">ProductB</span></span><br><span class="line"><span class="comment">GiftA*/</span></span><br></pre></td></tr></table></figure><p><img src="/2020/07/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.png" alt="image-20200731165004851"></p></li></ol><p><strong>缺点：</strong></p><p>产品族<strong>扩展非常困难</strong>，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码</p><p><strong>使用场景：</strong></p><p>1、QQ 换皮肤，一整套一起换</p><p>2、生成不同操作系统的程序</p><p> <strong>注意事项：</strong></p><p>产品族难扩展，产品等级易扩展</p><p>区别：</p><p>工厂方法模式： 一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。  每个具体工厂类只能创建一个具体产品类的实例。</p><p>抽象工厂模式： 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。  一个抽象工厂类，可以派生出多个具体工厂类。  每个具体工厂类可以创建多个具体产品类的实例。    </p><p>区别： 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。  工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个</p><p>在service层中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dao userDao = <span class="keyword">new</span> UserDao</span><br></pre></td></tr></table></figure><p>这个代码导致了Service层和Dao层紧密结合</p><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><ul><li>从设计原则来说，简单工厂模式不符合开闭原则。但是很神奇，在实际场景中，简单工厂模式确实用的最多的。个人觉得有以下这些原因<ul><li>相对实现方式比较简单，维护起来也不困难。</li><li>实际场景中需要工厂模式创建的对象数量一般也不会特别多。</li><li>可以通过<strong>反射+外部配置文件</strong>的手段解决开闭原则的问题。</li></ul></li><li>工厂方法模式是专门用于解决单个对象创建工作，本身模式没问题，也符合开闭原则。但是<strong>存在工厂类数量膨胀的问题。</strong>如果需要创建的工厂类不是很多，是一种不错的选择。</li><li>抽象工厂模式天生就是为<strong>生产产品族</strong>而生的。所以如果你需要创建的对象非常之多，但是对象之间存在明显产品族特征，那么这个时候用抽象工厂模式非常合适。</li></ul><h2 id="JDK中的工厂模式"><a href="#JDK中的工厂模式" class="headerlink" title="JDK中的工厂模式"></a>JDK中的工厂模式</h2><p><strong>JDK-Calendar</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title">createCalendar</span><span class="params">(TimeZone zone,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       Locale aLocale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CalendarProvider provider =</span><br><span class="line">        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)</span><br><span class="line">                             .getCalendarProvider();</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> provider.getInstance(zone, aLocale);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">            <span class="comment">// fall back to the default instantiation</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Calendar cal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">        String caltype = aLocale.getUnicodeLocaleType(<span class="string">&quot;ca&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;buddhist&quot;</span>:</span><br><span class="line">            cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;japanese&quot;</span>:</span><br><span class="line">                cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;gregory&quot;</span>:</span><br><span class="line">                cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cal == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If no known calendar type is explicitly specified,</span></span><br><span class="line">        <span class="comment">// perform the traditional way to create a Calendar:</span></span><br><span class="line">        <span class="comment">// create a BuddhistCalendar for th_TH locale,</span></span><br><span class="line">        <span class="comment">// a JapaneseImperialCalendar for ja_JP_JP locale, or</span></span><br><span class="line">        <span class="comment">// a GregorianCalendar for any other locales.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> The language, country and variant strings are interned.</span></span><br><span class="line">        <span class="keyword">if</span> (aLocale.getLanguage() == <span class="string">&quot;th&quot;</span> &amp;&amp; aLocale.getCountry() == <span class="string">&quot;TH&quot;</span>) &#123;</span><br><span class="line">            cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aLocale.getVariant() == <span class="string">&quot;JP&quot;</span> &amp;&amp; aLocale.getLanguage() == <span class="string">&quot;ja&quot;</span></span><br><span class="line">                   &amp;&amp; aLocale.getCountry() == <span class="string">&quot;JP&quot;</span>) &#123;</span><br><span class="line">            cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了日历类还有JDBC，当我们需要MySQL数据库的驱动时，我们就传MySQL的参数，用Oracle的就传相应的参数</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p><ul><li><p>二分搜索</p></li><li><p>大整数乘法</p></li><li><p>棋盘覆盖</p></li><li><p>合并排序</p></li><li><p>快速排序</p></li><li><p>线性时间选择</p></li><li><p>最接近点对问题</p></li><li><p>循环赛日程表</p></li><li><p>汉诺塔</p></li></ul><p>  分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题<br>  解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题<br>  合并：将各个子问题的解合并为原问题的解。</p><h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p>如果是有一个盘， A-&gt;C<br>如果我们有 n &gt;= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘</p><ol><li>先把 最上面的盘 A-&gt;B</li><li>把最下边的盘 A-&gt;C</li><li>把B塔的所有盘 从 B-&gt;C </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoiTower</span><span class="params">(<span class="keyword">int</span> num,<span class="keyword">char</span> a ,<span class="keyword">char</span> b, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第1个盘从 &quot;</span>+a+<span class="string">&quot;-&gt;&quot;</span>+c);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1.先把最上面的所有盘A-&gt;B</span></span><br><span class="line">        hanoiTower(num-<span class="number">1</span>,a,c,b);</span><br><span class="line">        <span class="comment">//把下面的盘A-&gt;C</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第&quot;</span>+num+<span class="string">&quot;个盘从 &quot;</span>+a+<span class="string">&quot;-&gt;&quot;</span>+c);</span><br><span class="line">        <span class="comment">//3.把B的盘移动到C</span></span><br><span class="line">        hanoiTower(num-<span class="number">1</span>,b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</p><p>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p><p>与分治法不同的是，<strong>适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。</strong> ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</p><p>动态规划可以通过填表的方式来逐步推进，得到最优解.</p><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>有一个背包，容量为4磅 ， 现有如下物品</p><table><thead><tr><th>物品</th><th>重量</th><th>价格</th></tr></thead><tbody><tr><td>a</td><td>1</td><td>1500</td></tr><tr><td>b</td><td>4</td><td>3000</td></tr><tr><td>c</td><td>3</td><td>2000</td></tr></tbody></table><p>要求达到的目标为装入的背包的总价值最大，并且重量不超出<br>要求装入的物品不能重复</p><p>算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果：</p><table><thead><tr><th>物品</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td></td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>a</td><td>0</td><td>1500(a)</td><td>1500(a)</td><td>1500(a)</td><td>1500(a)</td></tr><tr><td>b</td><td>0</td><td>1500(a)</td><td>1500(a)</td><td>1500(a)</td><td>3000(b)</td></tr><tr><td>c</td><td>0</td><td>1500(a)</td><td>1500(a)</td><td>2000(c)</td><td>3500(a+c)</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1)  v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是0</span><br><span class="line">(2) 当w[i]&gt; j 时：v[i][j]=v[i-1][j]   // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略</span><br><span class="line">(3) 当j&gt;=w[i]时： v[i] [j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125;  </span><br><span class="line">// 当 准备加入的新增的商品的容量小于等于当前背包的容量,</span><br><span class="line">// 装入的方式:</span><br><span class="line">v[i-1][j]： 就是上一个单元格的装入的最大值</span><br><span class="line">v[i] : 表示当前商品的价值 </span><br><span class="line">v[i-1][j-w[i]] ： 装入i-1商品，到剩余空间j-w[i]的最大值</span><br><span class="line">当j&gt;=w[i]时： v[i][j]=max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; : </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;<span class="comment">//物品的重量</span></span><br><span class="line">    <span class="keyword">int</span>[] val = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>&#125;; <span class="comment">//物品的价值 这里val[i] 就是前面讲的v[i]</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">4</span>; <span class="comment">//背包的容量</span></span><br><span class="line">    <span class="keyword">int</span> n = val.length; <span class="comment">//物品的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建二维数组，</span></span><br><span class="line">    <span class="comment">//v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值</span></span><br><span class="line">    <span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//为了记录放入商品的情况，我们定一个二维数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">        v[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//将第一列设置为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; v[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        v[<span class="number">0</span>][i] = <span class="number">0</span>; <span class="comment">//将第一行设置0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据前面得到公式来动态规划处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123; <span class="comment">//不处理第一行 i是从1开始的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;<span class="comment">//不处理第一列, j是从1开始的</span></span><br><span class="line">            <span class="comment">//公式</span></span><br><span class="line">            <span class="keyword">if</span>(w[i-<span class="number">1</span>]&gt; j) &#123; <span class="comment">// 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1]</span></span><br><span class="line">                v[i][j]=v[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明:</span></span><br><span class="line">                <span class="comment">//因为我们的i 从1开始的， 因此公式需要调整成</span></span><br><span class="line">                <span class="comment">//v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);</span></span><br><span class="line">                <span class="comment">//v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);</span></span><br><span class="line">                <span class="comment">//为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式</span></span><br><span class="line">                <span class="keyword">if</span>(v[i - <span class="number">1</span>][j] &lt; val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                    v[i][j] = val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line">                    <span class="comment">//把当前的情况记录到path</span></span><br><span class="line">                    path[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出一下v 看看目前的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; v.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].length;j++) &#123;</span><br><span class="line">            System.out.print(v[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">    <span class="comment">//输出最后我们是放入的哪些商品</span></span><br><span class="line">    <span class="comment">//遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; path.length; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     for(int j=0; j &lt; path[i].length; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         if(path[i][j] == 1) &#123;</span></span><br><span class="line">    <span class="comment">//             System.out.printf(&quot;第%d个商品放入到背包\n&quot;, i);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//动脑筋</span></span><br><span class="line">    <span class="keyword">int</span> i = path.length - <span class="number">1</span>; <span class="comment">//行的最大下标</span></span><br><span class="line">    <span class="keyword">int</span> j = path[<span class="number">0</span>].length - <span class="number">1</span>;  <span class="comment">//列的最大下标</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span> ) &#123; <span class="comment">//从path的最后开始找</span></span><br><span class="line">        <span class="keyword">if</span>(path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;第%d个商品放入到背包\n&quot;</span>, i);</span><br><span class="line">            j -= w[i-<span class="number">1</span>]; <span class="comment">//w[i-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="暴力匹配"><a href="#暴力匹配" class="headerlink" title="暴力匹配"></a>暴力匹配</h2><p>现在str1匹配到 i 位置，子串str2匹配到 j 位置，则有:</p><ul><li>如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符</li><li>如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。</li><li>用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量的时间。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">violenceMatch</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] s2 = str2.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> s1Len = s1.length;</span><br><span class="line">    <span class="keyword">int</span> s2Len = s2.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( i &lt; s1Len &amp;&amp; j&lt;s2Len)&#123; <span class="comment">//保证不越界</span></span><br><span class="line">        <span class="keyword">if</span> (s1[i]==s2[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i = i-(j-<span class="number">1</span>);</span><br><span class="line">            j = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == s2Len)&#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP算法</p><p>KMP方法算法就利用之前判断过信息，通过一个next数组，<strong>保存模式串中前后最长公共子序列的长度</strong>，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间</p><p><a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a> </p><p>字符串 bread</p><ul><li>前缀 b br bre ,brea</li><li>后缀d ed ead read</li></ul><p>abcda 前缀 a ab abc abcd  后缀 bcda ,cda,da,a 共有长度为1</p><ol><li><p>完成部分匹配表</p></li><li><p>使用部分匹配表匹配字符串</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">next数组每次</span><br><span class="line">ABABCABAA</span><br><span class="line"><span class="number">001201231</span></span><br><span class="line">AB ABC A   最长为<span class="number">1</span> </span><br><span class="line">要让下一位匹配 只用判断下一位是不是B就可以了 </span><br><span class="line">如果相同</span><br><span class="line"> len++;</span><br><span class="line"> next[i] = len; </span><br><span class="line">如果不相同</span><br><span class="line">需要向前进行比较比</span><br><span class="line">len = next[len-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String str1, String str2, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小</span></span><br><span class="line">            <span class="comment">//KMP算法核心点, 可以验证...</span></span><br><span class="line">            <span class="keyword">while</span>( j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">                <span class="comment">//直到找到一个相等的地方</span></span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == str2.length()) &#123;<span class="comment">//找到了 // j = 3 i</span></span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到一个字符串(子串) 的部分匹配值表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span>[] kmpNext(String dest) &#123;</span><br><span class="line">        <span class="comment">//创建一个next 数组保存部分匹配值</span></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//如果字符串是长度为1 部分匹配值就是0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">//表示当前位置的最长公共子串</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">//len表示最长的公共子串长度</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;dest.length())&#123;</span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i) == dest.charAt(len))&#123; <span class="comment">//这一步是比较这一位是否相同</span></span><br><span class="line">                len++;</span><br><span class="line">                next[i] = len; <span class="comment">//这一位的最长公共子串</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;  <span class="comment">//如果这一位不相等</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>)&#123;   <span class="comment">//len&gt;0时需要向前找到相等的</span></span><br><span class="line">                    len = next[len - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    next[i] = len; <span class="comment">//最长公共子串为0</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法.</p><p>不一定是最优的结果(有时候会是最优解)</p><h2 id="集合覆盖问题"><a href="#集合覆盖问题" class="headerlink" title="集合覆盖问题"></a>集合覆盖问题</h2><p>假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号</p><table><thead><tr><th>广播台</th><th>覆盖地区</th></tr></thead><tbody><tr><td>K1</td><td>“北京”, “上海”, “天津”</td></tr><tr><td>K2</td><td>“广州”, “北京”, “深圳”</td></tr><tr><td>K3</td><td>“成都”, “上海”, “杭州”</td></tr><tr><td>K4</td><td>“上海”, “天津”</td></tr><tr><td>K5</td><td>“杭州”, “大连”</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） </span><br><span class="line">将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。</span><br><span class="line">重复第<span class="number">1</span>步直到覆盖了全部的地区</span><br></pre></td></tr></table></figure><h1 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h1><p>有胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通<br>各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里<br>问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?</p><p><strong>最小生成树</strong>：普里姆算法和克鲁斯卡尔算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 </span><br><span class="line">2.若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1</span><br><span class="line">3.若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1</span><br><span class="line">4.重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prim</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试看看图是否创建ok</span></span><br><span class="line">        <span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> verxs = data.length;</span><br><span class="line">        <span class="comment">//邻接矩阵的关系使用二维数组表示,10000这个大数，表示两个点不联通</span></span><br><span class="line">        <span class="keyword">int</span> [][]weight=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>,<span class="number">0</span>,<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>,<span class="number">10000</span>,<span class="number">0</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">9</span>,<span class="number">10000</span>,<span class="number">0</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">8</span>,<span class="number">10000</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">10000</span>,<span class="number">10000</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;,&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建MGraph对象</span></span><br><span class="line">        MGraph graph = <span class="keyword">new</span> MGraph(verxs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个MinTree对象</span></span><br><span class="line">        MinTree minTree = <span class="keyword">new</span> MinTree();</span><br><span class="line">        minTree.createGraph(graph, verxs, data, weight);</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        minTree.showGraph(graph);</span><br><span class="line">        <span class="comment">//测试普利姆算法</span></span><br><span class="line">        minTree.prim(graph);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">10000</span>; <span class="comment">//默认10000不可达</span></span><br><span class="line">    <span class="comment">//创建图的邻接矩阵</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verxs 图对应的顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 图的各个顶点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 图的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(MGraph graph, <span class="keyword">int</span> verxs, <span class="keyword">char</span> data[], <span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; verxs; i++) &#123;<span class="comment">//顶点</span></span><br><span class="line">            graph.data[i] = data[i];</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; verxs; j++) &#123;</span><br><span class="line">                graph.weight[i][j] = weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示图的邻接矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(MGraph graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] link: graph.weight) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认从1开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph 图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(MGraph graph)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] lowcost = <span class="keyword">new</span> <span class="keyword">int</span>[graph.verxs];  <span class="comment">//v0与其他顶点的距离</span></span><br><span class="line">        <span class="keyword">int</span>[] mst = <span class="keyword">new</span> <span class="keyword">int</span>[graph.verxs];</span><br><span class="line">        <span class="comment">//h1 和 h2 记录两个顶点的下标</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;  <span class="comment">//最小值</span></span><br><span class="line">        <span class="keyword">int</span> minid;   <span class="comment">//记录最小值节点</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//总长</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; graph.verxs; i++)&#123;</span><br><span class="line">            lowcost[i] = graph.weight[<span class="number">0</span>][i]; <span class="comment">//初始化赋值</span></span><br><span class="line">            mst[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; graph.verxs; i++)&#123;</span><br><span class="line">            min = MAX;</span><br><span class="line">            minid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;graph.verxs; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (lowcost[j]&lt;min &amp;&amp; lowcost[j] != <span class="number">0</span>)&#123;  <span class="comment">//当前节点的路径最小，且不为0（自己，数组已经包含的）</span></span><br><span class="line">                    min = lowcost[j];</span><br><span class="line">                    minid = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(graph.data[mst[minid]] + <span class="string">&quot;到&quot;</span> + graph.data[minid] + <span class="string">&quot; 权值：&quot;</span> + min);</span><br><span class="line"></span><br><span class="line">            sum += min;</span><br><span class="line">            lowcost[minid] = <span class="number">0</span>; <span class="comment">//这条路不可以再走了</span></span><br><span class="line">            <span class="comment">//重新生成lowcost</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;graph.verxs;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (graph.weight[minid][j] &lt; lowcost[j])&#123; <span class="comment">//加入minid重新计算可达</span></span><br><span class="line">                    lowcost[j] = graph.weight[minid][j];</span><br><span class="line">                    mst[j] = minid;  <span class="comment">//记录前一个节点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sum:&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> verxs; <span class="comment">//表示图的节点个数</span></span><br><span class="line">    <span class="keyword">char</span>[] data;<span class="comment">//存放结点数据</span></span><br><span class="line">    <span class="keyword">int</span>[][] weight; <span class="comment">//存放边，就是我们的邻接矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MGraph</span><span class="params">(<span class="keyword">int</span> verxs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.verxs = verxs;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[verxs];</span><br><span class="line">        weight = <span class="keyword">new</span> <span class="keyword">int</span>[verxs][verxs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="克鲁斯卡尔"><a href="#克鲁斯卡尔" class="headerlink" title="克鲁斯卡尔"></a>克鲁斯卡尔</h1><p>先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</p><p>1) 就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点”。 </p><p><strong>我们加入的边的两个顶点不能都指向同一个终点，否则将构成回路。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kruskal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeNum; <span class="comment">//边的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertexs; <span class="comment">//顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix; <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="comment">//使用 INF 表示两个顶点不能连通</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="comment">//克鲁斯卡尔算法的邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span> matrix[][] = &#123;</span><br><span class="line">                <span class="comment">/*A*/</span><span class="comment">/*B*/</span><span class="comment">/*C*/</span><span class="comment">/*D*/</span><span class="comment">/*E*/</span><span class="comment">/*F*/</span><span class="comment">/*G*/</span></span><br><span class="line">                <span class="comment">/*A*/</span> &#123;   <span class="number">0</span>,  <span class="number">12</span>, INF, INF, INF,  <span class="number">16</span>,  <span class="number">14</span>&#125;,</span><br><span class="line">                <span class="comment">/*B*/</span> &#123;  <span class="number">12</span>,   <span class="number">0</span>,  <span class="number">10</span>, INF, INF,   <span class="number">7</span>, INF&#125;,</span><br><span class="line">                <span class="comment">/*C*/</span> &#123; INF,  <span class="number">10</span>,   <span class="number">0</span>,   <span class="number">3</span>,   <span class="number">5</span>,   <span class="number">6</span>, INF&#125;,</span><br><span class="line">                <span class="comment">/*D*/</span> &#123; INF, INF,   <span class="number">3</span>,   <span class="number">0</span>,   <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">                <span class="comment">/*E*/</span> &#123; INF, INF,   <span class="number">5</span>,   <span class="number">4</span>,   <span class="number">0</span>,   <span class="number">2</span>,   <span class="number">8</span>&#125;,</span><br><span class="line">                <span class="comment">/*F*/</span> &#123;  <span class="number">16</span>,   <span class="number">7</span>,   <span class="number">6</span>, INF,   <span class="number">2</span>,   <span class="number">0</span>,   <span class="number">9</span>&#125;,</span><br><span class="line">                <span class="comment">/*G*/</span> &#123;  <span class="number">14</span>, INF, INF, INF,   <span class="number">8</span>,   <span class="number">9</span>,   <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//大家可以在去测试其它的邻接矩阵，结果都可以得到最小生成树.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建KruskalCase 对象实例</span></span><br><span class="line">        Kruskal kruskalCase = <span class="keyword">new</span> Kruskal(vertexs, matrix);</span><br><span class="line">        <span class="comment">//输出构建的</span></span><br><span class="line">        kruskalCase.print();</span><br><span class="line">        kruskalCase.kruskal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">char</span>[] vertexs, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化顶点数和边的个数</span></span><br><span class="line">        <span class="keyword">int</span> vlen = vertexs.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化顶点, 复制拷贝的方式</span></span><br><span class="line">        <span class="keyword">this</span>.vertexs = <span class="keyword">new</span> <span class="keyword">char</span>[vlen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.vertexs[i] = vertexs[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化边, 使用的是复制拷贝的方式</span></span><br><span class="line">        <span class="keyword">this</span>.matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vlen][vlen];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.matrix[i][j] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计边的条数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.matrix[i][j] != INF) &#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[edgeNum]; <span class="comment">//用于保存最小生成树中每个顶点指向的重点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建结果数组,保存最小生成树</span></span><br><span class="line">        EData[] rets = <span class="keyword">new</span> EData[edgeNum];</span><br><span class="line">        EData[] edges = getEdges();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(edges);</span><br><span class="line">        <span class="comment">//遍历edges数组，将边添加到最小生成树中，判断是否构成回路</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;edgeNum; i++)&#123;</span><br><span class="line">            <span class="comment">//获取第i条边的顶点</span></span><br><span class="line">            <span class="keyword">int</span> p1 = getPosition(edges[i].start);</span><br><span class="line">            <span class="keyword">int</span> p2 = getPosition(edges[i].end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取p1这个顶点在树中的终点</span></span><br><span class="line">            <span class="keyword">int</span> m = getEnd(ends, p1); <span class="comment">//这个顶点如果没有</span></span><br><span class="line">            <span class="keyword">int</span> n = getEnd(ends, p2);</span><br><span class="line">            <span class="keyword">if</span> (m != n)&#123; <span class="comment">//没有构成回路</span></span><br><span class="line">                ends[m] = n;</span><br><span class="line">                rets[index++] = edges[i]; <span class="comment">//一天边加入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//&lt;E,F&gt; &lt;C,D&gt; &lt;D,E&gt; &lt;B,F&gt; &lt;E,G&gt; &lt;A,B&gt;。</span></span><br><span class="line">        <span class="comment">//统计并打印 &quot;最小生成树&quot;, 输出  rets</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树为&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            System.out.println(rets[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印邻接矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接矩阵为: \n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%12d&quot;</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();<span class="comment">//换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch 顶点的值，比如&#x27;A&#x27;,&#x27;B&#x27;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回ch顶点对应的下标，如果找不到，返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vertexs[i] == ch) &#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找不到,返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能: 获取图中边，放到EData[] 数组中，后面我们需要遍历该数组</span></span><br><span class="line"><span class="comment">     * 是通过matrix 邻接矩阵来获取</span></span><br><span class="line"><span class="comment">     * EData[] 形式 [[&#x27;A&#x27;,&#x27;B&#x27;, 12], [&#x27;B&#x27;,&#x27;F&#x27;,7], .....]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EData[] getEdges() &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        EData[] edges = <span class="keyword">new</span> EData[edgeNum];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt;vertexs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] != INF) &#123;</span><br><span class="line">                    edges[index++] = <span class="keyword">new</span> EData(vertexs[i], vertexs[j], matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能: 获取下标为i的顶点的终点(), 用于后面判断两个顶点的终点是否相同</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ends ： 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i : 表示传入的顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的就是 下标为i的这个顶点对应的终点的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">(<span class="keyword">int</span>[] ends, <span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// i = 4 [0,0,0,0,5,0,0,0,0,0,0,0]</span></span><br><span class="line">        <span class="keyword">while</span> (ends[i] != <span class="number">0</span>) &#123;  <span class="comment">//循环获得终点</span></span><br><span class="line">            i = ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有就等于他自己</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个类EData ，它的对象实例就表示一条边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EData</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">EData</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">char</span> start; <span class="comment">//边的一个点</span></span><br><span class="line">    <span class="keyword">char</span> end; <span class="comment">//边的另外一个点</span></span><br><span class="line">    <span class="keyword">int</span> weight; <span class="comment">//边的权值</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EData</span><span class="params">(<span class="keyword">char</span> start, <span class="keyword">char</span> end, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写toString, 便于输出边信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EData [&lt;&quot;</span> + start + <span class="string">&quot;, &quot;</span> + end + <span class="string">&quot;&gt;= &quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(EData o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>prim算法适合稠密图，kruskal算法适合稀疏图。</strong></p><p>prim O(n2)</p><p>kruskal O(nlogn)</p><h1 id="迪杰斯特拉"><a href="#迪杰斯特拉" class="headerlink" title="迪杰斯特拉"></a>迪杰斯特拉</h1><p>Dijkstra O(n²)</p><p>以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设置出发顶点为v，顶点集合V&#123;v1,v2,vi...&#125;，v到V中各顶点的距离构成距离集合Dis，Dis&#123;d1,d2,di...&#125;，Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到vi距离对应为di)</span><br><span class="line">1.从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径</span><br><span class="line">2.更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的)</span><br><span class="line">3.重复执行两步骤，直到最短路径顶点为目标顶点即可结束</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123; <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span> &#125;;</span><br><span class="line">        <span class="comment">//邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;<span class="comment">// 表示不可以连接</span></span><br><span class="line">        matrix[<span class="number">0</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">5</span>,<span class="number">7</span>,N,N,N,<span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,N,N,<span class="number">9</span>,N,N,<span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>,N,N,N,<span class="number">8</span>,N,N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,<span class="number">9</span>,N,N,N,<span class="number">4</span>,N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,<span class="number">8</span>,N,N,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N,N,N,<span class="number">4</span>,<span class="number">5</span>,N,<span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,N,N,<span class="number">4</span>,<span class="number">6</span>,N&#125;;</span><br><span class="line">        <span class="comment">//创建 Graph对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertex, matrix);</span><br><span class="line">        <span class="comment">//测试, 看看图的邻接矩阵是否ok</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line">        <span class="comment">//测试迪杰斯特拉算法</span></span><br><span class="line">        graph.dsj(<span class="number">0</span>);<span class="comment">//C</span></span><br><span class="line">        graph.showDijkstra();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertex; <span class="comment">// 顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix; <span class="comment">// 邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> VisitedVertex vv; <span class="comment">//已经访问的顶点的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">        <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vv.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] link : matrix) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迪杰斯特拉算法实现</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 表示出发顶点对应的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dsj</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        vv = <span class="keyword">new</span> VisitedVertex(vertex.length, index);</span><br><span class="line">        update(index);<span class="comment">//更新index顶点到周围顶点的距离和前驱顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;vertex.length; j++) &#123;</span><br><span class="line">            index = vv.updateArr();<span class="comment">// 选择并返回新的访问顶点</span></span><br><span class="line">            update(index); <span class="comment">// 更新index顶点到周围顶点的距离和前驱顶点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点,</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据遍历我们的邻接矩阵的  matrix[index]行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[index].length; j++) &#123;</span><br><span class="line">            <span class="comment">// len 含义是 : 出发顶点到index顶点的距离 + 从index顶点到j顶点的距离的和</span></span><br><span class="line">            len = vv.getDis(index) + matrix[index][j];</span><br><span class="line">            <span class="comment">// 如果j顶点没有被访问过，并且 len 小于出发顶点到j顶点的距离，就需要更新</span></span><br><span class="line">            <span class="keyword">if</span>(!vv.in(j) &amp;&amp; len &lt; vv.getDis(j)) &#123;</span><br><span class="line">                vv.updatePre(j, index); <span class="comment">//更新j顶点的前驱为index顶点</span></span><br><span class="line">                vv.updateDis(j, len); <span class="comment">//更新出发顶点到j顶点的距离</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisitedVertex</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录各个顶点是否访问过 1表示访问过,0未访问,会动态更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] already_arr;</span><br><span class="line">    <span class="comment">// 每个下标对应的值为前一个顶点下标, 会动态更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] pre_visited;</span><br><span class="line">    <span class="comment">// 记录出发顶点到其他所有顶点的距离,比如G为出发顶点，就会记录G到其它顶点的距离，会动态更新，求的最短距离就会存放到dis</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length :表示顶点的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index: 出发顶点对应的下标, 比如G顶点，下标就是6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VisitedVertex</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.already_arr = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">this</span>.pre_visited = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">this</span>.dis = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="comment">//初始化 dis数组</span></span><br><span class="line">        Arrays.fill(dis, <span class="number">65535</span>);</span><br><span class="line">        <span class="keyword">this</span>.already_arr[index] = <span class="number">1</span>; <span class="comment">//设置出发顶点被访问过</span></span><br><span class="line">        <span class="keyword">this</span>.dis[index] = <span class="number">0</span>;<span class="comment">//设置出发顶点的访问距离为0</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能: 判断index顶点是否被访问过</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果访问过，就返回true, 否则访问false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> already_arr[index] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能: 更新出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDis</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        dis[index] = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能: 更新pre这个顶点的前驱顶点为index顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePre</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        pre_visited[pre] = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能:返回出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDis</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继续选择并返回新的访问顶点，找出最短的顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">65535</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; already_arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(already_arr[i] == <span class="number">0</span> &amp;&amp; dis[i] &lt; min ) &#123;</span><br><span class="line">                min = dis[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新 index 顶点被访问过</span></span><br><span class="line">        already_arr[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示最后的结果</span></span><br><span class="line">    <span class="comment">//即将三个数组的情况输出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;==========================&quot;</span>);</span><br><span class="line">        <span class="comment">//输出already_arr</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : already_arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//输出pre_visited</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : pre_visited) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//输出dis</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : dis) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//为了好看最后的最短距离，我们处理</span></span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123; <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : dis) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">65535</span>) &#123;</span><br><span class="line">                System.out.print(vertex[count] + <span class="string">&quot;(&quot;</span>+i+<span class="string">&quot;) &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;N &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="弗洛伊德"><a href="#弗洛伊德" class="headerlink" title="弗洛伊德"></a>弗洛伊德</h1><p>弗洛伊德(Floyd):计算图中各个顶点之间的最短路径</p><p>弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径</span><br><span class="line">2.至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得</span><br><span class="line">2张表 ，一张是前驱节点，一张是距离</span><br><span class="line">1.通俗讲，就是讲这个顶点作为中间顶点计算所有顶点的最低路径</span><br><span class="line">2.每次更换中间节点，遍历，最后得出结果</span><br><span class="line">中间顶点  [A,B,C,D,E] K</span><br><span class="line">出发顶点  [A,B,C,D,E] i</span><br><span class="line">终点  [A,B,C,D,E]j</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Floyd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试看看图是否创建成功</span></span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123; <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span> &#125;;</span><br><span class="line">        <span class="comment">//创建邻接矩阵</span></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span> &#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">0</span>, N, <span class="number">9</span>, N, N, <span class="number">3</span> &#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">7</span>, N, <span class="number">0</span>, N, <span class="number">8</span>, N, N &#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, <span class="number">9</span>, N, <span class="number">0</span>, N, <span class="number">4</span>, N &#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, N, <span class="number">8</span>, N, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; N, N, N, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span> &#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 Graph 对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertex.length, matrix, vertex);</span><br><span class="line">        <span class="comment">//调用弗洛伊德算法</span></span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dis; <span class="comment">//各个顶点到其他顶点的距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] pre; <span class="comment">//前驱节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 邻接矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span>[][] matrix, <span class="keyword">char</span>[] vertex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">        <span class="keyword">this</span>.dis = matrix;</span><br><span class="line">        <span class="keyword">this</span>.pre = <span class="keyword">new</span> <span class="keyword">int</span>[length][length];</span><br><span class="line">        <span class="comment">// 对pre数组初始化, 注意存放的是前驱顶点的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Arrays.fill(pre[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示pre数组和dis数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了显示便于阅读，我们优化一下输出</span></span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123; <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dis.length; k++) &#123;</span><br><span class="line">            <span class="comment">// 先将pre数组输出的一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">                System.out.print(vertex[pre[k][i]] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">// 输出dis数组的一行数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;(&quot;</span>+vertex[k]+<span class="string">&quot;到&quot;</span>+vertex[i]+<span class="string">&quot;的最短路径是&quot;</span> + dis[k][i] + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">//保存距离</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; dis.length;k++)&#123;  <span class="comment">//中间节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++)&#123; <span class="comment">//从顶点开始</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dis.length; j++)&#123;</span><br><span class="line">                    len = dis[i][k] + dis[k][j];</span><br><span class="line">                    <span class="keyword">if</span> (len &lt; dis[i][j])&#123; <span class="comment">//如果小于</span></span><br><span class="line">                        dis[i][j] = len;</span><br><span class="line">                        pre[i][j] = pre[k][j]; <span class="comment">//更新前驱节点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="马踏棋盘算法"><a href="#马踏棋盘算法" class="headerlink" title="马踏棋盘算法"></a>马踏棋盘算法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseChessboard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> X ; <span class="comment">// 棋盘的列数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> Y ; <span class="comment">// 棋盘的行数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个数组，标记棋盘的各个位置是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> visited[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个属性，标记是否棋盘的所有位置都被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> finished; <span class="comment">// 如果为true,表示成功</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试骑士周游算法是否正确</span></span><br><span class="line">        X = <span class="number">8</span>;</span><br><span class="line">        Y = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">1</span>; <span class="comment">//马儿初始位置的行，从1开始编号</span></span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">1</span>; <span class="comment">//马儿初始位置的列，从1开始编号</span></span><br><span class="line">        <span class="comment">//创建棋盘</span></span><br><span class="line">        <span class="keyword">int</span>[][] chessboard = <span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[X * Y];<span class="comment">//初始值都是false</span></span><br><span class="line">        <span class="comment">//测试一下耗时</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        traversalChessboard(chessboard, row - <span class="number">1</span>, column - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;共耗时: &quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出棋盘的最后情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] rows : chessboard) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> step: rows) &#123;</span><br><span class="line">                System.out.print(step + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成骑士周游问题的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chessboard 棋盘</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 马儿当前的位置的行 从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> column 马儿当前的位置的列  从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> step 是第几步 ,初始位置就是第1步</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traversalChessboard</span><span class="params">(<span class="keyword">int</span>[][] chessboard, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        chessboard[row][column] = step;</span><br><span class="line">        <span class="comment">//row = 4 X = 8 column = 4 = 4 * 8 + 4 = 36</span></span><br><span class="line">        visited[row * X + column] = <span class="keyword">true</span>; <span class="comment">//标记该位置已经访问</span></span><br><span class="line">        <span class="comment">//获取当前位置可以走的下一个位置的集合</span></span><br><span class="line">        ArrayList&lt;Point&gt; ps = next(<span class="keyword">new</span> Point(column, row));</span><br><span class="line">        <span class="comment">//对ps进行排序,排序的规则就是对ps的所有的Point对象的下一步的位置的数目，进行非递减排序</span></span><br><span class="line">        sort(ps);</span><br><span class="line">        <span class="keyword">while</span> (!ps.isEmpty())&#123;</span><br><span class="line">            Point p = ps.remove(<span class="number">0</span>); <span class="comment">//取出下一个可以走的位置</span></span><br><span class="line">            <span class="comment">//判断这个点是否已经访问过</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[p.y * X + p.x]) &#123;<span class="comment">//说明还没有访问过</span></span><br><span class="line">                traversalChessboard(chessboard, p.y, p.x, step + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿是否完成了任务，使用   step 和应该走的步数比较 ，</span></span><br><span class="line">        <span class="comment">//如果没有达到数量，则表示没有完成任务，将整个棋盘置0</span></span><br><span class="line">        <span class="comment">//说明: step &lt; X * Y  成立的情况有两种</span></span><br><span class="line">        <span class="comment">//1. 棋盘到目前位置,仍然没有走完</span></span><br><span class="line">        <span class="comment">//2. 棋盘处于一个回溯过程</span></span><br><span class="line">        <span class="keyword">if</span>(step &lt; X * Y &amp;&amp; !finished ) &#123;</span><br><span class="line">            chessboard[row][column] = <span class="number">0</span>;</span><br><span class="line">            visited[row * X + column] = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            finished = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Point&gt; <span class="title">next</span><span class="params">(Point curPoint)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个ArrayList</span></span><br><span class="line">        ArrayList&lt;Point&gt; ps = <span class="keyword">new</span> ArrayList&lt;Point&gt;();</span><br><span class="line">        <span class="comment">//创建一个Point</span></span><br><span class="line">        Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line">        <span class="comment">//表示马儿可以走5这个位置</span></span><br><span class="line">        <span class="keyword">if</span>((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y -<span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走6这个位置</span></span><br><span class="line">        <span class="keyword">if</span>((p1.x = curPoint.x - <span class="number">1</span>) &gt;=<span class="number">0</span> &amp;&amp; (p1.y=curPoint.y-<span class="number">2</span>)&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走7这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走0这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走1这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走2这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走3这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿可以走4这个位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化，进行非递减排序</span></span><br><span class="line">    <span class="comment">//根据当前这个一步的所有的下一步的选择位置，进行非递减排序, 减少回溯的次数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(ArrayList&lt;Point&gt; ps)</span> </span>&#123;</span><br><span class="line">        ps.sort(<span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point o1, Point o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取到o1下一步所有的个数</span></span><br><span class="line">                <span class="keyword">int</span> count1 = next(o1).size();</span><br><span class="line">                <span class="keyword">int</span> count2 = next(o2).size();</span><br><span class="line">                <span class="keyword">if</span> (count1 &lt; count2)&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count1 == count2)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="一、网络模型"><a href="#一、网络模型" class="headerlink" title="一、网络模型"></a>一、网络模型</h1><p><strong>OSI分层 （7层）：</strong>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br><strong>TCP/IP分层（4层）：</strong>网络接口层、 网际层、运输层、 应用层。<br><strong>五层协议 （5层）：</strong>物理层、数据链路层、网络层、运输层、 应用层。</p><p>物理层：</p><ul><li><p><strong>该层为上层协议提供了一个传输数据的可靠物理媒介</strong></p></li><li><p>数据的单位称为<strong>比特</strong>(bit)。</p></li><li><p>物理层的主要设备:中继器、集线器、适配器。</p></li><li><p>主要协议：IEEE802.3 </p></li></ul><p>数据链路层</p><ul><li><p><strong>实现两个主机系统之间的数据传输透明</strong></p></li><li><p>数据的单位称为<strong>帧</strong>(frame)。</p></li><li><p>数据链路层主要设备:二层交换机、网桥。</p></li><li><p>主要协议：以太网协议ppp、MAC </p></li></ul><p>网络层</p><ul><li><strong>实现两个主机系统之间的数据传输透明,路由选择，连接的建立与终止等</strong>，<strong>它提供的服务使传输层不需要了解网络层的数据传输和交换技术</strong></li><li><strong>数据包</strong></li><li>网络层主要设备:路由器</li><li>网络层协议的代表包括:IP、IPX、RIP、ARP、RARP、OSPF等。</li></ul><p>传输层</p><ul><li>进程之间的通信。提供端到端的可靠报文传递和错误恢复</li><li><strong>TCP的叫段、UDP的叫数据报</strong></li><li>TCP/UDP</li></ul><p>会话层</p><ul><li>建立、管理和终止会话</li><li>会话协议数据单元SPDU</li></ul><p>表示层</p><ul><li>对数据进行翻译、加密和压缩</li></ul><p>应用层</p><ul><li>允许访问OSI环境的手段</li><li>TFTP，HHTP，SMTP,FTP,DN</li></ul><p>在TCP/IP中会话层和表示层，应用层是应用层</p><h1 id="二、TCP和UDP"><a href="#二、TCP和UDP" class="headerlink" title="二、TCP和UDP"></a>二、TCP和UDP</h1><p><strong>传输层协议</strong></p><h2 id="TCP和UCP的区别"><a href="#TCP和UCP的区别" class="headerlink" title="TCP和UCP的区别"></a>TCP和UCP的区别</h2><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接</td><td>有连接</td><td>无连接</td></tr><tr><td>可靠</td><td>可靠，使用流量控制和拥塞控制</td><td>不可靠，没有使用控制</td></tr><tr><td>有序</td><td>有序</td><td>无序</td></tr><tr><td>有界</td><td>无界</td><td>有界</td></tr><tr><td>重传机制</td><td>超时重传，快速重传</td><td>无</td></tr><tr><td>连接对象</td><td>一对一</td><td>一对一，一对多，多对多</td></tr><tr><td>传输方式</td><td>面向数据流</td><td>面向报文</td></tr><tr><td>首部开销</td><td>最小20字节，最大60字节</td><td>小，仅8字节</td></tr><tr><td>适用场景</td><td>可靠的应用传输（文件传输）</td><td>实时会议（视频会议，直播）</td></tr></tbody></table><p>是否有界</p><ul><li><strong>TCP通过字节流传输</strong>TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去，TCP发给对方的数据，对方在收到数据时必须给矛确认，只有在收到对方的确认时，本方TCP才会把TCP发送缓冲区中的数据删除。 而<strong>UDP传输报文的方式是由应用程序</strong>控制的，<strong>应用层</strong>交给UDP多长的报文，UDP照样发送，<strong>既不拆分，也不合并，而是保留这些报文的边界</strong>，即一次发送一个报文。有界与无界之分是根据接收报文来划分的，对于TCP协议，客户端连续发送数据，只要服务端的这个函数的缓冲区足够大，会一次性接收过来，即客户端是分好几次发过来，是有边界的，而服务端却一次性接收过来，所以证明是无边界的；而对于UDP协议，客户端连续发送数据，即使服务端的这个函数的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收，从而证明，这种UDP的通讯模式是有边界的,<strong>UDP无缓存服务，信息确认由应用层完成</strong>。</li></ul><p>TCP黏包问题</p><ul><li>如果发送的网络数据包太小，<strong>对较小的数据包进行合并</strong>，<strong>服务器在接收到消息（数据流）的时候就无法区分哪些数据包是客户端自己分开发送的，这样产生了粘包</strong>；</li></ul><p>UDP无连接</p><ul><li><blockquote><p>在发送端，应用层将数据传递给传输层的 UDP 协议，<strong>UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议</strong>，然后就传递给网络层了.在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。</p></blockquote></li></ul><h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p><a href="https://blog.csdn.net/Cecilia3333/article/details/80358201">TCP的各种机制</a></p><ul><li><p>可靠性</p><ul><li><strong>确认应答机制</strong>（ACK）</li><li><strong>超时重传机制</strong></li><li><strong>校验和</strong></li></ul></li><li><p>流量控制</p><ul><li><p>滑动窗口机制（ARQ)</p><blockquote><p><strong>建立连接时，各端分配一个缓冲区用来存储接收的数据，并将缓冲区的尺寸发送给另一端。接收方发送的确认消息中包含了自己剩余的缓冲区尺寸。剩余缓冲区空间的数量叫做窗口。</strong>滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。</p></blockquote></li></ul></li><li><p>拥塞控制</p><ul><li><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载</p></li><li><p>具体实现</p><blockquote><p><strong>慢启动</strong>（Slow Start）发送方维护拥塞窗口变量cwnd，先用小数据试探网络拥塞，没问题后来断加倍。拥塞窗口的大小取决于网络的拥塞程度，并且动态的变化。<br><strong>拥塞避免</strong>（Congestion voidance）：拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1<br><strong>快速重传</strong>（Fast Retransmit）：快重传要求接收方收到失序报文段后立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br><strong>快速恢复</strong>（Fast Recovery）：当发送方连续收到三个重复确认时，就把慢开始门限ssthresh门限减半。接下来将cwnd设置为ssthresh的大小，然后执行拥塞避免算法</p></blockquote></li></ul></li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="这里写图片描述"></p><ul><li>第一次握手：客户端将标志位SYN置为1，表示请求同步（建立连接）。随机产生一个序号seq=x，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</li><li>第二次握手：服务器端将标志位SYN置为1表示请求同步，ACK置为1表示收到请求。ack=x+1，用于给客户端和之前传送过来的seq校验。随机产生一个值seq=y，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</li><li>第三次握手：客户端收到确认后，检查ACK是否为1，ack是否为x+1，如果正确则将标志位ACK置为1，ack=y+1，seq=传过来的ack=x+1，并将该数据包发送给服务器端，并进入ESTABLISHED状态。服务器端检查ACK是否为1，ack是否为y+1，如果正确则连接建立成功服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。假如第三次握手没有到达服务器端呢？但是这时客户端已进入ESTABLISHED状态。但是其实这种情况下，只要客户端向服务器端写数据，就会收到服务器端的RST（复位）应答，这时客户端就能知道出现问题了。</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><h3 id><a href="#" class="headerlink" title></a><img src="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="这里写图片描述"></h3><p>1）首先客户端想要释放连接，向服务器端发送一段TCP报文，其中：</p><ul><li><p><strong>标记位为FIN，表示“请求释放连接“；</strong></p></li><li><p><strong>序号为Seq=U；</strong></p></li><li><p><strong>随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。</strong></p><p>注意：这里不发送的是正常连接时传输的数据(非确认报文)，而不是一切数据，所以客户端仍然能发送ACK确认报文。</p></li></ul><p>（2）服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中：</p><ul><li><strong>标记位为ACK，表示“接收到客户端发送的释放连接的请求”；</strong></li><li><strong>序号为Seq=V；</strong></li><li><strong>确认号为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值；</strong></li><li><strong>随后服务器端开始准备释放服务器端到客户端方向上的连接。客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段</strong></li></ul><p>前”两次挥手”既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了</p><p>（3）服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中：</p><ul><li><p><strong>标记位为FIN，ACK，表示“已经准备好释放连接了”。注意：这里的ACK并不是确认收到服务器端报文的确认报文。</strong></p></li><li><p><strong>序号为Seq=W；</strong></p></li><li><p><strong>确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。</strong></p><p>随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。</p></li></ul><p>（4）客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：</p><ul><li><p><strong>标记位为ACK，表示“接收到服务器准备好释放连接的信号”。</strong></p></li><li><p><strong>序号为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。</strong></p></li><li><p><strong>确认号为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。</strong></p><p>随后客户端开始在TIME-WAIT阶段等待2MSL</p></li></ul><h2 id="一个典型TCP客户端（主动建立连接，主动断开连接）会经历的状态序列。"><a href="#一个典型TCP客户端（主动建立连接，主动断开连接）会经历的状态序列。" class="headerlink" title="一个典型TCP客户端（主动建立连接，主动断开连接）会经历的状态序列。"></a>一个典型TCP客户端（主动建立连接，主动断开连接）会经历的状态序列。</h2><p>SYNC_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT</p><h2 id="TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为"><a href="#TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为" class="headerlink" title="TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为"></a>TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为</h2><p>客户端：发送X</p><p>服务端：发送Y， 确认X+1 </p><p>客户端：发送X+1（1000），确认Y+1（2000）</p><p>第二次的发送序号为 1999 确认序号为999</p><h3 id="为什么TCP连接要建立三次连接？"><a href="#为什么TCP连接要建立三次连接？" class="headerlink" title="为什么TCP连接要建立三次连接？"></a>为什么TCP连接要建立三次连接？</h3><p>为了防止失效的连接请求又传送到主机，因而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><h3 id="为什么要4次挥手？"><a href="#为什么要4次挥手？" class="headerlink" title="为什么要4次挥手？"></a>为什么要4次挥手？</h3><ul><li>当主机A确认发送完数据且知道B已经接受完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给主机B。</li><li>主机B收到A发送的FIN，表示收到了，就会发送ACK回复。</li><li><strong>但这是B可能还在发送数据，没有想要关闭数据口的意思，所以FIN与ACK不是同时发送的，而是等到B数据发送完了，才会发送FIN给主机A。</strong></li><li>A收到B发来的FIN，知道B的数据也发送完了，回复ACK， A等待2MSL以后，没有收到B传来的任何消息，知道B已经收到自己的ACK了，A就关闭链接，B也关闭链接了。</li></ul><h3 id="为什么TIME-WAIT状态还需要等2-MSL（Max-SegmentLifetime，最大分段生存期）秒之后才能返回到CLOSED状态呢？"><a href="#为什么TIME-WAIT状态还需要等2-MSL（Max-SegmentLifetime，最大分段生存期）秒之后才能返回到CLOSED状态呢？" class="headerlink" title="为什么TIME_WAIT状态还需要等2*MSL（Max SegmentLifetime，最大分段生存期）秒之后才能返回到CLOSED状态呢？"></a>为什么TIME_WAIT状态还需要等2*MSL（Max SegmentLifetime，最大分段生存期）秒之后才能返回到CLOSED状态呢？</h3><p>因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SENT状态到ESTABLISH状态那样），但是我们必须假想网络是不可靠的，你无法保证你最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来<strong>重发可能丢失的ACK报文</strong>。</p><h3 id="Time-wait-Close-wait"><a href="#Time-wait-Close-wait" class="headerlink" title="Time_wait,Close_wait"></a>Time_wait,Close_wait</h3><p>在这四次握手状态中，有一个<strong>特别要注意的状态TIME_WAIT</strong>。<strong>这个状态是主动关闭方在收到被关闭方的FIN后会处于并长期**</strong>处于的一个状态<strong>。</strong>也就是大约1-4分钟，然后由操作系统自动回收并将TCP连接设为CLOSED初始状态**。</p><ul><li>为实现TCP全双工连接的可靠释放</li><li>为使旧的数据包在网络因过期而消失</li></ul><h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p>TCP头部</p><p><img src="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%A4%B4%E9%83%A8.png" alt="TCP首部"></p><p>UDP头部20位</p><p><img src="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E5%A4%B4%E9%83%A8.png" alt="image-20200727220004371"></p><p>一共64位</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ul><li>TCP面向连接、UDP是无连接的；</li><li>TCP提供可靠的服务、也就是说，通过TCP连接传输的数据是无差错、不丢失、不重复且按序到达；UDP尽最大努力交付，即不保证可靠交付<br>TCP的逻辑通信信息是全双工的可靠信息；UDP则是不可靠信息</li><li>每一条TCP连接只能是点对点的；UDP支持一对多、多对一、多对多的交互通信</li><li>TCP面向字节流(可能会出现黏包问题)，实际上是TCP白数据看成一连串无结构的字节流；UDP是面向报文的(不会出现黏包问题)</li><li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如IP电话，实时视频会议等)</li><li>TCP首部开销20字节；UDP的首部开销小，只有8字节</li></ul><h3 id="为什么UDP有时比TCP更有优势"><a href="#为什么UDP有时比TCP更有优势" class="headerlink" title="为什么UDP有时比TCP更有优势?"></a>为什么UDP有时比TCP更有优势?</h3><p>UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏。</p><p>（1）<strong>网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。</strong></p><p>（2）<strong>TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。</strong></p><p>采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDP的协议"><a href="#UDP的协议" class="headerlink" title="UDP的协议"></a>UDP的协议</h3><p><a href="https://baike.baidu.com/item/TFTP">TFTP</a>、<a href="https://baike.baidu.com/item/SNMP">SNMP</a>、NFS、DNS 没有SMTP</p><h3 id="UDP如何保证可靠性"><a href="#UDP如何保证可靠性" class="headerlink" title="UDP如何保证可靠性?"></a>UDP如何保证可靠性?</h3><p>可靠性由上层应用实现，所以要实现udp可靠性传输，必须通过应用层来实现和控制。</p><p>实现确认机制、重传机制、窗口确认机制。</p><p> 发送：包的分片、包确认、包的重发</p><p>  接收：包的调序、包的序号确认</p><h1 id="三、HTTP"><a href="#三、HTTP" class="headerlink" title="三、HTTP"></a>三、HTTP</h1><h2 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<strong>是应用层协议</strong></p><h3 id="HTTP-常见的状态码，有哪些？"><a href="#HTTP-常见的状态码，有哪些？" class="headerlink" title="HTTP 常见的状态码，有哪些？"></a>HTTP 常见的状态码，有哪些？</h3><p><em>2xx</em>类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><em>3xx</em>类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p><ul><li><p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p></li><li><p>「<strong>302 Moved Permanently</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p><p> 301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p></li><li><p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</p></li></ul><p><em>4xx</em> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><em>5xx</em>类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a><a href="https://blog.csdn.net/aomize/article/details/78609301">报文格式</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">常见HTTP首部字段</span><br><span class="line">通用首部字段（请求报文与响应报文都会使用的首部字段）</span><br><span class="line">    Date：创建报文时间</span><br><span class="line">    Connection：连接的管理</span><br><span class="line">    Cache-Control：缓存的控制</span><br><span class="line">    Transfer-Encoding：报文主体的传输编码方式</span><br><span class="line">请求首部字段（请求报文会使用的首部字段）</span><br><span class="line">    Host：请求资源所在服务器</span><br><span class="line">    Accept：可处理的媒体类型</span><br><span class="line">    Accept-Charset：可接收的字符集</span><br><span class="line">    Accept-Encoding：可接受的内容编码</span><br><span class="line">    Accept-Language：可接受的自然语言</span><br><span class="line">响应首部字段（响应报文会使用的首部字段）</span><br><span class="line">    Accept-Ranges：可接受的字节范围</span><br><span class="line">    Location：令客户端重新定向到的</span><br><span class="line">    URI Server：HTTP服务器的安装信息</span><br><span class="line">实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）</span><br><span class="line">    Allow：资源可支持的HTTP方法</span><br><span class="line">    Content-Type：实体主类的类型</span><br><span class="line">    Content-Encoding：实体主体适用的编码方式</span><br><span class="line">    Content-Language：实体主体的自然语言</span><br><span class="line">    Content-Length：实体主体的的字节数</span><br><span class="line">    Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h2><h3 id="GET-和-POST-的区别？"><a href="#GET-和-POST-的区别？" class="headerlink" title="GET 和 POST 的区别？"></a>GET 和 POST 的区别？</h3><p><code>Get</code> 方法的含义是请求<strong>从服务器获取资源</strong>，这个资源可以是静态的文本、页面、图片视频等。 如，页面的请求</p><p>而<code>POST</code> 方法则是相反操作，它向 <code>URI</code> 指定的资源提交数据，数据就放在报文的 body 里。如，表单的提交。</p><h3 id="GET-和-POST-方法都是安全和幂等的吗？"><a href="#GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="GET 和 POST 方法都是安全和幂等的吗？"></a>GET 和 POST 方法都是安全和幂等的吗？</h3><ul><li><p>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</p></li><li><p>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p><p><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p></li></ul><p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。</p><h2 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a>HTTP 特性</h2><p><em>1. 简单</em></p><p><em>2. 灵活和易于扩展</em></p><p><em>3. 应用广泛和跨平台</em></p><p>缺点</p><p><em>1. 无状态双刃剑</em></p><p>无状态的<strong>好处</strong>，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p><p>无状态的<strong>坏处</strong>，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦</p><p><strong>Cookie</strong>可以解决这个问题</p><p>2.<em>不安全</em></p><ul><li>通信使用明文（不加密），内容可能会被窃听。比如，<strong>账号信息容易泄漏，那你号没了。</strong></li><li>不验证通信方的身份，因此有可能遭遇伪装。比如，<strong>访问假的淘宝、拼多多，那你钱没了。</strong></li><li>无法证明报文的完整性，所以有可能已遭篡改。比如，<strong>网页上植入垃圾广告，视觉污染，眼没了。</strong></li></ul><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p><strong>请求 - 应答</strong>的通信方式</p><p><em>1. 长连接</em></p><p>HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。</p><p>为了解决上述 TCP 连接问题，HTTP/1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p><p><em>2. 管道网络传输</em></p><p>在同一个 TCP 连接里面，客户端可以发起多个请求，<strong>只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，</strong>可以<strong>减少整体的响应时间。</strong></p><p><em>3. 队头阻塞</em></p><p>当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」。<strong>好比上班的路上塞车</strong>。</p><h3 id="在浏览器中输入url到显示页面的过程"><a href="#在浏览器中输入url到显示页面的过程" class="headerlink" title="在浏览器中输入url到显示页面的过程"></a>在浏览器中输入url到显示页面的过程</h3><ul><li><strong>1.输入地址</strong></li><li><strong>2.浏览器查找域名的 IP 地址</strong></li><li><strong>3.浏览器向 web 服务器发送一个 HTTP 请求</strong><ul><li>浏览器会以一个随机端口向服务器的WEB程序（常用的有httpd,nginx等）80端口<strong>发起TCP的连接请求</strong>。</li></ul></li><li><strong>4.服务器的永久重定向响应</strong></li><li><strong>5.浏览器跟踪重定向地址</strong></li><li><strong>6.服务器处理请求</strong></li><li><strong>7.服务器返回一个 HTTP 响应</strong>　</li><li><strong>8.浏览器显示 HTML</strong></li></ul><h3 id="HTTP传输过程"><a href="#HTTP传输过程" class="headerlink" title="HTTP传输过程"></a>HTTP传输过程</h3><ul><li>建立TCP连接</li><li>web浏览器发送请求 GET/index.jsp HTTP/1.1</li><li>web浏览器发送请求头信息，如果为post请求，会提交请求体</li><li>web服务器应答， HTTP/1.1 200 OK</li><li>web服务器发送应答头信息</li><li>web浏览器向服务器发送数据 根据Content-Type中所描述的格式</li><li>web服务器关闭TCP连接</li></ul><h2 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h2><h3 id="HTTP-与-HTTPS-有哪些区别"><a href="#HTTP-与-HTTPS-有哪些区别" class="headerlink" title="HTTP 与 HTTPS 有哪些区别"></a>HTTP 与 HTTPS 有哪些区别</h3><ol><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li><li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ol><p>HTTPS 解决了，<strong>窃听风险</strong>，<strong>篡改风险</strong>，<strong>冒充风险</strong></p><p>HTTP<strong>S</strong> 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议。<strong>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</strong></p><ul><li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li><li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li><li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li></ul><h3 id="HTTPS-是如何解决上面的三个风险的"><a href="#HTTPS-是如何解决上面的三个风险的" class="headerlink" title="HTTPS 是如何解决上面的三个风险的"></a>HTTPS 是如何解决上面的三个风险的</h3><h4 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h4><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。<ul><li><strong>对称加密</strong>和<strong>非对称加密</strong><ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul></li><li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。<ul><li>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</li></ul></li></ul></li></ul><h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><ul><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。<ul><li><strong>摘要算法</strong>用来实现<strong>完整性</strong>，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</li></ul></li></ul><h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><ul><li><p>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</p></li><li><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p></li></ul><h3 id="HTTPS-是如何建立连接的？其间交互了什么？"><a href="#HTTPS-是如何建立连接的？其间交互了什么？" class="headerlink" title="HTTPS  是如何建立连接的？其间交互了什么？"></a>HTTPS  是如何建立连接的？其间交互了什么？</h3><p>1、客户端获取主机证书</p><p>2、通过主机证书验证服务器的合法性，即是否是客户端想要连接的服务器：</p><p>通过证书中包含的签发机构，从根证书链中取得对应公钥，然后对目标域名进行签名，然后对比签名是否和证书中的一致；</p><p>如果CA不在证书链中，或者比对有一项不同则主机不被信任（或许是一个虚假主机，或许是不受信任的证书），如果选择信任则继续进行秘钥的磋商</p><p>3、传输秘钥的磋商，客户端随机生成传输秘钥，然后通过对证书中的公钥加密后传给服务器，</p><p>4、之后的http内容的加密则使用此密文进行加密。</p><h2 id="Http的发展"><a href="#Http的发展" class="headerlink" title="Http的发展"></a>Http的发展</h2><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p><em>1. 头部压缩</em></p><p>HTTP/2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的分</strong>。</p><p><em>2. 二进制格式</em></p><p>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式。</strong></p><p>头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧和数据帧</strong>。</p><p><em>3. 数据流</em></p><p>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>每个请求或回应的所有数据包，称为一个数据流（<code>Stream</code>）。</p><p><em>4. 多路复用</em></p><p>HTTP/2 是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</p><p>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</p><p><em>5. 服务器推送</em></p><p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。</p><p>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p><ul><li>HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li><li>HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li></ul><p>这都是基于 TCP 传输层的问题，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong> </p><p>基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p><ul><li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，<strong>其他流不会受到影响</strong>。</li><li>TL3 升级成了最新的 <code>1.3</code> 版本，头部压缩算法也升级成了 <code>QPack</code>。</li><li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 <code>TLS/1.3</code> 的三次握手。QUIC 直接把以往的 TCP 和 <code>TLS/1.3</code> 的 6 次交互<strong>合并成了 3 次，减少了交互次数</strong>。</li></ul><h1 id="四、IP"><a href="#四、IP" class="headerlink" title="四、IP"></a>四、IP</h1><p><strong>网络层协议</strong></p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h2 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h2><img src="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP数据报格式.png" alt="img" style="zoom:67%;"><ul><li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li><li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li><li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li></ul><h2 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h2><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><p><img src="/2020/07/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png" alt="image-20200812155218926"></p><ul><li><p>广播地址<br>广播地址(Broadcast Address)是专门<strong>用于同时向网络中所有工作站进行发送的一个地址</strong>。</p><p>在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255 （255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。</p><ul><li>计算广播地址<br>广播地址：网络地址的主机位全部变成1 ，10011111 即159 即：202.112.14.159</li></ul></li><li><p>回环地址<br>127.0.0.1，通常被称为本地回环地址(Loop back address)，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。在windows操作系统中也有相似的定义，所以通常在不安装网卡前就可以ping通这个本地回环地址。<strong>一般都会用来检查本地网络协议、基本数据接口等是否正常的</strong></p></li></ul><h3 id="2-子网划分"><a href="#2-子网划分" class="headerlink" title="2. 子网划分"></a>2. 子网划分</h3><p>为什么进行子网划分</p><ul><li><strong>减少网络流量</strong></li><li><strong>优化网络性能</strong>，这是减少网络流量的结果。</li><li><strong>简化管理</strong>，与庞大的网络相比，在一系列相连的小网络中找出并隔离网络问题更容易。</li><li><strong>有助于覆盖大型地理区域</strong>，WAN链路比LAN链路的速度慢得多，且更昂贵;单个大跨度的大型网络在前面说的各个方面都可能出现问题（网络流量太大，广播风暴），而将多个小网络连接起来可提高系统的效率。</li></ul><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><p>参考</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md">HTTP</a><br><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E7%9B%AE%E5%BD%95.md">计算机网络</a><br><a href="https://notecc.ink/posts/50daec4.html">网络</a><br><a href="https://blog.csdn.net/iva_brother/article/details/90317645">TCP与UDP的区别与联系</a><br><a href="https://mp.weixin.qq.com/s/amOya0M00LwpL5kCS96Y6w">图解 HTTP 常见的面试题</a><br><a href="https://blog.csdn.net/u011547347/article/details/83186514">https实现原理</a><br><a href="https://baijiahao.baidu.com/s?id=1654225744653405133&wfr=spider&for=pc">TCP 连接的“ 三次握手 ”与“ 四次挥手 ”</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-数组</title>
      <link href="/2020/07/25/leetcode/leetcode%E6%95%B0%E7%BB%84/"/>
      <url>/2020/07/25/leetcode/leetcode%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><p>1.</p><p>两遍哈希表</p><p>一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i] 本身！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) !=i)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,map.get(complement)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一遍哈希表</p><p>我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(complement),i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2020/07/24/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/07/24/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1.JDK 和 JRE 有什么区别？"></a>1.JDK 和 JRE 有什么区别？</h2><ul><li>JDK：Java Development Kit 的简称，Java 开发工具包，提供了 Java 的开发环境和运行环境。</li><li>JRE：Java Runtime Environment 的简称，Java 运行环境，为 Java 的运行提供了所需环境。</li></ul><p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 Java 源码的编译器 Javac，还包含了很多 Java 程序调试和分析的工具。简单来说：如果你需要运行 Java 程序，只需安装 JRE 就可以了，如果你需要编写 Java 程序，需要安装 JDK。</p><h2 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2.== 和 equals 的区别是什么？"></a>2.== 和 equals 的区别是什么？</h2><p>==：</p><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p><ul><li>基本类型：比较的是值是否相同；</li><li>引用类型：比较的是引用是否相同；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String y = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p><p>equals：</p><p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//String的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？"><a href="#3-两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？" class="headerlink" title="3.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？"></a>3.两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</h2><p>不对，两个对象的 hashCode() 相同，equals() 不一定 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;通话&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;重地&quot;</span>;</span><br><span class="line">System. out. println(String. format(<span class="string">&quot;str1：%d | str2：%d&quot;</span>,  str1. hashCode(),str2. hashCode()));</span><br><span class="line">System. out. println(str1. equals(str2));</span><br><span class="line">执行的结果：</span><br><span class="line">str1：<span class="number">1179395</span> | str2：<span class="number">1179395</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p><h2 id="4-final-在-Java-中有什么作用？"><a href="#4-final-在-Java-中有什么作用？" class="headerlink" title="4.final 在 Java 中有什么作用？"></a>4.final 在 Java 中有什么作用？</h2><ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><h2 id="5-Java-中的-Math-round-1-5-等于多少？"><a href="#5-Java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5.Java 中的 Math. round(-1. 5) 等于多少？"></a>5.Java 中的 Math. round(-1. 5) 等于多少？</h2><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p><h2 id="6-String-属于基础的数据类型吗？"><a href="#6-String-属于基础的数据类型吗？" class="headerlink" title="6. String 属于基础的数据类型吗？"></a>6. String 属于基础的数据类型吗？</h2><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p><h2 id="7-Java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-Java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. Java 中操作字符串都有哪些类？它们之间有什么区别？"></a>7. Java 中操作字符串都有哪些类？它们之间有什么区别？</h2><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p><p>String 和 StringBuffer、StringBuilder 的区别在于 <strong>String 声明的是不可变的对象</strong>，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p><p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p><h2 id="8-String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8.String str=”i”与 String str=new String(“i”)一样吗？"></a>8.String str=”i”与 String str=new String(“i”)一样吗？</h2><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，Java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p><h2 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9.如何将字符串反转？"></a>9.如何将字符串反转？</h2><p> StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// StringBuffer reverse</span><br><span class="line">StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">stringBuffer. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuffer. reverse()); // gfedcba// StringBuilder reverse</span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">stringBuilder. append(&quot;abcdefg&quot;);</span><br><span class="line">System. out. println(stringBuilder. reverse()); // gfedcba</span><br></pre></td></tr></table></figure><h2 id="10-抽象类必须要有抽象方法吗？"><a href="#10-抽象类必须要有抽象方法吗？" class="headerlink" title="10.抽象类必须要有抽象方法吗？"></a>10.抽象类必须要有抽象方法吗？</h2><p>不需要，抽象类不一定非要有抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System. out. println(<span class="string">&quot;hi~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-普通类和抽象类有哪些区别？"><a href="#11-普通类和抽象类有哪些区别？" class="headerlink" title="11.普通类和抽象类有哪些区别？"></a>11.普通类和抽象类有哪些区别？</h2><p>· 普通类不能包含抽象方法，抽象类可以包含抽象方法。</p><p>· 抽象类不能直接实例化，普通类可以直接实例化。</p><h2 id="12-抽象类能使用-final-修饰吗？"><a href="#12-抽象类能使用-final-修饰吗？" class="headerlink" title="12.抽象类能使用 final 修饰吗？"></a>12.抽象类能使用 final 修饰吗？</h2><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</p><h2 id="13-接口和抽象类有什么区别？"><a href="#13-接口和抽象类有什么区别？" class="headerlink" title="13.接口和抽象类有什么区别？"></a>13.接口和抽象类有什么区别？</h2><p>· 实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</p><p>· 构造函数：抽象类可以有构造函数；接口不能有。</p><p>· 实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</p><p>· 访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p><h2 id="14-Java-中-IO-流分为几种？"><a href="#14-Java-中-IO-流分为几种？" class="headerlink" title="14.Java 中 IO 流分为几种？"></a>14.Java 中 IO 流分为几种？</h2><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流和字符流。</p><p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><h2 id="15-BIO、NIO、AIO-有什么区别？"><a href="#15-BIO、NIO、AIO-有什么区别？" class="headerlink" title="15.BIO、NIO、AIO 有什么区别？"></a>15.BIO、NIO、AIO 有什么区别？</h2><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><h2 id="16-Java-容器都有哪些？"><a href="#16-Java-容器都有哪些？" class="headerlink" title="16.Java 容器都有哪些？"></a>16.Java 容器都有哪些？</h2><p>Java 容器分为 Collection 和 Map 两大类，其下又有很多子类，如下所示：</p><ul><li><p>Collection</p></li><li><p>List</p><ul><li>ArrayList</li><li>LinkedList</li><li>Vector</li><li>Stack</li></ul></li><li><p>Set</p><ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul></li><li><p>Map</p><ul><li>HashMap</li><li>LinkedHashMap</li><li>TreeMap</li><li>ConcurrentHashMap</li><li>Hashtable</li></ul></li></ul><h2 id="17-Collection-和-Collections-有什么区别？"><a href="#17-Collection-和-Collections-有什么区别？" class="headerlink" title="17.Collection 和 Collections 有什么区别？"></a>17.Collection 和 Collections 有什么区别？</h2><ul><li>Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。</li><li>Collections 是一个包装类，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： Collections. sort(list)。</li></ul><h2 id="18-List、Set、Map-之间的区别是什么？"><a href="#18-List、Set、Map-之间的区别是什么？" class="headerlink" title="18.List、Set、Map 之间的区别是什么？"></a>18.List、Set、Map 之间的区别是什么？</h2><p><img src="/2020/07/24/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80/%E9%9B%86%E5%90%88.png" alt="image-20200724232852799"></p><h2 id="19-HashMap-和-Hashtable-有什么区别？"><a href="#19-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="19. HashMap 和 Hashtable 有什么区别？"></a>19. HashMap 和 Hashtable 有什么区别？</h2><ul><li>存储：<strong>HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。</strong></li><li>线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 <strong>ConcurrentHashMap</strong> 替代。</li></ul><h2 id="22-如何决定使用-HashMap-还是-TreeMap？"><a href="#22-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="22. 如何决定使用 HashMap 还是 TreeMap？"></a>22. 如何决定使用 HashMap 还是 TreeMap？</h2><p>对于在 Map 中<strong>插入、删除、定位一个元素这类操作，HashMap 是最好的选择</strong>，因为相对而言 HashMap 的插入会更快，但如果你要<strong>对一个 key 集合进行有序的遍历，那 TreeMap 是更好的选择</strong>。</p><h2 id="23-说一下-HashMap-的实现原理？"><a href="#23-说一下-HashMap-的实现原理？" class="headerlink" title="23.说一下 HashMap 的实现原理？"></a>23.说一下 HashMap 的实现原理？</h2><p>HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。当 hash 冲突的个数比较少时，使用链表否则使用红黑树。</p><h2 id="23-ArrayList-和-LinkedList-的区别是什么？"><a href="#23-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="23. ArrayList 和 LinkedList 的区别是什么？"></a>23. ArrayList 和 LinkedList 的区别是什么？</h2><ul><li>数据结构实现：ArrayList 是<strong>动态数组</strong>的数据结构实现，而 LinkedList 是<strong>双向链表</strong>的数据结构实现。</li><li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li><li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li></ul><p>综合来说，在需要频繁<strong>读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</strong></p><h2 id="24-ArrayList-和-Vector-的区别是什么？"><a href="#24-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="24. ArrayList 和 Vector 的区别是什么？"></a>24. ArrayList 和 Vector 的区别是什么？</h2><ul><li>线程安全：Vector 使用了 <strong>Synchronized</strong> 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，<strong>只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</strong></li></ul><h2 id="25-Array-和-ArrayList-有何区别"><a href="#25-Array-和-ArrayList-有何区别" class="headerlink" title="25.Array 和 ArrayList 有何区别"></a>25.Array 和 ArrayList 有何区别</h2><ul><li>Array <strong>可以存储基本数据类型和对象</strong>，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><h2 id="26-在-Queue-中-poll-和-remove-有什么区别？"><a href="#26-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="26.在 Queue 中 poll()和 remove()有什么区别？"></a>26.在 Queue 中 poll()和 remove()有什么区别？</h2><ul><li>相同点：都是返回第一个元素，并在队列中删除返回的对象。</li><li>不同点：如果没有元素 poll()会返回 null，而 remove()会直接抛出 NoSuchElementException 异常。</li></ul><h2 id="27-迭代器-Iterator-是什么？"><a href="#27-迭代器-Iterator-是什么？" class="headerlink" title="27.迭代器 Iterator 是什么？"></a>27.迭代器 Iterator 是什么？</h2><p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext())&#123;</span><br><span class="line">  String obj = it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p><h2 id="28-Iterator-和-ListIterator-有什么区别？"><a href="#28-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="28.Iterator 和 ListIterator 有什么区别？"></a>28.Iterator 和 ListIterator 有什么区别？</h2><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li><li>ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h2 id="29-怎么确保一个集合不能被修改？"><a href="#29-怎么确保一个集合不能被修改？" class="headerlink" title="29.怎么确保一个集合不能被修改？"></a>29.怎么确保一个集合不能被修改？</h2><p>使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合</p><h2 id="30-守护线程是什么？"><a href="#30-守护线程是什么？" class="headerlink" title="30.守护线程是什么？"></a>30.守护线程是什么？</h2><p>守护线程是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。在 Java 中垃圾回收线程就是特殊的守护线程。</p><h2 id="31-创建线程有哪几种方式？"><a href="#31-创建线程有哪几种方式？" class="headerlink" title="31.创建线程有哪几种方式？"></a>31.创建线程有哪几种方式？</h2><ul><li>继承 Thread 重写 run 方法；</li><li>实现 Runnable 接口；</li><li>实现 Callable 接口。</li></ul><h2 id="33-说一下-runnable-和-callable-有什么区别？"><a href="#33-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="33.说一下 runnable 和 callable 有什么区别？"></a>33.说一下 runnable 和 callable 有什么区别？</h2><p>runnable 没有返回值，<strong>callable 可以拿到有返回值</strong>，callable 可以看作是 runnable 的补充。</p><h2 id="33-sleep-和-wait-有什么区别？"><a href="#33-sleep-和-wait-有什么区别？" class="headerlink" title="33.sleep() 和 wait() 有什么区别？"></a>33.sleep() 和 wait() 有什么区别？</h2><ul><li>类的不同：sleep() 来自 Thread，wait() 来自 Object。</li><li>释放锁：sleep() 不释放锁；wait() 释放锁。</li><li>用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify()/notifyAll()直接唤醒。</li></ul><h2 id="34-notify-和-notifyAll-有什么区别？"><a href="#34-notify-和-notifyAll-有什么区别？" class="headerlink" title="34.notify() 和 notifyAll() 有什么区别？"></a>34.notify() 和 notifyAll() 有什么区别？</h2><p><strong>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</strong>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><h2 id="35-线程的-run-和-start-有什么区别？"><a href="#35-线程的-run-和-start-有什么区别？" class="headerlink" title="35.线程的 run() 和 start() 有什么区别？"></a>35.线程的 run() 和 start() 有什么区别？</h2><p>run()相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。</p><p>而<strong>start()的作用是启动相应的线程。</strong>启动一个线程实际是请求Java虚拟机运行相应的线程，而这个线程何时能够运行是由线程调度器决定的。start()调用结束并不表示相应线程已经开始运行，这个线程可能稍后运行，也可能永远也不会运行。</p><h2 id="36-线程池中-submit-和-execute-方法有什么区别？"><a href="#36-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="36.线程池中 submit() 和 execute() 方法有什么区别？"></a>36.线程池中 submit() 和 execute() 方法有什么区别？</h2><p>· execute()：只能执行 Runnable 类型的任务。</p><p>· submit()：可以执行 Runnable 和 Callable 类型的任务。</p><p>Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。</p><h2 id="37-多线程中-synchronized-锁升级的原理是什么？"><a href="#37-多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="37.多线程中 synchronized 锁升级的原理是什么？"></a>37.多线程中 synchronized 锁升级的原理是什么？</h2><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 <strong>threadid</strong> 字段，在第一次访问的时候 threadid 为空，<strong>jvm 让其持有偏向锁</strong>，并将 threadid 设置为其线程 id，<strong>再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁</strong>，通过<strong>自旋循环</strong>一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级<strong>升级为重量级锁</strong>，此过程就构成了 synchronized 锁的升级。</p><p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p><h2 id="38-说一下-synchronized-底层实现原理？"><a href="#38-说一下-synchronized-底层实现原理？" class="headerlink" title="38.说一下 synchronized 底层实现原理？"></a>38.说一下 synchronized 底层实现原理？</h2><p>是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要<strong>进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作</strong>，性能也很低。但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：<strong>偏向锁（Biased Locking）、轻量级锁和重量级锁</strong>，大大改进了其性能。</p><h2 id="39-synchronized-和-volatile-的区别是什么？"><a href="#39-synchronized-和-volatile-的区别是什么？" class="headerlink" title="39.synchronized 和 volatile 的区别是什么？"></a>39.synchronized 和 volatile 的区别是什么？</h2><p>· volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</p><p>· volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</p><p>· volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p><h2 id="40-synchronized-和-ReentrantLock-区别是什么？"><a href="#40-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="40.synchronized 和 ReentrantLock 区别是什么？"></a>40.synchronized 和 ReentrantLock 区别是什么？</h2><p>· ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；</p><p>· ReentrantLock <strong>必须手动获取与释放锁</strong>，而 synchronized 不需要手动释放和开启锁；</p><p>· ReentrantLock <strong>只适用于代码块锁</strong>，而 synchronized 可用于修饰方法、代码块等。</p><h2 id="41-atomic"><a href="#41-atomic" class="headerlink" title="41.atomic"></a>41.atomic</h2><p>利用 CAS (Compare And Wwap) 和 volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><h2 id="42-什么是-Java-序列化？什么情况下需要序列化？"><a href="#42-什么是-Java-序列化？什么情况下需要序列化？" class="headerlink" title="42.什么是 Java 序列化？什么情况下需要序列化？"></a>42.什么是 Java 序列化？什么情况下需要序列化？</h2><p>Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。</p><ul><li><p>想把的内存中的对象状态保存到一个文件中或者数据库中时候；</p></li><li><p>想用套接字在网络上传送对象的时候；</p></li><li><p>想通过RMI（远程方法调用）传输对象的时候。</p></li></ul><h2 id="43-怎么实现动态代理？"><a href="#43-怎么实现动态代理？" class="headerlink" title="43.怎么实现动态代理？"></a>43.怎么实现动态代理？</h2><p>JDK 原生动态代理和 cglib 动态代理。JDK 原生动态代理是基于接口实现的，而 cglib 是基于继承当前类的子类实现的。</p><h2 id="44-对象拷贝"><a href="#44-对象拷贝" class="headerlink" title="44.对象拷贝"></a>44.对象拷贝</h2><p>· 实现 Cloneable 接口并重写 Object 类中的 clone() 方法。</p><p>· 实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p><p>· 浅克隆：当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p><p>· 深克隆：除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-栈队列</title>
      <link href="/2020/07/24/leetcode/leetcode%E6%A0%88%E9%98%9F%E5%88%97/"/>
      <url>/2020/07/24/leetcode/leetcode%E6%A0%88%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-用栈实现队列"><a href="#1-用栈实现队列" class="headerlink" title="1. 用栈实现队列"></a>1. 用栈实现队列</h1><p>使用栈实现队列的下列操作：</p><p>push(x) – 将一个元素放入队列的尾部。<br>pop() – 从队列首部移除元素。<br>peek() – 返回队列首部的元素。<br>empty() – 返回队列是否为空。</p><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks">https://leetcode-cn.com/problems/implement-queue-using-stacks</a></p><p>栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lq.leetcode.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in2out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-用队列实现栈"><a href="#2-用队列实现栈" class="headerlink" title="2. 用队列实现栈"></a>2. 用队列实现栈</h1><p>225</p><p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="comment">//每次将插入的数据重新插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size--&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-最小值栈"><a href="#3-最小值栈" class="headerlink" title="3. 最小值栈"></a>3. 最小值栈</h1><p>155</p><img src="/2020/07/24/leetcode/leetcode%E6%A0%88%E9%98%9F%E5%88%97/最小栈.gif" alt="fig1" style="zoom:67%;"><p>按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p><p>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</p><p>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</p><p>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dataStack.add(x);</span><br><span class="line">        min = Math.min(min, x);</span><br><span class="line">        minStack.add(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">        min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2020/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h2><span id="more"></span><p>线性结构常见的有：数组、队列、链表和栈</p><p>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</p><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p><p>稀疏数组的处理方法是:<br>记录数组一共有几行几列，有多少个不同的值<br>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p><ul><li>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)<br>把稀疏数组存盘，并且可以从新恢复原来的二维数组数</li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>循环队列</p><p>rear = （rear+1）%maxSize ；front = （front+1）%maxSize ；公式进行指针计算。</p><p>队空状态的条件为：front = rear。而如果整个队列全部存满数据那么，队满的条件也是front = rear；所以循环队列需要损失一个存储空间</p><p>队列内个数（rear+maxSize-front）%maxSize;</p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object data;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Object e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data=e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>添加 </p><ul><li>找到最好的一个节点temp</li><li>temp.next = newnode</li><li>newnode.pre = temp</li></ul><p>删除</p><ul><li>找到这个节点temp</li><li>temp.pre.next = temp.next</li><li>temp.next.pre = temp.pre</li></ul><h4 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h4><p>单向环形列表</p><p>Josephu  问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为<strong>k</strong>（1&lt;=k&lt;=n）的人从1开始报数，数到<strong>m</strong> 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p><p>用一个不带头结点的循环链表来处理Josephu 问题：<strong>先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</strong></p><p>构建一个单向环形链表</p><ul><li>创建第一个节点，让first指向该点，并形成环形。</li><li>每创建一个新的节点，就把该节点，加入到已有的环形链表中即可</li></ul><p>遍历</p><ul><li>让辅助指针指向curboy,指向first</li><li>while循环遍历直到curBoy.next=first</li></ul><p>根据用户的输入</p><ul><li>n=5 5个人</li><li>k=1 从第一个人开始报数</li><li>m=2 输两下</li></ul><p>解决</p><ul><li>创建一个辅助指针helper ,指向链表的最后一个节点</li><li>报数前，让first和helper移动 k-1</li><li>当报数时，first个helper同时移动m-1;</li><li>first指向的小孩出圈<ul><li>first = first.next</li><li>helper.next = first</li></ul></li></ul><p>5个小孩出圈顺序 2-&gt;4-&gt;1-&gt;5-&gt;3</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先入后出</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。     </li><li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li><li>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</li><li>二叉树的遍历。</li><li>图形的深度优先(depth一first)搜索法</li></ul><h4 id="计算器实现"><a href="#计算器实现" class="headerlink" title="计算器实现"></a>计算器实现</h4><ol><li>遍历表达式</li><li>数字如数栈</li><li>符号<ol><li>栈空就入栈</li><li>不为空，就比较优先级，<strong>如果当前操作符的优先级小于，就需要从数栈中pop两个数</strong>，在pop一个符号，将结果入数栈，然后将操作符如入符号栈，<strong>如果当前操作符大于栈中的操作符， 加载直接入符</strong>号栈</li></ol></li><li>扫描完毕，就顺序从数栈和符号栈中pop出相应的数和符号，并运行</li><li>只有一个数字，就是结果</li></ol><h4 id="前缀、中缀、后缀表达式-逆波兰表达式"><a href="#前缀、中缀、后缀表达式-逆波兰表达式" class="headerlink" title="前缀、中缀、后缀表达式(逆波兰表达式)"></a>前缀、中缀、后缀表达式(逆波兰表达式)</h4><p>前缀表达式(波兰表达式)</p><ul><li><p>前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前<br>举例说明： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6</p><p>前缀表达式的计算机求值</p><p><strong>从右至左扫描表达式</strong>，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p><p>例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:</p></li></ul><ul><li><p>从右至左扫描，将6、5、4、3压入堆栈</p></li><li><p>遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈</p></li><li><p>接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈</p></li><li><p>最后是-运算符，计算出35-6的值，即29，由此得出最终结果</p></li></ul><p>后缀表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后</span><br><span class="line">中举例说明： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –</span><br></pre></td></tr></table></figure><p><strong>从左至右</strong>扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p><h5 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h5><p>1)初始化两个栈:运算符栈s1和储存中间结果的栈s2;</p><p>2)从左至右扫描中缀表达式;</p><p>3)遇到操作数时，将其压s2;</p><p>4)遇到运算符时，比较其与s1栈顶运算符的优先级:</p><p>​    1.如果s1为空，或栈顶运算符为左括号“”，则直接将此运算符入栈;</p><p>​    2.否则，若优先级比栈顶运算符的高，也将运算符压入s1;</p><p>​    3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较;</p><p>5)遇到括号时:</p><p>​    (1)如果是左括号“(”，则直接压入s1</p><p>​    (2)如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一-对括号丢弃</p><p>6)重复步骤2至5，直到表达式的最右边</p><p>7)将s1中剩余的运算符依次弹出并压入s2</p><p>8)依次弹出s2中的元素并输出，结果的逆即为中缀表达式对应的后缀表达式</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><h3 id="八皇后问题-回溯算法"><a href="#八皇后问题-回溯算法" class="headerlink" title="八皇后问题(回溯算法)"></a>八皇后问题(回溯算法)</h3><p>任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p><ul><li>第一个皇后先放第一行第一列</li><li>第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li><li>继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li><li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.</li><li>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 </li></ul><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><img src="/2020/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/排序.png" alt="image-20200723100629298" style="zoom:67%;"><img src="/2020/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/排序时间复杂度2.png" alt="image-20200723101337221" style="zoom: 67%;"><p><img src="/2020/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="排序时间复杂度"></p><ul><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li></ul><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</p><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</p><p>Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) </p><p>[<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F.md]">https://github.com/CyC2018/CS-Notes/blob/master/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F.md]</a>(<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/算法">https://github.com/CyC2018/CS-Notes/blob/master/notes/算法</a> - 排序.md)</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p><p><strong>如果一趟比较下来没有进行过交换，就说明序列有序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序算法,O(n*n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">// 临时变量</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标识变量，表示是否进行过交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123; <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>; <span class="comment">// 重置flag!!!, 进行下次判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8w数据 13066ms</span></span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//选择排序时间复杂度是 O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">int</span> min = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">                min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">                minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">            arr[minIndex] = arr[i];</span><br><span class="line">            arr[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8w数据 2363ms</span></span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。</p><p>插入排序的时间复杂度取决于数组的初始顺序，如果数组已经部分有序了，那么逆序较少，需要的交换次数也就较少，时间复杂度较低。</p><ul><li>平均情况下插入排序需要 ~N2/4 比较以及 ~N2/4 次交换；</li><li>最坏的情况下需要 ~N2/2 比较以及 ~N2/2 次交换，最坏的情况是数组是倒序的；</li><li>最好的情况下需要 N-1 次比较和 0 次交换，最好的情况就是数组已经有序了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> insertVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> insertIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//使用for循环来把代码简化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">//定义待插入的数</span></span><br><span class="line">        insertVal = arr[i];</span><br><span class="line">        insertIndex = i - <span class="number">1</span>; <span class="comment">// 即arr[1]的前面这个数的下标</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line">        <span class="comment">// 说明</span></span><br><span class="line">        <span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line">        <span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line">        <span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line">        <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">            arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];<span class="comment">// arr[insertIndex]</span></span><br><span class="line">            insertIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line">        <span class="comment">// 举例：理解不了，我们一会 debug</span></span><br><span class="line">        <span class="comment">//这里我们判断是否需要赋值</span></span><br><span class="line">        <span class="keyword">if</span>(insertIndex + <span class="number">1</span> != i) &#123;</span><br><span class="line">            arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8w数据 680ms</span></span><br></pre></td></tr></table></figure><p>当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>缩小增量排序</p><p>对于大规模的数组，插入排序很慢，因为它只能交换相邻的元素，每次只能将逆序数量减少 1。希尔排序的出现就是为了解决插入排序的这种局限性，它通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 根据前面的逐步分析，使用循环处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历各组中所有的元素(共gap组，每组有个元素), 步长gap</span></span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">                <span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">                arr[j+gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8w数据 17ms  80w 220 800w 2949</span></span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base中存放基准数</span></span><br><span class="line">    <span class="keyword">int</span> base = array[left];   <span class="comment">//选择要比较的数据</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span>(i != j) &#123;</span><br><span class="line">        <span class="comment">// 顺序很重要，先从右边开始往左找，直到找到比base值小的数</span></span><br><span class="line">        <span class="keyword">while</span>(array[j] &gt;= base &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再从左往右边找，直到找到比base值大的数</span></span><br><span class="line">        <span class="keyword">while</span>(array[i] &lt;= base &amp;&amp; i &lt; j) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面的循环结束表示找到了位置或者(i&gt;=j)了，交换两个数在数组中的位置</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = array[i];</span><br><span class="line">            array[i] = array[j];</span><br><span class="line">            array[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将基准数放到中间的位置（基准数归位）</span></span><br><span class="line">    array[left] = array[i];</span><br><span class="line">    array[i] = base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归，继续向基准的左右两边执行和上面同样的操作</span></span><br><span class="line">    <span class="comment">// i的索引处为上面已确定好的基准值的位置，无需再处理</span></span><br><span class="line">    quickSort(array, left, i - <span class="number">1</span>);</span><br><span class="line">    quickSort(array, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8w 40ms 80w 147ms 800w 1298 </span></span><br></pre></td></tr></table></figure><p>空间换时间 综合上比希尔排序快</p><p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>利用归并的思想实现的排序方法</p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤     3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> temp[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(arr,left,mid,temp);</span><br><span class="line">        mergeSort(arr,mid+<span class="number">1</span>,right,temp);</span><br><span class="line">        <span class="comment">//合并</span></span><br><span class="line">        merge(arr,left,mid,right,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right,<span class="keyword">int</span> temp[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left; <span class="comment">//右边索引</span></span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>; <span class="comment">//左边索引</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//执行temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先把左右两边的数据填充到temp ,直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        <span class="comment">//把昨天的数组拷贝到temp</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j])&#123;</span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">//将右边有序序列填充</span></span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把有剩余数据的一边，填充到temp</span></span><br><span class="line">    <span class="keyword">while</span> ( i &lt;= mid)&#123;</span><br><span class="line">        temp[t++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( j&lt;= right)&#123;</span><br><span class="line">        temp[t++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把temp拷贝到arr</span></span><br><span class="line">    <span class="comment">//不是每次都拷贝所有</span></span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tempLeft = left;</span><br><span class="line">    <span class="keyword">while</span> ( tempLeft &lt;= right)&#123;</span><br><span class="line">        arr[tempLeft++] = temp[t++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8w 34ms 80w 177 800w 1765</span></span><br></pre></td></tr></table></figure><p>（1）稳定性<br>     　归并排序是一种<strong>稳定的排序</strong>。<br>（2）存储结构要求<br>    　可用顺序存储结构。也易于在链表上实现。<br>（3）时间复杂度<br>    　对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是<strong>O(nlogn)</strong>。<br>（4）空间复杂度<br>   　 需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。</p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><ul><li>稳定性的排序</li><li>桶排序的扩展</li><li>将整数按位数切割成不同的数字，然后按每个位数分别比较。</li></ul><p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 得到数组中最大的数的位数</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>]; <span class="comment">//假设第一数就是最大数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到最大数是几位数</span></span><br><span class="line">    <span class="keyword">int</span> maxLength = (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">    <span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line">    <span class="comment">//3. 名明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line">    <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">    <span class="comment">//可以这里理解</span></span><br><span class="line">    <span class="comment">//比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line">    <span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里我们使用循环将代码处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> , n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">//取出每个元素的对应位的值</span></span><br><span class="line">            <span class="keyword">int</span> digitOfElement = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//放入到对应的桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]++] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">            <span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">            <span class="keyword">if</span>(bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                    <span class="comment">//取出元素放入到arr</span></span><br><span class="line">                    arr[index++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">            bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8w 23ms  80w 95ms 800 518ms</span></span><br></pre></td></tr></table></figure><p>空间换时间 耗费额外的内存空间</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li><p>顺序(线性)查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线性查找是逐一比对，发现有相同值，就返回下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二分查找/折半查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right =arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((left &lt;= right))&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; target)&#123;</span><br><span class="line">                right = mid -<span class="number">1</span>; <span class="comment">//向左边查找</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>{1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch2(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch2(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//        * 思路分析</span></span><br><span class="line">        <span class="comment">//        * 1. 在找到mid 索引值，不要马上返回</span></span><br><span class="line">        <span class="comment">//        * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line">        <span class="comment">//        * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line">        <span class="comment">//        * 4. 将Arraylist返回</span></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; resIndexlist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line">        <span class="keyword">int</span> temp = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; <span class="number">0</span> || arr[temp] != findVal) &#123;<span class="comment">//退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，就temp 放入到 resIndexlist</span></span><br><span class="line">            resIndexlist.add(temp);</span><br><span class="line">            temp -= <span class="number">1</span>; <span class="comment">//temp左移</span></span><br><span class="line">        &#125;</span><br><span class="line">        resIndexlist.add(mid);  <span class="comment">//</span></span><br><span class="line">        <span class="comment">//向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line">        temp = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; arr.length - <span class="number">1</span> || arr[temp] != findVal) &#123;<span class="comment">//退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，就temp 放入到 resIndexlist</span></span><br><span class="line">            resIndexlist.add(temp);</span><br><span class="line">            temp += <span class="number">1</span>; <span class="comment">//temp右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resIndexlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插值查找</p></li></ul><p>int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low])  ;/<em>插值索引</em>/</p><p>对应前面的代码公式：int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要</span></span><br><span class="line">    <span class="comment">//否则我们得到的 mid 可能越界</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求出mid, 自适应</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">    <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line">    <span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 说明应该向右边递归</span></span><br><span class="line">        <span class="keyword">return</span> insertValueSearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 说明向左递归查找</span></span><br><span class="line">        <span class="keyword">return</span> insertValueSearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快.<br>关键字分布不均匀的情况下，该方法不一定比折半查找要好</p><ul><li>斐波那契查找</li></ul><p>斐波那契(黄金分割法)原理:<br>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的id时,要求查找到该员工的 所有信息.</p><p>要求: 不使用数据库,尽量节省内存,速度越快越好=&gt;哈希表(散列)</p><p>散列表（Hash table，也叫哈希表），是根据<strong>关键码值</strong>(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<strong>散列函数</strong>，存放记录的数组叫做散列表。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>数组存储方式的分析</p><ul><li>优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。</li><li>缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低</li></ul><p>链式存储方式的分析</p><ul><li>优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。</li><li>缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) </li></ul><p>树存储方式的分析</p><ul><li>能提高数据存储，读取的效率,  比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</li></ul><p><strong>二叉树</strong></p><p>1）在二叉树的第i层上最多有2i-1 个节点 。（i&gt;=1）</p><p>2）二叉树中如果深度为k,那么最多有2k-1个节点。(k&gt;=1）</p><p>3）n0=n2+1 n0表示度数为0的节点数，n2表示度数为2的节点数。</p><p>4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。</p><p>5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：</p><ul><li>(1) 若     i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;</li><li>(2) 若     2i&gt;n，则该结点无左孩子， 否则，编号为 2i 的结点为其左孩子结点；</li><li>(3) 若     2i+1&gt;n，则该结点无右孩子结点， 否则，编号为2i+1 的结点为其右孩子结点。</li></ul><p><strong>线索化二叉树</strong></p><p>n个结点的二叉链表中含有n+1  【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）<br>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。<strong>根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种</strong><br>一个结点的前一个结点，称为前驱结点<br>一个结点的后一个结点，称为后继结点</p><p><img src="/2020/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="image-20200725160237037"></p><p>遍历线索化二叉树</p><p>说明：对前面的中序线索化的二叉树， 进行遍历<br>分析：因为线索化后，各个结点指向有变化，因此原来的遍历方式不能使用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。 遍历的次序应当和中序遍历保持一致。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是<strong>不稳定排序。</strong><br>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。<br>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p><ul><li>将待排序序列构造成一个大顶堆</li></ul><p><img src="/2020/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%861.png" alt="计算机生成了可选文字: 16 20 20 16 17"></p><img src="/2020/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Blog\source\_posts\数据结构\堆2.png" alt="计算机生成了可选文字: 20 17" style="zoom: 50%;"><ul><li>此时，整个序列的最大值就是堆顶的根节点。</li><li>将其与末尾元素进行交换，此时末尾就为最大值。</li></ul><img src="/2020/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/堆3.png" alt="计算机生成了可选文字: 17" style="zoom:50%;"><ul><li>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</li></ul><p><img src="/2020/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%864.png" alt="计算机生成了可选文字: 16"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length/<span class="number">2</span> - <span class="number">1</span>; i&gt;=<span class="number">0</span> ; i--)&#123;</span><br><span class="line">        adjustHeap(arr,i,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = arr.length-<span class="number">1</span>; j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">        temp = arr[j];</span><br><span class="line">        arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = temp;</span><br><span class="line">        adjustHeap(arr,<span class="number">0</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *将一个数组调整成大顶堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 非叶子节点索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k+<span class="number">1</span>&lt; length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//左小于右</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[k]&gt;temp)&#123; <span class="comment">//子节点大于父节点</span></span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            i=k;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将以i为父节点的值放在了堆顶</span></span><br><span class="line">    arr[i] = temp; <span class="comment">//将temp放到调整后的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8w 11ms 80w 147ms 800w 2204ms</span></span><br></pre></td></tr></table></figure><h3 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h3><p>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，<br>赫夫曼树是<strong>带权路径长度最短的树</strong>，权值较大的结点离根较近。</p><p><strong>结点的权及带权路径长度</strong></p><p><strong>树的带权路径长度</strong></p><p>构成赫夫曼树的步骤：</p><ul><li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li><li>取出根节点权值最小的两颗二叉树 </li><li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  </li><li>再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历 arr 数组</span></span><br><span class="line">        <span class="comment">// 2. 将arr的每个元素构成成一个Node</span></span><br><span class="line">        <span class="comment">// 3. 将Node 放入到ArrayList中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//排序</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//Collections.sort使用合并排序算法而不是快速排序。但是Arrays.sort使用快速排序</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出权值最小的</span></span><br><span class="line">            Node left = nodes.get(<span class="number">0</span>);</span><br><span class="line">            Node right = nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构建一颗新的二叉树</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(left.value+right.value);</span><br><span class="line">            parent.left = left;</span><br><span class="line">            parent.right = right;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//删除2个节点</span></span><br><span class="line">            nodes.remove(left);</span><br><span class="line">            nodes.remove(right);</span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赫夫曼编码</p><p>  哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法</p><p>赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间</p><p>d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  // 各个字符对应的个数<br>0=  ,  1=a, 10=i, 11=e, 100=k, 101=l, 110=o, 111=v, 1000=j, 1001=u, 1010=y, 1011=d</p><ul><li>说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推.</li></ul><p>字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码</p><p>无损压缩</p><ul><li>Node {data 数据weight权值 left right }</li><li>字符串byte数组</li><li>准备构建赫夫曼的Node ,将节点放入list</li><li>创建对应huffman树</li></ul><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。<br>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点</p><p>二叉排序树创建和遍历</p><p>二叉排序树的删除</p><p>删除叶子节点<br>删除只有一颗子树的节点<br>删除有两颗子树的节点.</p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。</p><p>左旋转</p><p>将A 节点的 右节点 的 左节点 ，指向 A节点<br>将 A节点的右节点，指向A 节点的右节点的左节点</p><p>二叉树与B树</p><p>B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。</p><p>2-3树</p><ul><li>2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)</li><li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li><li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.</li><li>2-3树是由二节点和三节点构成的树。</li></ul><p>B树</p><p>就是B-树 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.</p><p>B+树</p><p>关键字都出现在叶子结点的链表中</p><p>即数据只能在叶子节点【也叫稠密索引】，非叶子结点相当于是叶子结点的索引（稀疏索引）</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>顶点(vertex)，边(edge)，路径，无向图，有向图，带权图</p><p><strong>邻接矩阵</strong></p><p><strong>矩阵上的每个坐标代表当前两个顶点之间是否有边，有边值为1，无边为0</strong></p><p><strong>邻接表</strong></p><p>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失.<br>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成</p><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</p><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-链表</title>
      <link href="/2020/07/21/leetcode/leetcode%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/07/21/leetcode/leetcode%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-归并两个有序的链表"><a href="#1-归并两个有序的链表" class="headerlink" title="1.归并两个有序的链表"></a>1.归并两个有序的链表</h1><span id="more"></span><ol start="21"><li>Merge Two Sorted Lists</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-从有序链表中删除重复节点"><a href="#2-从有序链表中删除重复节点" class="headerlink" title="2.从有序链表中删除重复节点"></a>2.从有序链表中删除重复节点</h1><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       ListNode current = head;</span><br><span class="line">       <span class="keyword">while</span> (current != <span class="keyword">null</span> &amp;&amp; current.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (current.next.val == current.val)&#123;</span><br><span class="line">               current.next = current.next.next;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               current = current.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="3-删除链表的倒数第-n-个节点"><a href="#3-删除链表的倒数第-n-个节点" class="headerlink" title="3.删除链表的倒数第 n 个节点"></a>3.删除链表的倒数第 n 个节点</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个节点</a></p><p>首先设立<strong>预先指针 pre</strong>，预先指针是一个小技巧，在第2题中进行了讲解</p><p>设预先指针 <strong>pre 的下一个节点指向 head</strong>，设前指针为 start，后指针为 end，二者都等于 pre</p><p><strong>start 先向前移动n步</strong></p><p><strong>之后 start 和 end 共同向前移动，此时二者的距离为 n</strong>，<strong>当 start 到尾部时，end 的位置恰好为倒数第 n 个节点</strong></p><p>因为要删除该节点，所以要移动到该节点的前一个才能删除，所以<strong>循环结束条件为 start.next != null</strong></p><p><strong>删除后返回 pre.next，为什么不直接返回 head 呢，因为 head 有可能是被删掉的点</strong></p><p>时间复杂度：O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        pre.next=head;</span><br><span class="line">        ListNode start=pre;</span><br><span class="line">        ListNode end=pre;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            start=start.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(start.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            start=start.next;</span><br><span class="line">            end=end.next;</span><br><span class="line">        &#125;</span><br><span class="line">        end.next=end.next.next;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="4-两两交换链表中的节点"><a href="#4-两两交换链表中的节点" class="headerlink" title="4 两两交换链表中的节点"></a>4 两两交换链表中的节点</h1><p>24(<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       ListNode per = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">       per.next=head;</span><br><span class="line"></span><br><span class="line">       ListNode tmp=per;</span><br><span class="line">       <span class="comment">//正序交换</span></span><br><span class="line">       <span class="keyword">while</span>(tmp.next!=<span class="keyword">null</span>&amp;&amp;tmp.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">           ListNode start=tmp.next;</span><br><span class="line">           ListNode end = tmp.next.next;</span><br><span class="line"></span><br><span class="line">           tmp.next=end;</span><br><span class="line">           start.next=end.next;</span><br><span class="line">           end.next=start;</span><br><span class="line"></span><br><span class="line">           tmp=tmp.next.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> per.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="5-相交链表"><a href="#5-相交链表" class="headerlink" title="5.相交链表"></a>5.相交链表</h1><p>160(<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a>)</p><p>编写一个程序，找到两个单链表相交的起始节点.</p><p>如果两个链表相交，那么相交点之后的长度是相同的</p><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p><p><strong>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode l1 = headA;</span><br><span class="line">        ListNode l2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (l1 != l2)&#123;</span><br><span class="line">            l1 = (l1 == <span class="keyword">null</span>) ? headB : l1.next;</span><br><span class="line">            l2 = (l2 == <span class="keyword">null</span>) ? headA : l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="6-链表反转"><a href="#6-链表反转" class="headerlink" title="6.链表反转"></a>6.链表反转</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></p><p>反转一个单链表。</p><p>头插法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = newhead.next;</span><br><span class="line">            newhead.next = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        ListNode newhead = reverseList(next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="7-链表求和"><a href="#7-链表求和" class="headerlink" title="7.链表求和"></a>7.链表求和</h1><p>445 给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>将数组压入栈中，在顺序取出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用栈实现</span></span><br><span class="line">    Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    ListNode current1 = l1;</span><br><span class="line">    ListNode current2 = l2;</span><br><span class="line">    <span class="comment">//数据进栈</span></span><br><span class="line">    <span class="keyword">while</span> (current1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        s1.push(current1.val);</span><br><span class="line">        current1 = current1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (current2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">        s2.push(current2.val);</span><br><span class="line">        current2 = current2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span> ;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">while</span> (!s1.isEmpty() || !s2.isEmpty() || c!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (s1.isEmpty()? <span class="number">0</span>: s1.pop())+(s2.isEmpty()? <span class="number">0</span> : s2.pop())+c;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        c = sum / <span class="number">10</span>;</span><br><span class="line">        node.next = head;</span><br><span class="line">        head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例模式</title>
      <link href="/2020/07/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><span id="more"></span><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类<strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法(静态方法)。</p><p>比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这是就会使用到单例模式。</p><p><strong>1) 饿汉式(静态常量)</strong></p><p><strong>2) 饿汉式（静态代码块）</strong></p><p>3) 懒汉式(线程不安全)</p><p>4) 懒汉式(线程安全，同步方法)</p><p>5) 懒汉式(线程安全，同步代码块)</p><p><strong>6) 双重检查</strong></p><p><strong>7) 静态内部类</strong></p><p><strong>8) 枚举</strong></p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>1) 构造器私有化 (防止 new )</p><p>2) 类的内部创建对象</p><p>3) 向外暴露一个静态的公共方法。getInstance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。<strong>避免了线程同步问题。</strong></p><p>2) 缺点：在类装载的时候就完成实例化，<strong>没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</strong></p><p>结论：这种单例模式<strong>可用</strong>，<strong>可能</strong>造成内存浪费</p><h2 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的</p><h2 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公用方法，当使用该方法时 ，才去创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) 起到了Lazy Loading的效果，但是<strong>只能在单线程下使用</strong>。</p><p>2) 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式</p><p>3) 结论：<strong>在实际开发中，不要使用这种方式</strong></p><h2 id="懒汉式-线程安全，同步方法"><a href="#懒汉式-线程安全，同步方法" class="headerlink" title="懒汉式(线程安全，同步方法)"></a>懒汉式(线程安全，同步方法)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公用方法，当使用该方法时 ，才去创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) 解决了线程不安全问题</p><p>2) 效率太低了，每个线程在想获得类的实例时候，<strong>执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。</strong>方法进行同步效率太低</p><p>3) 结论：<strong>在实际开发中，不推荐使用这种方式</strong></p><h2 id="懒汉式-线程安全，同步代码块"><a href="#懒汉式-线程安全，同步代码块" class="headerlink" title="懒汉式(线程安全，同步代码块)"></a>懒汉式(线程安全，同步代码块)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公用方法，当使用该方法时 ，才去创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是这种同步并不能起到线程同步的作用</strong>。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例</p><p>结论：在<strong>实际开发中，不能使用这种方式</strong></p><h2 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a><strong>双重检查</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//volatile不能少 new不是一个原子操作 可能指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公用方法，当使用该方法时 ，才去创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，实例化代码只用执行一次，<strong>后面再次访问时</strong>，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步.</p><p>线程安全；<strong>延迟加载；效率较高</strong></p><p>结论：在实际开发中，<strong>推荐使用这种单例设计模式</strong></p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a><strong>静态内部类</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的公用方法，当使用该方法时 ，才去创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</p><p>2) 静态内部类方式在<strong>Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</strong></p><p>3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p><p>4) 优点：避免了<strong>线程不安全</strong>，利用静态内部类特点实现延迟加载，效率高</p><p>5) 结论：推荐使用</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><strong>枚举</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>  <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1) 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，<strong>而且还能防止反序列化重新创建新的对象。</strong></p><p>2) 这种方式是Effective Java作者Josh Bloch 提倡的方式</p><p>3) 结论：推荐使用</p><h2 id="单例模式JDK"><a href="#单例模式JDK" class="headerlink" title="单例模式JDK"></a>单例模式JDK</h2><p>我们JDK中，java.lang.Runtime就是经典的单例模式(<strong>饿汉式</strong>)</p><h2 id="细节说明"><a href="#细节说明" class="headerlink" title="细节说明"></a><strong>细节说明</strong></h2><ul><li><p>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</p></li><li><p>当想实例化一个单例类的时候，必须要记住<strong>使用相应的获取对象的方法</strong>，而不是使用new</p></li><li><p>单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如数据源、session工厂等)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>面向对象（Object Oriented)） -&gt;功能模块[设计模式+算法（数据结构] -&gt;框架(使用多种设计模式) -&gt;架构[服务器集群]</p><p>代码重用性、可扩展性，可读性、可靠性、高内聚低耦合</p><span id="more"></span><h2 id="七大原则"><a href="#七大原则" class="headerlink" title="七大原则"></a>七大原则</h2><h3 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h3><p>一个类只负责一项职责，如A类负责两个不同职责，职责1需要改变A时，可能造成职责2错误，需要把A分为A1,A2 。 如UserDao应该仅仅操作user一张表。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上</p><img src="/2020/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/接口隔离.png" alt="接口隔离" style="zoom:50%;"><p>​        将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p><img src="/2020/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/改进接口隔离.png" alt="改进接口隔离" style="zoom: 67%;"><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象</p><p>2) <strong>抽象不应该依赖细节，细节应该依赖抽象</strong></p><p>3) 依赖倒转(倒置)的中心思想是面向<strong>接口编程</strong></p><p>4) 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</p><p><strong>依赖关系传递的三种方式</strong> 接口传递、 构造方法传递、setter方式传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> principle.inversion.improve;</span><br><span class="line"><span class="comment">//方式1： 通过接口传递实现依赖</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//客户端无需改变</span></span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">      person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;电子邮件信息: hello,world&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;微信信息: hello,ok&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver)</span> </span>&#123;</span><br><span class="line">      System.out.println(receiver.getInfo());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2: 通过构造方法依赖传递</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">//ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ITV tv; <span class="comment">//成员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenAndClose</span><span class="params">(ITV tv)</span></span>&#123; <span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">this</span>.tv = tv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式3 , 通过setter方法传递</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">// ITV接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> ITV tv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tv = tv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tv.play();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</p><p>继承时遵循里氏替换原则</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</p><p>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，<strong>增加对象间的耦合性</strong>，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</p><ul><li>所有引用基类的地方必须能透明地使用其子类的对象。</li><li>在子类中<strong>尽量</strong>不要重写父类的方法</li><li>继承实际上让两个类耦合性增强了，<strong>在适当的情况下，可以通过聚合，组合，依赖 来解决问题。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><ul><li>一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。</li><li>当软件需要变化时，尽量<strong>通过扩展</strong>软件实体的行为来实现变化，而<strong>不是通过修改</strong>已有的代码来实现变化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用方的代码就不需要修</span></span><br><span class="line">        s.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息</p><p>只与直接的朋友通信</p><p>直接朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称<strong>出现成员变量，方法参数，方法返回值中的类为直接的朋友</strong>，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部</p><ul><li>迪米特法则的核心是<strong>降低类之间的耦合</strong></li><li>但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</li></ul><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>尽量使用合成/聚合的方式，而不是使用继承</p><img src="/2020/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/合成复用.png" alt="合成复用" style="zoom: 80%;"><h3 id="设计原则核心思想"><a href="#设计原则核心思想" class="headerlink" title="设计原则核心思想"></a>设计原则核心思想</h3><ul><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的松耦合设计而努力</li></ul><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>UML——Unified modeling language UML (<strong>统一建模语言</strong>)</p><p>是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系</p><p>Rational  Rose来画类图</p><p>图分类：</p><p>1) 用例图(use case)<br>2) 静态结构图：类图、对象图、包图、组件图、部署图<br>3) 动态行为图：交互图（时序图与协作图）、状态图、活动图</p><p>类之间的关系：<strong>依赖、泛化（继承）、实现、关联、聚合与组合</strong></p><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a><strong>依赖关系</strong></h4><p>只要是在<strong>类中用到了对方</strong>，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了</p><img src="/2020/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/依赖.png" alt="依赖" style="zoom:67%;"><h4 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h4><p>泛化关系实际上就是继承关系,他是<strong>依赖关系的特例</strong></p><img src="/2020/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/泛化.png" alt="泛化" style="zoom:67%;"><h4 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h4><p>实现关系实际上就是A类实现B接口，他是<strong>依赖关系的特例</strong></p><p><img src="/2020/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB.png" alt="实现关系"></p><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><p>关联关系实际上就是<strong>类与类之间的联系，他是依赖关系的特例</strong></p><p>关联具有导航性：即双向关系或单向关系</p><p>关系具有多重性：如“1”（表示有且仅有一个），“0…”（表示0个或者多个），“0，1”（表示0个或者一个），“n…m”(表示n到 m个都可以),“m…*”（表示至少m个）。</p><h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><p>表示的是<strong>整体和部分</strong>的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。</p><p>如：一台电脑由键盘(keyboard)、显示器(monitor)，鼠标等组成；组成电脑的各个配件是可以从电脑上分离出来的，使用带空心菱形的实线来表示：</p><img src="/2020/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/聚合关系.png" alt="image-20200721195509574" style="zoom:67%;"><h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p>组合关系：也是整体与部分的关系，但是整体与部分不可以分开。 </p><p>再看一个案例：在程序中我们定义实体：Person与IDCard、Head, 那么 Head 和Person 就是 组合，IDCard 和 Person 就是聚合。</p><p>但是如果在程序中Person实体中定义了对IDCard进行<strong>级联删除</strong>，即删除Person时连同IDCard一起删除，那么IDCard 和 Person 就是组合了</p><img src="/2020/07/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/组合.png" alt="image-20200721195926231" style="zoom:67%;"><h2 id="设计模式类型"><a href="#设计模式类型" class="headerlink" title="设计模式类型"></a>设计模式类型</h2><p><strong>1)</strong> <strong>创建型模式</strong>：<strong>单例模式</strong>、抽象工厂模式、原型模式、建造者模式、<strong>工厂模式</strong>。</p><p><strong>2)</strong> <strong>结构型模式</strong>：适配器模式、桥接模式、<strong>装饰模式</strong>、组合模式、外观模式、享元模式、<strong>代理模式</strong>。</p><p><strong>3)</strong> <strong>行为型模式</strong>：模版方法模式、命令模式、访问者模式、迭代器模式、<strong>观察者模式</strong>、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式(责任链模式)。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm(8)--垃圾回收2</title>
      <link href="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/"/>
      <url>/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><span id="more"></span><h2 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h2><p>会显式触发FullGC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而system.gc() )调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p><p>无须手动触发。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p><ul><li>如果调用<strong>System.runFinalization()会强制调用</strong>，并打印运行结果，但是不一定会触发销毁的方法，调用System.runFinalization()会强制调用 失去引用对象的finalize()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 局部变量回收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVarGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发Minor GC没有回收对象，然后在触发Full GC将该对象存入old区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 触发YoungGC的时候，已经被回收了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不会被回收，因为它还存放在局部变量表索引为1的槽中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会被回收，因为它还存放在局部变量表索引为1的槽中，但是后面定义的value把这个槽给替换了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * localvarGC5中的数组已经被回收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localvarGC5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        localvarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalVarGC localVarGC = <span class="keyword">new</span> LocalVarGC();</span><br><span class="line">        localVarGC.localvarGC3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>javadoc中对outofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</p><ul><li>Java虚拟机的堆内存设置不够。</li></ul><p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</p><ul><li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li></ul><p>我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</p><p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的ooM有所改观，出现ooM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</p><p><strong>出OutofMemoryError之前，通常垃圾收集器会被触发</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如：在引用机制分析中，涉及到JVM会去尝试回收软引用指向的对象等。</span><br><span class="line">在java.nio.BIts.reserveMemory（）方法中，我们能清楚的看到，System.gc（）会被调用，以清理空间。</span><br></pre></td></tr></table></figure><p><strong>当然，也不是在任何情况下垃圾收集器都会被触发的</strong></p><p>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><strong>只有对象不会 再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</strong></p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致00M，也可以叫做宽泛意义上的“内存泄漏”。</p><p>这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p><p>例如：买房子：80平的房子，但是有10平是公摊的面积，我们是无法使用这10平的空间，这就是所谓的内存泄漏</p><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F.png" alt="内存泄漏"></p><p>举例</p><ul><li><p>单例模式<br>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p></li><li><p>一些提供close的资源未关闭导致内存泄漏<br>数据库连接（dataSourse.getConnection() ），网络连接（socket）和io连接必须手动close，否则是不能被回收的。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_45759791/article/details/107336360">https://blog.csdn.net/weixin_45759791/article/details/107336360</a></p></li></ul><h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>指的是GC事件发生过程中，会产生应用程序的停顿。</p><p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿。</p><h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><ul><li>并行（Paralle1）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如ParNew、Parallel Scavenge、Parallel old；</li><li>串行（Serial）<ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li></ul></li></ul><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/垃圾回收并发并行.png" alt="image-20200719145522190" style="zoom:67%;"><ul><li>并发（Concurrent）：指<strong>用户线程与垃圾收集线程</strong>同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。&gt;用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li></ul><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/E:%5CBlog%5Csource_posts%5Cjvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)%5C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%B9%B6%E5%8F%91.png" alt="image-20200719150136115"></p><h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p><p>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。</p><p>大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如<strong>方法调用、循环跳转和异常跳转</strong>等。</p><ul><li><strong>抢先式中断</strong>：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li><strong>主动式中断</strong>：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</li></ul><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>线程处于sleep-状态或Blocked 状态，这时候线程无法响应JVM的中断请求,需要安全区域（Safe Region）来解决。</p><p><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始Gc都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</strong></p><ul><li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p><p>强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么</p><ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）</li></ul><p>引用强度依次逐渐减弱</p><p>java.1ang.ref包中</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p><strong>只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</strong></p><p>强引用是造成Java内存泄漏的主要原因之一。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>内存足够是不会回收，内存不足就回收。</p><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 创建一个软引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用，这是必须的，不然会存在强引用和软引用</span></span><br></pre></td></tr></table></figure><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>只能生存到下一次垃圾回收之前</p><p><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。</strong></p><p>三级缓存 ：内存缓存，本地缓存，网络缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">// 创建一个弱引用</span></span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>; <span class="comment">//销毁强引用，这是必须的，不然会存在强引用和弱引用</span></span><br></pre></td></tr></table></figure><p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。<strong>弱引用对象更容易、更快被GC回收。</strong></p><p>面试题：你开发中使用过WeakHashMap吗？</p><p>WeakHashMap用来存储图片信息，可以在内存不足的时候，及时回收，避免了OOM</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p><strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</strong>跟踪垃圾回收过程</p><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p><p>如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p><p>虚引用必须和引用队列一起使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 声明强引用</span><br><span class="line">Object obj = new Object();</span><br><span class="line">// 声明引用队列</span><br><span class="line">ReferenceQueue phantomQueue = new ReferenceQueue();</span><br><span class="line">// 声明虚引用（还需要传入引用队列）</span><br><span class="line">PhantomReference&lt;Object&gt; sf = new PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = null; </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhantomReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前类对象的声明</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;</span><br><span class="line">    <span class="comment">// 引用队列</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize方法&quot;</span>);</span><br><span class="line">        obj = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.getStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> PhantomReferenceTest();</span><br><span class="line">        <span class="comment">// 构造了PhantomReferenceTest对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj, phantomQueue);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(phantomReference.get());</span><br><span class="line">            <span class="comment">// 去除强引用</span></span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 第一次进行GC，由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第一次GC操作&quot;</span>);</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 不是 null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第二次GC操作&quot;</span>);</span><br><span class="line">            obj = <span class="keyword">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 不是 null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">null</span></span><br><span class="line">第一次GC操作</span><br><span class="line">调用当前类的finalize方法</span><br><span class="line">obj 不是 <span class="keyword">null</span></span><br><span class="line">第二次GC操作</span><br><span class="line">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="line">obj 是 <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>从上述运行结果我们知道，第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次gc，因为会调用finalize方法，将对象复活了，所以对象没有被回收，但是调用第二次gc操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是 将回收的值存入到引用队列中。</p><h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><p>它用于实现对象的finalize() 方法，也可以称为终结器引用</p><p>无需手动编码，其内部配合引用队列使用</p><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java不同版本新特性</span><br><span class="line">语法层面：Lambda表达式、switch、自动拆箱装箱、enum</span><br><span class="line">API层面：Stream API、新的日期时间、Optional、String、集合框架</span><br><span class="line">底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池位置变化</span><br></pre></td></tr></table></figure><h3 id="垃圾收集器分类"><a href="#垃圾收集器分类" class="headerlink" title="垃圾收集器分类"></a>垃圾收集器分类</h3><h4 id="按线程数分"><a href="#按线程数分" class="headerlink" title="按线程数分"></a><strong>按线程数分</strong></h4><p><strong>按线程数分</strong>（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</p><ul><li><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><p>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<strong>串行回收默认被应用在客户端的Client模式下的JVM中</strong><br>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。</p></li><li><p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。</p></li></ul><h4 id="按工作模式分"><a href="#按工作模式分" class="headerlink" title="按工作模式分"></a>按工作模式分</h4><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ul><h4 id="按碎片处理方式分"><a href="#按碎片处理方式分" class="headerlink" title="按碎片处理方式分"></a>按碎片处理方式分</h4><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。 指针碰撞</li><li>非压缩式的垃圾回收器不进行这步操作。空闲列表</li></ul><h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><ul><li><strong>吞吐量</strong>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li><li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。（重要）</li><li><strong>内存占用</strong>：Java堆区所占的内存大小。</li></ul><p>一款优秀的收集器通常最多同时满足其中的两项。</p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾收集时间）</p><ul><li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li></ul><h3 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h3><p>指一个时间段内应用程序线程暂停，让Gc线程执行的状态</p><h3 id="7种经典的垃圾收集器"><a href="#7种经典的垃圾收集器" class="headerlink" title="7种经典的垃圾收集器"></a>7种经典的垃圾收集器</h3><ul><li>串行回收器：Serial、Serial old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G11</li></ul><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/垃圾收集.png" alt="垃圾收集" style="zoom:67%;"><h3 id="7款经典收集器与垃圾分代之间的关系"><a href="#7款经典收集器与垃圾分代之间的关系" class="headerlink" title="7款经典收集器与垃圾分代之间的关系"></a>7款经典收集器与垃圾分代之间的关系</h3><p>新生代收集器：Serial、ParNew、Paralle1 Scavenge；</p><p>老年代收集器：Serial old、Parallel old、CMS；</p><p>整堆收集器：G1</p><h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB.png" alt="组合关系"></p><ul><li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14中：弃用Paralle1 Scavenge和Serialold GC组合（JEP366）</li><li>（青色虚线）JDK14中：删除CMs垃圾回收器（JEP363）</li></ul><p>因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><h3 id="如何查看默认垃圾收集器"><a href="#如何查看默认垃圾收集器" class="headerlink" title="如何查看默认垃圾收集器"></a>如何查看默认垃圾收集器</h3><p>-XX:+PrintcommandLineFlags：（包含使用的垃圾收集器）</p><p>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</p><h2 id="Serial和Serial-Old-回收器-并行"><a href="#Serial和Serial-Old-回收器-并行" class="headerlink" title="Serial和Serial Old 回收器:并行"></a>Serial和Serial Old 回收器:并行</h2><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><p>-XX：+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。</p><h2 id="ParNew回收器-并行"><a href="#ParNew回收器-并行" class="headerlink" title="ParNew回收器:并行"></a>ParNew回收器:并行</h2><p>Par是Parallel的缩写，New：只能处理的是新生代</p><p>ParNew收集器在年轻代中同样也是采用复制算法、”stop-the-World”机制。</p><p>除Serial外，目前只有ParNew GC能与CMS收集器配合工作</p><p>-XX：+UseParNewGC”</p><p>-XX:ParallelGCThreads限制线程数量</p><h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>也采用了复制算法、并行回收和”Stop the World”机制。</p><ul><li>达到一个可控制的吞吐量</li><li>自适应调节策略</li></ul><p><strong>高吞吐量则可以高效率地利用CPU时间</strong>，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Parallel old收集器采用了标记-压缩算法，但同样也是基于并行回收和”stop-the-World”机制。</p><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/Parallel.png" alt="Parallel"></p><p>在Java8中，默认是此垃圾收集器。</p><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><ul><li>-XX：+UseParallelGC 年轻代</li><li>-XX：+UseParalleloldcc 老年代<ul><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul></li><li>-XX:ParallelGcrhreads线程数,最好与CPU数量相等<ul><li>在默认情况下，当CPU数量小于8个，ParallelGcThreads的值等于CPU数量。</li><li>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU Count]/8]</li></ul></li><li>-XX:MaxGCPauseMillis 暂停时间</li><li>-XX:GCTimeRatio垃圾收集时间占总时间的比例</li><li>-XX:+UseAdaptivesizepplicy 设置Parallel scavenge收集器具有自适应调节策略</li></ul><h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>Concurrent-Mark-Sweep</p><p><strong>实现了让垃圾收集线程与用户线程同时工作</strong>。</p><p><strong>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</strong>CMS收集器就非常符合这类应用的需求。</p><p>CMS的垃圾收集算法采用<strong>标记-清除算法</strong>，并且也会”stop-the-world”</p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/CMS.png" alt="image-20200719230711532" style="zoom:67%;"><ul><li><strong>初始标记</strong>（Initial-Mark）阶段：程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是<strong>标记出GCRoots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</li><li><strong>并发标记</strong>（Concurrent-Mark）阶段：<strong>从GG Roots的直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长但是不需要停顿用户线程</strong>，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<strong>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</strong>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段<strong>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。</strong>由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><p><strong>在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。</strong>当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure” 失败</p><p><strong>标记清除算法</strong>采用空闲列表</p><h3 id="CMS为什么不使用标记整理算法"><a href="#CMS为什么不使用标记整理算法" class="headerlink" title="CMS为什么不使用标记整理算法"></a>CMS为什么不使用标记整理算法</h3><p>因为当并发清除的时候，用Compact整理内存的话，<strong>原来的用户线程使用的内存还怎么用呢</strong>？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world” 这种场景下使用</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>并发收集</li><li>低延迟</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><strong>会产生内存碎片</strong>，无法分配大对象的情况下，不得不提前触发FullGC。</li><li><strong>CMS收集器对CPU资源非常敏感。</strong>在并发阶段，会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li><strong>CMS收集器无法处理浮动垃圾。</strong>可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，<strong>那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</strong>，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ul><h3 id="设置的参数"><a href="#设置的参数" class="headerlink" title="设置的参数"></a>设置的参数</h3><ul><li><p>-XX：+UseConcMarkSweepGC 使用   自动ParNew</p></li><li><p>-XX:CMSInitiatingoccupanyFraction 设置堆内存使用率的阈值</p><p>JDK6及以上版本默认值为92%，该选项便可以有效降低Ful1Gc的执行次数。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li><li>如果你想要最小化GC的中断或停顿时间，请选CMs GC。</li></ul><p><strong>JDK9</strong>   CMS标记废弃</p><p>JDK14 删除CMS</p><h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><p><strong>在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</strong>。</p><p>它把堆内存分割为很多不相关的区域（Region），每次根据允许的收集时间，优先回收价值最大的Region。垃圾优先（Garbage First）。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>并行与并发</strong><ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行</li></ul></li><li><strong>分代收集</strong>、<ul><li>G1依然属于分代型垃圾回收器，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>同时兼顾年轻代和老年代。</li></ul></li></ul><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/G1%E5%88%86%E5%8C%BA.png" alt="G1分区"></p><ul><li><p><strong>空间整合</strong></p><ul><li>CMS：“标记-清除”算法、内存碎片、若干次Gc后进行一次碎片整理</li><li>G1内存的回收是以region作为基本单位的。<strong>Region之间是复制算法</strong>，但<strong>整体上实际可看作是标记-压缩（Mark-Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li></ul></li><li><p><strong>可预测的停顿时间模型</strong></p><p> 能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ul><li>G1可以只选取部分区域进行内存回收，这样缩小了回收的范围</li><li>每次根据允许的收集时间，优先回收价值最大的Region</li><li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ul></li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</li><li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</li></ul><h3 id="G1参数设置"><a href="#G1参数设置" class="headerlink" title="G1参数设置"></a>G1参数设置</h3><ul><li><p>-XX:+UseG1GC  使用</p></li><li><p>-XX:G1HeapRegionSize设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</p></li><li><p>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</p></li><li><p>-XX:+ParallelGcThread 设置STW工作线程数的值。最多设置为8</p></li><li><p>-XX:ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1/4左右。</p></li><li><p>-XX:InitiatingHeapoccupancyPercent 设置触发并发Gc周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p></li><li><p>第一步：开启G1垃圾收集器</p></li><li><p>第二步：设置堆的最大内存</p></li><li><p>第三步：设置最大的停顿时间</p></li></ul><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/G1%E6%B5%81%E7%A8%8B.png" alt="G1流程"></p><p> （如果需要，单线程、独占式、高强度的Fu11GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p><h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><p>一个对象被不同区域引用的问题</p><p><strong>解决方法：</strong></p><p>每个Region都有一个对应的Remembered Set；每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/RS.png" alt="RS"></p><h3 id="G1回收过程-年轻代GC"><a href="#G1回收过程-年轻代GC" class="headerlink" title="G1回收过程-年轻代GC"></a>G1回收过程-年轻代GC</h3><p>当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/%E5%B9%B4%E8%BD%BB%E4%BB%A3GC.png" alt="年轻代GC"></p><p>第一阶段，扫描根</p><p>第二阶段，更新RSet,RSet可以准确的反映老年代对所在的内存分段中对象的引用。</p><p>第三阶段，处理RSet</p><p>第四阶段，复制对象。</p><p>第五阶段，处理引用</p><h3 id="G1回收过程-并发标记过程"><a href="#G1回收过程-并发标记过程" class="headerlink" title="G1回收过程-并发标记过程"></a>G1回收过程-并发标记过程</h3><ul><li><strong>初始标记阶段</strong>：标记从根节点直接可达的对象。这个阶段是sTw的，并且会触发一次年轻代GC。</li><li><strong>根区域扫描（</strong>Root Region Scanning）：G1 Gc扫描survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在youngGC之前完成。</li><li><strong>并发标记</strong>（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被youngGC中断。在并发标记阶段，若<strong>发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。</strong>同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是sTw的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ul><h3 id="G1回收过程-混合回收"><a href="#G1回收过程-混合回收" class="headerlink" title="G1回收过程 - 混合回收"></a>G1回收过程 - 混合回收</h3><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/G1混合回收.png" alt="G1混合回收" style="zoom:67%;"><p>除了回收整个Young Region，还会回收一部分的old Region。</p><h3 id="G1回收的优化建议"><a href="#G1回收的优化建议" class="headerlink" title="G1回收的优化建议"></a>G1回收的优化建议</h3><p>年轻代大小</p><ul><li><p>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</p></li><li><p>固定年轻代的大小会覆盖暂停时间目标</p></li></ul><p>暂停时间目标不要太过严苛</p><ul><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/%E6%80%BB%E7%BB%93.png" alt="总结"></p><h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><ul><li>-XX:+PrintGc输出GC日志。类似：-verbose:gc</li><li>-XX:+PrintGcDetails输出Gc的详细日志</li><li>-XX:+PrintGcTimestamps 输出Gc的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDatestamps 输出Gc的时间戳（以日期的形式，如2013-05-04T21：53：59.234+0800）</li><li>-XX:+PrintHeapAtGC在进行Gc的前后打印出堆的信息</li><li>-Xloggc:../logs/gc.1og日志文件的输出路径</li></ul><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/gc%E5%9B%BE%E7%89%87.png" alt="gc图片"></p><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/cg%E5%8F%82%E6%95%B0.png" alt="cg参数"></p><h3 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h3><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/YoungGC.png" alt="YoungGC"></p><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p><img src="/2020/07/19/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(2)/FullGC.png" alt="FullGC"></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm(7)--垃圾回收</title>
      <link href="/2020/07/18/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2020/07/18/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><!--- more--><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p><img src="/2020/07/18/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A6%82%E8%BF%B0.png" alt="概述"></p><h3 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h3><p>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，<strong>甚至可能导致内存溢出</strong>。</p><h2 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h2><ul><li>内存迟早都会被消耗完</li><li>垃圾回收可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象。</strong></li><li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong></li></ul><h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>自动内存管理，无需开发人员手动参与内存的分配与回收，<strong>这样降低内存泄漏和内存溢出的风险</strong></p><p>可以更专心地专注于业务开发</p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p><h3 id="担忧"><a href="#担忧" class="headerlink" title="担忧"></a>担忧</h3><p>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</p><h3 id="GC主要关注的区域"><a href="#GC主要关注的区域" class="headerlink" title="GC主要关注的区域"></a>GC主要关注的区域</h3><p> 方法区 和堆</p><p>Java堆是垃圾收集器的工作重点</p><ul><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ul><h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="标记阶段（重要）"><a href="#标记阶段（重要）" class="headerlink" title="标记阶段（重要）"></a>标记阶段（重要）</h2><p>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</p><p>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，<strong>当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</strong></p><p>判断对象存活一般有两种方式：<strong>引用计数算法和可达性分析算法</strong>。</p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>引用计数算法（Reference Counting）比较简单，对<strong>每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</strong></p><p>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p><p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</p><p>缺点：</p><ul><li>它需要单独的字段存储计数器，这样的做法<strong>增加了存储空间的开销</strong>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这<strong>增加了时间开销。</strong></li><li><strong>无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</strong></li></ul><h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p><img src="/2020/07/18/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="循环引用"></p><p>java中不会出现这种内存泄露</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefCountGC</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个成员属性的唯一作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 引用</span></span><br><span class="line">    Object reference = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RefCountGC obj1 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        RefCountGC obj2 = <span class="keyword">new</span> RefCountGC();</span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line">        obj1 = <span class="keyword">null</span>;</span><br><span class="line">        obj2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 显示的执行垃圾收集行为，判断obj1 和 obj2是否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[GC (System.gc()) [PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K), <span class="number">0.0061980</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.36</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 808K-&gt;0<span class="title">K</span><span class="params">(76288K)</span>] [ParOldGen: 8K-&gt;672<span class="title">K</span><span class="params">(175104K)</span>] 816K-&gt;672<span class="title">K</span><span class="params">(251392K)</span>, [Metaspace: 3479K-&gt;3479<span class="title">K</span><span class="params">(1056768K)</span>], 0.0045983 secs] [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [<span class="number">0x000000076b500000</span>, <span class="number">0x0000000770a00000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">1</span>% used [<span class="number">0x000000076b500000</span>,<span class="number">0x000000076b5a3ee8</span>,<span class="number">0x000000076f500000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076f500000</span>,<span class="number">0x000000076f500000</span>,<span class="number">0x000000076ff80000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076ff80000</span>,<span class="number">0x000000076ff80000</span>,<span class="number">0x0000000770a00000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 672K [<span class="number">0x00000006c1e00000</span>, <span class="number">0x00000006cc900000</span>, <span class="number">0x000000076b500000</span>)</span><br><span class="line">  object space 175104K, <span class="number">0</span>% used [<span class="number">0x00000006c1e00000</span>,<span class="number">0x00000006c1ea8070</span>,<span class="number">0x00000006cc900000</span>)</span><br><span class="line"> Metaspace       used 3486K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 385<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">                                 </span></span><br><span class="line"><span class="class">//<span class="title">gc</span>         </span></span><br><span class="line"><span class="class"><span class="title">PSYoungGen</span>: 15490<span class="title">K</span>-&gt;808<span class="title">K</span>(76288<span class="title">K</span>)] 15490<span class="title">K</span>-&gt;816<span class="title">K</span>(251392<span class="title">K</span>)</span></span><br><span class="line"><span class="class">                        </span></span><br></pre></td></tr></table></figure><p>Python，它更是同时支持引用计数和垃圾收集机制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">手动解除：很好理解，就是在合适的时机，解除引用关系。</span><br><span class="line">使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</span><br></pre></td></tr></table></figure><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>根搜索算法、追踪性垃圾收集</p><p>同样具备实现简单和执行高效等特点<strong>，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。</strong></p><p>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p><p>基本思路：</p><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><img src="/2020/07/18/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/可达性算法.png" alt="可达性算法" style="zoom: 50%;"><h4 id="GC-Roots可以是哪些？"><a href="#GC-Roots可以是哪些？" class="headerlink" title="GC Roots可以是哪些？"></a>GC Roots可以是哪些？</h4><ul><li><strong>虚拟机栈中引用的对象</strong><ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li><strong>本地方法栈内JNI（通常说的本地方法）</strong></li><li><strong>引用的对象方法区中类静态属性引用的对象</strong><ul><li>比如：Java类的引用类型静态变量</li></ul></li><li><strong>方法区中常量引用的对象</strong></li><li>比如：字符串常量池（string Table）里的引用</li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：Nu11PointerException、outofMemoryError），系统类加载器。</li></ul></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p>总结一句话就是，除了堆空间外的一些结构，比如 虚拟机栈、本地方法栈、方法区、字符串常量池 等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</p><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，<strong>还可以有其他对象“临时性”地加入</strong>，共同构成完整GC Roots集合。比如：<strong>分代收集和局部回收（PartialGC）。</strong></p><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，<strong>它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，</strong>那它就是一个Root。</p><p>注意<br>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致GC进行时必须“stop The World”的一个重要原因。</p><p>即使是号称（几乎）不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的。</strong></p><h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><p>允许开发人员提供对象被销毁之前的自定义处理逻辑。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p><p>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放。</strong>通常在这个方法中进行一些<strong>资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</strong></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p>永远<strong>不要主动调用某个对象的finalize()</strong>方法I应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li><p>在finalize（）时可能<strong>会导致对象复活</strong>。</p></li><li><p>finalize（）方法的<strong>执行时间是没有保障的</strong>，它完全由GC线程决定，极端情况下，若不发生GC，则finalize（）方法将没有执行机会。<br>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</p></li><li><p>一个糟糕的finalize（）会严重影响Gc的性能。</p></li></ul></li></ul><p>从功能上来说，finalize（）方法与c++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize（）方法在本质上不同于C++中的析构函数。</p><p>由于finalize（）方法的存在，虚拟机中的对象一般处于<strong>三种可能的状态。</strong></p><p><strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong></p><ul><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize（）中复活。</li><li>不可触及的：对象的finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<strong>finalize()只会被调用一次</strong>。</li></ul><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><ul><li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象<strong>是否有必要执行finalize（）</strong>方法<ul><li>如果对象objA没有重写finalize（）方法，或者finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize（）方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize（）方法执行。</li><li><strong>finalize（）方法是对象逃脱死亡的最后机会</strong>，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。finalize方法不会被再次调用，对象会直接变成不可触及的状态。</li></ul></li></ul><h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p><p><a href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/</a> 下载</p><h3 id="命令行使用-jmap"><a href="#命令行使用-jmap" class="headerlink" title="命令行使用 jmap"></a>命令行使用 jmap</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps 查看进程id</span><br><span class="line">jmap -dump:format=b,live,file=test1.bin 进程id</span><br></pre></td></tr></table></figure><h3 id="使用JVIsualVM"><a href="#使用JVIsualVM" class="headerlink" title="使用JVIsualVM"></a>使用JVIsualVM</h3><p>监视-dump-save as</p><p>使用MAT 或Jprofiler查看GC root</p><h3 id="检查OOM"><a href="#检查OOM" class="headerlink" title="检查OOM"></a>检查OOM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:HeapDumpOnOutOfMemoryError  //设定自动生成dump</span><br></pre></td></tr></table></figure><p>然后用MAT或Jprofiler打开</p><h2 id="清除阶段（重要）"><a href="#清除阶段（重要）" class="headerlink" title="清除阶段（重要）"></a>清除阶段（重要）</h2><h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为<strong>stop the world</strong>），然后进行两项工作，第一项则是标记，第二项则是清除</p><ul><li>标记：Collector从引用根节点开始遍历，<strong>标记所有被引用的对象（不是垃圾）。</strong>一般是在对象的Header中记录为可达对象。<ul><li><strong>标记的是引用的对象，不是垃圾！！</strong></li></ul></li><li><strong>清除</strong>：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ul><p><img src="/2020/07/18/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="标记清除"></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ul><h4 id="什么是清除？"><a href="#什么是清除？" class="headerlink" title="什么是清除？"></a>什么是清除？</h4><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址。</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src="/2020/07/18/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法"></p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行（老年代大量的对象存活，那么复制的对象将会有很多，效率会很低）</p><p>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>基于老年代垃圾回收的特性，需要使用其他的算法。</p><p><img src="/2020/07/18/java%E5%9F%BA%E7%A1%80/jvm-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" alt="标记整理"></p><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>消除了内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ul><li>年轻代（Young Gen）<br>年轻代特点：<strong>区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</strong></li></ul><p>这种情况<strong>复制算法</strong>的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，<strong>通过hotspot中的两个survivor的设计得到缓解。</strong></p><ul><li>老年代（Tenured Gen）<br>老年代特点：<strong>区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</strong></li></ul><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由<strong>标记-清除或者是标记-清除与标记-整理的混合实现。</strong></p><ul><li>Mark阶段的开销与存活对象的数量成正比。</li><li>Sweep阶段的开销与所管理区域的大小成正相关。</li><li>compact阶段的开销与存活对象的数据成正比。</li></ul><p>以HotSpot中的CMS回收器为例，<strong>CMS是基于Mark-Sweep实现的</strong>，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。</p><h2 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h2><p>解决stop the World</p><p>可以让垃圾收集线程和应用程序线程交替执行。每次，<strong>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。<strong>增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></p><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降</p><h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。</p><p>将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm(6)--string</title>
      <link href="/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-String/"/>
      <url>/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-String/</url>
      
        <content type="html"><![CDATA[<h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><span id="more"></span><ul><li>String：字符串，使用一对 ”” 引起来表示<ul><li>String s1 = “mogublog” ; // 字面量的定义方式</li><li>String s2 = new String(“moxi”);</li></ul></li><li>string声明为<strong>final</strong>的，不可被继承</li><li>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示string可以比较大小</li><li><strong>string在jdk8及以前内部定义了final char[] value用于存储字符串数据。JDK9时改为byte[]</strong></li></ul><h3 id="为什么JDK9改变了结构"><a href="#为什么JDK9改变了结构" class="headerlink" title="为什么JDK9改变了结构"></a>为什么JDK9改变了结构</h3><p>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。从许多不同的应用程序收集的数据表明，<strong>字符串是堆使用的主要组成部分</strong>，而且，<strong>大多数字符串对象只包含拉丁字符。这些字符只需要一个字节的存储空间，</strong>因此这些字符串对象的内部char数组中有一半的空间将不会使用。<br>String再也不用char[] 来存储了，改成了byte [] 加上<strong>编码标记</strong>，节约了一些空间</p><p>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</p><h3 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h3><p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。<br>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>当调用string的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的不可变性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字面量定义的方式，“abc”存储在字符串常量池中</span></span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">        s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s1);<span class="comment">//hello</span></span><br><span class="line">        System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="comment">// 只要进行了修改，就会重新创建一个对象，这就是不可变性</span></span><br><span class="line">        s2 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">        System.out.println(s2);<span class="comment">//abcdef</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s2 = s1.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">        System.out.println(s2);<span class="comment">//mbc</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> [] ch = &#123;<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch [])</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringExer ex = <span class="keyword">new</span> StringExer();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);</span><br><span class="line">        System.out.println(ex.ch);</span><br><span class="line">        <span class="comment">//good</span></span><br><span class="line">        <span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p><p>String的string Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进string Pool的<strong>string非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用string.intern时性能会大幅下降。</strong></p><p>使用-XX:StringTablesize可设置stringTab1e的长度</p><p>在jdk6中stringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。stringTablesize设置没有要求</p><p>在jdk7中，stringTable的长度默认值是60013，</p><p>在JDK8中，StringTable可以设置的最小值为1009</p><p><strong>data.intern()  如果字符串常量池中没有对应data的字符串，则在常量池中生成</strong></p><h2 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h2><p>在Java语言中有8种基本数据类型和一种比较特殊的类型string。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p><p><strong>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，string类型的常量池比较特殊。它的主要使用方法有两种。</strong></p><p>直接使用双引号声明出来的String对象会直接存储在常量池中。</p><ul><li>比如：string info=“atguigu.com”；</li><li>如果不是用双引号声明的string对象，可以使用string提供的intern（）方法。</li></ul><p>Java 6及以前，字符串常量池存放在永久代</p><p>Java 7中 oracle的工程师对字符串池的逻辑做了很大的改变，即将<strong>字符串常量池的位置调整到Java堆内</strong></p><p>Java8元空间，字符串常量在堆</p><h3 id="为什么StringTable从永久代调整到堆中"><a href="#为什么StringTable从永久代调整到堆中" class="headerlink" title="为什么StringTable从永久代调整到堆中"></a>为什么StringTable从永久代调整到堆中</h3><ul><li>永久代的默认比较小</li><li>永久代垃圾回收频率低</li></ul><h2 id="String的基本操作"><a href="#String的基本操作" class="headerlink" title="String的基本操作"></a>String的基本操作</h2><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p><h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><ul><li>常量与常量的拼接结果在常量池，原理是<strong>编译期优化</strong></li><li>常量池中<strong>不会存在相同内容的变量</strong></li><li><strong>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</strong></li><li>如果拼接的结果调用<strong>intern()</strong>方法，则<strong>主动将常量池中还没有的字符串对象放入池中</strong>，并返回此对象地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String s1 = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;  <span class="comment">// 得到 abc的常量池,编译期优化</span></span><br><span class="line">       String s2 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// abc存放在常量池，直接将常量池的地址返回</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 最终java编译成.class，再执行.class</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       System.out.println(s1 == s2); <span class="comment">// true，因为存放在字符串常量池</span></span><br><span class="line">       System.out.println(s1.equals(s2)); <span class="comment">// true</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">       String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">       String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">       String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;    </span><br><span class="line">       String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">       String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">       String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">       System.out.println(s3 == s4); <span class="comment">// true</span></span><br><span class="line">       System.out.println(s3 == s5); <span class="comment">// false</span></span><br><span class="line">       System.out.println(s3 == s6); <span class="comment">// false</span></span><br><span class="line">       System.out.println(s3 == s7); <span class="comment">// false</span></span><br><span class="line">       System.out.println(s5 == s6); <span class="comment">// false</span></span><br><span class="line">       System.out.println(s5 == s7); <span class="comment">// false</span></span><br><span class="line">       System.out.println(s6 == s7); <span class="comment">// false</span></span><br><span class="line"><span class="comment">//只要有变量，就在堆空间中new一个String</span></span><br><span class="line">       String s8 = s6.intern();</span><br><span class="line">       <span class="comment">//判断字符串常量池中是否存在，存在返回地址，不存在就创建</span></span><br><span class="line">       System.out.println(s3 == s8); <span class="comment">// true</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>拼接操作的底层其实使用了StringBuilder</p><p>s1+s2执行细节</p><ul><li>new StringBuilder</li><li>s.append(“a”)</li><li>s.append(“b”)</li><li>s.toString()  <strong>类似于new String</strong></li></ul><p>在JDK5之后，使用的是StringBuilder，在JDK5之前使用的是StringBuffer</p><p>注意，我们<strong>左右两边如果是变量的话，就是需要new StringBuilder进行拼接</strong></p><p>但是<strong>如果使用的是final修饰，则是从常量池中获取。</strong>所以说拼接符号左右两边都是字<strong>符串常量或常量引用 则仍然使用编译器优化</strong>，即费StringBuilder的方式。也就是说被final修饰的变量，将会变成常量，类和方法将不能被继承、</p><ul><li>在开发中，能够使用final的时候，建议使用上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String s1 = <span class="string">&quot;a&quot;</span>;<span class="comment">//被final修饰的变量拜年成了常量</span></span><br><span class="line">    <span class="keyword">final</span> String s2 = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String s3 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String s4 = s1 + s2;<span class="comment">//从常量池中取出常量s1和s2，所以他不是变量，也就不会采用new StringBuilder方式拼接</span></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="拼接操作和append性能对比"><a href="#拼接操作和append性能对比" class="headerlink" title="拼接操作和append性能对比"></a>拼接操作和append性能对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>&#123;</span><br><span class="line">    String src = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src += <span class="string">&quot;a&quot;</span>; <span class="comment">// 每次循环都会创建一个StringBuilder对象 String对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(<span class="keyword">int</span> highLevel)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法1耗费的时间：4005ms，方法2消耗时间：7m</p><p>结论：</p><ul><li>通过StringBuilder的append()方式添加字符串的效率，要远远高于String的字符串拼接方法</li></ul><p>好处</p><ul><li><p>StringBuilder的append的方式，自始至终<strong>只创建一个StringBuilder的对象</strong></p><p>对于字符串拼接的方式，还需要创建很多StringBuilder对象和 调用toString时候创建的String对象</p></li><li><p>内存中由于创建了较多的StringBuilder和String对象，内存占用过大，<strong>如果进行GC那么将会耗费更多的时间</strong></p></li></ul><p>改进的空间</p><ul><li>我们使用的是StringBuilder的空参构造器，默认的字符串容量是16，然后将原来的字符串拷贝到新的字符串中， 我们也可以默认初始化更大的长度，减少扩容的次数</li><li><strong>因此在实际开发中，我们能够确定，前前后后需要添加的字符串不高于某个限定值，那么建议使用构造器创建一个阈值的长度</strong></li></ul><table><thead><tr><th align="center"><strong>String</strong></th><th align="center"><strong>StringBuffer</strong></th><th align="center"><strong>StringBuilder</strong></th></tr></thead><tbody><tr><td align="center">String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td><td align="center">StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td><td align="center">可变类，速度更快</td></tr><tr><td align="center">不可变</td><td align="center">可变</td><td align="center">可变</td></tr><tr><td align="center"></td><td align="center">线程安全</td><td align="center">线程不安全</td></tr><tr><td align="center"></td><td align="center">多线程操作字符串</td><td align="center">单线程操作字符串</td></tr></tbody></table><h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h2><p>intern是一个native方法，调用的是底层C的方法</p><p>字符串池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串对象相等的字符串，则返回池中的字符串。否则，该字符串对象将被添加到池中，并返回对该字符串对象的引用。</p><p>如果不是用双引号声明的string对象，可以使用string提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String myInfo = <span class="keyword">new</span> string(<span class="string">&quot;I love atguigu&quot;</span>).intern();</span><br></pre></td></tr></table></figure><p>如果在任意字符串上调用string.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>+<span class="string">&quot;c&quot;</span>）.intern（）==<span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//如何保证s指向字符串常量池</span><br><span class="line">方式一 :String s = &quot; afsadf&quot;</span><br><span class="line">方式二 :String s = new String().intern;</span><br><span class="line">  String s = new StringBuilder(&quot;gfgs&quot;).toString().intern();</span><br></pre></td></tr></table></figure><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="new-String-“ab”-会创建几个对象"><a href="#new-String-“ab”-会创建几个对象" class="headerlink" title="new String(“ab”)会创建几个对象"></a>new String(“ab”)会创建几个对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class StringNewTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String str = new String(&quot;ab&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里面就是两个对象</p><ul><li>一个对象是：new关键字在堆空间中创建</li><li>另一个对象：字符串常量池中的对象</li></ul><p>证明字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #2 &lt;java/lang/String&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 ldc #3 &lt;ab&gt;</span><br><span class="line"> 6 invokespecial #4 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"> 9 astore_1</span><br><span class="line">10 return</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="new-String-“a”-new-String-“b”-会创建几个对象"><a href="#new-String-“a”-new-String-“b”-会创建几个对象" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象"></a>new String(“a”) + new String(“b”) 会创建几个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringNewTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们创建了6个对象</p><ul><li>对象1：new StringBuilder()</li><li>对象2：new String(“a”)</li><li>对象3：常量池的 a</li><li>对象4：new String(“b”)</li><li>对象5：常量池的 b</li><li>对象6：toString中会创建一个 new String(“ab”)<br><strong>调用toString方法，不会在常量池中生成ab</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #2 &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"> 7 new #4 &lt;java/lang/String&gt;</span><br><span class="line">10 dup</span><br><span class="line">11 ldc #5 &lt;a&gt;</span><br><span class="line">13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">19 new #4 &lt;java/lang/String&gt;</span><br><span class="line">22 dup</span><br><span class="line">23 ldc #8 &lt;b&gt;</span><br><span class="line">25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line">28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line">34 astore_1</span><br><span class="line">35 return</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="intern的使用：JDK6和JDK7"><a href="#intern的使用：JDK6和JDK7" class="headerlink" title="intern的使用：JDK6和JDK7"></a>intern的使用：JDK6和JDK7</h3><h4 id="JDK6中"><a href="#JDK6中" class="headerlink" title="JDK6中"></a>JDK6中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);  <span class="comment">// 在常量池中已经有了 造了两个对象，一个是因为new在堆空间 另一个在字符串常量池1</span></span><br><span class="line">s.intern(); <span class="comment">// 将该对象放入到常量池。但是调用此方法没有太多的区别，因为已经存在了1</span></span><br><span class="line"><span class="comment">//不会改变s的引用</span></span><br><span class="line">String s2 = <span class="string">&quot;1&quot;</span>;<span class="comment">//这个就是第一行new的时候再堆中的地址，而s是在常量池中的地址，显然不是同一个地址</span></span><br><span class="line">System.out.println(s == s2); <span class="comment">// false//如果第二行中改为s=s.inter();这里就是true了</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//表示new String(&quot;11&quot;)在堆区开辟了一个内存空间，并把其地址赋给了s3</span></span><br><span class="line"><span class="comment">//执行完上一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？不存在！</span></span><br><span class="line">s3.intern();<span class="comment">//在字符串常量池中生成&quot;11&quot; jdk6中：创建了一个新的对象&quot;11&quot;，也就有了新的地址</span></span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//在上一行执行时，在常量池中生成的&quot;11&quot;的地址赋给了s4</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false s3是堆区内存空间的地址，s4是常量池中&quot;11&quot;的地址，所以为false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>false<br>false</p><p>为什么对象会不一样呢？</p><ul><li>一个是new创建的对象，一个是常量池中的对象，显然不是同一个</li></ul><p>  s=s.intern() 就是true</p><h4 id="JDK7-8中"><a href="#JDK7-8中" class="headerlink" title="JDK7/8中"></a>JDK7/8中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s.intern();</span><br><span class="line">String s2 = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">System.out.println(s == s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">s3.intern();<span class="comment">//和jdk6不一样的就在这里，jdk7/8中，并不会创建一个新的对象&quot;11&quot;而是指向上一行中new String(&quot;11&quot;)的地址</span></span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;<span class="comment">//s4指向的是上一行中常量池中的对象&quot;11&quot; 但是他也是指向堆空间new String(&quot;11&quot;)的地址，所以两者一致</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>false<br>true</p><p><strong>s3.intern();//和jdk6不一样的就在这里，jdk7/8中，并不会创建一个新的对象”11”而是指向上一行中new String(“11”)的地址</strong></p><p>在JDK7中，在JDK7中，并没有创新一个新对象，而是指向常量池中的新对象</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>);<span class="comment">//表示new String(&quot;11&quot;)在堆区开辟了一个内存空间，并把其地址赋给了s3</span></span><br><span class="line">String s4 = <span class="string">&quot;11&quot;</span>;  <span class="comment">// 在常量池中生成的字符串</span></span><br><span class="line">String s5 = s3.intern();  <span class="comment">// 然后s3就会从常量池中找，发现有了，就什么事情都不做</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s4); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>总结<br>总结string的intern（）的使用：</p><p>JDK1.6中，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，会把此<strong>对象复制一份</strong>，放入串池，并返回串池中的对象地址</li></ul><p>JDK1.7起，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，则会把<strong>对象的引用地址复制一份</strong>，放入串池，并返回串池中的引用地址</li></ul><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><p>JDK6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//表示new String(&quot;ab&quot;)在堆区开辟了一个内存空间，并把其地址赋给了s</span></span><br><span class="line"><span class="comment">//在上一行代码执行之后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line">  String s2 = s.intern();<span class="comment">//在jdk6中：在字符串常量池中创建一个字符串&quot;ab&quot;，并把它的地址赋值给s2</span></span><br><span class="line">  System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true &quot;ab&quot;就是常量池中的地址，所以与s2一致</span></span><br><span class="line">  System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// false s记录的是new的地址 在堆区的地址</span></span><br></pre></td></tr></table></figure><p>JDK7/8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  String s = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//表示new String(&quot;ab&quot;)在堆区开辟了一个内存空间，并把其地址赋给了s</span></span><br><span class="line"><span class="comment">//在上一行代码执行之后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line">  String s2 = s.intern();<span class="comment">//在jdk8中：在字符串常量池中没有创建一个字符串&quot;ab&quot;，而是创建一个引用，指向new String(&quot;ab&quot;) 并返回给s2 </span></span><br><span class="line">  System.out.println(s2 == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true 常量池中没有&quot;ab&quot;，所以&quot;ab&quot;就是堆空间的地址，所以与s2一致</span></span><br><span class="line">  System.out.println(s == <span class="string">&quot;ab&quot;</span>); <span class="comment">// true s记录的是new的地址 在堆区的地址</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  String s1 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;b&quot;</span>);<span class="comment">//表示new String(&quot;ab&quot;)在堆区开辟了一个内存空间，并把其地址赋给了s1</span></span><br><span class="line"><span class="comment">//在上一行代码执行之后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line">  s1.intern();</span><br><span class="line"><span class="comment">//在jdk8中：在字符串常量池中没有创建一个字符串&quot;ab&quot;，而是创建一个引用，指向new String(&quot;ab&quot;) 并返回给s2 </span></span><br><span class="line"><span class="comment">//在jdk6中：会在字符串常量池中创建一个字符串&quot;ab&quot;</span></span><br><span class="line">  String s2=<span class="string">&quot;ab&quot;</span>;<span class="comment">//jdk8：因为常量池中没有&quot;ab&quot;所以把堆区的地址给了s2 jdk6：把常量池中的&quot;ab&quot;的地址给了s2</span></span><br><span class="line">  System.out.println(s1 == s2); <span class="comment">// jdk8:true jdk6:false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);<span class="comment">//表示new String(&quot;ab&quot;)在堆区开辟了一个内存空间，并把其地址赋给了s1，并且执行完毕之后会在字符串常量池中生成&quot;ab&quot;</span></span><br><span class="line"><span class="comment">//在上一行代码执行之后，字符串常量池中已经有了&quot;ab&quot;</span></span><br><span class="line">  s1.intern();<span class="comment">//因为已经有了&quot;ab&quot;，所以 这步什么也没有做</span></span><br><span class="line">  String s2=<span class="string">&quot;ab&quot;</span>;<span class="comment">//无论是jdk几，因为常量池中都有&quot;ab&quot;所以把常量池中的&quot;ab&quot;的地址给了s2</span></span><br><span class="line">  System.out.println(s1 == s2); <span class="comment">// jdk8:false jdk6:false</span></span><br></pre></td></tr></table></figure><h3 id="intern的空间效率测试"><a href="#intern的空间效率测试" class="headerlink" title="intern的空间效率测试"></a>intern的空间效率测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringIntern2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT = <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> String[MAX_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer [] data = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> String(String.valueOf(data[i%data.length]));</span><br><span class="line">            <span class="comment">//arr[i] = new String(String.valueOf(data[i%data.length])).intern();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.getStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论</strong>：对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省内存空间。</p><h2 id="StringTable的垃圾回收"><a href="#StringTable的垃圾回收" class="headerlink" title="StringTable的垃圾回收"></a>StringTable的垃圾回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringGCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            String.valueOf(i).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h2><p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p><p><strong>实现</strong></p><ul><li><p>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的string对象。</p></li><li><p>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的string对象。</p></li><li><p>使用一个hashtab1e来记录所有的被string对象使用的不重复的char数组。当去重的时候，会查这个hashtable，来看堆上是否已经存在一个一模一样的char数组。</p></li><li><p>如果存在，string对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</p></li><li><p>如果查找失败，char数组会被插入到hashtable，这样以后的时候就可以共享这个数组了。</p></li></ul><p>  UsestringDeduplication（bool）：开启string去重，默认是不开启的，需要手动开启。<br>  Printstringbeduplicationstatistics（bool）：打印详细的去重统计信息<br>  stringpeduplicationAgeThreshold（uintx）：达到这个年龄的string对象被认为是去重的候选对象</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm(5)--内存</title>
      <link href="/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-%E5%86%85%E5%AD%98/"/>
      <url>/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h1><p><img src="/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-%E5%86%85%E5%AD%98/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96.png" alt="对象实例化"></p><span id="more"></span><h2 id="对象创建方式"><a href="#对象创建方式" class="headerlink" title="对象创建方式"></a>对象创建方式</h2><ul><li>new：最常见的方式、单例类中调用getInstance的静态类方法，xxxbulider/XXXFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为<strong>过时</strong>的方法，因为<strong>只能调用空参构造器</strong></li><li>Constructor的newInstance(XXX)：反射的方式，<strong>可以调用空参的，或者带参的构造器</strong> 权限没有要求</li><li>使用clone()：不调用任何的构造器，要求当前的类需要<strong>实现Cloneable接口中的clone接口</strong></li><li>使用序列化：序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ul><h2 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h2><p><strong>判断对象对应的类是否加载、链接、初始化</strong></p><p>首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是<strong>否已经被加载</strong>，解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</p><p><strong>为对象分配内存</strong></p><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</p><ul><li>如果内存规整：指针碰撞<ul><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li></ul></li><li>如果内存不规整<ul><li>虚拟表需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p><strong>处理并发问题</strong></p><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）<ul><li>在Eden区给每个线程分配一块区域</li></ul></li></ul><p><strong>初始化分配到的内存</strong></p><p>给对象属性赋值的操作</p><ul><li>属性的默认初始化</li><li>显示初始化</li><li>代码块中的初始化</li><li>构造器初始化</li></ul><p>所有属性设置<strong>默认值</strong>，<strong>保证对象实例字段在不赋值可以直接使用</strong></p><p><strong>设置对象的对象头</strong></p><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><p>执行init<strong>方法进行初始化</strong></p><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。<br>clinit 静态属性初始化</p><p><strong>所以总结在6步都执行完后才算对象创建完 ，new不算 ；</strong></p><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><img src="/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-%E5%86%85%E5%AD%98/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="对象内存布局"></p><p><img src="/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%9B%BE%E7%A4%BA.png" alt="内存分布图示"></p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><p><img src="/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-%E5%86%85%E5%AD%98/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D.png" alt="对象访问定位"></p><p>通过栈上的reference 引用来访问</p><h3 id="对象访问的两种方式"><a href="#对象访问的两种方式" class="headerlink" title="对象访问的两种方式"></a>对象访问的两种方式</h3><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><img src="/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-%E5%86%85%E5%AD%98/句柄访问.png" alt="句柄访问" style="zoom: 50%;"><p>句柄访问就是说栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池</p><p><strong>优点</strong>：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</p><h4 id="直接指针（HotSpot采用）"><a href="#直接指针（HotSpot采用）" class="headerlink" title="直接指针（HotSpot采用）"></a>直接指针（HotSpot采用）</h4><img src="/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-%E5%86%85%E5%AD%98/直接指针.png" alt="直接指针" style="zoom:50%;"><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。<strong>元空间</strong></p><p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p><p>通常，访问直接内存的速度会优于Java堆。即<strong>读写性能高。</strong></p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul><table><thead><tr><th align="center">IO</th><th align="center">NIO(new IO/Non-blocking IO)</th></tr></thead><tbody><tr><td align="center">byte[]/char[]</td><td align="center">Buffer</td></tr><tr><td align="center">Stream</td><td align="center">Channel</td></tr></tbody></table><p><img src="/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-%E5%86%85%E5%AD%98/%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="直接缓冲区"></p><p>存在的问题<br>也可能导致outofMemoryError异常</p><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。<br>缺点</p><ul><li><p>分配回收成本较高</p></li><li><p>不受JVM内存回收管理</p><p>直接内存大小可以通过MaxDirectMemorySize设置</p></li></ul><p>如果不指定，默认与堆的最大值-xmx参数值一致</p><h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><p>执行引擎属于JVM的下层，里面包括 解释器、及时编译器、垃圾回收器</p><img src="/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-%E5%86%85%E5%AD%98/执行引擎.png" alt="执行引擎" style="zoom:80%;"><p>执行引擎是Java虚拟机核心的组成部分之一。“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式。</strong></p><p>JVM的主要任务是<strong>负责装载字节码 到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。<br>执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将<strong>高级语言翻译为机器语言的译者。</strong></p><h3 id="执行引擎的工作流程"><a href="#执行引擎的工作流程" class="headerlink" title="执行引擎的工作流程"></a>执行引擎的工作流程</h3><img src="/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-%E5%86%85%E5%AD%98/执行引擎工作流程.png" alt="执行引擎工作流程" style="zoom:67%;"><ul><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ul><p>所有的Java虚拟机的执行引擎输入，输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行过程。</p><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><p><img src="/2020/07/17/java%E5%9F%BA%E7%A1%80/jvm-%E5%86%85%E5%AD%98/%E7%BC%96%E8%AF%91%E5%92%8C%E6%89%A7%E8%A1%8C.png" alt="编译和执行"></p><h3 id="什么是解释器（Interpreter）"><a href="#什么是解释器（Interpreter）" class="headerlink" title="什么是解释器（Interpreter）"></a>什么是解释器（Interpreter）</h3><p>当Java虚拟机启动时会根据预定义的规范<strong>对字节码采用逐行解释的方式执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言</p><h3 id="为什么Java是半编译半解释型语言"><a href="#为什么Java是半编译半解释型语言" class="headerlink" title="为什么Java是半编译半解释型语言"></a>为什么Java是半编译半解释型语言</h3><p><strong>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</strong></p><p><strong>翻译成本地代码后，就可以做一个缓存操作，存储在方法区中</strong></p><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p><p>字节码典型的应用为：Java bytecode</p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p><h3 id="解释器分类"><a href="#解释器分类" class="headerlink" title="解释器分类"></a>解释器分类</h3><p>在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><ul><li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</li><li>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li></ul><p>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。</p><p>Interpreter模块：实现了解释器的核心功能<br>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</p><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><p>即时编译器</p><h3 id="HotSpot-JVM执行方式"><a href="#HotSpot-JVM执行方式" class="headerlink" title="HotSpot JVM执行方式"></a>HotSpot JVM执行方式</h3><p>当虚拟机启动的时候，<strong>解释器可以首先发挥作用</strong>，而不必等待即时编译器全部编译完成再执行，这样可以<strong>省去许多不必要的编译时间</strong>。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，<strong>将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率</strong></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm(4)--方法区</title>
      <link href="/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(3)/"/>
      <url>/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(3)/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(3)/%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB.png" alt="线程共享"></p><span id="more"></span><h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p><img src="/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(3)/%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.png" alt="三者关系"></p><ul><li>Person：存放在元空间，也可以说方法区</li><li>person：存放在Java栈的局部变量表中</li><li>new Person()：存放在Java堆中</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</p><p>所以，方法区看作是一块独立于Java堆的内存空间。</p><p>方法区主要存放的是 Class，而堆中主要存放的是 实例化的对象</p><ul><li>方法区与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：jdk7 java.lang.OutofMemoryError：PermGen space 或者jdk8 java.lang.OutOfMemoryError:Metaspace<ul><li>加载大量的第三方的jar包<br>Tomcat部署的工程过多（30~50个）<br>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ul><h4 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h4><p>在jdk7及以前，习惯上把方法区，称为永久代。jdk8开始，使用元空间取代了永久代。</p><p>JDK 1.8后，元空间存放在堆外内存中<br>本质上，方法区和永久代并不等价。仅是对hotspot而言的。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。</p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong></p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常<br>设置方法区的</p><h3 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h3><h4 id="jdk7及以前"><a href="#jdk7及以前" class="headerlink" title="jdk7及以前"></a>jdk7及以前</h4><ul><li>通过-xx:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ul><h4 id="JDK8以后"><a href="#JDK8以后" class="headerlink" title="JDK8以后"></a>JDK8以后</h4><p>元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize指定</p><p>默认值依赖于平台。<strong>windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</strong></p><p>对于一个64位的服务器端JVM来说，其默认的-xx:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Ful1GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。<br><strong>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Ful1GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</strong></p><h4 id="如何解决这些OOM"><a href="#如何解决这些OOM" class="headerlink" title="如何解决这些OOM"></a>如何解决这些OOM</h4><ul><li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）<br>内存泄漏就是 有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GCRoots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GCRoots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ul><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><p><img src="/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(3)/%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%92%E5%88%86.png" alt="方法区划分"></p><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p><h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVm必须在方法区中存储以下类型信息：</p><ul><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ul><h3 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h3><p>JVM必须在方法区中保存类型的所有域的相关信息以及域(Field)的声明顺序。</p><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p><h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）<br>异常表（abstract和native方法除外）</li></ul><h3 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h3><ul><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</li></ul><h3 id="全局常量"><a href="#全局常量" class="headerlink" title="全局常量"></a>全局常量</h3><p>全局常量就是使用 static final 进行修饰</p><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * non-final的类变量</span><br><span class="line"> *</span><br><span class="line"> * @author: 陌溪</span><br><span class="line"> * @create: 2020-07-08-16:54</span><br><span class="line"> */</span><br><span class="line">public class MethodAreaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Order order = new Order();</span><br><span class="line">        //Order order = null;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Order &#123;</span><br><span class="line">    public static int count = 1;</span><br><span class="line">    public static final int number = 2;</span><br><span class="line">    public static void hello() &#123;</span><br><span class="line">        System.out.println(&quot;hello!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(3)/final%E5%B8%B8%E9%87%8F.png" alt="final常量"></p><p>在编译是就已经赋值，所以说他不能被修改</p><h3 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h3><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚C1assFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚classFile中的常量池。</li></ul><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p><h4 id="为什么需要常量池"><a href="#为什么需要常量池" class="headerlink" title="为什么需要常量池"></a>为什么需要常量池</h4><p>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。r在动态链接的时候会用到运行时常量池，之前有介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p><h4 id="常量池中有什么"><a href="#常量池中有什么" class="headerlink" title="常量池中有什么"></a>常量池中有什么</h4><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p><strong>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</strong></p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p><p>常量池表（Constant Pool Table）是Class文件的一部分，用于存放编译期生成的<strong>各种字面量与符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</p><p>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> a = x / y;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">50</span>;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(3)/%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%BE%E4%BE%8B.png" alt="方法区举例"></p><p>0 将500压如栈中<br>3 弹出栈顶500 放入本地变量表1中<br>4 100压栈<br>6 弹出栈顶100 放入本地变量表2中<br>7 读取本地变量1 压栈<br>8 读取本地变量2 压栈<br>9 除法运算 结果进展<br>10  弹出栈顶 放入本地变量表3中<br>11 将50压栈<br>13 弹出，放入4中<br>15 获取类或接口的值推入栈中 #2代表常量池中的Fieldref<br>18 取<br>19 取<br>21加<br>22  调用静态方法 jvm根据方法创建新栈帧</p><h3 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h3><p>只有Hotspot才有永久代。</p><table><thead><tr><th>JDK1.6及以前</th><th>有永久代，静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p><img src="/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(3)/jdk8%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="jdk8的实现"></p><h3 id="为什么永久代要被元空间替代"><a href="#为什么永久代要被元空间替代" class="headerlink" title="为什么永久代要被元空间替代"></a>为什么永久代要被元空间替代</h3><p>JRockit和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代</p><ul><li>为永久代设置空间大小是很难确定的</li><li>对永久代进行调优是很困难的。<ul><li>主要是为了降低Full GC</li></ul></li></ul><h3 id="StringTable为什么要调整位置"><a href="#StringTable为什么要调整位置" class="headerlink" title="StringTable为什么要调整位置"></a>StringTable为什么要调整位置</h3><p>jdk7中将StringTable放到了堆空间中。因为<strong>永久代的回收效率很低</strong>，在full gc的时候才会触发。而fullgc是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致stringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h3 id="静态变量存放在那里？"><a href="#静态变量存放在那里？" class="headerlink" title="静态变量存放在那里？"></a>静态变量存放在那里？</h3><p>静态引用对应的<strong>对象实体</strong>始终都存在堆空间*<em>new *</em>对象的名的位置在变</p><p><strong>jhsdb.ext</strong>，需要在jdk9的时候才引入的</p><p><img src="/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(3)/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F.png" alt="静态变量"></p><p>staticobj随着Test的类型信息存放在方法区，instanceobj随着Test的对象实例存放在Java堆，localobject则是存放在foo（）方法栈帧的局部变量表中。</p><p>而对象的实体则一直在栈中</p><h3 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h3><p>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。</p><p><strong>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</strong></p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如osGi、JSP的重加载等，否则通常是很难达成的。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class 以及 -XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息。</p><p><img src="/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(3)/%E6%80%BB%E7%BB%93.png" alt="总结"></p><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><p>百度<br>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p><p>蚂蚁金服：<br>Java8的内存分代改进<br>JVM内存分哪几个区，每个区的作用是什么？<br>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？<br>二面：Eden和survior的比例分配</p><p>小米：<br>jvm内存分区，为什么要有新生代和老年代</p><p>字节跳动：<br>二面：Java的内存分区<br>二面：讲讲vm运行时数据库区<br>什么时候对象会进入老年代？</p><p>京东：<br>JVM的内存结构，Eden和Survivor比例。<br>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p><p>天猫：<br>一面：Jvm内存模型以及分区，需要详细到每个区放什么。<br>一面：JVM的内存模型，Java8做了什么改</p><p>拼多多：<br>JVM内存分哪几个区，每个区的作用是什么？</p><p>美团：<br>java内存分配<br>jvm的永久代中会发生垃圾回收吗？<br>一面：jvm内存分区，为什么要有新生代和老年代？</p><p>视频链接：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ">https://www.bilibili.com/video/BV1PJ411n7xZ</a><br>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</p><p>蚂蚁金服：<br>Java8的内存分代改进<br>JVM内存分哪几个区，每个区的作用是什么？<br>一面：JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？<br>二面：Eden和survior的比例分配</p><p>小米：<br>jvm内存分区，为什么要有新生代和老年代</p><p>字节跳动：<br>二面：Java的内存分区<br>二面：讲讲vm运行时数据库区<br>什么时候对象会进入老年代？</p><p>京东：<br>JVM的内存结构，Eden和Survivor比例。<br>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</p><p>天猫：<br>一面：Jvm内存模型以及分区，需要详细到每个区放什么。<br>一面：JVM的内存模型，Java8做了什么改</p><p>拼多多：<br>JVM内存分哪几个区，每个区的作用是什么？</p><p>美团：<br>java内存分配<br>jvm的永久代中会发生垃圾回收吗？<br>一面：jvm内存分区，为什么要有新生代和老年代？</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm(3)--堆</title>
      <link href="/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(2)/"/>
      <url>/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(2)/</url>
      
        <content type="html"><![CDATA[<h2 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h2><span id="more"></span><p><strong>一个Native Method就是一个java调用非java代码的接口</strong>，一个Native Method 是这样一个java方法：该方法的底层实现由非Java语言实现，比如C。这个特征并非java特有，很多其他的编程语言都有这一机制，比如在C++ 中，你可以用extern “C” 告知C++ 编译器去调用一个C的函数。<br>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。<br>本地接口的作用是融合不同的编程语言为java所用，它的初衷是融合C/C++程序。<br>标识符native可以与其他所有的java标识符连用，但是abstract除外。</p><ul><li>与java环境外交互：</li><li>与操作系统交互（比如线程最后要回归于操作系统线程）</li><li>Sun’s Java<br>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>1.Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法（一般非Java实现的方法）的调用</p><p>2.本地方法栈，也是线程私有的。</p><p>3.允许被实现成固定或者是可动态拓展的内存大小。（和Java虚拟机栈在内存溢出方面情况是相同的）</p><p>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个StackOverFlowError异常。</p><p>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么java虚拟机将会抛出一个OutOfMemoryError异常。</p><p>4.本地方法是使用C语言实现的</p><p>5.它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载本地方法库。</p><p><strong>6.当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限</strong></p><p>本地方法可以通过本地方法接口来 <strong>访问虚拟机内部的运行时数据区</strong></p><p>它甚至可以直接使用本地处理器中的寄存器</p><p>直接从本地内存的堆中分配任意数量的内存</p><p>7.并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>所有的线程共享java堆</p><p>数组或对象永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</p><p>堆，是GC(Garbage Collection，垃圾收集器)执行垃圾回收的重点区域</p><p>jdk目录，jdk1.8.0_171.jdk/Contents/Home/bin下找到jvisualvm 运行（或者直接终端运行jvisualvm），查看进程，可以看到我们设置的配置信息： </p><p>JDK 8以后： 逻辑上分为新生区+养老区+元空间（即Xms/Xmx分配的内存物理上没有涉及元空间）</p><p>元空间在方法区</p><ul><li>Young Generation Space：又被分为Eden区和Survior区 </li><li>Tenure generation Space： Old/Tenure</li><li>Meta Space： Meta</li></ul><h4 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h4><p>1.Java堆区用于存储java对象实例，堆的大小在jvm启动时就已经设定好了，可以通过 “-Xmx”和 “-Xms”来进行设置</p><ul><li>-Xms 用来设置堆空间（年轻代+老年代）的初始内存大小，等价于 -XX:InitialHeapSize<ul><li>-X 是jvm的运行参数</li><li>ms 是memory start</li></ul></li><li>-Xmx 用于设置堆的最大内存，等价于 -XX:MaxHeapSize</li></ul><p>2.一旦堆区中的内存大小超过 -Xmx所指定的最大内存时，将会抛出OOM异常。</p><ul><li>默认情况下，初始内存大小：物理内存大小/64;最大内存大小：物理内存大小/4。</li><li>手动设置：-Xms600m -Xmx600m</li></ul><p>3.通常会将-Xms和-Xmx两个参数配置相同的值，其目的就是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</p><ul><li>比如说：默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。<br>因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小</li></ul><p>4.查看设置的堆内存参数：</p><ul><li>方式一： ==终端输入jps== ， 然后 ==jstat -gc 进程id==</li><li>方式二：（控制台打印）Edit Configurations-&gt;VM Options 添加 ==-XX:+PrintGCDetails==</li></ul><p><strong>form 和to区只有一个能放</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> Picture(<span class="keyword">new</span> Random().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Picture</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Picture</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pixels = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h4><p><img src="/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(2)/%E5%A0%86%E7%A9%BA%E9%97%B4.png" alt="堆空间"></p><ul><li>配置新生代与老年代在堆结构的占比<ul><li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li><li>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li></ul></li><li>在hotSpot中，Eden空间和另外两个Survivor空间缺省所占的比例是8：1：1（测试的时候是6：1：1），开发人员可以通过选项 -XX:SurvivorRatio 调整空间比例，如-XX:SurvivorRatio=8</li><li>可以使用选项-Xmn设置新生代最大内存大小（这个参数一般使用默认值就好了）</li></ul><p><strong>过程</strong></p><p>1.new的对象先放伊甸园区。此区有大小限制。</p><p>2.当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC),将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p><p>3.然后将伊甸园中的剩余的幸存对象移动到幸存者0区。</p><p>4.如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</p><p>5.如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</p><p>6.啥时候能去养老区呢？可以设置次数。默认是15次。·可以设置参数：-XX:MaxTenuringThreshold=进行设置。</p><p>7.在养老区，相对悠闲。当老年区内存不足时，再次触发GC：Major GC，进行养老区的内存清理。</p><p>8.若养老区执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常。</p><p>总结：针对幸存者s0,s1区：复制之后有交换，谁空谁是to。<br>      关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不再永久区/元空间收集。</p><p>注意：只有伊甸园满了才会触minorGC/youngGC,而幸存者区满了是绝对不会触发minorGC的</p><h4 id="常用调优工具"><a href="#常用调优工具" class="headerlink" title="常用调优工具"></a>常用调优工具</h4><p>1.JDK命令行</p><p>2.Eclipse：Memory Analyzer Tool</p><p>3.Jconsole</p><p>4.VisualVM</p><p>5.Jprofiler</p><p>6.Java Flight Recorder</p><p>7.GCViewer</p><p>8.GC Easy</p><p>针对hotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><h4 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h4><p><strong>1.部分收集</strong>：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集<ul><li>目前，只有CMS GC会有单独收集老年代的行为</li><li>注意，很多时候Major GC 会和 Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收</li></ul></li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>混合收集不涉及方法区回收，只是新生代，老年代的混合收集。</li><li>目前，之后G1 GC会有这种行为。</li></ul></li></ul><p><strong>2.整堆收集</strong>（Full GC）：收集整个java堆和方法区的垃圾收集。</p><p><strong>年轻代GC（Minor GC）触发机制</strong>：</p><ul><li>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC.(每次Minor GC会清理年轻代的内存，Survivor是被动GC，不会主动GC)</li></ul><p><strong>老年代GC(Major GC/Full GC)触发机制</strong></p><ul><li>出现了Major GC，经常会伴随至少一次的Minor GC（不是绝对的，在Parallel Scavenge 收集器的收集策略里就有直接进行Major GC的策略选择过程）<ul><li>也就是老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</li></ul></li><li>Major GC速度一般会比Minor GC慢10倍以上，STW时间更长</li><li>如果Major GC后，内存还不足，就报OOM了</li></ul><p><strong>Full GC触发机制</strong></p><ul><li>触发Full GC执行的情况有以下五种<ul><li>①调用System.gc()时，系统建议执行Full GC，但是<strong>不必然执行</strong></li><li>②老年代空间不足</li><li>③方法区空间不足</li><li>④通过Minor GC后进入老年代的平均大小小于老年代的可用内存</li><li>⑤由Eden区，Survivor S0（from）区向S1（to）区复制时，对象大小由于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul></li><li>说明：Full GC 是开发或调优中尽量要避免的，这样暂停时间会短一些</li></ul><h4 id="内存分配策略总结"><a href="#内存分配策略总结" class="headerlink" title="内存分配策略总结"></a>内存分配策略总结</h4><ul><li><p>如果对象在Eden出生并经过第一次Minor GC后依然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，把那个将对象年龄设为1.对象</p><p>在Survivor区中每熬过一次MinorGC</p><p>，年龄就增加一岁，当它的年龄增加到一定程度（默认15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代中</p><ul><li>对象晋升老年代的年龄阈值，可以通过选项 -XX：MaxTenuringThreshold来设置</li></ul></li><li><p>针对不同年龄段的对象分配原则如下：</p><ul><li>优先分配到Eden</li><li>大对象直接分配到老年代<ul><li>我们要尽量避免程序中出现过多的大对象</li></ul></li><li>长期存活的对象分配到老年代</li><li>动态对象年龄判断<ul><li>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入到老年代。无需等到MaxTenuringThreshold中要求的年龄</li></ul></li></ul></li></ul><h2 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2><h4 id="（Thread-Local-Allocation-Buffer）"><a href="#（Thread-Local-Allocation-Buffer）" class="headerlink" title="（Thread Local Allocation Buffer）"></a><strong>（Thread Local Allocation Buffer）</strong></h4><ul><li>众所周知堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据。由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。</li><li>一般为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</li><li>为了解决这一问题，TLAB应运而生。</li></ul><h4 id="什么是TLAB"><a href="#什么是TLAB" class="headerlink" title="什么是TLAB"></a><strong>什么是TLAB</strong></h4><ul><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</li><li>多线程同时分配内</li></ul><p><img src="/2020/07/16/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86(2)/TLAB.png" alt="TLAB"></p><p>“-XX:UseTLAB“ 设置是够开启TLAB空间</p><p>”-XX:TLABWasteTargetPercent“ 设置TLAB空间所占用Eden空间的百分比大小</p><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配了内存</p><h2 id="堆空间的参数设置"><a href="#堆空间的参数设置" class="headerlink" title="堆空间的参数设置"></a>堆空间的参数设置</h2><ul><li><p>-XX:PrintFlagsInitial: 查看所有参数的默认初始值</p></li><li><p>-XX:PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）</p><ul><li>具体查看某个参数的指令：<ul><li>jps：查看当前运行中的进程</li><li>jinfo -flag SurvivorRatio 进程id： 查看新生代中Eden和S0/S1空间的比例</li></ul></li></ul></li><li><p>-Xms: 初始堆空间内存（默认为物理内存的1/64）</p></li><li><p>-Xmx: 最大堆空间内存（默认为物理内存的1/4）</p></li><li><p>-Xmn: 设置新生代大小（初始值及最大值）</p></li><li><p>-XX:NewRatio: 配置新生代与老年代在堆结构的占比</p></li><li><p>-XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</p></li><li><p>-XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄(默认15)</p></li><li><p>-XX:+PrintGCDetails：输出详细的GC处理日志</p><ul><li>打印gc简要信息：① -XX:+PrintGC ② -verbose:gc</li></ul></li><li><p>-XX:HandlePromotionFailure：是否设置空间分配担保</p><p>在发生Minor Gc之前，虚拟机会检查老年代<strong>最大可用的连续空间是否大于新生代所有对象的总空间</strong>。</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败。（==JDK 7以后的规则HandlePromotionFailure可以认为就是true）<ul><li>如果HandlePromotionFailure=true,那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。<ul><li>√如果大于，则尝试进行一次Minor GC,只是尝试看能否触发分配担保（我们肯定希望的是分配担保成功Eden–&gt;old/tentired），但这次Minor GC依然是有风险的；</li><li>√如果小于，则改为进行一次Full GC。</li></ul></li><li>√如果HandlePromotionFailure=false,则改为进行一次Full GC。</li></ul></li></ul></li></ul><h2 id="堆是分配对象的唯一选择么"><a href="#堆是分配对象的唯一选择么" class="headerlink" title="堆是分配对象的唯一选择么?"></a>堆是分配对象的唯一选择么?</h2><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析（Escape Analysis)后发现，一<strong>个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</strong>这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><ul><li>逃逸分析的基本行为就是分析对象动态作用域：<ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></li><li>如何快速的判断是否发生了逃逸分析，就看new的对象实体是否有可能在方法外被调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">//use V</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有发生逃逸的对象，则可以分配到栈上：原因如下：</p><p>1.随着方法执行的结束，栈空间就被移除。</p><p>2.虚拟机栈空间是线程私有的，不会被共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="comment">//return sb;发生了逃逸</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString();<span class="comment">//没有发生</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，就看“new的对象实体”是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span>? <span class="keyword">new</span> EscapeAnalysis() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = <span class="keyword">new</span> EscapeAnalysis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useEscapeAnalysis1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        EscapeAnalysis e = getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码优化理论"><a href="#代码优化理论" class="headerlink" title="代码优化理论"></a>代码优化理论</h2><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>将堆分配转化为栈分配。如果一个对象在子线程中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</p><p>常见的发生逃逸的场景：给成员变量赋值、方法返回值、实例引用传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackAllocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h4><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫 <strong>锁消除</strong></p><h4 id="分离对象或标量替换"><a href="#分离对象或标量替换" class="headerlink" title="分离对象或标量替换"></a>分离对象或标量替换</h4><ul><li>标量Scalar：是指一个无法在分解成更小的数据的数据。Java中的原始数据类型就是标量。</li><li>相对的，那些还可以分解的数据叫做 聚合量(Aggregate)，Java中对象就是聚合量，因为它可以分解成其他聚合量和标量。</li><li>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来替代。这个过程就是标量替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        alloc();   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Point point = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置参数：-XX:+EliminateAllocations，开启标量替换。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm(2)--栈</title>
      <link href="/2020/07/15/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/"/>
      <url>/2020/07/15/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/java%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="java体系结构"></p><span id="more"></span><h2 id="运行时数据区内部结构"><a href="#运行时数据区内部结构" class="headerlink" title="运行时数据区内部结构"></a>运行时数据区内部结构</h2><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8C%BA%E5%9F%9F.png" alt="jvm运行时区域"></p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/E:%5CBlog%5Csource_posts%5Cjvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86%5Cjvm%E5%86%85%E5%AD%98%E5%9B%BE.png" alt="img"></p><p>java虚拟机定了了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与县城一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。<br>如图，<strong>灰色的区域为单独线程私有的，红色的为多个线程共享</strong>的</p><p>1.每个线程：独立包括程序计数器、栈、本地栈</p><p>2.线程间共享：堆、堆外内存（方法区、永久代或元空间、代码缓存）</p><p>一般来说，jvm优化95%是优化堆区，5%优化的是方法区，至于栈区无非出入栈操作优化较少</p><p>每个Java应用程序都有一个Runtime类的实例，该实例允许该应用程序与运行该应用程序的环境进行交互。 当前运行时可以从getRuntime方法获得。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>1.线程是一个程序里的运行单元，JVM允许一个程序有多个线程并行的执行；</p><p>2.在HotSpot JVM，每个线程都与操作系统的本地线程直接映射。</p><p>　　当一个java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。java线程执行终止后。本地线程也会回收。</p><p>3.操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用java线程中的run（）方法.</p><h5 id="JVM系统线程分类"><a href="#JVM系统线程分类" class="headerlink" title="JVM系统线程分类"></a>JVM系统线程分类</h5><p>如果你使用jconsole或者任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用main方法的main线程以及所有这个main线程自己创建的线程；</p><p>这些主要的后台系统线程在HotSpot JVM里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作时需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行包括“stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li>周期任务线程：这种线程是时间周期事件的提现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC线程：这种线程对于JVM里不同种类的垃圾收集行为提供了支持</li><li>编译线程：这种线程在运行时会降字节码编译成本地代码</li><li>信号调度线程：这种线程接收信号并发送给JVM,在它内部通过调用适当的方法进行处理。</li></ul><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</strong></p><p>一个线程对应一个 JVM Stack。JVM Stack 中包含一组 Stack Frame。当 JVM 调用一个 Java 方法时，它从对应类的类型信息中得到此方法的局部变量区和操作数栈的大小，并据此分配栈帧内存，然后压入 JVM 栈中。</p><p>在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/PC%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="PC寄存器"></p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>PC寄存器是用来存储指向下一条指令的地址，也即将将要执行的指令代码。由执行引擎读取下一条指令。</p><p>1.它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</p><p>2.在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</p><p>3.任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果实在执行native方法，则是未指定值（undefined）,因为程序计数器不负责本地方法栈。</p><p>4.它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p><p>5.字节码解释器工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令</p><p>6.它是唯一一个在java虚拟机规范中<strong>没有规定任何OOM（Out Of Memery）情况</strong>的区域,而且没有垃圾回收</p><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PCRegister</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">int</span> k = i+j;</span><br><span class="line">        String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%BE%E4%BE%8B.png" alt="寄存器举例"></p><p>指令地址+操作地址</p><p>这些指令在PC寄存器中 ，</p><p>执行引擎会将其取出，操作局部变量表、操作数栈，翻译成机器指令送给CPU</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>1.<strong>使用PC寄存器存储字节码指令地址有什么用呢（为什么使用PC寄存器记录当前线程的执行地址呢）</strong></p><p>（1）多线程宏观上是并行（多个事件在同一时刻同时发生）的，但实际上是并发交替执行的</p><p>（2）因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行<br>（3）JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</p><p>所以，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。<br>2.<strong>PC寄存器为什么会设定为线程私有？</strong><br>（1）我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停滴做任务切换，这样必然会导致经常中断或恢复，如何保证分毫无差呢？</p><p>（2）为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是<strong>为每一个线程都分配一个PC寄存器,</strong>这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>根据栈设计的<strong>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</strong></p><p><strong>栈是运行时的单位，而堆是存储的单位</strong><br>1.栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。</p><p>2.一般来讲，对象主要都是放在堆空间的，是运行时数据区比较大的一块</p><p>3.栈空间存放 基本数据类型的局部变量，以及引用数据类型的对象的引用</p><h4 id="Java虚拟机栈的特点"><a href="#Java虚拟机栈的特点" class="headerlink" title="Java虚拟机栈的特点"></a>Java虚拟机栈的特点</h4><p>1.java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应这个一次次的java方法调用。它是线程私有的</p><p>2.生命周期和线程是一致的</p><p>3.栈是一种快速有效的分配存储方式，访问速度仅次于PC寄存器（程序计数器）</p><p>4.作用：主管java程序的运行，它保存方法的局部变量、8种基本数据类型、对象的引用地址、部分结果，并参与方法的调用和返回。</p><ul><li>局部变量：相较于成员变量（成员变量或称属性）</li><li>基本数据变量：8种基本数据类型</li><li>引用类型变量：类，数组，接口</li></ul><p>5.JVM直接对java栈的操作只有两个</p><p>（1）每个方法执行，伴随着进栈（入栈，压栈）</p><p>（2）执行结束后的出栈工作</p><p>6.对于栈来说不存在垃圾回收问题，但是肯定存在OOM异常</p><h4 id="栈中可能出现的异常"><a href="#栈中可能出现的异常" class="headerlink" title="栈中可能出现的异常"></a>栈中可能出现的异常</h4><p>ava虚拟机规范允许<strong>Java栈的大小是动态的或者是固定不变的</strong></p><ul><li>如果采用固定大小的Java虚拟机栈，那每一个线程的java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量，java虚拟机将会抛出一个 <strong>StackOverFlowError</strong>异常</li><li>如果java虚拟机栈可以动态拓展，并且在尝试拓展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个 <strong>OutOfMemoryError异常</strong></li></ul><h4 id="设置栈的内存大小"><a href="#设置栈的内存大小" class="headerlink" title="设置栈的内存大小"></a>设置栈的内存大小</h4><p>我们可以使用参数-Xss选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。 （IDEA设置方法：Run-EditConfigurations-VM options 填入指定栈的大小<strong>-Xss256k</strong>）</p><h4 id="存储结构和运行原理"><a href="#存储结构和运行原理" class="headerlink" title="存储结构和运行原理"></a>存储结构和运行原理</h4><p><strong>存储结构</strong></p><ul><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧(Stack Frame)</strong>的格式存在</li><li>在这个线程上正在执行的每个方法都对应各自的一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><p><strong>运行原理</strong></p><ul><li>不同线程中所包含的栈帧是不允许相互引用的，即不可能在另一个栈帧中引用另外一个线程的栈帧</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li><li>Java方法有两种返回函数的方式，<strong>一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></li></ul><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><h5 id="1-局部变量表（Local-Variables）"><a href="#1-局部变量表（Local-Variables）" class="headerlink" title="1.局部变量表（Local Variables）"></a><strong>1.局部变量表</strong>（Local Variables）</h5><ul><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress类型</li><li>由于局部变量表是建立在线程的栈上，是线程私有的数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>,并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的</li><li><strong>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。</strong>对一个函数而言，他的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间。</li><li><strong>局部变量表中的变量只在当前方法调用中有效。</strong>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。<strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</strong></li></ul><h6 id="查看帧的局部变量表"><a href="#查看帧的局部变量表" class="headerlink" title="查看帧的局部变量表"></a>查看帧的局部变量表</h6><p>利用javap命令对字节码文件进行解析查看main()方法对应栈帧的局部变量表</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.png" alt="局部变量表"></p><p>也可以在IDEA 上安装jclasslib byte viewcoder插件查看方法内部字节码信息剖析</p><h6 id="变量槽slot的理解与演示"><a href="#变量槽slot的理解与演示" class="headerlink" title="变量槽slot的理解与演示"></a>变量槽slot的理解与演示</h6><ul><li><p>局部变量表，<strong>最基本的存储单元是Slot(变量槽)</strong></p></li><li><p>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p></li><li><p>在局部变量表里，<strong>32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double）占用两个slot。</strong></p><ul><li>byte、short、char、float在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true；</li><li>long和double则占据两个slot。</li></ul></li></ul><ul><li><p>如果当前帧是由构造方法或者实例方法创建的（意思是当前帧所对应的方法是构造器方法或者是普通的实例方法），那么<strong>该对象引用this将会存放在index为0的slot处</strong>,其余的参数按照参数表顺序排列。</p></li><li><p>静态方法中不能引用this，是因为静态方法所对应的栈帧当中的局部变量表中不存在this</p></li></ul><h6 id="slot的重复利用"><a href="#slot的重复利用" class="headerlink" title="slot的重复利用"></a>slot的重复利用</h6><p>栈帧中的局部变量表中的槽位是可以重复利用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">            b = a+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//变量c使用之前以及经销毁的变量b占据的slot位置</span></span><br><span class="line">        <span class="keyword">int</span> c = a+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3个变量</p><h6 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h6><p>变量的分类：</p><ul><li>按照数据类型分：<ul><li>①基本数据类型;</li><li>②引用数据类型；</li></ul></li><li>按照在类中声明的位置分：<ul><li>①成员变量：在使用前，都经历过默认初始化赋值<ul><li>static修饰：类变量：类加载链接的准备prepare阶段给类变量默认赋0值——&gt;初始化阶段initialization给类变量显式赋值即静态代码块赋值；</li><li>不被static修饰：实例变量：随着对象的创建，会在堆空间分配实例变量空间，并进行默认赋值</li></ul></li><li>②局部变量：在使用前，<strong>必须要进行显式赋值的</strong>！否则，编译不通过</li></ul></li></ul><p><strong>补充</strong></p><ul><li>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li><li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li></ul><h5 id="2-操作数栈"><a href="#2-操作数栈" class="headerlink" title="2.操作数栈"></a>2.操作数栈</h5><p>（Operand Stack）(或表达式栈)</p><ul><li>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出的操作数栈，也可以成为表达式栈</li><li><strong>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）或出栈（pop）</strong><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用他们后再把结果压入栈。（如字节码指令bipush操作）</li><li>比如：执行复制、交换、求和等操作</li></ul></li></ul><h6 id="代码追踪"><a href="#代码追踪" class="headerlink" title="代码追踪"></a>代码追踪</h6><p>①15入栈；②存储15，15进入局部变量表</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%881.png" alt="操作数栈1"></p><p>③压入8；④8出栈，存储8进入局部变量表；</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%882.png" alt="操作数栈2"></p><p>⑤从局部变量表中把索引为1和2的是数据取出来，放到操作数栈；⑥iadd相加操作</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%883.png" alt="操作数栈3"></p><p>⑦iadd操作结果23出栈⑧将23存储在局部变量表索引为3的位置上istore_3</p><p>只用了两个栈的空间</p><h6 id="栈顶缓存技术ToS"><a href="#栈顶缓存技术ToS" class="headerlink" title="栈顶缓存技术ToS"></a>栈顶缓存技术ToS</h6><p>（Top-of-Stack Cashing）</p><ul><li>基于栈式架构的虚拟机所使用的零地址指令（即不考虑地址，单纯入栈出栈）更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数</li><li>由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率</strong></li></ul><h5 id="3-动态链接"><a href="#3-动态链接" class="headerlink" title="3.动态链接"></a>3.动态链接</h5><p>（Dynamic Linking）(或执行”运行时常量池”的方法引用)—-深入理解Java多态特性必读！！</p><p>1.运行时常量池位于方法区（注意： JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。）</p><p>2.每一个栈帧内部都<strong>包含一个指向运行时常量池Constant pool或该栈帧所属方法的引用</strong>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令</p><p>3.在Java源文件被编译成字节码文件中时，所有的变量和方法引用都作为符号引用（symbolic Refenrence）保存在class字节码文件（javap反编译查看）的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用（#）最终转换为调用方法的直接引用。</strong></p><h5 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4.方法返回地址"></a>4.方法返回地址</h5><p>（Return Adress）（或方法正常退出或者异常退出的定义）</p><ul><li>一个方法的结束，有两种方式：<ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者（方法的调用者可能也是一个方法）的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。</strong>而通过异常退出时，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</li><li>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</li><li><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></li></ul><p>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口；</p><ul><li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</li><li>在字节码指令中，返回指令包含ireturn（当返回值是boolena、byte、char、short和int类型时使用）、lreturn、freturn、dreturn以及areturn(引用类型的)</li><li>另外还有一个return指令供声明为void的方法、实例初始化方法、类和接口的初始化方法使用</li></ul><p>在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜素到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong><br>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</p><h5 id="5-一些附加信息"><a href="#5-一些附加信息" class="headerlink" title="5.一些附加信息"></a>5.一些附加信息</h5><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><strong>静态链接</strong><br>当一个 字节码文件被装载进JVM内部时，如果被调用的目标方法在<strong>编译期</strong>可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</li><li><strong>动态链接</strong><br>如果被调用的方法在<strong>编译期无法被确定</strong>下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</li></ul><p>对应的方法的绑定机制为：早起绑定（Early Binding）和晚期绑定（Late Bingding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong><br>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</li><li><strong>晚期绑定</strong><br>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。 <strong>例如传参为接口，方法</strong>不知道实例的到底是哪个，体现出了多态的特性。</li></ul><p>字节码文件中，构造器和方法都在method中</p><p>语言都支持封装，集成和多态等面向对象特性，既然这一类的编程语言具备多态特性，<strong>那么自然也就具备早期绑定和晚期绑定两种绑定方式。</strong><br>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字<strong>final</strong>来标记这个方法。</p><h2 id="虚方法和非虚方法"><a href="#虚方法和非虚方法" class="headerlink" title="虚方法和非虚方法"></a>虚方法和非虚方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子类对象的多态性使用前提：实际开发编写代码中用的接口，实际执行是导入的的三方jar包已经实现的功能</span><br><span class="line">①类的继承关系（父类的声明）②方法的重写（子类的实现）</span><br></pre></td></tr></table></figure><p>非虚方法</p><ul><li>如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法</li><li><strong>静态方法、私有方法、final方法、实例构造器（实例已经确定，this()表示本类的构造器）、父类方法（super调用）都是非虚方法</strong></li></ul><p>其他所有体现多态特性的方法称为虚方法</p><ul><li>普通调用指令：<pre><code>1.invokestatic：调用静态方法，解析阶段确定唯一方法版本；  2.invokespecial:调用&lt;init&gt;方法、私有及父类方法，解析阶段确定唯一方法版本；  3.invokevirtual调用所有虚方法；  4.invokeinterface：调用接口方法；</code></pre></li><li>动态调用指令（Java7新增）：<pre><code>5.invokedynamic：动态解析出需要调用的方法，然后执行 .</code></pre>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。</li></ul><p><strong>其中invokestatic指令和invokespecial指令调用的方法称为非虚方法</strong></p><p><strong>其中invokevirtual（final修饰的除外，JVM会把final方法调用也归为invokevirtual指令，但要注意final方法调用不是虚方法）、invokeinterface指令调用的方法称称为虚方法。</strong></p><p>但是java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令.<strong>直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在java中才有了直接生成方式</strong></p><h2 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h2><ul><li>动态类型语言和静态类型语言两者的却别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言。</li><li>直白来说 <strong>静态语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</strong>,这是动态语言的一个重要特征</li><li>Java是静态类型语言（尽管lambda表达式为其增加了动态特性），js，python是动态类型语言.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java：String info = <span class="string">&quot;aaa&quot;</span>;<span class="comment">//静态语言</span></span><br><span class="line"></span><br><span class="line">JS：<span class="keyword">var</span> name = <span class="string">&quot;aaa“；var name = 10;//动态语言</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Python: info = 130;//更加彻底的动态语言</span></span><br></pre></td></tr></table></figure><h2 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h2><ul><li>1 找到操作数栈的第一个元素所执行的对象的实际类型，记作C。</li><li>2.如果在类型C中找到与常量池中的描述符、简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</li><li>3.否则，按照继承关系从下往上依次对c的各个父类进行第二步的搜索和验证过程。</li><li>4.如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。 <strong>IllegalAccessError介绍</strong> 程序视图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li></ul><h2 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h2><ul><li>在面向对象编程中，会很频繁期使用到动态分派，如果在每次动态分派的过程中都要重新在累的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，jvm采用在类的方法区建立一个虚方法表（virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</li><li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li><li>那么虚方法表什么时候被创建？ 虚方法表会在类加载的<strong>链接阶段</strong>被创建 并开始初始化，类的变量初始值准备完成之后，jvm会把该类的虚方法表也初始化完毕</li></ul><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/jvm-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%A9%BA%E9%97%B4%E5%88%92%E5%88%86/%E8%99%9A%E6%96%B9%E6%B3%95%E8%A1%A8.png" alt="虚方法表"></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ul><li><p>举例栈溢出的情况？</p><ul><li>-Xss设置栈的大小</li></ul></li><li><p>调制栈大小，就能保证不溢出吗？</p><ul><li>不能，只能出现的时间晚一些</li></ul></li><li><p>分配的栈内存越大越好吗？</p><ul><li>线程数会变小</li></ul></li><li><p>垃圾回收是否会涉及虚拟机栈？</p><ul><li>不会</li></ul></li><li><p>方法中定义的局部变量是否是线程安全的</p><p>具体问题具体分析</p><p>线程安全：</p><ul><li>如果只有一个线程才可以操作此数据，则必线程安全</li><li>如果多个线程操作此数据，则此数据时共享数据，如果不考虑同步机制，会存在线程安全问题</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程（4）</title>
      <link href="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/"/>
      <url>/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/</url>
      
        <content type="html"><![CDATA[<h2 id="集合类不安全"><a href="#集合类不安全" class="headerlink" title="集合类不安全"></a>集合类不安全</h2><h4 id="List-不安全"><a href="#List-不安全" class="headerlink" title="List 不安全"></a>List 不安全</h4><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.util.ConcurrentModificationException 并发修改异常！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 并发下 ArrayList 不安全的吗，Synchronized；</span></span><br><span class="line">        <span class="comment">/*** 解决方案；</span></span><br><span class="line"><span class="comment">        * 1、List&lt;String&gt; list = new Vector&lt;&gt;();</span></span><br><span class="line"><span class="comment">        * 2、List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt; ());</span></span><br><span class="line"><span class="comment">        * 3、List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;()；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">        <span class="comment">// CopyOnWrite 写入时复制 COW 计算机程序设计领域的一种优化策略；</span></span><br><span class="line">        <span class="comment">// 多个线程调用的时候，list，读取的时候，固定的，写入（覆盖）</span></span><br><span class="line">        <span class="comment">// 在写入的时候避免覆盖，造成数据问题！</span></span><br><span class="line">        <span class="comment">// 读写分离</span></span><br><span class="line">        <span class="comment">// CopyOnWriteArrayList 比 Vector Nb 在哪里？</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line">                System.out.println(list); </span><br><span class="line">                &#125;,String.valueOf(i)).start(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lock 利用Arrays.copyof()来复制一份新数组，再进行设置</p><h4 id="Set-不安全"><a href="#Set-不安全" class="headerlink" title="Set 不安全"></a>Set 不安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set&lt;String&gt; set = new HashSet&lt;&gt;(); 不安全</span></span><br><span class="line"><span class="comment">// Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span></span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br></pre></td></tr></table></figure><p>hashSet 底层是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// add set 本质就是 map key是无法重复的！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h4 id="Map-不安全"><a href="#Map-不安全" class="headerlink" title="Map 不安全"></a>Map 不安全</h4><p>hashMap</p><p>加载因子 0.75</p><p>位运算  16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentModificationException </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// map 是这样用的吗？ 不是，工作中不用 HashMap </span></span><br><span class="line">        <span class="comment">// 默认等价于什么？ new HashMap&lt;&gt;(16,0.75); </span></span><br><span class="line">        <span class="comment">// Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); </span></span><br><span class="line">        <span class="comment">// 唯一的一个家庭作业：研究ConcurrentHashMap的原理 </span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">30</span>; i++) &#123; </span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123; </span><br><span class="line">                map.put(Thread.currentThread().getName(),UUID.randomUUID().toString().substring( <span class="number">0</span>,<span class="number">5</span>)); </span><br><span class="line">                System.out.println(map); &#125;,String.valueOf(i)).start(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h5><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>FIFO<br>写入 ：队列慢，就阻塞，<br>取：队列空，就必须等待生产</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/Queue.png" alt="Queue">)<img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/BlockingQueue.png" alt="BlockingQueue"></p><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/%E5%AE%9E%E7%8E%B0%E5%9B%BE.png" alt="实现图"></p><p>阻塞队列：多线程并发处理，线程池！</p><p><strong>学会使用队列</strong></p><table><thead><tr><th><strong>方式</strong></th><th><strong>抛出异常</strong></th><th><strong>有返回值，不抛出异常</strong></th><th><strong>阻塞 等待</strong></th><th><strong>超时等待</strong></th></tr></thead><tbody><tr><td>添加</td><td>add</td><td>offer()</td><td>put()</td><td>offer(,,)</td></tr><tr><td>移除</td><td>remove</td><td>poll()</td><td>take()</td><td>poll(,)</td></tr><tr><td>检测队首元素</td><td>element</td><td>peek</td><td></td><td></td></tr></tbody></table><p>添加、移除</p><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>同步队列</p><p>没有容量，进去一个元素，必须等待取出来之后，才能再往里面放一个元素！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步队列</span></span><br><span class="line"><span class="comment"> * 和其他的BlockingQueue 不一样， SynchronousQueue 不存储元素</span></span><br><span class="line"><span class="comment"> * put了一个元素，必须从里面先take取出来，否则不能在put进去值！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;(); <span class="comment">// 同步队列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; put 1&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; put 2&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; put 3&quot;</span>);</span><br><span class="line">                blockingQueue.put(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+blockingQueue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;=&gt;&quot;</span>+blockingQueue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;T2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池：三大方法、7大参数、4种拒绝策略</p><h4 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h4><p>程序的运行，本质：占用系统的资源！ 优化资源的使用！=&gt;池化技术</p><p>线程池、连接池、内存池、对象池///….. 创建、销毁。十分浪费资源</p><p>池化技术：事先准备好一些资源，有人要用，就来我这里拿，用完之后还给我。</p><p><strong>线程池的好处</strong></p><p>1、降低资源的消耗</p><p>2、提高响应的速度</p><p>3、方便管理。</p><p><strong>线程复用、可以控制最大并发数、管理线程</strong></p><h4 id="线程池：三大方法"><a href="#线程池：三大方法" class="headerlink" title="线程池：三大方法"></a>线程池：三大方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors 工具类、3大方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newSingleThreadExecutor();<span class="comment">// 单个线程</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newFixedThreadPool(5);// 创建一 个固定的线程池的大小</span></span><br><span class="line">        <span class="comment">// ExecutorService threadPool = Executors.newCachedThreadPool(); // 可伸缩的，遇强则强，遇弱则弱</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用了线程池之后，使用线程池来创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ok&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 线程池用完，程序结束，关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7大参数"><a href="#7大参数" class="headerlink" title="7大参数"></a>7大参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//本质</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>corePoolSize: 线程池的核心线程数(常驻线程数),也就是线程池的最小线程数,这部分线程不会被回收.</p></li><li><p>maximumPoolSize: 线程池最大线程数,线程池中允许同时执行的最大线程数量</p></li><li><p>keepAliveTime: 当线程池中的线程数量超过corePoolSize，但此时没有任务执行，<br>那么空闲的线程会保持keepAliveTime才会被回收，corePoolSize的线程不会被回收。</p></li><li><p>unit: KeepAliveTime的时间单位</p></li><li><p>workQueue: 当线程池中的线程达到了corePoolSize的线程数量，<br>并仍然有新任务，那么新任务就会被放入workQueue。          </p></li><li><p>threadFactory: 创建工作线程的工厂,也就是如何创建线程的,一般采用默认的</p></li><li><p>handler: 拒绝策略，当线程池中的工作线程达到了最大数量，<br>并且阻塞队列也已经满了，那么拒绝策略会决定如何处理新的任务。ThreadPoolExecutor 提供了四种策略:</p><ul><li>AbortPolicy(是线程池的默认拒绝策略): 如果使用此拒绝策略，那么将对新的任务抛出RejectedExecutionException异常，来拒绝任务。</li><li>DiscardPolicy: 如果使用此策略，那么会拒绝执行新的任务，但不会抛出异常。</li><li>DiscardOldestPolicy: 如果使用此策略，那么不会拒绝新的任务，但会抛弃阻塞队列中等待最久的那个线程。     </li><li>CallerRunsPolicy: 如果使用此策略，不会拒绝新的任务，但会让调用者执行线程。<br>也就是说哪个线程发出的任务，哪个线程执行。</li></ul></li></ol><h4 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy() <span class="comment">// 银行满了，还有人进来，不处理这个人的，抛出异常</span></span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy() <span class="comment">// 哪来的去哪里！ main线程执行</span></span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy() <span class="comment">//队列满了，丢掉任务，不会抛出异常！</span></span><br><span class="line"><span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy() <span class="comment">//队列满了，尝试去和最早的竞争，也不会抛出异常！</span></span><br></pre></td></tr></table></figure><h4 id="阿里巴巴开发者手册"><a href="#阿里巴巴开发者手册" class="headerlink" title="阿里巴巴开发者手册"></a>阿里巴巴开发者手册</h4><p>不建议开发者使用Executors创建线程池</p><p><strong>newFixedThreadPool和newSingleThreadPoolExecutor都是创建固定线程的线程池,<br>尽管它们的线程数是固定的，但是它们的阻塞队列的长度却是Integer.MAX_VALUE的,所以，<br>队列的任务很可能过多，导致OOM。</strong></p><p><strong>newCacheThreadPool和newScheduledThreadPool创建出来的线程池的线程数量却是Integer.MAX_VALUE的，<br>如果任务数量过多,也很可能发生OOM。</strong>          </p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%A7%84%E8%8C%83.png" alt="线程池规范"></p><h4 id="手动创建一个线程池"><a href="#手动创建一个线程池" class="headerlink" title="手动创建一个线程池"></a>手动创建一个线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,</span><br><span class="line">                <span class="number">5</span>,</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy() <span class="comment">//拒绝策略</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 最大承载：Deque + max</span></span><br><span class="line">            <span class="comment">// 超过 RejectedExecutionException</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 使用了线程池之后，使用线程池来创建线程</span></span><br><span class="line">                threadPool.execute(()-&gt;&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; ok&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 线程池用完，程序结束，关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最大线程到底该如何定义</span><br><span class="line">1、CPU 密集型，几核，就是几，可以保持CPu的效率最高！</span><br><span class="line">Runtime.getRuntime().availableProcessors(),</span><br><span class="line">2、IO  密集型   &gt; 判断你程序中十分耗IO的线程，</span><br><span class="line">程序   15个大型任务  io十分占用资源！</span><br></pre></td></tr></table></figure><h2 id="四大函数式接口（必需掌握）"><a href="#四大函数式接口（必需掌握）" class="headerlink" title="四大函数式接口（必需掌握）"></a>四大函数式接口（必需掌握）</h2><p>lambda表达式、链式编程、函数式接口、Stream流式计算</p><h4 id="函数式接口：-只有一个方法的接口"><a href="#函数式接口：-只有一个方法的接口" class="headerlink" title="函数式接口： 只有一个方法的接口"></a>函数式接口： 只有一个方法的接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型、枚举、反射 </span></span><br><span class="line"><span class="comment">// lambda表达式、链式编程、函数式接口、Stream流式计算 </span></span><br><span class="line"><span class="comment">// 超级多FunctionalInterface </span></span><br><span class="line"><span class="comment">// 简化编程模型，在新版本的框架底层大量应用！ </span></span><br><span class="line"><span class="comment">// foreach(消费者类的函数式接口)</span></span><br></pre></td></tr></table></figure><p>四大函数式接口</p><p>Consumer、Function 、Predicate、Supplier</p><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/Function.png" alt="Function"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Function 函数型接口, 有一个输入参数，有一个输出</span></span><br><span class="line">    <span class="comment">//只要是 函数型接口 可以 用 lambda表达式简化</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//        Function&lt;String,String&gt; function = new Function&lt;String,String&gt;() &#123;</span></span><br><span class="line">    <span class="comment">//            @Override</span></span><br><span class="line">    <span class="comment">//            public String apply(String str) &#123;</span></span><br><span class="line">    <span class="comment">//                return str;</span></span><br><span class="line">    <span class="comment">//            &#125;</span></span><br><span class="line">    <span class="comment">//        &#125;;</span></span><br><span class="line"></span><br><span class="line">    Function&lt;String,String&gt; function = str-&gt;&#123;<span class="keyword">return</span> str;&#125;;</span><br><span class="line">    System.out.println(function.apply(<span class="string">&quot;asd&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h4><p>断定型接口</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/Predicate.png" alt="Predicate"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//断定型接口：有一个输入参数，返回值只能是 布尔值</span></span><br><span class="line">    <span class="comment">//判断字符串是否为空</span></span><br><span class="line">    <span class="comment">// Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line">    <span class="comment">//     @Override</span></span><br><span class="line">    <span class="comment">//     public boolean test(String str) &#123;</span></span><br><span class="line">    <span class="comment">//         return str.isEmpty();</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    Predicate&lt;String&gt; predicate = (str)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> str.isEmpty();</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(predicate.test(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>消费者接口</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/Consumer.png" alt="Consumer"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//只有输入，没有返回值</span></span><br><span class="line">    <span class="comment">// Consumer&lt;String&gt; consumer = new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line">    <span class="comment">//     @Override</span></span><br><span class="line">    <span class="comment">//     public void accept(String s) &#123;</span></span><br><span class="line">    <span class="comment">//         System.out.println(s);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    Consumer&lt;String&gt; consumer = str -&gt;&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;;</span><br><span class="line">    consumer.accept(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h4><p>供给型接口</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/Supplier.png" alt="Supplier"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* Supplier&lt;Integer&gt; supplier = new Supplier&lt;&gt;() &#123;</span></span><br><span class="line"><span class="comment">        @Override</span></span><br><span class="line"><span class="comment">        public Object get() &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;get&quot;);</span></span><br><span class="line"><span class="comment">            return 1024;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;;*/</span></span><br><span class="line">    Supplier supplier = ()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(supplier.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h2><p>大数据：存储 + 计算</p><p>集合、MySQL 本质就是存储东西的；</p><p>计算都应该交给流来操作！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目要求：一分钟内完成此题，只能用一行代码实现！</span></span><br><span class="line"><span class="comment"> * 现在有5个用户！筛选：</span></span><br><span class="line"><span class="comment"> * 1、ID 必须是偶数</span></span><br><span class="line"><span class="comment"> * 2、年龄必须大于23岁</span></span><br><span class="line"><span class="comment"> * 3、用户名转为大写字母</span></span><br><span class="line"><span class="comment"> * 4、用户名字母倒着排序</span></span><br><span class="line"><span class="comment"> * 5、只输出一个用户！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">2</span>,<span class="string">&quot;b&quot;</span>,<span class="number">22</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">3</span>,<span class="string">&quot;c&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">4</span>,<span class="string">&quot;d&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">6</span>,<span class="string">&quot;e&quot;</span>,<span class="number">25</span>);</span><br><span class="line">        <span class="comment">// 集合就是存储</span></span><br><span class="line">        List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算交给Stream流</span></span><br><span class="line">        <span class="comment">// lambda表达式、链式编程、函数式接口、Stream流式计算</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getId()%<span class="number">2</span>==<span class="number">0</span>;&#125;)</span><br><span class="line">                .filter(u-&gt;&#123;<span class="keyword">return</span> u.getAge()&gt;<span class="number">23</span>;&#125;)</span><br><span class="line">                .map(u-&gt; &#123;<span class="keyword">return</span> u.getName().toUpperCase();&#125;)</span><br><span class="line">                .sorted( (uu1,uu2)-&gt;&#123;<span class="keyword">return</span> uu2.compareTo(uu1);&#125;)</span><br><span class="line">                .limit(<span class="number">1</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>ForkJoin 在 JDK 1.7 ， 并行执行任务！提高效率。大数据量！</p><p>大数据：Map Reduce （把大任务拆分为小任务）</p><h4 id="ForkJoin-特点：工作窃取"><a href="#ForkJoin-特点：工作窃取" class="headerlink" title="ForkJoin 特点：工作窃取"></a>ForkJoin 特点：工作窃取</h4><p>这个里面维护的都是双端队列</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96.png" alt="工作窃取"></p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/ForkJoin.png" alt="ForkJoin"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span>  <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//3000   6000（ForkJoin）  9000（Stream并行流）</span></span><br><span class="line">    <span class="comment">//1、forkjoinPool 通过它来执行</span></span><br><span class="line">    <span class="comment">// 2、计算任务 forkjoinPool.execute(ForkJoinTask task)</span></span><br><span class="line">    <span class="comment">// 3. 计算类要继承 ForkJoinTask</span></span><br><span class="line">    <span class="keyword">private</span> Long start;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> Long end;    <span class="comment">// 1990900000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界值</span></span><br><span class="line">    <span class="keyword">private</span> Long temp = <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinDemo</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( (end-start)&lt;temp)&#123;</span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i=start;i&lt;end;i++)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//分支合并计算  递归</span></span><br><span class="line">            <span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinDemo task1 = <span class="keyword">new</span> ForkJoinDemo(start, middle);</span><br><span class="line">            task1.fork();<span class="comment">// 拆分任务，把任务压入线程队列</span></span><br><span class="line">            ForkJoinDemo task2 = <span class="keyword">new</span> ForkJoinDemo(middle+<span class="number">1</span>, end);</span><br><span class="line">            task2.fork(); <span class="comment">// 拆分任务，把任务压入线程队列</span></span><br><span class="line">            <span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//test1(); //8151</span></span><br><span class="line">        <span class="comment">//test2(); //4333</span></span><br><span class="line">        test3();<span class="comment">//359</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通程序员</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Long i = <span class="number">1L</span>; i &lt;= <span class="number">10_0000_0000</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot; 时间：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会使用ForkJoin</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Long start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinDemo(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>);</span><br><span class="line">        ForkJoinTask&lt;Long&gt; submit = forkJoinPool.submit(task);<span class="comment">// 提交任务</span></span><br><span class="line">        Long sum = submit.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot; 时间：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Stream并行流 ()  (]</span></span><br><span class="line">        <span class="keyword">long</span> sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10_0000_0000L</span>).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;sum=&quot;</span>+sum+<span class="string">&quot;时间：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p> 设计的初衷： 对将来的某个事件的结果进行建模</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步调用： CompletableFuture</span></span><br><span class="line"><span class="comment"> * // 异步执行</span></span><br><span class="line"><span class="comment"> * // 成功回调</span></span><br><span class="line"><span class="comment"> * // 失败回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/*//无返回值</span></span><br><span class="line"><span class="comment">        CompletableFuture&lt;Void&gt; com = CompletableFuture.runAsync( ()-&gt;&#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                TimeUnit.SECONDS.sleep(2);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            System.out.println(Thread.currentThread().getName()+&quot;runAsync=&gt;Void&quot;);</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;111111111&quot;);</span></span><br><span class="line"><span class="comment">        com.get();  //获取阻塞执行结果*/</span></span><br><span class="line">        <span class="comment">//有返回值</span></span><br><span class="line">        <span class="comment">// ajax，成功和失败的回调</span></span><br><span class="line">        <span class="comment">// 返回的是错误信息；</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync( ()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;supplyAsync=&gt;supply&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(completableFuture.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;t:&quot;</span> + t); <span class="comment">// 正常的返回结果</span></span><br><span class="line">            System.out.println(<span class="string">&quot;u:&quot;</span> + u); <span class="comment">// 错误信息：java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span></span><br><span class="line">        &#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="keyword">return</span> <span class="number">233</span>;<span class="comment">// 可以获取到错误的返回结果</span></span><br><span class="line">        &#125;).get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可能浪费空间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data1 =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data2 =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data3 =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data4 =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Hungry HUNGRY = <span class="keyword">new</span> Hungry();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HUNGRY;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> liuqi = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (liuqi==<span class="keyword">false</span>)&#123;</span><br><span class="line">                liuqi=<span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不要使用反射破坏异常&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span>  <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检查锁 DCL懒汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lazyMan=<span class="keyword">new</span> LazyMan(); <span class="comment">//不是一个原子操作</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * new分为3步</span></span><br><span class="line"><span class="comment">                     * 1.分配内存空间</span></span><br><span class="line"><span class="comment">                     * 2.执行构造方法，初始化</span></span><br><span class="line"><span class="comment">                     * 3.把这个对象指向这个空间</span></span><br><span class="line"><span class="comment">                     * 可能重排序</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Field liuqi = LazyMan.class.getDeclaredField(<span class="string">&quot;liuqi&quot;</span>);</span><br><span class="line">        liuqi.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        LazyMan instance = declaredConstructor.newInstance();</span><br><span class="line">        liuqi.set(instance,<span class="keyword">false</span>);</span><br><span class="line">        LazyMan instance2 = declaredConstructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Holder</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.HOLDER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> Holder HOLDER = <span class="keyword">new</span> Holder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本身也是一个class类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span>  <span class="title">EnumSingle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumSingle</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSingle <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EnumSingle instance1 = EnumSingle.INSTANCE;</span><br><span class="line">        Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        EnumSingle instance2 = declaredConstructor.newInstance(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// NoSuchMethodException: com.kuang.single.EnumSingle.&lt;init&gt;()</span></span><br><span class="line">        System.out.println(instance1);</span><br><span class="line">        System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/%E5%8F%8D%E7%BC%96%E8%AF%91%E6%9E%9A%E4%B8%BE.png" alt="反编译枚举"></p><h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常在业务操作，这里面比较的都是一个个对象</span></span><br><span class="line">    <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CAS  compareAndSet : 比较并交换！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp(); <span class="comment">// 获得版本号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a1=&gt;&quot;</span>+stamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;a2=&gt;&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;a3=&gt;&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;a&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乐观锁的原理相同！</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp(); <span class="comment">// 获得版本号</span></span><br><span class="line">            System.out.println(<span class="string">&quot;b1=&gt;&quot;</span>+stamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="number">1</span>, <span class="number">6</span>,</span><br><span class="line">                    stamp, stamp + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;b2=&gt;&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;b&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br><strong>Integer 使用了对象缓存机制，默认范围是 -128 ~ 127 ，推荐使用静态工厂方法 valueOf 获取对象实例，而不是 new，因为 valueOf 使用缓存，而 new 一定会创建新的对象分配新的内存空间；</strong></p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/Integer.png" alt="Integer"></p><h2 id="锁的理解"><a href="#锁的理解" class="headerlink" title="锁的理解"></a>锁的理解</h2><h4 id="1-公平锁，非公平锁"><a href="#1-公平锁，非公平锁" class="headerlink" title="1.公平锁，非公平锁"></a>1.公平锁，非公平锁</h4><p>公平锁： 非常公平， 不能够插队，必须先来后到！</p><p>非公平锁：非常不公平，可以插队 （默认都是非公平）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-可重入锁"><a href="#2-可重入锁" class="headerlink" title="2.可重入锁"></a>2.可重入锁</h4><p>递归锁</p><h5 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            phone.sms();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;sms&quot;</span>);</span><br><span class="line">        call(); <span class="comment">// 这里也有锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-自旋锁"><a href="#3-自旋锁" class="headerlink" title="3.自旋锁"></a>3.自旋锁</h4><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/spinlock.png" alt="spinlock"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinlockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&gt;mylock&quot;</span>);</span><br><span class="line">        <span class="comment">//自旋锁</span></span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>,thread))&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myUnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;==&gt;mylock&quot;</span>);</span><br><span class="line">        atomicReference.compareAndSet(thread,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h4><p>1、使用 jps -l 定位进程号</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/%E5%AE%9A%E4%BD%8D%E8%BF%9B%E7%A8%8B%E5%8F%B7.png" alt="定位进程号"></p><p>2、使用 jstack 进程号 找到死锁问题</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(4)/%E6%8E%92%E6%9F%A5%E6%AD%BB%E9%94%81.png" alt="排查死锁"></p><p>排查问题</p><p>1.日志</p><p>2.堆栈信息</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程（3）</title>
      <link href="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(3)/"/>
      <url>/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(3)/</url>
      
        <content type="html"><![CDATA[<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h4 id="reentrantlock"><a href="#reentrantlock" class="headerlink" title="reentrantlock"></a>reentrantlock</h4><p>使用reentrantlock可以完成sync的功能</p><p>CAS锁</p><p>需要注意的是，必须要必须要必须要<strong>手动释放锁</strong>（重要的事情说三遍）</p><p>使用syn锁定的话如果遇到异常，jvm会自动释放锁，但是lock必须手动释放锁，因此经常在finally中进行锁的释放</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T02_ReentrantLock2</span> </span>&#123;</span><br><span class="line">   Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         lock.lock(); <span class="comment">//synchronized(this)</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(i);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         lock.lock();</span><br><span class="line">         System.out.println(<span class="string">&quot;m2 ...&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      T02_ReentrantLock2 rl = <span class="keyword">new</span> T02_ReentrantLock2();</span><br><span class="line">      <span class="keyword">new</span> Thread(rl::m1).start();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">new</span> Thread(rl::m2).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用tryLock进行尝试锁定，不管锁定与否，方法都将继续执行</p><p>可以根据tryLock的返回值来判定是否锁定</p><p> 也可以指定tryLock的时间，由于tryLock(time)抛出异常，所以要注意unclock的处理，必须放到finally中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">locked = lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">System.out.println(<span class="string">&quot;m2 ...&quot;</span> + locked);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(locked) lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用ReentrantLock还可以调用lockInterruptibly方法，可以对线程interrupt方法做出响应，</p><p> 在一个线程等待锁的过程中，<strong>可以被打断</strong></p><p>打断了之前加的所</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//lock.lock();</span></span><br><span class="line">      lock.lockInterruptibly(); <span class="comment">//可以对interrupt()方法做出响应</span></span><br><span class="line">      System.out.println(<span class="string">&quot;t2 start&quot;</span>);</span><br><span class="line">      TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;t2 end&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;interrupted!&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock还可以指定为公平锁</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock=<span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>       LQ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateDate</span>   2020/7/5 18:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>      1.0</span></span><br><span class="line"><span class="comment"> * 两个线程，一个对变量加+1，一个对变量-1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.线程操作资源</span></span><br><span class="line"><span class="comment"> * 2.判断/干活/通知</span></span><br><span class="line"><span class="comment"> * 3.防止虚假唤醒</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * wait要用while 需要重新判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aircondtion</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//干活</span></span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+number);</span><br><span class="line">        <span class="comment">//通知</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//干活</span></span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+number);</span><br><span class="line">        <span class="comment">//通知</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aircondtion2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">while</span> (number == <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干活</span></span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+number);</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumerDemo04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Aircondtion aircondtion = <span class="keyword">new</span> Aircondtion();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    aircondtion.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    aircondtion.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    aircondtion.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    aircondtion.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="synchronized与Lock的区别"><a href="#synchronized与Lock的区别" class="headerlink" title="synchronized与Lock的区别"></a>synchronized与Lock的区别</h4><p>两者区别：<br>1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；<br>2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；<br>3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；<br>4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；<br>5.synchronized的锁<strong>可重入、不可中断、非公平</strong>，而Lock锁<strong>可重入、可判断、可公平</strong>（两者皆可）<br>6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</p><h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>精准的通知和唤醒线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareData</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;s</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.判断</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.干活</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">15</span>;i++)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.通知</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ShareData shareData = <span class="keyword">new</span> ShareData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                shareData.print5();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                shareData.print10();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                shareData.print15();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h4><p>和runable</p><p>1、可以有返回值</p><p>2、可以抛出异常</p><p>3、方法不同，run()/ call()</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(3)/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(3)%5CCallable%E5%AE%9E%E7%8E%B0.png" alt="Callable实现"></p><p>FutureTask是一个Runnable的实现类</p><p>他的构造方法可以和Callable有关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****come in call method &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyThread2());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;A&quot;</span>).start(); <span class="comment">// 结果会被缓存，效率高</span></span><br><span class="line">        Integer o = (Integer) futureTask.get();<span class="comment">//这个get 方法可能会产生阻塞！把他放到 最后</span></span><br><span class="line">        <span class="comment">// 或者使用异步通信来处理！</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>有缓存</li><li>会阻塞</li></ol><h2 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AQS是Doug Lea大师为JDK编写的一套基于API层面的抽象队列同步器.</span><br><span class="line">AbstractQueuedSynchronizer,抽象队列同步器.</span><br><span class="line">Lock,CountDownLatch等等这些并发工具都是基于AQS来实现的。</span><br><span class="line">由此可以看出Doug Lea大师的功力已经臻至化境</span><br></pre></td></tr></table></figure><h4 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h4><p><strong>AQS的核心思想是如果被请求的资源空闲，那么就将当前请求资源的线程设置为有效的工作线程;<br>如果请求的资源被其他线程所占有， 那么就使用CLH线程（FIFO）阻塞队列来提供阻塞线程并唤线程分配资源的机制。</strong></p><p>CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。</p><p><strong>在CLH队列中，每个请求资源的线程都会被封装成队列中的一个节点。</strong></p><p><strong>在AQS内部有一个int类型的state表示线程同步状态，<br>当线程lock获取到锁后，该state计数就加1,unlock就减1，<br>这就是为什么解锁次数要对应加锁次数的原因。</strong></p><p><strong>AQS主要实现技术为:CLH队列(Craig,Landin and Hagersten)，<br>自旋CAS，park(阻塞线程)以及unparkSuccessor(唤醒阻塞队列中的后继线程)。</strong></p><blockquote><p>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p></blockquote><h4 id="AQS的两种共享资源的访问方式"><a href="#AQS的两种共享资源的访问方式" class="headerlink" title="AQS的两种共享资源的访问方式"></a>AQS的两种共享资源的访问方式</h4><blockquote><p>AQS定义了两种共享资源方式.</p></blockquote><ol><li>独占式(Exclusive): <strong>同一时间只有一个线程可以访问共享资源,也就是独占锁。</strong><br>如:Synchronized,ReentrantLock。<br><strong>对于独占式锁的实现,在AQS中对应tryAcquire获取锁和tryRelease释放锁。</strong></li></ol><ul><li>共享式(Share): <strong>同一时间允许多个线程同时访问共享资源,也就是共享锁。</strong><br>CountDownLatch,Semaphore,ReentrantReadWriteLock的ReadLock都是共享锁。<br><strong>对于共享式锁的实现,在AQS中对应tryAcquireShare获取锁和tryReleaseShare释放锁。</strong></li></ul><h4 id="lock-tryLock和lockInterruptibly区别"><a href="#lock-tryLock和lockInterruptibly区别" class="headerlink" title="lock,tryLock和lockInterruptibly区别"></a>lock,tryLock和lockInterruptibly区别</h4><p><strong>PS: AQS中的锁计数指的是 state 变量。</strong></p><ul><li><p>lock: 如果线程获取到了锁或线程已经拥有了锁就更改锁计数，<br>否则线程就加入阻塞队列并一直CAS自旋获取。</p></li><li><p>tryLock: 线程尝试获取锁，如果线程获取到了锁或线程已经拥有了锁就更改锁计数，否则返回false。</p></li><li><p>lockInterruptibly: 如果线程在获取锁之前被设置了中断状态，那么当线程获取锁时就会响应中断状态，<br>抛出InterruptedException异常。如果获取不到就加入阻塞队列并自旋获取，并且阻塞自旋期间还会响应中断，<br>也就是说在阻塞自旋期间可能抛出InterruptedException异常。<br><strong>所以lockInterruptibly优先响应中断，而不是优先获取锁。</strong><br>如果线程获取到了锁或线程已经拥有了锁才更改锁计数。</p></li></ul><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>倒计时 不一定在一个线程只减一下，可以多下</p><blockquote><p>CountDownLatch允许count个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p></blockquote><p>CountDownLatch是共享锁的一种实现,<strong>它默认构造AQS的state为count。<br>当线程使用countDown方法时,其实使用了tryReleaseShared方法以CAS的操作来减少state,<br>直至state为0就代表所有的线程都调用了countDown方法。</strong><br>假如某线程A调用await方法时，如果state不为0，就代表还有线程未执行countDown方法，<br>那么就把线程A放入阻塞队列Park，并自旋CAS判断state == 0。<br>直至最后一个线程调用了countDown，使得state == 0，<br>于是阻塞的线程判断成功，并被唤醒，就继续往下执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usingCountDownLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">100</span>];</span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(threads.length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;threads.length; i++) &#123;</span><br><span class="line">        threads[i] = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++) result += j;</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">        threads[i].start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;end latch&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>栅栏 达到一定条件栅栏开放  </p><p>条件 动作 限流</p><p>CycliBarrier的功能与CountDownLatch相似，但是<strong>CountDownLatch的实现是基于AQS的，<br>而CycliBarrier是基于ReentrantLock(ReentrantLock也属于AQS同步器)和Condition的。</strong></p><p>CountDownLatch虽然可以令多个线程阻塞在同一代码处，但只能await一次就不能使用了。<br>而CycliBarrier有Generation代的概念，一个代，就代表CycliBarrier的一个循环，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //CyclicBarrier barrier = new CyclicBarrier(20);</span><br><span class="line"></span><br><span class="line">    CyclicBarrier barrier = new CyclicBarrier(20, () -&gt; System.out.println(&quot;满人&quot;));</span><br><span class="line">    for(int i=0; i&lt;100; i++) &#123;</span><br><span class="line"></span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    barrier.await();</span><br><span class="line"></span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; catch (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h4><p>让线程阶段性的同步执行 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MarriagePhaser</span> <span class="keyword">extends</span> <span class="title">Phaser</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (phase) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;所有人到齐了！&quot;</span> + registeredParties);</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;所有人吃完了！&quot;</span> + registeredParties);</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;所有人离开了！&quot;</span> + registeredParties);</span><br><span class="line">                System.out.println();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;婚礼结束！新郎新娘抱抱！&quot;</span> + registeredParties);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">phaser.bulkRegister(<span class="number">7</span>);<span class="comment">//注册线程数</span></span><br><span class="line"> phaser.arriveAndDeregister();<span class="comment">//结束</span></span><br><span class="line">phaser.arriveAndAwaitAdvance();<span class="comment">//到达</span></span><br></pre></td></tr></table></figure><h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><p>读写锁 ：共享锁、排他锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T10_TestReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">static</span> Lock readLock = readWriteLock.readLock();</span><br><span class="line">    <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Lock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;read over!&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟读取操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Lock lock, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            value = v;</span><br><span class="line">            System.out.println(<span class="string">&quot;write over!&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟写操作</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Runnable readR = ()-&gt; read(lock);</span></span><br><span class="line">        Runnable readR = ()-&gt; read(readLock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Runnable writeR = ()-&gt;write(lock, new Random().nextInt());</span></span><br><span class="line">        Runnable writeR = ()-&gt;write(writeLock, <span class="keyword">new</span> Random().nextInt());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">18</span>; i++) <span class="keyword">new</span> Thread(readR).start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) <span class="keyword">new</span> Thread(writeR).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量  公平锁</p><blockquote><p>Semaphore允许一次性最多(不是同时)permits个线程执行任务。</p></blockquote><p>Semaphore与CountDownLatch一样，也是共享锁的一种实现。<br><strong>它默认构造AQS的state为permits。<br>当执行任务的线程数量超出permits,那么多余的线程将会被放入阻塞队列Park,并自旋判断state是否大于0。<br>只有当state大于0的时候，阻塞的线程才有机会继续执行,此时先前执行任务的线程继续执行release方法，<br>release方法使得state的变量会加1，那么自旋的线程便会判断成功。</strong></p><p>如此，<strong>每次只有不超过permits个的线程能自旋成功，便限制了执行任务线程的数量。</strong><br>所以这也是我为什么说它可能不是permits个线程同时执行，<br>因为只要state&gt;0,线程就有机会执行.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T11_TestSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Semaphore s = new Semaphore(2);</span></span><br><span class="line">        Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//允许一个线程同时执行</span></span><br><span class="line">        <span class="comment">//Semaphore s = new Semaphore(1);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;T1 running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;T1 running...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                s.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;T2 running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;T2 running...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                s.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程（2）</title>
      <link href="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)/"/>
      <url>/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>是可重入锁</p><p>synchronized是jdk提供的jvm层面的同步机制。<br><strong>它解决的是多线程之间访问共享资源的同步问题,它保证了<br>在被它修饰的方法或代码块同一时间只有一个线程执行。</strong></p><p><strong>sync(Object) 不能实验String常量 Integer Long</strong></p><span id="more"></span><p>java6之前的synchronized属于<strong>重量锁</strong>,性能较差,<br>它是基于操作系统的Mutex Lock互斥量实现的。</p><p><strong>因为java线程是映射到操作系统的线程之上的,<br>所以暂停或唤醒线程都需要Java程序从用户态转换为内核态,这段转换时间消耗较长。</strong></p><blockquote><p>java6之后jvm团队对synchronized做出了非常大的优化。</p></blockquote><h4 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h4><p>先看我编写的一段测试代码:</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%861.png" alt="synchronized底层原理1"></p><p>使用 javap -c -v -l 指令反编译 class文件后的 <strong>字节码指令</strong> 如下</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%862.png" alt="synchronized底层原理2"></p><p>可以清楚的看到,在进入synchronized的时候，底层字节码编译出来的指令为<br><strong>monitorenter</strong>,在执行完同步代码块后又有一个<strong>monitorexit</strong>指令.</p><p>想了解synchronized究竟是如何实现的,可以直接进入openjdk:src/share/vm/runtime 目录,<br>这个目录存放的是hotspot虚拟机在运行时所需的代码。</p><p>可以直接锁定其中的 objectMonitor.cpp源文件和objectMonitor.hpp头文件.<br>看到这2个文件，相信各位同学应该就知道，这个就是synchronized锁对象的monitor，它也是<br>一个对象,不过它是一个c++对象(见:objectMonitor.hpp头文件):</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%863.png" alt="synchronized底层原理3"> </p><p><strong>其实真正的锁应该是这个monitor cpp对象,synchronized锁的那个java对象起到的只是关联monitor的作用,<br>只不过我们身在java层面，无法感知到jvm层面monitor的作用，所以才称synchronized的java锁对象为锁。</strong></p><p>以下是monitorenter指令执行过程(见 InterpreterRuntime.cpp):</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%864.png" alt="synchronized底层原理4"></p><p>这里做一个总结吧,这个总结可能不太准确，但大致是这样的:<br><strong>每次执行monitorenter指令的时候,是将当前synchronized锁对象<br>关联的</strong>monitor<strong>的_recursions加1,<br>执行monitorexit指令的时候,将当前object对象关联的</strong>monitor<strong>的_recursions减1,<br>当_recursions为0的时候，就说明线程不再持有锁对象。</strong></p><p><strong>如果熟悉AQS原理的同学就知道在AQS内部，<br>有一个被volatile修饰state变量，<br>这个state变量就是AQS的核心，<br>state变量的作用类比到此处就是monitor计数器的作用。</strong></p><p>sync(Object) 系统中记录这个ID （偏向锁）</p><p>如果线程征用升级为自旋锁，10次以后升级为重量级锁 进入OS的等待队列</p><p>执行时间短 线程少 自旋</p><p>时间长 线程多 OS系统</p><p><strong>锁的升级 ：偏向，自旋，重量</strong></p><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入就是说某个线程已经获得某个锁，可以再次获取锁而不会出现死锁 </p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnReentrant</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        inner();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="父子类同时锁"><a href="#父子类同时锁" class="headerlink" title="父子类同时锁"></a>父子类同时锁</h4><p>子类的同步方法上调用父类的同步方法，锁的对象还是子类this</p><h4 id="加锁时抛出异常"><a href="#加锁时抛出异常" class="headerlink" title="加锁时抛出异常"></a>加锁时抛出异常</h4><p>加锁时抛出异常会让锁释放，让其他想获得锁的对象获得</p><h4 id="synchronized-使用方法"><a href="#synchronized-使用方法" class="headerlink" title="synchronized 使用方法"></a>synchronized 使用方法</h4><ol><li><p>修饰静态方法: 修饰静态方法是给类加锁,会作用于所有对象,因为静态方法属于类,<br>而不属于对象,不管有多少个对象,static方法都是共享的。</p></li><li><p>修饰实例方法: 修饰实例方法是给对象加锁,会作用于当前类的实例对象。</p></li><li><p>修饰代码块: 修饰代码块,根据代码块给定的对象加锁,线程想要进入代码块,只能获取指定的对象的锁。</p></li></ol><h4 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h4><ul><li><p>Synchronized是基于JVM层面的同步机制;而ReentrantLock是基于Java API层面提供的同步机制。</p></li><li><p>Synchronized和Reentrantlock都属于<strong>可重入锁</strong>。</p></li><li><p>ReentrantLock提供了比Synchronized更高级的功能:</p><ul><li><p>公平锁</p></li><li><p>更方便的线程间的通信(Condition)</p></li><li><p>等待可中断(在线程等待获取锁的时候可以被中断) </p></li></ul></li></ul><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁对共享的数据很乐观，认为不会发生线程安全的问题，从而不给数据加锁。<br>乐观锁适用于读多写少的环境。常见的例子就是mysql的更新使用version控制。</p><p><strong>CAS属于乐观锁。</strong></p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁对共享的数据很悲观，认为无论什么时候都有可能发生线程安全的问题，<br>所以在每次读写数据的时候都会加锁。</p><p><strong>Synchronized属于悲观锁。</strong></p><h4 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4><p>锁一次只能被一个线程占有使用。</p><p>Synchronized和ReetrantLock都是独占锁。</p><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><p>锁可以被多个线程持有。</p><p>对于ReentrantReadWriteLock而言,它的读锁是共享锁,写锁是独占锁。</p><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁指根据线程在<strong>队列</strong>中的<strong>优先级</strong>获取锁,比如线程优先加入阻塞队列,那么线程就优先获取锁。</p><h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非公平锁指在获取锁的时候,每个线程都会去争抢,并且都有机会获取到锁,无关线程的优先级。</p><h4 id="可重入锁-递归锁"><a href="#可重入锁-递归锁" class="headerlink" title="可重入锁(递归锁)"></a>可重入锁(递归锁)</h4><p>一个线程获取到锁后,如果继续遇到被相同锁修饰的资源,那么可以继续获取该锁。</p><p>Synchronized和Reentrantlock都是可重入锁。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnReentrant</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        inner();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在线程获取偏向锁的时候,<br>jvm会判断锁对象MarkWord里偏向线程的ID是否为当前线程ID。</p><p>如果是,则说明当前锁对象处于偏向状态。</p><p>如果不是,则jvm尝试CAS把对象的MarkWord的偏向线程ID设置为当前线程ID,</p><p>如果设置成功,那么对象偏向当前线程，并将当对象的锁标志位改为01。</p><p>如果设置失败，则说明多线程竞争，将撤销偏向锁，升级为轻量级锁。</p><p><strong>偏向锁适用于单线程无锁竞争环境(单线程环境)。</strong></p><p>hotspot偏向锁实现(faster_enter):<br><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)/%E5%81%8F%E5%90%91%E9%94%81%E5%AE%9E%E7%8E%B0.png" alt="偏向锁实现"></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>在线程获取对象锁时，jvm首先会判断对象是否为无锁状态(无锁状态标志位为01)。</p><p>如果对象是无锁状态，那么将在线程的栈帧中开辟一块空间用于存储对象的MarkWord，<br>然后将对象的MarkWord复制到栈帧空间去，并使用CAS更新对象的MarkWord为指向<br>线程栈帧的指针。</p><p>如果更新成功，那么当前线程获取锁成功，并修改对象的MarkWord标志位<br>为 00 。</p><p>如果更新失败，那么jvm会判断对象的MarkWord是否已经指向线程的栈帧。</p><p>如果已经指向，那么线程直接执行同步代码。否则，说明多个线程竞争，将inflate为重量级锁。</p><p><strong>轻量级锁适用于多线程无锁竞争环境(多线程轮流执行,并不会发生冲突)。</strong></p><p>hotspot轻量级锁实现(slow_enter):<br><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%AE%9E%E7%8E%B0.png" alt="轻量级锁实现">   </p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>在争夺锁的过程中，线程不会停止获取锁，而是通过CAS不断的判断线程是否符合获取锁的条件。</p><p><strong>AQS获取锁的核心就是CAS。</strong></p><h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>自旋锁意味着线程会不断的消耗cpu资源，短时间还行，长时间就意味着而资源的浪费。<br>所以自适应自旋锁会有一个自旋的生命周期,过了这个生命周期,线程将不再自旋。</p><p>网上有文章说这个生命周期依据前一个线程的自旋时间来决定，但是我暂且没有找到相关资料，不敢妄自揣测。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p><strong>锁消除属于Java编译器对程序的一种优化机制。</strong><br>锁消除是指当JVM的JIT编译器检测出一些已经加锁的代码不可能出现共享的数据存在竞争的问题，<br>会消除这样的锁。<strong>锁消除的依据来源于逃逸分析算法。</strong><br>如果判断到一段代码，在堆上的数据不会逃逸出去被其他线程访问到，<br>那么就把它们当做栈上的数据，为线程私有的，自然无需同步加锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//每次线程进入此方法，创建的都是不同的StringBuffer临时对象,</span><br><span class="line">//也就是说 StringBuffer 临时对象不会逃出方法t,作用于外部,</span><br><span class="line">//所以根本不存在线程之间的竞争，那么JIT在编译时就会消除append方法的锁</span><br><span class="line">public String t(String s1, String s2,String s3)</span><br><span class="line">&#123;</span><br><span class="line">    return new StringBuffer().append(s1).append(s2)</span><br><span class="line">                .append(s3).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>当虚拟机检测出一系列连续的操作都对同一个连续加锁，<br>那么它会把加锁的返回扩大至整个操作的序列的外部，保证只加锁一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public String t()</span><br><span class="line">&#123; </span><br><span class="line">    StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">    for (int i = 0 ; i &lt; 100 ; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        //append方法执行一百次,难道加100次锁?</span><br><span class="line">       stringBuffer.append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return stringBuffer.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//t方法经过优化后可能如下:</span><br><span class="line">public String t()</span><br><span class="line">&#123; </span><br><span class="line">    StringBuffer stringBuffer = new StringBuffer();</span><br><span class="line">    //把synchronized方法提升到for循环面，这样就避免了每次</span><br><span class="line">    //append方法的同步</span><br><span class="line">    synchronized (stringBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">       for (int i = 0 ; i &lt; 100 ; ++i)</span><br><span class="line">       &#123;</span><br><span class="line">           stringBuffer.append(i);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stringBuffer.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p><strong>死锁是指多个进程在执行过程中,循环等待彼此占有的资源而导致程序的无限期的阻塞的情况。</strong></p><p>产生死锁的条件:</p><ol><li>互斥条件: 一个资源在一段时间内只能被一个进程所持有。</li><li>不可抢占条件: 进程所持有的资源只能由进程自己主动释放,其他资源的申请者不能向进程持有者抢夺资源。</li><li>占有且申请条件: 进程已经持有一个资源后,又申请其他资源,但是其他资源已被其他线程所占有。</li><li>循环等待条件: 在条件3之上,进程1有进程2需要申请的资源,进程2有进程1需要申请的资源。那么这2个线程<br> 不停等待彼此持有的资源,又不能释放已拥有的资源,陷入循环等待。</li></ol><p>死锁:</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)/%E6%AD%BB%E9%94%81.png" alt="死锁"></p><h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁?"></a>如何避免死锁?</h4><p>只要打破死锁产生的4个条件之一就行,但是真正能够被打破的条件只有第3和第4个条件。<br>因为第1和第2个条件都是锁的必要条件。</p><p>所以有如下解决死锁的方案:</p><ul><li>可以打破第3个条件: <strong>实现资源的有序分配。</strong> </li><li>可以打破第4个条件: <strong>设置等待超时时间。</strong><h4 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h4></li></ul><p>锁的细化 </p><p>锁的粗化</p><p>用对象作为锁的时候 应该加上final 保证锁的对象不变</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile是JVM提供的轻量级的线程同步机制。它可以保证内存的可见性，禁止指令重排序。<br>但是volatile，并<strong>不能保证数据的原子性</strong>，所以它不合适作为线程同步的工具。</p><h4 id="volatile保证内存的可见性"><a href="#volatile保证内存的可见性" class="headerlink" title="volatile保证内存的可见性"></a>volatile保证内存的可见性</h4><p>可见性是指一个线程的对于共享数据的修改对其他线程是可见的。<br>jvm的内存模型是: <strong>线程总是从主内存读取变量到工作内存，然后在工作内存中进行修改，<br>在修改完变量后，才把变量同步到主内存中。</strong><br>如果多个线程同时读取了一个变量到各自的内存中，其中一个线程对变量进行了修改，并同步回了主内存，<br>但其它线程仍然使用的是原来的旧值，这就造成了数据的不一致。</p><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="Java内存模型"></p><p>解决这个问题的办法就是给变量加上volatile关键字修饰。<br>volatile使得被它修饰的变量在被线程修改后，那么线程就需要把修改后的变量重新同步到主内存，<br>且其他线程每次使用这个变量，都需要从主内存读取。</p><p>MESI</p><p>缓存一致性协议</p><h4 id="volatile禁止指令重排序"><a href="#volatile禁止指令重排序" class="headerlink" title="volatile禁止指令重排序"></a>volatile禁止指令重排序</h4><p>指令重排序是编译器和cpu为了程序的高效运行的一种优化手段,<br><strong>指令重排序只能保证程序执行的结果是正确的，但是无法保证程序指令运行的顺序是否与代码的顺序一致,<br>volatile就禁止了这种重排序。</strong></p><p>比如: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. int a = 1;</span><br><span class="line">2. int b = 3;</span><br><span class="line">3. int c = a + b;</span><br></pre></td></tr></table></figure><p>上面的代码在编译后,指令执行的顺序可能有:<br>1,2,3和2,1,3<br>这样程序实际执行的顺序可能与代码的顺序不符,但并不会影响程序最终的结果。</p><h4 id="volatile如何禁止指令重排序的"><a href="#volatile如何禁止指令重排序的" class="headerlink" title="volatile如何禁止指令重排序的?"></a>volatile如何禁止指令重排序的?</h4><p><strong>volatile通过提供内存屏障来防止指令重排序。<br>java内存模型会在每个volatile写操作前后都会插入store指令，将工作内存中的变量同步回主内存。<br>在每个volatile读操作前后都会插入load指令，从主内存中读取变量。</strong></p><h5 id="单例模式双重检查要加volatile吗"><a href="#单例模式双重检查要加volatile吗" class="headerlink" title="单例模式双重检查要加volatile吗"></a>单例模式双重检查要加volatile吗</h5><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mgr</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Mgr INSTANCE;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Mgr</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mgr <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Mgr.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Mgr();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须要加volatile </p><p>new 一个对象 的过程</p><ul><li><p>申请一块内存，变量设默认值</p></li><li><p>给变量赋值</p></li><li><p>把变量赋值给栈中的instance</p><p>指令重排序会把第二步和第三步换位</p></li></ul><p>会造成变量值 的使用问题</p><h4 id="volatile不保证原子性"><a href="#volatile不保证原子性" class="headerlink" title="volatile不保证原子性"></a>volatile不保证原子性</h4><blockquote><p>比如: i++</p></blockquote><p>如果是多线程环境下，一个线程读取到i的值到工作内存，然后对i做出自增操作，<br>然后写回主内存，其它内存才知道i的值被修改了，这个<strong>过程本身就不是原子</strong>的。<br>所以不能拿volatile来带替synchronized,如果是多线程环境，仍然需要使用synchronized保证线程同步。</p><p>loadfence原语指令</p><p>storefence原语指令</p><h3 id="CAS-无锁优化-自旋-乐观"><a href="#CAS-无锁优化-自旋-乐观" class="headerlink" title="CAS(无锁优化 自旋 乐观)"></a>CAS(无锁优化 自旋 乐观)</h3><p>CAS: Compare And Swap 比较成功并交换。<br>CAS体现的是一种乐观锁的机制。<br><strong>CAS涉及到3个元素: 指定的内存地址,期盼值和目标值。</strong><br><strong>将指定内存地址的值与期盼值相比较，如果比较成功就将内存地址的值修改为目标值。</strong></p><h4 id="CAS在JAVA中的底层实现-Atomic原子类实现"><a href="#CAS在JAVA中的底层实现-Atomic原子类实现" class="headerlink" title="CAS在JAVA中的底层实现(Atomic原子类实现)"></a>CAS在JAVA中的底层实现(Atomic原子类实现)</h4><p>CAS在Java中的实现是 juc的atomic包下的Atomicxx原子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="comment">//反射操作，获取这个类的值在内存中分偏移地址</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入volatile保证内存的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//原子性由CAS保证。这个操作是一个原子操作，同一时刻只有一个线程可以执行。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">而这些Atomic原子类的核心是: &lt;Unsafe&gt;类</span><br><span class="line">Unsafe类是个final类，它的核心方法都是native的，里面的操作都是原子操作。</span><br><span class="line">因为Java无法像C/C++一样使用指针来操作内存,</span><br><span class="line">Unsafe类就解决了这个问题。 </span><br><span class="line">CAS的效率更高</span><br></pre></td></tr></table></figure><p>cpu原语操作</p><blockquote><p>拿incrementAndGet方法来说，<br>Unsafe首先调用getAndAddInt方法,<br>它会根据当前Atomic的value在内存中地址获取到当前对象的值,<br><strong>然后再重复此操作，把之前获得的值与第二遍获得的值进行比较，</strong><br><strong>如果成功，就把内存地址的值更新为新值，否则就do while循环.</strong></p><p>简单来说，就是如果要修改的值与内存中一样就对他进行改变。不一样就一直获取内存中的值。</p><p>cas(0,1){<br>while(如果当前m==0;m=1)<br>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">&gt;<span class="keyword">int</span> var5;</span><br><span class="line">&gt;<span class="keyword">do</span> &#123;</span><br><span class="line">  var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">   <span class="comment">//对象，参数的偏移地址，当前内存的值，要修改成为的值。</span></span><br><span class="line">&gt;&#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">return</span> var5;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img src="/2020/07/15/java%E5%9F%BA%E7%A1%80/java%E5%A4%9A%E7%BA%BF%E7%A8%8B(2)/unsafe.png" alt="unsafe"></p><p><strong>并且有个重要的细节就是,Atomic原子类内部的value值都是由volatile修饰的,<br>这就使得Atomic的value值是对其他线程可见的。</strong></p><h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><ul><li><p>循环时间开销大: 我在看源码的时候，发现Atomic的CAS操作并没有进行CAS失败的退出处理，<br>只是单纯的循环比较并交换，这就让我很担心它的性能问题，<br>如果长时间不成功，那会是很可怕的一件事请，至少cpu的负荷会很大。</p></li><li><p>只能保证一个共享变量的原子操作: Atomic原子类只能保证一个变量的原子操作，<br>如果是多数据的话，还是考虑用互斥锁来实现数据的同步吧</p></li><li><p>ABA问题: ABA问题是指如果一个线程进行CAS操作并成功了，却不代表这个过程就是没有问题的。</p></li></ul><blockquote><p>假设2个线程读取了同一份数据，线程1修改了这个值并把它改回了原值，并同步到主内存中，<br>另一个线程准备进行CAS操作,当它发现原值和期盼的值是一样的，那么CAS仍然成功。</p></blockquote><h4 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h4><p>一个线程线程要使用变量1<br>另一个线程把它变成2又变会1 加版本号</p><p>在juc的atomic包中提供了 AtomicStampedReference 类,<br>这个类较普通的原子类新增了一个<strong>stamp</strong>字段，它的作用相当于version。<br>每次修改这个引用的值，也都会修改stamp的值，<br>当发现stamp的值与期盼的stamp不一样，也会修改失败.<br>这就类似于以version实现乐观锁一样。             </p><ul><li>基础类型 无所谓</li><li>引用类型  指向已经改变         </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常在业务操作，这里面比较的都是一个个对象</span></span><br><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//后面的1就是时间戳</span></span><br></pre></td></tr></table></figure><h4 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h4><p>final 修饰 构造方法单例模式</p><p>等同于c c++的指针</p><ul><li>直接操作内存<ul><li>allocateMemory putXX freeMemory pageSize</li></ul></li><li>直接生成类的实例<ul><li>allocateInstance</li></ul></li><li>直接操作类或实例变量<ul><li>getInt</li><li>getObject</li><li>objectFieldOffset</li></ul></li><li>CAS相关操作<ul><li>weekCompareAndSetObject Int Long</li></ul></li></ul><h4 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h4><p>在线程多，循环次数多的情况下 比CAS好</p><p><code>LongAdder</code>类与<code>AtomicLong</code>类的区别在于高并发时前者将对单一变量的CAS操作分散为对数组<code>cells</code>中多个元素的CAS操作，取值时进行求和；而在并发较低时仅对<code>base</code>变量进行CAS操作，与<code>AtomicLong</code>类原理相同。</p><h4 id="synchronize和Atomic效率"><a href="#synchronize和Atomic效率" class="headerlink" title="synchronize和Atomic效率"></a>synchronize和Atomic效率</h4><p>当低并发时（小于150000），Atomic效率优于synchronized<br>当高并发时（大于150000），synchronized效率优于Atomic</p><p>总结:<br>synchronized ：重量级操作，基于悲观锁，可重入锁。<br>AtomicInteger：乐观 ，用CAS实现<br>当并发量大时，Atomic 出错概率会增大，不断校正错误更费时间<br><a href="https://blog.csdn.net/baidu_35773818/article/details/89604328">https://blog.csdn.net/baidu_35773818/article/details/89604328</a></p><h4 id="8锁"><a href="#8锁" class="headerlink" title="8锁"></a>8锁</h4><p>1 标准访问，先打印短信还是邮件<br>2 停4秒在短信方法内，先打印短信还是邮件<br>3 普通的hello方法，是先打短信还是hello<br>4 现在有两部手机，先打印短信还是邮件<br>5 两个静态同步方法，1部手机，先打印短信还是邮件<br>6 两个静态同步方法，2部手机，先打印短信还是邮件<br>7 1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件<br>8 1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件</p><p>运行答案：<br>1、短信<br>2、短信<br>3、Hello<br>4、邮件<br>5、短信<br>6、短信<br>7、邮件<br>8、邮件</p><p>A 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，<br>其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法<br>锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</p><p>加个普通方法后发现和同步锁无关<br>换成两个对象后，不是同一把锁了，情况立刻变化。</p><p>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。<br>具体表现为以下3种形式。</p><ul><li>对于普通同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前类的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象</li></ul><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</p><p>也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，<br>可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，<br>所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</p><p>所有的静态同步方法用的也是同一把锁——<strong>类对象本身</strong>，<br>这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。<br>但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，<br>而不管是同一个实例对象的静态同步方法之间，<br>还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>ThreadLocal为每个线程都提供了一份相同的变量的副本，<br>每个线程都可以修改这个副本，但不用担心与其他线程发生数据冲突，<br>实现了线程之间的数据隔离。</p><p>ThreadLocal的原理还得从Thread线程类说起，<br><strong>每个Thread类内部都有一个ThreadLocalMap，当使用ThreadLocal的get和remove操作的时候，<br>就是使用每个线程的ThreadLocalMap的get和remove。</strong></p><h4 id="ThreadLocal引发的内存泄露"><a href="#ThreadLocal引发的内存泄露" class="headerlink" title="ThreadLocal引发的内存泄露"></a>ThreadLocal引发的内存泄露</h4><p><strong>在ThreadLocalMap中，key是使用弱引用的ThreadLocal存储的。</strong><br>弱引用是只要垃圾回收器开始回收，无论内存是否充足，都会回收掉弱引用对象，如此一来，<br>当ThreadLocal被回收掉,那么ThreadLocalMap将可能出现Null Key 的 value。但是也不必太过担心，<br>因为设计者已经想到了这点，所以ThreadLocal会自动处理key 为 null的 value。</p><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><blockquote><p>http连接池，数据库连接池，线程池等都是利用了池化技术。<br>如果一个资源需要多次使用并且很昂贵，那么使用new创建的对象或资源，可能会带来较大的消耗。</p></blockquote><p>池化技术的好处在于</p><ol><li>方便资源的管理，无需显示的使用new创建。</li><li>降低了资源的消耗，在池子里的资源可以重复利用</li><li>提供了任务的响应速度，任务可以很快的被分配资源进行处理。</li></ol><h4 id="线程池构造参数"><a href="#线程池构造参数" class="headerlink" title="线程池构造参数"></a>线程池构造参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> new ThreadPoolExecutor</span><br><span class="line">(int corePoolSize,</span><br><span class="line"></span><br><span class="line"> int maximumPoolSize, </span><br><span class="line"></span><br><span class="line"> long keepAliveTime,</span><br><span class="line"></span><br><span class="line"> TimeUnit unit,</span><br><span class="line"></span><br><span class="line"> BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line"></span><br><span class="line"> ThreadFactory threadFactory,</span><br><span class="line"></span><br><span class="line"> RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><ol><li><p>corePoolSize: 线程池的核心线程数(常驻线程数),也就是线程池的最小线程数,这部分线程不会被回收.</p></li><li><p>maximumPoolSize: 线程池最大线程数,线程池中允许同时执行的最大线程数量</p></li><li><p>keepAliveTime: 当线程池中的线程数量超过corePoolSize，但此时没有任务执行，<br>那么空闲的线程会保持keepAliveTime才会被回收，corePoolSize的线程不会被回收。</p></li><li><p>unit: KeepAliveTime的时间单位</p></li><li><p>workQueue: 当线程池中的线程达到了corePoolSize的线程数量，<br>并仍然有新任务，那么新任务就会被放入workQueue。          </p></li><li><p>threadFactory: 创建工作线程的工厂,也就是如何创建线程的,一般采用默认的</p></li><li><p>handler: 拒绝策略，当线程池中的工作线程达到了最大数量，<br>并且阻塞队列也已经满了，那么拒绝策略会决定如何处理新的任务。ThreadPoolExecutor 提供了四种策略:</p><ul><li><p>AbortPolicy(是线程池的默认拒绝策略): 如果使用此拒绝策略，那么将对新的任务抛出RejectedExecutionException异常，来拒绝任务。</p></li><li><p>DiscardPolicy: 如果使用此策略，那么会拒绝执行新的任务，但不会抛出异常。</p></li><li><p>DiscardOldestPolicy: 如果使用此策略，那么不会拒绝新的任务，但会抛弃阻塞队列中等待最久的那个线程。     </p></li><li><p>CallerRunsPolicy: 如果使用此策略，不会拒绝新的任务，但会让调用者执行线程。<br>也就是说哪个线程发出的任务，哪个线程执行。</p></li></ul></li></ol><h4 id="阿里巴巴开发者手册不建议开发者使用Executors创建线程池"><a href="#阿里巴巴开发者手册不建议开发者使用Executors创建线程池" class="headerlink" title="阿里巴巴开发者手册不建议开发者使用Executors创建线程池"></a>阿里巴巴开发者手册不建议开发者使用Executors创建线程池</h4><p><strong>newFixedThreadPool和newSingleThreadPoolExecutor都是创建固定线程的线程池,<br>尽管它们的线程数是固定的，但是它们的阻塞队列的长度却是Integer.MAX_VALUE的,所以，<br>队列的任务很可能过多，导致OOM。</strong></p><p><strong>newCacheThreadPool和newScheduledThreadPool创建出来的线程池的线程数量却是Integer.MAX_VALUE的，<br>如果任务数量过多,也很可能发生OOM。</strong>          </p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC</title>
      <link href="/2020/07/12/java%E5%9F%BA%E7%A1%80/GC/"/>
      <url>/2020/07/12/java%E5%9F%BA%E7%A1%80/GC/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#gc">GC</a><ul><li><a href="#判断对象存活的方法">判断对象存活的方法</a><ul><li><a href="#引用计数法缺点">引用计数法缺点</a></li><li><a href="#什么是gc-root-">什么是GC Root ?</a></li></ul></li><li><a href="#垃圾回收算法">垃圾回收算法</a><ul><li><a href="#复制算法copying">复制算法(Copying)</a></li><li><a href="#标记-清除算法mark-sweep">标记-清除算法(Mark-Sweep)</a></li><li><a href="#标记-整理算法mark-compact">标记-整理算法(Mark-Compact)</a></li><li><a href="#分代收集算法">分代收集算法</a></li><li><a href="#内存分配与垃圾回收策略">内存分配与垃圾回收策略</a></li><li><a href="#一次gc的过程">一次GC的过程</a></li><li><a href="#动态年龄阈值">动态年龄阈值</a></li></ul></li><li><a href="#垃圾回收器">垃圾回收器</a><ul><li><a href="#serial串行收集器">Serial串行收集器</a></li><li><a href="#serial-old-串行收集器老年代版本">Serial Old 串行收集器(老年代版本)</a></li><li><a href="#parallel-scavenge-并行多线程收集器">Parallel Scavenge 并行多线程收集器</a></li><li><a href="#parallel-old-并行收集器老年代版本">Parallel Old 并行收集器(老年代版本)</a></li><li><a href="#parnew-多线程收集器">ParNew 多线程收集器</a></li><li><a href="#cms-并发标记清除收集器">CMS 并发标记清除收集器</a></li><li><a href="#cms收集器回收过程">CMS收集器回收过程</a></li><li><a href="#g1-收集器">G1 收集器</a></li><li><a href="#g1回收器的特点">G1回收器的特点</a></li><li><a href="#g1收集器回收过程">G1收集器回收过程</a></li></ul></li></ul></li></ul><span id="more"></span><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h3 id="判断对象存活的方法"><a href="#判断对象存活的方法" class="headerlink" title="判断对象存活的方法"></a>判断对象存活的方法</h3><p>在垃圾回收器对堆内存回收前，需要判断对象是否存活。</p><ul><li><p>引用计数算法: 给每个对象添加一个引用计数器,每当对象被引用,<br>对象的引用计数器就加1,当引用失效时,引用计数器就减1。<br>直到引用计数器为0,就代表对象不再被引用。</p></li><li><p>可达性算法: 通过GC ROOT的对象节点往下搜索,节点走过的路径被称为引用链。<br>如果一个对象不处于任何引用链,那么就可以判断此对象是不可达的。</p></li></ul><h4 id="引用计数法缺点"><a href="#引用计数法缺点" class="headerlink" title="引用计数法缺点"></a>引用计数法缺点</h4><p>引用计数的主要缺陷是很难解决<strong>循环引用</strong>的问题:<br>也就是当2个对象互相引用的时候,除了彼此,<br>没有其它对象再引用这2个对象,那么他们的引用计数都为1,就无法被回收。<br>jvm实现一般不采用这种方式          </p><h4 id="什么是GC-Root"><a href="#什么是GC-Root" class="headerlink" title="什么是GC Root ?"></a>什么是GC Root ?</h4><p>上面说通过GC Root对象搜索引用链,那么GC Root对象是什么对象,<br>或者说什么样的对象是GC Root对象。<br>可以作为GC Root对象的有: </p><ol><li>虚拟机栈和本地方法栈区中的引用对象(stack)</li><li>方法区中类的静态属性引用的对象(static)</li><li>方法区中的常量引用的对象(final)   </li></ol><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/GC/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png" alt="可达性算法">      </p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>常见的垃圾回收算法主要有以下4种:</p><ol><li>复制算法</li><li>标记-清除算法</li><li>标记-整理算法</li><li>分代收集算法</li></ol><h4 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h4><p>将堆内存分为2块大小相等的内存空间，<br>每次只使用其中的一块内存，另一块则空闲。<br>当其中一块内存使用完后，<br>就将仍然存活的对象复制到另一块空闲内存空间，再清理已使用的内存。</p><p><strong>复制算法的优点是不会产生连续的内存碎片，速度也很高效。<br>但是缺点更明显:1.每次只使用内存的一半，就代表可使用的内存减少了1/2，代价很高昂。2.如果全部存活，要全部复制一遍，对象的存活率必须低</strong></p><p><strong>复制算法一般用于新生代。<br>因为新生代的GC非常频繁，每次GC的对象较多，存活的对象较少。<br>所以采用复制算法效率更高，复制时只需要复制少量存活的对象。</strong></p><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/GC/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法">         </p><h4 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark-Sweep)"></a>标记-清除算法(Mark-Sweep)</h4><p>标记-清除算法分为2个步骤：标记和清除。</p><p>首先标记出所有可达(存活)的对象，在标记完成后，<br>统一回收所有未被标记(不可达)的对象。</p><p>标记-清除算法的缺点主要有2个:</p><ol><li><strong>标记和清除2个阶段的耗时都比较长，可以总结为效率较低。</strong></li><li><strong>对象在内存中的分布可能是不连续的，分散的，标记-清除后可能造成不连续的内存碎片。</strong><br>当内存碎片过多后，后续想要分配较大的对象时，无法找到足够大的内存碎片，<br>可能又需要触发GC。</li></ol><p><strong>标记-清除算法一般用于老年代。</strong><br>因为老年代中的对象存活率较高，几乎很少被回收，<br>所以标记-清除和标记-整理算法GC的时间不会太长，<br>GC的对象相比新生代更少。</p><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/GC/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="标记-清除算法"></p><h4 id="标记-整理算法-Mark-Compact"><a href="#标记-整理算法-Mark-Compact" class="headerlink" title="标记-整理算法(Mark-Compact)"></a>标记-整理算法(Mark-Compact)</h4><p>标记-整理算法是对标记-清除算法的一种改进。</p><p>标记-整理算法与标记-清除算法的在标记阶段是相同的，<br>都是首先标记出所有可达(存活)的对象。<br>但<strong>标记之后并不直接清理未被标记(不可达)的对象，<br>而是使被标记(存活)的对象向内存一端移动，然后清理掉这一端外的内存。</strong></p><p><strong>标记-整理算法的优点是:<br>几乎不会如标记-清除算法那样产生不连续的内存碎片。<br>但，所谓慢工出细活,标记-整理的效率是比标记-清除要低的。</strong>         </p><p><strong>标记-整理算法和标记-清除算法一样，一般用于老年代。</strong></p><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/GC/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="标记-整理算法">         </p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p><strong>分代收集算法并不是指某一种具体的垃圾收集算法，<br>而是将复制，标记-清除，标记-整理等算法合理运用到堆区的不同空间。</strong><br>比如新生代使用复制算法，老年代使用标记清除或标记整理算法。</p><p>现代的几乎所有的JVM都使用分代收集，毕竟每种算法都有优缺点，<br>结合它们的特点，对不同的环境采用不同的算法是非常明智的选择。</p><h4 id="内存分配与垃圾回收策略"><a href="#内存分配与垃圾回收策略" class="headerlink" title="内存分配与垃圾回收策略"></a>内存分配与垃圾回收策略</h4><ol><li>对象优先在eden区域被分配</li><li>大对象将直接进入老年代<br>(大对象是指需要大量连续的内存空间的对象，如长字符串，大数组等。)</li><li>长期存活的对象将进入老年代</li></ol><h4 id="一次GC的过程"><a href="#一次GC的过程" class="headerlink" title="一次GC的过程"></a>一次GC的过程</h4><p>对象优先在eden区被分配，当eden区内存不足时，<br>JVM发起Minor GC。Minor GC的范围包括eden和From Survivor:</p><p>首先JVM会根据可达性算法标记出所有存活的对象。</p><p>如果存活的对象中，有的对象的年龄已经达到晋升阈值<br>(阈值是动态计算的，可以通过-XX:MaxTenuringThreshold设置最大年龄阈值)，<br>那么将已经达到阈值的对象复制到老年代中。</p><p>如果To Survivor空间不足以存放剩余存活对象，<br>则直接将存活的对象提前复制到老年代。<br>如果老年代也没有足够的空间存放存活的对象，<br>那么将触发Full GC(GC整个堆，包括新生代和老年代)。</p><p>如果To Survivor可以存放存活的对象，<br>那么将对象复制到To Survivor空间，并清理eden和From Survivor。</p><p>此时From Survivor为空，<br>那么From Survivor就成为了下一次的To Survivor，<br>此时To Survivor存放着存活的对象，就成为了下一次的From Survivor。<br>这样From Survivor与To Survivor就是不断交替复制的使用。</p><p><strong>老年代的空间比新生代的空间要大，<br>所以老年代的Major GC要比Minor GC耗时更长。<br>根据垃圾回收器的不同，老年代的GC算法也不同。</strong></p><h4 id="动态年龄阈值"><a href="#动态年龄阈值" class="headerlink" title="动态年龄阈值"></a>动态年龄阈值</h4><p>JVM并不要求对象年龄一定要达到 MaxTenuringThreshold 才会<br>晋升到老年代，晋升的年龄阈值是动态计算的。￼￼￼￼￼<br>如果在Survivor中，某个相同年龄阶段的所有对象大小的总和<br>大于Survivor区域的一半，则大于等于这个年龄的所有对象<br>可以直接进入老年代，无需等到MaxTenuringThreshold。</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><strong>如果说垃圾回收算法是JVM对GC算法的方法论，那么垃圾回收器就是对GC算法的实现。</strong></p><p>垃圾回收器主要分为以下几种收集器:</p><ul><li><p>Serial收集器</p></li><li><p>Parallel Scanvel收集器</p></li><li><p>ParNew收集器</p></li><li><p>CMS收集器</p></li><li><p>G1收集器</p></li></ul><h4 id="Serial串行收集器"><a href="#Serial串行收集器" class="headerlink" title="Serial串行收集器"></a>Serial串行收集器</h4><p>Serial收集器为单线程环境设计,并只使用一个线程进行垃圾回收。<br>在回收时，会暂停用户线程,并不适用于并发环境。</p><p>Serial收集器在单线程环境中是很高效的,它没有多线程切换的消耗。     </p><p><strong>Serial收集器采用复制算法</strong></p><h4 id="Serial-Old-串行收集器-老年代版本"><a href="#Serial-Old-串行收集器-老年代版本" class="headerlink" title="Serial Old 串行收集器(老年代版本)"></a>Serial Old 串行收集器(老年代版本)</h4><p>它是 Serial收集器的老年代使用的GC收集器，同样是一个单线程的垃圾收集器。 </p><p><strong>Serial Old收集器采用的是标记-整理算法。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">/** 开启串行收集器使用 -XX:+UseSerialGC , </span><br><span class="line">  * 这样默认新生代使用 Serial 收集器,</span><br><span class="line">  * 老年代使用 Serial Old 收集器. </span><br><span class="line">  *</span><br><span class="line">  * 设置VM参数:</span><br><span class="line">  *</span><br><span class="line">  * -XX:+Xlogs:gc* 打印gc信息</span><br><span class="line">  * -XX:+PrintCommandLineFlags  打印java版本信息</span><br><span class="line">  * -XX:+UseSerialGC 使用串行GC</span><br><span class="line">  */                      </span><br><span class="line"></span><br><span class="line">//如果程序正常运行,日志会显示 :</span><br><span class="line">// 新生代的信息为:  def new generation.....</span><br><span class="line">// 老年代的信息为:  tenured generation.....</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Parallel-Scavenge-并行多线程收集器"><a href="#Parallel-Scavenge-并行多线程收集器" class="headerlink" title="Parallel Scavenge 并行多线程收集器"></a>Parallel Scavenge 并行多线程收集器</h4><p>Parallel Scavenge是并行收集器，它使用多个垃圾回收线程一起工作,<br>但是仍然会暂停用户线程。</p><p>Parallel Scavenge与其它垃圾回收器不同的是它<strong>更关注于达到可控制的吞吐量。</strong></p><p>吞吐量是CPU运行用户应用程序代码的时间与CPU总消耗的时间的比值:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量 = 应用程序代码运行时间 / (应用程序代码运行时间 + GC时间)</span><br></pre></td></tr></table></figure><p><strong>Parallel Scavenge收集器采用复制算法</strong></p><h4 id="Parallel-Old-并行收集器-老年代版本"><a href="#Parallel-Old-并行收集器-老年代版本" class="headerlink" title="Parallel Old 并行收集器(老年代版本)"></a>Parallel Old 并行收集器(老年代版本)</h4><p>它是 Parallel Scavenge 的老年代版本,同样是一个并行多线程的收集器。</p><p><strong>Parallel Old收集器采用标记-整理算法。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 设置 Parallel Scavenge 收集器的参数:</span><br><span class="line"> *</span><br><span class="line"> * -XX:+UseParallelGC</span><br><span class="line"> * </span><br><span class="line"> * ParallelGC老年代默认使用的 Parallel Old GC 回收器</span><br><span class="line"> * </span><br><span class="line"> * 并行收集器打印的新生代的信息为:</span><br><span class="line"> *  PSYoungGen ....</span><br><span class="line"> *  </span><br><span class="line"> *  老年代的信息为:</span><br><span class="line"> *  ParOldGen ....</span><br><span class="line"> * </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="ParNew-多线程收集器"><a href="#ParNew-多线程收集器" class="headerlink" title="ParNew 多线程收集器"></a>ParNew 多线程收集器</h4><p>它可以看做是多线程版的Serial收集器。<br>除了多线程外，ParNew收集器与Serial收集器几乎没啥区别。</p><p><strong>PS:目前只有Serial和ParNew能作为CMS收集器的新生代收集器。</strong></p><p><strong>ParNew收集器采用复制算法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * </span><br><span class="line">  * 设置ParNewGC回收器的参数为:</span><br><span class="line">  * -XX:+UseConcMarkSweepGC</span><br><span class="line">  * </span><br><span class="line">  */</span><br></pre></td></tr></table></figure><h4 id="CMS-并发标记清除收集器"><a href="#CMS-并发标记清除收集器" class="headerlink" title="CMS 并发标记清除收集器"></a>CMS 并发标记清除收集器</h4><p>Concurrent Mark Sweep,并发标记-清除垃圾回收器。<br>它是一款老年代的收集器，是<strong>以达到最短回收停顿时间目标的收集器。</strong></p><p><strong>见名知意,CMS收集器使用的是标记-清除算法。<br>CMS在垃圾回收过程中，用户线程可以同时工作，无需暂停。</strong></p><p><strong>因为CMS收集器采用的是标记-清除算法，所以回收时可能会产生不连续的内存碎片。</strong></p><p><strong>PS: CMS收集器在jdk14中被删除了。</strong></p><h4 id="CMS收集器回收过程"><a href="#CMS收集器回收过程" class="headerlink" title="CMS收集器回收过程"></a>CMS收集器回收过程</h4><ul><li><p>初始标记(Stop The World，此阶段会暂停用户线程): 只标记与GC ROOT直接关联的对象。</p></li><li><p>并发标记: 对第一个阶段已经标记的对象进行Tracing，标记所有可达的对象。</p></li><li><p>重新标记(Stop The World,此阶段会暂停用户线程): 在第二个阶段，由于用户程序的运行，<br>可能有些对象之间的引用关系受到了影响，所以需要对这部分对象进行重新标记调整。</p></li><li><p>并发清除: 清除所有未被标记的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 设置 CMS 收集器参数:</span><br><span class="line"> * -XX:+UseConcMarkSweepGC</span><br><span class="line"> *</span><br><span class="line"> * 使用ConcMarkSweepGC收集器后,它的新生代使用的是:</span><br><span class="line"> * ParNew收集器.</span><br><span class="line"> *</span><br><span class="line"> * 当ConcMarkSweepGC收集器出现异常时,会将CMS替换成Serial Old收集器</span><br><span class="line"> *</span><br><span class="line"> * CMS回收分为4个阶段:</span><br><span class="line"> *</span><br><span class="line"> * 初始标记:    (Stop the world 暂停用户线程)</span><br><span class="line"> * 标记与GC Root直接可达的对象.      </span><br><span class="line"> *</span><br><span class="line"> * 并发标记:  </span><br><span class="line"> * 从第一步标记的可达的对象开始,并发的标记所有可达的对象 </span><br><span class="line"> *</span><br><span class="line"> * 重新标记:    (Stop the world 暂停用户线程)</span><br><span class="line"> * 在第二部的并发标记阶段,由于程序运行导致对象间引用的关系发生变化,</span><br><span class="line"> * 就需要重新标记</span><br><span class="line"> *</span><br><span class="line"> * 并发清除:     </span><br><span class="line"> * 这个阶段不暂停用户线程,并且并发的去清除未被标记的对象</span><br><span class="line"> * </span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p>G1收集器可以说是目前最前沿的一款收集器，它是一款面向服务端的收集器。<br>G1收集器<strong>无需配合其他收集器就可以管理整个堆内存。</strong><br>jdk9开始，G1成为jdk默认使用的垃圾回收器。</p></li></ul><h4 id="G1回收器的特点"><a href="#G1回收器的特点" class="headerlink" title="G1回收器的特点"></a>G1回收器的特点</h4><ul><li><p>并行和并发: G1能够充分利用多核cpu的优势，使垃圾回收与用户线程同时运行。</p></li><li><p>可预测的停顿: 降低GC停顿时间是CMS与G1收集器的共同目标。但是除了降低GC停顿时间，<br>G1收集器还可以建立可预测的停顿时间模型。(…太np了 =_=)</p></li><li><p>空间整合: 个人认为这是G1收集器不同于其他收集器的最大亮点了。<br>在其他收集器中，堆区基本都分为新生代和老年代。<br>而在G1收集器中虽然仍然保留了新生代和老年代的概念，但已经不再是物理上的分隔了。</p></li></ul><p><strong>在G1收集器的堆内存模型中，内存被分割成了一块一块大小相等的Region，<br>在这些Region中，Region的类型也不同，有eden，survivor，old，humongous之分。<br>当有大对象时，对象会被分配到Humongous Region之中。</strong></p><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/GC/img/jdk-jvm-juc/G1%E6%94%B6%E9%9B%86%E5%99%A8Region.png" alt="G1收集器Region"></p><h4 id="G1收集器回收过程"><a href="#G1收集器回收过程" class="headerlink" title="G1收集器回收过程"></a>G1收集器回收过程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G1收集器与CMS收集器的回收过程相似</span><br></pre></td></tr></table></figure><ul><li><p>初始标记(Stop The World,此阶段会暂停用户线程): 只标记与GC ROOT直接关联的对象。</p></li><li><p>并发标记: 对第一个阶段标记的对象Tracing，标记所有可达的对象。</p></li><li><p>最终标记(Stop The World,此阶段会暂停用户线程): 在并发标记阶段，由于用户线程执行，<br>可能导致被标记对象之间的引用关系发生影响，需要对这些对象进行重新标记调整。</p></li><li><p>筛选回收: 不同于CMS的并发清除，G1收集器首先会对所有Region的回收价值和回收成本进行排序,<br>然后再进行回收。这样可以在有限的时间内获得最大的回收率。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * 因为我的机器的jdk版本是11,所以无需指定垃圾回收器</span><br><span class="line"> * 指定G1回收器的参数是: -XX:+UseG1GC</span><br><span class="line"> *</span><br><span class="line"> * 1:初始标记:(Stop the world 暂停用户线程)</span><br><span class="line"> *   标记所有与GC Root直接可达的对象</span><br><span class="line"> *</span><br><span class="line"> * 2:并发标记</span><br><span class="line"> *  从第一个阶段标记的对象开始,trace标记</span><br><span class="line"> *</span><br><span class="line"> * 4:最终标记:(Stop the world 暂停用户线程)</span><br><span class="line"> *  在第二步并发标记的阶段,由于程序执行,</span><br><span class="line"> *  导致被标记对象之间的引用关系发生变化,所以需要重新调整标记</span><br><span class="line"> *</span><br><span class="line"> * 5:筛选回收:</span><br><span class="line"> *  和CMS的并发回收不一样,</span><br><span class="line"> *  G1收集器首先会对所有Region的回收价值和回收成本进行排序,</span><br><span class="line"> *  然后再进行回收。</span><br><span class="line"> *  这样可以保证在有限的时间内获得最大的回收率.</span><br><span class="line"> *</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2020/07/12/java%E5%9F%BA%E7%A1%80/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/07/12/java%E5%9F%BA%E7%A1%80/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p><strong>进程与线程最主要的区别是它们是操作系统管理资源的不同方式的体现。</strong><br>准确来说进程与线程属于衍生关系。<br>进程是操作系统执行程序的一次过程,在这个过程中可能会产生多个线程。</p><blockquote><p>比如在使用QQ时，有窗口线程，<br>文字发送的线程，语音输入的线程，可能不是很恰当，但是就是这个意思。</p></blockquote><p><strong>由于系统在线程之间的切换比在进程之间的切换更高效率，所以线程也被成为轻量级进程。</strong></p><h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><ol><li><p>并发: <strong>多个程序可以同时运行的现象</strong>，更细化的是多进程可以同时运行或者多指令可以同时运行。多个线程任务被一个cpu轮流执行。<br><strong>并发强调的是计算机应用程序有处理多个任务的能力。并发的”同时”是经过上下文快速切换，使得看上去多个进程同时都在运行的现象，是一种OS欺骗用户的现象</strong>。</p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Blog\source\_posts\java多线程\并发.png" alt="image-20200719145125356" style="zoom:50%;"></li><li><p>并行:多个线程被多个cpu同时执行。这里也并不是只允许多个cpu处理多任务，一个cpu也是可以的，<br>只要cpu能在同一时刻处理多任务。<strong>并行的”同时”是同一时刻可以多个进程在运行(处于running)</strong></p><p><strong>并行强调的是计算机应用程序拥有同时处理多任务的能力。</strong></p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/Blog\source\_posts\java多线程\并行.png" alt="image-20200719145208852" style="zoom:50%;"></li></ol><h4 id="并发和并行对比"><a href="#并发和并行对比" class="headerlink" title="并发和并行对比"></a>并发和并行对比</h4><p>并发，指的是多个事情<strong>，在同一时间段内同时发生了。</strong></p><p>并行，指的是多个事情，<strong>在同一时间点上同时发生了。</strong></p><p><strong>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</strong></p><p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。</p><p>否则，看似同时发生的事情，其实都是并发执行的。</p><h4 id="多线程的利弊"><a href="#多线程的利弊" class="headerlink" title="多线程的利弊"></a>多线程的利弊</h4><ul><li><p>利:</p><ul><li><p>线程可以比作轻量级的进程，cpu在线程之间的切换比在进程之间的切换，耗费的资源要少的多。</p></li><li><p>现在是多核cpu时代，意味着多个线程可以被多个cpu同时运行(并行)，如果可以利用好多线程，那么可以编写出高并发的程序。</p></li></ul></li><li><p>弊:</p><ul><li>虽然线程带来的好处很多，但是并发编程并不容易，如果控制不好线程，那么就可能造成死锁，资源闲置，内存泄露等问题。</li></ul></li></ul><h4 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h4><p>cpu是采用时间片的轮转制度，在多个线程之间来回切换运行的。<br>当cpu切换到另一个线程的时候，它会先保存当前线程执行的状态，<br>以便在下次切换回来执行时，可以重新加载状态，继续运行。<br><strong>从保存线程的状态再到重新加载回线程的状态的这个过程就叫做上下文切换。</strong></p><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><p>在Java中可以通过Thread类的setPriority方法来设置线程的优先级，<br>虽然可以通过这样的方式来设置线程的优先级，但是线程执行的先后顺序并不依赖与线程的优先级。<br>换句话说就是，<strong>线程的优先级不保证线程执行的顺序。</strong></p><h4 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h4><p>见:jdk Thread类源码中的state枚举类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NEW,RUNNABLE,BLOCKED,WAITING,TIMED_WAITING,TERMINATED</span><br></pre></td></tr></table></figure><h4 id="sleep方法和wait方法的区别"><a href="#sleep方法和wait方法的区别" class="headerlink" title="sleep方法和wait方法的区别"></a>sleep方法和wait方法的区别</h4><ol><li><p>sleep方法是Thread类的方法；而wait方法是Object类的方法。</p></li><li><p>sleep方法会<strong>使当前线程让出cpu的调度资源</strong>，从而让其他线程有获得被执行的机会，</p></li></ol><p><strong>但是并不会让当前线程释放锁对象。</strong><br>而wait方法是<strong>让当前线程释放锁并进入wait状态，</strong><br>不参与获取锁的争夺，从而让其他等待资源的线程有机会获取锁，<br>只有当其他线程调用notify或notifyAll方法是，被wait的线程才能重新与其他线程一起争夺资源。</p><h4 id="stop-suspend-resume等方法为什么会被遗弃"><a href="#stop-suspend-resume等方法为什么会被遗弃" class="headerlink" title="stop,suspend,resume等方法为什么会被遗弃"></a>stop,suspend,resume等方法为什么会被遗弃</h4><ul><li><p>stop: stop方法被弃用很好理解，因为stop方法是强行终止线程的执行，<br>不管线程的run方法是否执行完，资源是否释放完，它都会终止线程的运行，并释放锁。<br>显然，这在设计上就不合理。  </p></li><li><p>suspend和resume: suspend方法用于阻塞一个线程,但并不释放锁，<br>而resume方法的作用只是为了恢复被suspend的线程。<br>假设A，B线程都争抢同一把锁，A线程成功的获得了锁，<br>然后被suspend阻塞了，却并没有释放锁，它需要其他线程来唤醒，<br>但此时B线程需要获得这把锁才能唤醒A，所以此时就陷入了死锁。</p></li></ul><h4 id="interrupt-interrupted-isInterrupted方法区别"><a href="#interrupt-interrupted-isInterrupted方法区别" class="headerlink" title="interrupt,interrupted,isInterrupted方法区别"></a>interrupt,interrupted,isInterrupted方法区别</h4><ul><li><p>interrupt: 这个方法并不是中断当前线程，而是给当前线程设置一个中断状态。</p></li><li><p>isInterrupted: 当线程调用interrupt方法后，线程就有了一个中断状态，<br>而使用isInterrupted方法就可以检测到线程的中断状态。</p></li><li><p>interrupted: 这个方法用于清除interrupt方法设置的中断状态。<br>如果一个线程之前调用了interrupt方法设置了中断状态，<br>那么interrupted方法就可以清除这个中断状态。          </p></li></ul><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><p>join方法的作用是让指定线程加入到当前线程中执行。</p><p>假如在main方法里面创建一个线程A执行，并调用A的join方法，<br>那么当前线程就是main，指定的A线程就会在main之前执行，<br>等A执行完后，才会继续执行main。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Thread a = new Thread(()-&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(1);</span><br><span class="line">            </span><br><span class="line">        &#125;catch (Exception e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;thread join&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    a.start();</span><br><span class="line"></span><br><span class="line">    //a会在main线程之前执行</span><br><span class="line">    a.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;main&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>join方法的底层是wait方法，调用A线程(子线程)的join方法实际上是让main线程wait，<br>等A线程执行完后，才能继续执行后面的代码。</strong></p><h4 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h4><p>yield属于Thread的静态方法，<br>它的作用是让当前线程让出cpu调度资源。</p><p>yield方法其实就和线程的优先级一样，你虽然指定了，<br>但是最后的结果不由得你说了算，<br><strong>即使调用了yield方法，最后仍然可能是这个线程先执行，<br>只不过说别的线程可能先执行的机会稍大一些。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="/2020/07/12/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/"/>
      <url>/2020/07/12/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#java集合">java集合</a><ul><li><a href="#线程不安全的集合">线程不安全的集合</a><ul><li><a href="#hashmap的特点">HashMap的特点</a></li><li><a href="#hashmap的长度容量为什么要设计成2的幂">HashMap的长度(容量)为什么要设计成2的幂？</a></li><li><a href="#hashtable的特点">HashTable的特点</a></li><li><a href="#treemap">TreeMap</a></li><li><a href="#arraylist的特点">ArrayList的特点</a></li><li><a href="#vector的特点">Vector的特点</a></li><li><a href="#linkedlist的特点">LinkedList的特点</a></li><li><a href="#set">Set</a></li><li><a href="#concurrentmodificationexception异常">ConcurrentModificationException异常</a></li></ul></li><li><a href="#线程安全的集合">线程安全的集合</a><ul><li><a href="#线程安全的-list">线程安全的 List</a></li><li><a href="#copyonwritearraylist">CopyOnWriteArrayList</a></li><li><a href="#线程安全的set">线程安全的Set</a></li><li><a href="#线程安全的map">线程安全的Map</a></li><li><a href="#concurrenthashmap">ConcurrentHashMap</a></li><li><a href="#concurrentskiplistmap">ConcurrentSkipListMap</a></li></ul></li></ul></li></ul><span id="more"></span><h1 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h1><h3 id="线程不安全的集合"><a href="#线程不安全的集合" class="headerlink" title="线程不安全的集合"></a>线程不安全的集合</h3><h4 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a>HashMap的特点</h4><ul><li><p>HashMap在Jdk8之前使用拉链法实现,jdk8之后使用拉链法+红黑树实现。</p></li><li><p>HashMap是线程不安全的,并允许null key 和 null value。**</p></li><li><p>HashMap在我当前的jdk版本(11)的默认容量为0,在第一次添加元素的时候才初始化容量为 16,<br>之后才扩容为原来的2倍。</p></li><li><p>HashMap的扩容是根据 threshold决定的 : threshold = loadFactor * capacity。<br>当 size 大于 threshold 时,扩容。</p></li><li><p><strong>当每个桶的元素数量达到默认的阈值TREEIFY_THRESHOLD(8)时，HashMap会判断当前数组的<br>长度是否大于MIN_TREEIFY_CAPACITY(64),如果大于，那么这个桶的链表将会转为红黑树，否则HashMap将会扩容。<br>当红黑树节点的数量小于等于默认的阈值UNTREEIFY_THRESHOLD(6)时，那么在扩容的时候，这个桶的红黑树将转为链表。</strong></p></li></ul><h4 id="HashMap的长度-容量-为什么要设计成2的幂？"><a href="#HashMap的长度-容量-为什么要设计成2的幂？" class="headerlink" title="HashMap的长度(容量)为什么要设计成2的幂？"></a>HashMap的长度(容量)为什么要设计成2的幂？</h4><blockquote><p>这就不得不佩服大师们的设计。</p></blockquote><p>想想看，一个对象的hashcode是很大的，当HashMap的容量仅为16,32时，<br>如何根据hashcode来确定key在数组中的下标。<br>一个好的办法就是取余: hashcode % length。<br>这样就能确保，key的下标是永远不会超过数组的长度的。<br>但是想想，除了取余有没有更好的办法，</p><p>当然有:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash % length == hash &amp; (length - 1)</span><br></pre></td></tr></table></figure><p>为什么上面这个性能超高的等式成立，当然是有条件的，</p><p><strong>只有当length为2的幂的时候这样的等式才成立,</strong><br>这就明白了为什么使用2的幂来定义HashMap的长度。</p><h4 id="HashTable的特点"><a href="#HashTable的特点" class="headerlink" title="HashTable的特点"></a>HashTable的特点</h4><ul><li><p>HashTable底层使用拉链法实现。</p></li><li><p>HashTable就像Vector一样,也是jdk1就存在的很古老的一个类，它是线程安全的，<br>实现线程安全的手段是使用synchronized。</p></li><li><p>HashTable的默认容量为16，每次扩容为原来的2倍+1。</p></li><li><p>HashTable不允许null key 和 null value。</p></li></ul><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p><strong>TreeMap使用红黑树实现,不允许null key,允许自然排序Comparable和比较器Comparator排序。</strong></p><h4 id="ArrayList的特点"><a href="#ArrayList的特点" class="headerlink" title="ArrayList的特点"></a>ArrayList的特点</h4><ul><li><p>ArrayList底层使用Object数组实现。</p></li><li><p>ArrayList的容量默认为0,只有在第一次执行add操作时才会初始化容量为10，正常的扩容是为原来的1/2倍。</p></li><li><p>由于ArrayList采用数组实现,它的容量是固定的,所以当添加新元素的时候,如果超出了数组的容量,<br>那么此时add操作的时间复杂度将会是O(n-1)。</p></li><li><p>ArrayList实现了RandomAccess接口，该接口没有具体的规范，只是一个标记，<br>这代表ArrayList支持快速的随机访问。</p></li><li><p>ArrayList在内存空间利用率上肯定是不如LinkedList的，<br>因为数组是一片固定的连续的内存空间，一旦分配就无法改变，<br>所以难免会有空间不足或空间使用率很低的情况。</p></li></ul><h4 id="Vector的特点"><a href="#Vector的特点" class="headerlink" title="Vector的特点"></a>Vector的特点</h4><ol><li><p>ArrayList是线程不安全的，Vector是线程安全的，<br>但Vector实现线程安全的手段是synchronized。这就好比HashMap与HashTable的区别。</p></li><li><p>Vector默认容量为10。</p></li><li><p>Vector是当它的扩容增量大于0时，会扩容为原来的容量+扩容增量，否则扩容为原来的2倍。</p></li></ol><h4 id="LinkedList的特点"><a href="#LinkedList的特点" class="headerlink" title="LinkedList的特点"></a>LinkedList的特点</h4><ul><li><p>LinkedList底层使用<strong>双端链表</strong>实现。</p></li><li><p>LinkedList的add操作只需要改变尾节点的引用就行了。<br>但是如果需要在指定位置进行add操作的话，那么时间复杂度也是比较高的,为O(n)，<br>因为需要从头节点或尾节点遍历到需要操作的节点。</p></li><li><p>LinkedList的空间利用率虽然很高，但是它的每个Node可以说也是占用了较大空间的，<br>因为每个Node需要保存它的前继和后继节点。</p></li></ul><p><strong>PS: 双端链表与双向链表的区别:<br>双端链表:每个Node都保存了前后2个节点的引用，双向链表的first节点的前一个节点为null,<br> last节点的后一个节点为null。</strong></p><p><strong>双向链表: 每个Node都保存了前后2个节点的引用，<br>双向链表的first节点的前一个节点指向last节点，<br>last节点的最后一个节点指向first节点。</strong></p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>为啥不单独说HashSet，我目前看到的JDK所有的Set,都是使用Map实现的,</p><p>用Key存储，value是一个Object常量</p><p>除了CopyOnWriteArraySet(底层是CopyOnWriteArrayList)。</p><p>TreeSet –&gt; TreeMap</p><p>LinkedHashSet –&gt; LinkedHashMap</p><p>HashSet –&gt; HashMap</p><p>ConcurrentSkipListSet –&gt; ConcurrentSkipListMap</p><p>Set是如何保证元素不会重复,这个得看各自Map的实现了。</p><p>拿HashMap来讲，它先判断key的hash是否相等，然后才使用equals判断2个对象是否相等。</p><h4 id="ConcurrentModificationException异常"><a href="#ConcurrentModificationException异常" class="headerlink" title="ConcurrentModificationException异常"></a>ConcurrentModificationException异常</h4><p>ConcurrentModificationException可以从名字看出是并发修改的异常。</p><p>但我要说的是<strong>这个异并不是在修改的时候会抛出的，而是在调用迭代器遍历集合的时候才会抛出。</strong></p><p>而集合类的大部分toString方法，都是使用迭代器遍历的。<strong>所以如果多线程修改集合后，<br>接着就遍历集合，那么很有可能会抛出ConcurrentModificationException。</strong></p><p><strong>在ArrayList，HashMap等非线程安全的集合内部都有一个modCount变量，<br>这个变量是在集合被修改时(删除，新增)，都会被修改。</strong></p><p>如果是多线程对同一个集合做出修改操作，就可能会造成modCount与实际的操作次数不符，<br>那么最终在调用集合的迭代方法时，modCount与预期expectedModeCount比较，<br>expectedModCount是在迭代器初始化时使用modCount赋值的，<br><strong>如果发现modCount与expectedModeCount不一致，就说明在使用迭代器遍历集合期间，<br>有其他线程对集合进行了修改,所以就会抛出ConcurrentModificationException异常。</strong></p><h3 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h3><h4 id="线程安全的-List"><a href="#线程安全的-List" class="headerlink" title="线程安全的 List"></a>线程安全的 List</h4><ol><li>使用集合工具类Collections的 synchronizedList把普通的List转为线程安全的List.(不推荐)</li><li>使用Vector.(不推荐)</li><li>使用CopyOnWriteArrayList,推荐使用此种方法，因为以上2种全部都是单纯的Synchronized加锁.</li></ol><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>CopyOnWriteArrayList是线程安全的ArrayList，可以被称为写时复制的ArrayList。<br>CopyOnWriteArrayList底层仍然使用数组实现，<br>但是它的修改操作(增删改)采用synchronized关键字保证并发的安全性，<br>然后<strong>在进行修改的时候复制原来的数组到一个新副本，对新副本进行修改，修改完后再设置原数组。</strong><br>这样就不会让写操作影响读操作了。 </p><p><strong>但是CopyOnWriteArrayList不容忽视的缺点就是修改操作比较消耗内存空间，所以它适用于读多写少的环境。</strong></p><h4 id="线程安全的Set"><a href="#线程安全的Set" class="headerlink" title="线程安全的Set"></a>线程安全的Set</h4><ol><li>使用集合工具类的Collections的synchronizedSet把普通的set转为线程安全的set(不推荐)</li><li>使用CopyOnWriteArraySet,此set适用于读多写少的情况，它的底层采用CopyOnWriteArrayList实现.</li><li>使用ConcurrentSkipListSet，底层采用ConcurrentSkipListMap实现</li></ol><h4 id="线程安全的Map"><a href="#线程安全的Map" class="headerlink" title="线程安全的Map"></a>线程安全的Map</h4><ol><li>使用集合工具类Collections的synchronizedMap把普通map转为线程安全的map(不推荐)</li><li>HashTable(不推荐)</li><li>使用ConcurrentHashMap(常用)</li><li>ConcurrentSkipListMap(跳表map,推荐)</li></ol><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap使用数组+链表/红黑树实现,其扩容机制与HashMap一样。</p><p><strong>但是ConcurrentHashMap控制并发的方法改为了CAS+synchronized,<br>synchronized锁的只是链表的首节点或红黑树的首节点。</strong></p><p><strong>PS:我只看了常用的put,get,remove等核心方法的源码.<br>整个ConcurrentHashMap的实现用”复杂”来形容一点也不为过,<br>你只要想到它内部有52个内部类就知道有多复杂了,但如果不考虑并发CAS这部分，<br>ConcurrentHashMap和普通的HashMap的差别是不大的。</strong></p><h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><p>ConcurrentSkipListMap是基于跳表这种数据结构实现的。<br>跳表比较特殊，它由多个层次的链表组成，每层链表又有多个索引节点连接，<br>每层链表的元素也都是有序的。处于上层索引的链表都是下层链表的子集。<br>跳表与普通链表相比查找元素的效率更高。</p><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/Java%E9%9B%86%E5%90%88/%E8%B7%B3%E8%A1%A8.png" alt="跳表"></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-周阳</title>
      <link href="/2020/07/12/java%E5%9F%BA%E7%A1%80/%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%91%A8%E9%98%B3/"/>
      <url>/2020/07/12/java%E5%9F%BA%E7%A1%80/%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%91%A8%E9%98%B3/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%91%A8%E9%98%B3/java%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="jdk8之后的jvm内存分区"></p><span id="more"></span><p>灰色：线程私有</p><p>亮色：所有线程共享，存在垃圾回收</p><h2 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1.类加载器"></a>1.类加载器</h2><p>.class结果类加载器 变成Class</p><p>jdk自己的类 是bootstrap 加载器  mull</p><p>自己编写的类走的是$AppClassLoader 加载器</p><p>sun.misc.Launcher   jvm调用的入口程序</p><h4 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h4><p>启动类 bootstrap</p><p>扩展类 extension</p><p>应用程序类 appclassloader</p><h4 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h4><p>java.lang.ClassLoader的子类，用户自己实现</p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。 </p><h4 id="沙箱安全"><a href="#沙箱安全" class="headerlink" title="沙箱安全"></a>沙箱安全</h4><p>自定义string类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java\lang\String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的string类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</p><h4 id="判断两个类相同"><a href="#判断两个类相同" class="headerlink" title="判断两个类相同"></a>判断两个类相同</h4><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><p>类的完整类名必须一致，包括包名。<br>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同。<br>换句话说，在JvM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。</p><p>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</p><h2 id="2-本地方法接口-栈"><a href="#2-本地方法接口-栈" class="headerlink" title="2.本地方法接口/栈"></a>2.本地方法接口/栈</h2><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序</p><p>本地方法栈：它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</p><p>native是一个关键字，只有声明，没有实现</p><h2 id="3-PC寄存器"><a href="#3-PC寄存器" class="headerlink" title="3.PC寄存器"></a>3.PC寄存器</h2><p>记录了方法之间的调用和执行情况，用来存储指向下一条指令的地址</p><h2 id="4-方法区"><a href="#4-方法区" class="headerlink" title="4.方法区"></a>4.方法区</h2><p>4.1各线程共享的运行时内存区域。它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。</p><p>4.2上面讲的是规范，在不同虚拟机里头实现是不一样的，最典型的就是jdk7<strong>永久代</strong>(PermGen space)和jdk8<strong>元空间</strong>(Metaspace)。</p><p>元空间使用的是本地内存，所以元空间仅受本地物理内存的限制。<br>元空间存储着已被加载的类的方法描述，字段描述，运行时常量池等信息。</p><p><strong>字符串常量池在jdk7已经从永久代转移到了堆内存之中。</strong></p><p><strong>无论是永久代还是元空间，都有可能发生OOM。</strong></p><h2 id="5-stack"><a href="#5-stack" class="headerlink" title="5.stack"></a>5.stack</h2><h4 id="5-1栈管运行，堆管存储"><a href="#5-1栈管运行，堆管存储" class="headerlink" title="5.1栈管运行，堆管存储"></a>5.1栈管运行，堆管存储</h4><p>栈（FILO）队列（FIFO）</p><p>e.printStateTrace()</p><p>是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说<strong>不存在垃圾回收问题</strong>，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。</p><h4 id="5-2栈有哪些东西"><a href="#5-2栈有哪些东西" class="headerlink" title="5.2栈有哪些东西"></a>5.2栈有哪些东西</h4><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%91%A8%E9%98%B3/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="Java虚拟机栈"></p><p>8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。</p><p>本地变量（Local Variables）:输入参数和输出参数以及方法内的变量；</p><p>栈操作（Operand Stack）:记录出栈、入栈的操作；</p><p>栈帧数据（Frame Data）:包括类文件、方法等等。</p><h5 id="5-2-1栈帧"><a href="#5-2-1栈帧" class="headerlink" title="5.2.1栈帧"></a>5.2.1栈帧</h5><p><strong>栈帧是用于支持Java方法运行时的数据结构。</strong><br><strong>栈帧包含了局部变量表，操作数栈，动态连接，方法出口等信息。</strong><br><strong>每个方法执行时，都会在java虚拟机栈中创建一个栈帧。</strong><br><strong>对方法的调用和返回，就对应着栈帧的入栈和出栈的过程。</strong></p><h5 id="5-2-2局部变量表"><a href="#5-2-2局部变量表" class="headerlink" title="5.2.2局部变量表"></a>5.2.2局部变量表</h5><p><strong>局部变量表用于存储方法参数和方法内定义的局部变量。<br>局部变量表存放了各种已知的数据类型的变量。</strong><br>一个局部变量的类型可以是基本数据类型<br>(int,short,float,double,boolean,long,byte,char)或引用类型(reference)。<br>在Java代码被编译成class字节码后，方法Code属性的locals就确定了方法的局部变量表的大小。<br>局部变量表以slot为最小单位，一个slot代表4个字节，也就是32位长度的大小。</p><h5 id="5-2-3操作数栈"><a href="#5-2-3操作数栈" class="headerlink" title="5.2.3操作数栈"></a>5.2.3操作数栈</h5><p>操作数栈是一个后进先出(LIFO)的数据结构。<br><strong>它存储的是方法在进行数据运算时的元素。</strong><br>和局部变量表一样，操作数栈的每个元素的类型也可以是基本数据类型和引用类型。<br>操作数栈的深度不会超过 Code属性的stack值。</p><p>使用javap -c 反编译class文件后可以得到的字节码指令如下:</p><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%91%A8%E9%98%B3/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.png" alt="局部变量表"></p><h5 id="5-2-4动态连接"><a href="#5-2-4动态连接" class="headerlink" title="5.2.4动态连接"></a>5.2.4动态连接</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">了解动态连接首先需要了解符号引用和直接引用</span><br></pre></td></tr></table></figure><ul><li><p>符号引用: 符号引用存于Class文件常量池。分为类的全限定名，方法名和描述符，字段名和描述符。</p></li><li><p>直接引用: 指向目标的指针，可以简单理解为目标的内存地址(如指向类的字段的内存地址)。</p></li></ul><p>Class文件常量池如下(javap -c 反编译class文件后的字节码):</p><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%91%A8%E9%98%B3/Class%E6%96%87%E4%BB%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="Class文件常量池"></p><p><strong>在虚拟机栈中，每个栈帧都包含了一个该栈帧所属方法的符号引用，<br>持有这个符号引用的目的是为了支持方法调用过程中的动态连接。<br>这些符号引用有的一部分会在JVM类解析阶段就会转为直接引用，这部分转换成为静态解析。<br>还有一部分会在运行时转为直接引用，这部分称为动态连接。</strong></p><h5 id="5-2-5方法出口"><a href="#5-2-5方法出口" class="headerlink" title="5.2.5方法出口"></a>5.2.5方法出口</h5><p>当方法执行时，有2种方式可以退出该方法。</p><ol><li><p>正常退出: 当方法执行时，执行到return指令，该方法就会正常退出。<br>一般来说，方法正常退出时，调用线程的程序计数器的值可以作为方法返回的地址，<br>栈帧中可能会保存这个计数器的值。</p></li><li><p>异常退出: 在方法执行过程中遇到了异常，并且方法内部没有处理这个异常，就会导致方法退出。<br>方法异常退出时，返回地址需要通过异常处理器表来确定的，栈帧中不会保存这部分值。</p></li></ol><p><strong>无论何种退出方式，在方法退出后，都需要回到方法被调用的位置，程序才能继续执行。</strong></p><p>StackOverFlowError 是错误</p><h4 id="5-3-堆-栈-方法区的交互关系"><a href="#5-3-堆-栈-方法区的交互关系" class="headerlink" title="5.3 堆+栈+方法区的交互关系"></a>5.3 堆+栈+方法区的交互关系</h4><p>栈+堆+方法区关系</p><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%91%A8%E9%98%B3/%E6%A0%88+%E5%A0%86+%E6%96%B9%E6%B3%95%E5%8C%BA%E5%85%B3%E7%B3%BB.png" alt="栈+堆+方法区关系"></p><p>HotSpot是使用指针的方式来访问对象：<br>Java堆中会存放访问类元数据的地址，<br>reference存储的就直接是对象的地址</p><h2 id="6-堆Heap"><a href="#6-堆Heap" class="headerlink" title="6.堆Heap"></a>6.堆Heap</h2><h4 id="6-1Young-Generation-Space-新生区-Young-New"><a href="#6-1Young-Generation-Space-新生区-Young-New" class="headerlink" title="6.1Young Generation Space  新生区                    Young/New"></a>6.1Young Generation Space  新生区                    Young/New</h4><h5 id="6-1-1伊甸园"><a href="#6-1-1伊甸园" class="headerlink" title="6.1.1伊甸园"></a>6.1.1伊甸园</h5><h5 id="6-1-2幸存者0区-from"><a href="#6-1-2幸存者0区-from" class="headerlink" title="6.1.2幸存者0区 from"></a>6.1.2幸存者0区 from</h5><h5 id="6-1-3幸存者1区-to"><a href="#6-1-3幸存者1区-to" class="headerlink" title="6.1.3幸存者1区 to"></a>6.1.3幸存者1区 to</h5><p>GC之后交互交换</p><h4 id="6-2Tenure-generation-space-养老区-Old-Tenure"><a href="#6-2Tenure-generation-space-养老区-Old-Tenure" class="headerlink" title="6.2Tenure generation space  养老区                     Old/ Tenure"></a>6.2Tenure generation space  养老区                     Old/ Tenure</h4><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%91%A8%E9%98%B3/%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D.png" alt="堆空间分配"></p><p>当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收<strong>(Minor GC</strong>)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。若幸存 0区也满了，再对该区进行垃圾回收，然后移动到 1 区。那如果1 区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生MajorGC（<strong>FullGC</strong>），进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。<br><strong>如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二：</strong><br><strong>（1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。</strong><br><strong>（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。</strong></p><p>Minor GC 复制  -&gt; 清空 -&gt; 互换（from区和to区每次GC之后会交换，谁空谁是to区）</p><p>1.Eden、from复制到to区 年龄+1</p><p>Eden慢第一次GC 把活着的对象拷贝到 from区，第二次GC时把Eden和from一起GC ,存活的对象到to区，并把年龄+1    </p><p>2.清空Eden、from</p><p>清空Eden和from的对象，就是复制之后交换，谁空谁是to</p><p>3.to和from交换</p><p>to和from交换，to成为下一次GC的from区，部分对象会在from和to直接复制，到15次后如果还是存活，就存入到老年代</p><h4 id="6-3Permanent-Space-永久区-Perm-但永久代已被元空间代替-在方法区"><a href="#6-3Permanent-Space-永久区-Perm-但永久代已被元空间代替-在方法区" class="headerlink" title="6.3Permanent Space              永久区                         Perm  但永久代已被元空间代替,在方法区"></a>6.3Permanent Space              永久区                         Perm  但永久代已被元空间代替,在方法区</h4><h2 id="7-jvm调优"><a href="#7-jvm调优" class="headerlink" title="7 jvm调优"></a>7 jvm调优</h2><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%91%A8%E9%98%B3/java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.png" alt="java垃圾收集"></p><p>元空间与永久代之间最大的区别在于：<br>永久带使用的JVM的堆内存，但是java8以后的元空间并不在虚拟机中而是使用本机物理内存。</p><table><thead><tr><th>默认物理内存</th><th>功能</th></tr></thead><tbody><tr><td>-Xms</td><td>默认物理内存1/64 初始值</td></tr><tr><td>-Xmx</td><td>默认物理内存1/4  最大值</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出GC日志</td></tr></tbody></table><p>-Xms 1/64 默认物理内存</p><p>-Xmx 1/4</p><p>生产中把两个值设置成一样，防止内存忽高忽低，不稳定</p><p>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</p><h2 id="8-GC"><a href="#8-GC" class="headerlink" title="8 GC"></a>8 GC</h2><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%91%A8%E9%98%B3/FullGC.png" alt="FullGC"></p><p>JVM进行GC时，大部分回收新生代<br>普通GC (minor GC)：只针对新时代 非常频繁，一般回收速度较快</p><p>全局GC(magor GC or Full Gc)：MajorGC 老年代的垃圾收集，至少伴随一次MinorGC，速度上慢10倍</p><p>元空间不GC</p><p>system.gc()；通知gc进程 ，但不一定执行。</p><h2 id="9-JMM"><a href="#9-JMM" class="headerlink" title="9 JMM"></a>9 JMM</h2><p>volatile 保证可见性，不<strong>保证原子性</strong></p><p>java memory model java内存模型</p><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/%E8%AF%BE%E5%A0%82%E9%9A%8F%E7%AC%94-%E5%91%A8%E9%98%B3/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="JMM内存模型"></p><p>JMM内存模型</p><p>1.可见性</p><p>2.原子性</p><p>3.有序性</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm</title>
      <link href="/2020/07/12/java%E5%9F%BA%E7%A1%80/JVM/"/>
      <url>/2020/07/12/java%E5%9F%BA%E7%A1%80/JVM/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#jvm">JVM</a><ul><li><a href="#jvm运行时内存分区">JVM运行时内存分区</a><ul><li><a href="#程序计数器">程序计数器</a></li><li><a href="#程序计数器的特点">程序计数器的特点</a></li><li><a href="#java虚拟机栈">Java虚拟机栈</a></li><li><a href="#栈帧">栈帧</a></li><li><a href="#局部变量表">局部变量表</a></li><li><a href="#操作数栈">操作数栈</a></li><li><a href="#动态连接">动态连接</a></li><li><a href="#方法出口">方法出口</a></li><li><a href="#本地方法栈">本地方法栈</a></li><li><a href="#堆">堆</a></li><li><a href="#方法区">方法区</a></li></ul></li><li><a href="#javavirtualmachineerror">JavaVirtualMachineError</a><ul><li><a href="#stackoverflowerror">StackOverflowError</a></li><li><a href="#outofmemoryerror">OutOfMemoryError</a></li></ul></li></ul></li></ul><span id="more"></span><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p><strong>PS:JVM部分参考了《深入理解Java虚拟机 - 第二版》(周志明).<br>个人认为《深入理解Java虚拟机 - 第二版》上的部分内容已经过时<br>有些知识请各位同学明鉴，此外我后续会根据 《深入理解Java虚拟机 - 第三版》的内容来做更新和修改。</strong></p><h3 id="JVM运行时内存分区"><a href="#JVM运行时内存分区" class="headerlink" title="JVM运行时内存分区"></a>JVM运行时内存分区</h3><blockquote><p>以HotSpot为例:</p></blockquote><ul><li><p>JDK8之前: </p><ul><li><p>线程私有的部分有:程序计数器(PC寄存器),JAVA虚拟机栈,本地方法栈(native)。</p></li><li><p>线程共享部分有: GC堆,永久代(是方法区的一种实现)。</p></li></ul></li></ul><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/JVM/jdk8%E4%B9%8B%E5%89%8D%E7%9A%84JVM%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt="jdk8之前的jvm内存分区"></p><ul><li><p>JDK8之后:</p><ul><li>线程私有的部分不变, 线程共享部分的永久代改为了元空间(MetaSpace)<br>(永久代和元空间都是方法区的实现),字符串常量池也移动到了heap空间</li></ul></li></ul><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/JVM/jdk8%E4%B9%8B%E5%90%8E%E7%9A%84jvm%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt="jdk8之后的jvm内存分区">     </p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，<strong>它的作用是作为当前线程执行的字节码的行号计数器。<br>当字节码解释器工作时，通过改变行号计数器的值来选取下一条要执行的字节码指令。</strong><br>分支，循环，跳转，异常处理，线程恢复等功能都需要依赖程序计数器完成。</p><p><strong>程序计数器是属于线程私有的部分。<br>当cpu在多个线程之间切换执行时，需要记录下当前线程执行的字节码的位置，<br>以便下次切换回当前线程时，能够继续执行字节码指令，<br>所以每个线程都需要有自己的程序计数器。</strong></p><h4 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h4><ol><li>如果当前线程执行的是java方法，那么程序计数器记录的是字节码指令的地址。</li><li>如果当前线程执行的native方法，那么程序计数器记录的值为空(undefined)。</li><li>程序计数器这部分内存区域是JVM中唯一不会出现OOM错误的区域</li><li>程序计数器的生命周期与线程相同,即程序计数器随着线程创建而创建，<br>随着线程的销毁而销毁。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 javap -c 反编译class文件后的代码如下,</span><br><span class="line">红框里的就是字节码的偏移地址:</span><br></pre></td></tr></table></figure><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/JVM/JVM%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="JVM程序计数器"></p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java虚拟机栈与程序计数器一样，都是线程私有的部分，生命周期也跟线程一样。</p><p><strong>Java虚拟机栈描述的是Java方法运行时的内存模型，它由一个一个的栈帧组成。</strong></p><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><strong>栈帧是用于支持Java方法运行时的数据结构。<br>栈帧包含了局部变量表，操作数栈，动态连接，方法出口等信息。<br>每个方法执行时，都会在java虚拟机栈中创建一个栈帧。<br>对方法的调用和返回，就对应着栈帧的入栈和出栈的过程。</strong></p><p>Java虚拟机栈:<br><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="Java虚拟机栈"></p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p><strong>局部变量表用于存储方法参数和方法内定义的局部变量。<br>局部变量表存放了各种已知的数据类型的变量。</strong><br>一个局部变量的类型可以是基本数据类型<br>(int,short,float,double,boolean,long,byte,char)或引用类型(reference)。<br>在Java代码被编译成class字节码后，方法Code属性的locals就确定了方法的局部变量表的大小。<br>局部变量表以slot为最小单位，一个slot代表4个字节，也就是32位长度的大小。</p><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>操作数栈是一个后进先出(LIFO)的数据结构。<br><strong>它存储的是方法在进行数据运算时的元素。</strong><br>和局部变量表一样，操作数栈的每个元素的类型也可以是基本数据类型和引用类型。<br>操作数栈的深度不会超过 Code属性的stack值。</p><p>使用javap -c 反编译class文件后可以得到的字节码指令如下:</p><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/JVM/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8.png" alt="局部变量表"></p><h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">了解动态连接首先需要了解符号引用和直接引用</span><br></pre></td></tr></table></figure><ul><li><p>符号引用: 符号引用存于Class文件常量池。分为类的全限定名，方法名和描述符，字段名和描述符。</p></li><li><p>直接引用: 指向目标的指针，可以简单理解为目标的内存地址(如指向类的字段的内存地址)。</p></li></ul><p>Class文件常量池如下(javap -c 反编译class文件后的字节码):</p><p><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/JVM/Class%E6%96%87%E4%BB%B6%E5%B8%B8%E9%87%8F%E6%B1%A0.png" alt="Class文件常量池"></p><p><strong>在虚拟机栈中，每个栈帧都包含了一个该栈帧所属方法的符号引用，<br>持有这个符号引用的目的是为了支持方法调用过程中的动态连接。<br>这些符号引用有的一部分会在JVM类解析阶段就会转为直接引用，这部分转换成为静态解析。<br>还有一部分会在运行时转为直接引用，这部分称为动态连接。</strong></p><h4 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h4><p>当方法执行时，有2种方式可以退出该方法。</p><ol><li><p>正常退出: 当方法执行时，执行到return指令，该方法就会正常退出。<br>一般来说，方法正常退出时，调用线程的程序计数器的值可以作为方法返回的地址，<br>栈帧中可能会保存这个计数器的值。</p></li><li><p>异常退出: 在方法执行过程中遇到了异常，并且方法内部没有处理这个异常，就会导致方法退出。<br>方法异常退出时，返回地址需要通过异常处理器表来确定的，栈帧中不会保存这部分值。</p></li></ol><p><strong>无论何种退出方式，在方法退出后，都需要回到方法被调用的位置，程序才能继续执行。</strong></p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈与虚拟机栈的作用是相似的，<br>不过<strong>虚拟机栈是为执行Java方法提供服务的，<br>本地方法栈视为执行native方法提供服务的。</strong><br>在本地方法执行的时候，也会在本地方法栈中创建栈帧，<br>用于存放该本地方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><strong>堆是JVM中内存占用最大的一块区域，它是所有线程共享的一块区域。<br>堆的作用是为对象分配内存并存储和回收它们。<br>堆是垃圾回收的主要区域，所以堆区也被成为GC堆。</strong></p><p>堆区可以划分为 <strong>新生代(Young Generation),老年代(Old Generation)</strong> 和<br>永久代(Permanent Generation),但永久代已被元空间代替,<br><strong>元空间存储的是类的元信息，几乎不可能发生GC。</strong></p><p>新生代再细分可以分为: <strong>Eden空间，From Survivor空间和To Survivor空间。</strong></p><p>缺省状态下新生代占堆区的 1/3,老年代占堆区的2/3，<br>eden空间占新生代的80%,2个Survivor空间栈新生代的20%,<br>FromSurvivor和ToSurvivor的空间占比为1:1。</p><p>(通过-XX:NewRatio参数可以调整新生代和老年代的空间占比)<br>(通过-XX:SurvivorRatio参数可以调整eden和survivor的空间占比)</p><p><strong>发生在新生代的GC叫做Young GC或Minor GC,<br>发生在老年代的GC叫做Old GC或Major GC</strong></p><p>堆:<br><img src="/2020/07/12/java%E5%9F%BA%E7%A1%80/JVM/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.png" alt="堆内存分区"></p><p><strong>PS:<br>FromSurvivor和ToSurvivor这两块内存空间并不是固定的，<br>在进行GC的时候，这两块内存会轮流替换使用。这部分内容参考GC部分。</strong></p><p><strong>PS:<br>有的文章说 Full GC与Major GC一样是属于对老年代的GC，<br>也有的文章说 Full GC 是对整个堆区的GC，所以这点需要各位同学自行分辨Full GC语义。<br>见: <a href="https://www.zhihu.com/question/41922036">知乎讨论</a></strong></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区在JVM规范里也是各个<strong>线程共享的一部分区域，<br>它用于存储已被jvm加载的类的元信息，运行时常量池等数据。</strong></p><p>HotSpot虚拟机对于方法区的实现在jdk8之前为永久代，在jdk8之后，<br>HotSpot移除了永久代，新增了元空间。</p><p>元空间使用的是本地内存，所以元空间仅受本地物理内存的限制。<br>元空间存储着已被加载的类的方法描述，字段描述，运行时常量池等信息。</p><p><strong>字符串常量池在jdk7已经从永久代转移到了堆内存之中。</strong></p><p><strong>无论是永久代还是元空间，都有可能发生OOM。</strong></p><h3 id="JavaVirtualMachineError"><a href="#JavaVirtualMachineError" class="headerlink" title="JavaVirtualMachineError"></a>JavaVirtualMachineError</h3><h4 id="StackOverflowError"><a href="#StackOverflowError" class="headerlink" title="StackOverflowError"></a>StackOverflowError</h4><p>当前线程执行或请求的栈的大小超过了Java<br>虚拟机栈的最大空间(比如递归嵌套调用太深),就可能出现StackOverflowError错误</p><h4 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h4><p>发生OOM的情况: </p><ul><li><p>java heap space </p><blockquote><p>当需要为对象分配内存时，堆空间占用已经达到最大值，<br>无法继续为对象分配内存，可能会出现OOM: java heap space错误。 </p></blockquote></li><li><p>Requested array size exceeds VM limit</p><blockquote><p>当为数组分配内存时，数组需要的容量超过了虚拟机的限制范围，<br>就会抛出OOM: Requested array size exceeds VM limit。<br>根据我的测试，Integer.MAX_VALUE - 2 是虚拟机能为数组分配的最大容量      </p></blockquote></li><li><p>GC overhead limit exceed</p><blockquote><p>垃圾回收器花费了很长时间GC,但是GC回收的内存非常少,<br>就可能抛出OOM:GC overhead limit exceed 错误。</p><p>但是这点在我的机器上测试不出来,可能与jdk版本或gc收集器或Xmx分配内存的大小有关,<br>一直抛出的是java heap space</p></blockquote></li><li><p>Direct buffer memory</p><blockquote><p>当程序分配了超额的本地物理内存(native memory/ direct buffer)，<br>minor gc(young gc)并不会回收这部分内存，<br>只有 full gc才会回收直接内存，如果不发生full  gc，<br>但直接内存却被使用完了，那么可能会发生 OOM: Direct buffer memory。</p></blockquote></li><li><p>unable to create new native thread </p><blockquote><p>操作系统的线程资源是有限的，<br>如果程序创建的线程资源太多(无需超过平台限制的线程资源上限)，<br>就可能发生 OOM: unable to create new native thread 错误。 </p></blockquote></li><li><p>Metaspace</p><blockquote><p>当加载到元空间中的类的信息太多，就有可能导致 OOM : Metaspace。</p><blockquote><p><strong>使用cglib的库，可以动态生成class，所以可以使用cglib测试此错误。</strong></p></blockquote></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/12/hello-world/"/>
      <url>/2020/07/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="博客的搭建与备份"><a href="#博客的搭建与备份" class="headerlink" title="博客的搭建与备份"></a>博客的搭建与备份</h3><p><a href="https://www.jianshu.com/p/9b87aae19093">https://www.jianshu.com/p/9b87aae19093</a></p><h2 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h2><p>由于博客是在本地生成的，如果更换电脑，那我们是不是就不能用这个博客了？方法总比问题多，我们可以利用<code>github</code>来备份博客的文件和数据。</p><p><a href="https://github.com/coneycode/hexo-git-backup">https://github.com/coneycode/hexo-git-backup</a></p><p>1.安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure><p>2.在博客配置文件 _config.yml 中添加:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backup: </span><br><span class="line">type: git </span><br><span class="line">theme: next,... </span><br><span class="line">message: update xxx </span><br><span class="line">repository: </span><br><span class="line">git@github.com:TRHX/TRHX.github.io.git,backup</span><br></pre></td></tr></table></figure><p>配置中可以设置提交时的信息(message); </p><p>可以指定一起备份的主题(支持多个, 逗号分隔);</p><p> repository 也可以指定多个地方进行同步备份;</p><p> 网上说的比较多的是将备份放到博客项目的一个分支里, 即将上面的 branchName 设置成分支名称, git 路径与博客项目 github用户名.github.io 一致;</p><p>3.在命令行中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo backup</span><br></pre></td></tr></table></figure><p>如果原先是通过手动方式进行的备份, 即没有使用插件, 此时再用插件备份是会出错的. 解决方法是将博客目录下的 .git 目录删除, 再执行 hexo backup 命令;</p><p>原文</p><p> <a href="https://memento.net.cn/post/b96cbb80.html">https://memento.net.cn/post/b96cbb80.html</a></p><h2 id="解决index-lock-的办法"><a href="#解决index-lock-的办法" class="headerlink" title="解决index.lock 的办法"></a>解决index.lock 的办法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -f .git/index.lock</span><br></pre></td></tr></table></figure><h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><p>常见命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><p>组合命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><h3 id="Hexo版本升级"><a href="#Hexo版本升级" class="headerlink" title="Hexo版本升级"></a>Hexo版本升级</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br><span class="line">npm update</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
