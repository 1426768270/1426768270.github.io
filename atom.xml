<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>naive的博客</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-10-15T05:46:38.856Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>naive</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://yoursite.com/2022/09/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2022/09/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP%E7%AE%97%E6%B3%95/</id>
    <published>2022-09-21T14:37:06.000Z</published>
    <updated>2022-10-15T05:46:38.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h3 id="KMP解决的问题"><a href="#KMP解决的问题" class="headerlink" title="KMP解决的问题"></a>KMP解决的问题</h3><p>字符串str1和字符串str2，str1是否包含str2，如果包含返回str2在str1中的位置。如何做到时间复杂度O(n)完成？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">str1</span> <span class="number">111111112</span></span><br><span class="line"><span class="attribute">str2</span> <span class="number">1112</span></span><br></pre></td></tr></table></figure><p>这样如果使用暴力查找，复杂度较高，<code>O(n*m)</code> str1是n,str2是m</p><h3 id="最长前缀和"><a href="#最长前缀和" class="headerlink" title="最长前缀和"></a>最长前缀和</h3><p>求字符串中字符k前面的前缀和后缀的最大匹配个数。</p><p>例如字符串 <code>abbabbk</code>前后缀如下</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>前缀</td><td>a</td><td>ab</td><td>abb</td><td>abba</td><td>abbab</td></tr><tr><td>后缀</td><td>b</td><td>bb</td><td>abb</td><td>babb</td><td>bbabb</td></tr><tr><td></td><td>x</td><td>x</td><td>√</td><td>x</td><td>x</td></tr></tbody></table><p>对于k来说就前缀和后缀的最大匹配个数为3。</p><p>对于 <code>aaaaak</code>前后缀如下：</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>前缀</td><td>a</td><td>aa</td><td>aaa</td><td>aaaa</td></tr><tr><td>后缀</td><td>a</td><td>aa</td><td>aaa</td><td>aaaa</td></tr><tr><td></td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>对于k来说就前缀和后缀的最大匹配个数为4。</p><h3 id="KMP算法-1"><a href="#KMP算法-1" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP算法第一步就是求解字符串str每一位字符前面字符的前缀和后缀的最大匹配个数，叫<code>nextarr</code>，利用数组对查找进行加速。</p><p>对于字符串 aabaabsaa每一位的前缀和后缀的最大匹配个数如下（nextarr数组）：</p><table><thead><tr><th>a</th><th>a</th><th>b</th><th>a</th><th>a</th><th>b</th><th>s</th><th>…</th></tr></thead><tbody><tr><td>-1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>2</td><td>3</td><td>…</td></tr></tbody></table><p>对两个字符串str1,str2有如下：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">str<span class="number">1</span>i......<span class="keyword">X</span></span><br><span class="line">str<span class="number">2</span><span class="number">0</span>......<span class="keyword">Y</span></span><br><span class="line"></span><br><span class="line">经典算法</span><br><span class="line">当<span class="keyword">X</span>不等于<span class="keyword">Y</span>时</span><br><span class="line">对于暴力匹配算法str<span class="number">1</span>会从<span class="keyword">X</span>跳到第i+<span class="number">1</span>位置，str<span class="number">2</span>从<span class="keyword">Y</span>跳到<span class="number">0</span>位置开始匹配</span><br><span class="line"></span><br><span class="line">对于KMP算法</span><br><span class="line">就会获得<span class="keyword">Y</span>字符串之前的最大前缀最大，</span><br><span class="line">比对的<span class="keyword">X</span>会停留，比对的<span class="keyword">Y</span>位置回跳到最大前缀的结束位置.从这<span class="number">2</span>个位置开始继续比对</span><br><span class="line">因为<span class="keyword">X</span>之前的位置与<span class="keyword">Y</span>位置之前的位置已经比较过，利用前缀和后缀做一个小加速</span><br><span class="line">例如：</span><br><span class="line">str<span class="number">1</span>  ...abb[abbs]</span><br><span class="line">str<span class="number">2</span>     abbabbc</span><br></pre></td></tr></table></figure><p>当比到s和c时发现2个字符串不相等，这时使用kmp算法 将str2直接从c调到第2个位置a,理解成以str1的的第4位a为开头能不能配成str2。</p><ol><li><p>从<strong>可能不相等的位置</strong>开始往下走</p></li><li><p>证明从str1 第1位到第4位 中间<strong>任何一个位置配不成str2</strong>。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 i<span class="params">...</span>k<span class="params">...</span>j<span class="params">...</span>X</span><br><span class="line">str2 <span class="number">0.</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.Y</span><br><span class="line">j是最大前缀的位置</span><br><span class="line"><span class="number">1.</span>假设i到j 中存在k可以配出str2 </span><br><span class="line"><span class="number">2.</span>那么k..x为str2前缀</span><br><span class="line"><span class="number">3.</span>那么Y之前就找到了一个更大的前缀， k到x 这样就矛盾了。</span><br><span class="line">所以直接跳过到j</span><br></pre></td></tr></table></figure></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总复杂度O(N)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndexOf</span><span class="params">(String s, String m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || m == <span class="keyword">null</span> || m.length() &lt; <span class="number">1</span> || s.length() &lt; m.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = m.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = getNextArray(str2); <span class="comment">//O(M)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(N)</span></span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1[i1] == str2[i2]) &#123; <span class="comment">// 字符相等，2个字符串同时往后移动</span></span><br><span class="line">                i1++;</span><br><span class="line">                i2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[i2] == -<span class="number">1</span>) &#123; <span class="comment">// i2 == 0 str2比对的位置不能再往前了，已经是0位置了，让str1换个开头继续推 str1[i + 1]</span></span><br><span class="line">                i1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// str2可以往前跳 调到最大前缀的位置进行比对</span></span><br><span class="line">                i2 = next[i2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果str2匹配完成，找到该位置。 否则返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> i2 == str2.length ? i1 - i2 : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNextArray(<span class="keyword">char</span>[] ms) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ms.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[ms.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>; <span class="comment">//默认为-1</span></span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>; <span class="comment">// next数组开始的位置</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">//表示最长的公共子串长度</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; ms.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ms[i - <span class="number">1</span>] == ms[len]) &#123; <span class="comment">//如果相等 abbe[len] abbe[i]</span></span><br><span class="line">                next[i++] = ++len; <span class="comment">//这一位的next数组就等于 上一位的最大前缀 + 1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123; <span class="comment">// abbe abbc</span></span><br><span class="line">                len = next[len]; <span class="comment">// 如果不相等找len位置的最大前缀进行比较</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[i++] = <span class="number">0</span>; <span class="comment">//这一位没有最大前缀</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getIndexOf(<span class="string">&quot;babcabcd&quot;</span>, <span class="string">&quot;abcabcd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h1&gt;&lt;h3 id=&quot;KMP解决的问题&quot;&gt;&lt;a href=&quot;#KMP解决的问题&quot; class=&quot;headerlink&quot; title=&quot;KMP解决的问题&quot;&gt;&lt;/a&gt;KMP解决的问题&lt;/h3&gt;&lt;p&gt;字符串str1和字符串str2，str1是否包含str2，如果包含返回str2在str1中的位置。如何做到时间复杂度O(n)完成？&lt;/p&gt;
&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;str1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;111111112&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;str2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1112&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这样如果使用暴力查找，复杂度较高，&lt;code&gt;O(n*m)&lt;/code&gt; str1是n,str2是m&lt;/p&gt;
&lt;h3 id=&quot;最长前缀和&quot;&gt;&lt;a href=&quot;#最长前缀和&quot; class=&quot;headerlink&quot; title=&quot;最长前缀和&quot;&gt;&lt;/a&gt;最长前缀和&lt;/h3&gt;&lt;p&gt;求字符串中字符k前面的前缀和后缀的最大匹配个数。&lt;/p&gt;
&lt;p&gt;例如字符串 &lt;code&gt;abbabbk&lt;/code&gt;前后缀如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;前缀&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;ab&lt;/td&gt;
&lt;td&gt;abb&lt;/td&gt;
&lt;td&gt;abba&lt;/td&gt;
&lt;td&gt;abbab&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;后缀&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;bb&lt;/td&gt;
&lt;td&gt;abb&lt;/td&gt;
&lt;td&gt;babb&lt;/td&gt;
&lt;td&gt;bbabb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;对于k来说就前缀和后缀的最大匹配个数为3。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>有序表并查集</title>
    <link href="http://yoursite.com/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2022-09-18T10:25:41.000Z</published>
    <updated>2022-09-21T15:16:40.247Z</updated>
    
    <content type="html"><![CDATA[<p>来源 左神 有序表并查集</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="岛问题"><a href="#岛问题" class="headerlink" title="岛问题"></a>岛问题</h3><p>【题目】leetcode 200<br>一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛? </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【举例】</span><br><span class="line">001010</span><br><span class="line">111010</span><br><span class="line">100100</span><br><span class="line">000000</span><br><span class="line">这个矩阵中有三个岛</span><br></pre></td></tr></table></figure><p>遍历二维数组每一位， 如果这一位为1，就调用感染函数进行感染（周围的岛屿都变为2），记录了调用几次感染函数,就有几个岛屿。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountIslands</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义 遍历二维数组每一位， 如果这一位为1，就调用感染函数进行感染，最后记录了调用几次感染函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="keyword">null</span> || m[<span class="number">0</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = m.length;</span><br><span class="line">        <span class="keyword">int</span> M = m[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    infect(m, i, j, N, M);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 感染函数， 感染这个数值周围所有的联通 dfs</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">char</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= N || j &lt; <span class="number">0</span> || j &gt;= M || m[i][j] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i，j没有越界，并且都为1</span></span><br><span class="line">        m[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        infect(m, i + <span class="number">1</span>, j, N, M);</span><br><span class="line">        infect(m, i - <span class="number">1</span>, j, N, M);</span><br><span class="line">        infect(m, i, j + <span class="number">1</span>, N, M);</span><br><span class="line">        infect(m, i, j - <span class="number">1</span>, N, M);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] m = &#123;&#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> CountIslands().numIslands(m));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：在遍历阶段，每个位置遍历一次，感染阶段，每个位置只遍历4次（上下左右调用），<code>O(n*m)</code>。</p><p><strong>如何设计一个并行算法解决这个问题？</strong></p><h3 id="并查集介绍"><a href="#并查集介绍" class="headerlink" title="并查集介绍"></a>并查集介绍</h3><ol><li><p>并查集是一种<strong>树型的数据结构</strong>，用于处理一些<strong>不相交集合（disjoint sets）的合并及查询问题。</strong></p></li><li><p>并查集通常包含两种操作</p><ul><li><code>init(s)</code>：建立一个新的并查集，其中包含s个单元素集合</li><li><code>union(x, y)</code>：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并</li><li><code>find(x)</code>：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了</li></ul></li></ol><p><strong>find(D)和find(F)分别返回元素D和元素F所属集合的代表A和H：</strong></p><img src="/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/并查集查找.png" alt="img" style="zoom:80%;"><p><strong>union(D, F)将元素D和元素F所在的集合合并：</strong></p><p><img src="/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%90%88%E5%B9%B6.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 样本进来会包一层，叫做元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;V, Element&lt;V&gt;&gt; elementMap;</span><br><span class="line">        <span class="comment">// key某个元素value该元素的父</span></span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Element&lt;V&gt;, Element&lt;V&gt;&gt; fatherMap;</span><br><span class="line">        <span class="comment">// key某个集合的代表元素value该集合的大小</span></span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Element&lt;V&gt;, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">(List&lt;V&gt; list)</span> </span>&#123;</span><br><span class="line">            elementMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            fatherMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            sizeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (V val : list) &#123;</span><br><span class="line">                Element&lt;V&gt; element = <span class="keyword">new</span> Element&lt;&gt;(val);</span><br><span class="line">                elementMap.put(val, element);</span><br><span class="line">                fatherMap.put(element, element);</span><br><span class="line">                sizeMap.put(element, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给定一个ele，往上一直找，把代表元素返回</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Element&lt;V&gt; <span class="title">findHead</span><span class="params">(Element&lt;V&gt; element)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Element&lt;V&gt;&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="comment">// 一直找到最上方节点</span></span><br><span class="line">            <span class="keyword">while</span> (element != fatherMap.get(element)) &#123;</span><br><span class="line">                path.push(element);</span><br><span class="line">                element = fatherMap.get(element);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把路径上元素的 父节点 都设置成顶部元素</span></span><br><span class="line">            <span class="keyword">while</span> (!path.isEmpty()) &#123;</span><br><span class="line">                fatherMap.put(path.pop(), element);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否是同一个集合</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (elementMap.containsKey(a) &amp;&amp; elementMap.containsKey(b)) &#123;</span><br><span class="line">                <span class="keyword">return</span> findHead(elementMap.get(a)) == findHead(elementMap.get(b));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 联合2个集合</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (elementMap.containsKey(a) &amp;&amp; elementMap.containsKey(b)) &#123;</span><br><span class="line">                Element&lt;V&gt; af = findHead(elementMap.get(a));</span><br><span class="line">                Element&lt;V&gt; bf = findHead(elementMap.get(b));</span><br><span class="line">                <span class="comment">// 如果两个元素不是同一个父</span></span><br><span class="line">                <span class="keyword">if</span> (af != bf) &#123;</span><br><span class="line">                    <span class="comment">// 数量少的集合要挂在数量多集合的下面</span></span><br><span class="line">                    Element&lt;V&gt; big = sizeMap.get(af)&gt;=sizeMap.get(bf) ? af : bf;</span><br><span class="line">                    Element&lt;V&gt; small = big == af ? af : bf;</span><br><span class="line">                    <span class="comment">// 更新 small的父节点为big</span></span><br><span class="line">                    fatherMap.put(small, big);</span><br><span class="line">                    <span class="comment">// 更新各自集合的尺寸</span></span><br><span class="line">                    sizeMap.put(big, sizeMap.get(af) + sizeMap.get(bf));</span><br><span class="line">                    sizeMap.remove(small);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单次时间复杂度可以是<code>O(1)</code></p><h3 id="并查集解决岛问题"><a href="#并查集解决岛问题" class="headerlink" title="并查集解决岛问题"></a>并查集解决岛问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> row, col;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        row = grid.length;</span><br><span class="line">        col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> n = row * col;</span><br><span class="line">        <span class="keyword">int</span> ocean = <span class="number">0</span>;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    ocean += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) uf.union(node(i, j), node(i - <span class="number">1</span>, j));</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) uf.union(node(i, j), node(i, j - <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; row - <span class="number">1</span> &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) uf.union(node(i, j), node(i + <span class="number">1</span>, j));</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; col - <span class="number">1</span> &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) uf.union(node(i, j), node(i, j + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.size - ocean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">node</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i * col + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] roots;</span><br><span class="line">    <span class="keyword">int</span> size;   <span class="comment">// 岛屿数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        roots = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            roots[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        size = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != roots[i]) &#123;</span><br><span class="line">            roots[i] =roots[roots[i]];</span><br><span class="line">            i = roots[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot != qRoot) &#123;</span><br><span class="line">            roots[pRoot] = qRoot;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用并查集在多个cpu上计算岛屿，将矩阵拆分为多块，每块各自使用感染算法计算各自的的岛屿，并记录各自块的边界上的岛屿的联通情况（<code>land[i][j] = a</code>），当所有块的岛屿计算完成后，在根据边界上的岛屿如果联通，就合并为一个集合。</p><h3 id="并查集题"><a href="#并查集题" class="headerlink" title="并查集题"></a>并查集题</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源 左神 有序表并查集&lt;/p&gt;
&lt;h2 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h2&gt;&lt;h3 id=&quot;岛问题&quot;&gt;&lt;a href=&quot;#岛问题&quot; class=&quot;headerlink&quot; title=&quot;岛问题&quot;&gt;&lt;/a&gt;岛问题&lt;/h3&gt;&lt;p&gt;【题目】leetcode 200&lt;br&gt;一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛? &lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;【举例】&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;001010&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111010&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个矩阵中有三个岛&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;遍历二维数组每一位， 如果这一位为1，就调用感染函数进行感染（周围的岛屿都变为2），记录了调用几次感染函数,就有几个岛屿。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CountIslands&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    定义 遍历二维数组每一位， 如果这一位为1，就调用感染函数进行感染，最后记录了调用几次感染函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;numIslands&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[][] m)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (m == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || m[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; N = m.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; M = m[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; res = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; M; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (m[i][j] == &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    infect(m, i, j, N, M);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 感染函数， 感染这个数值周围所有的联通 dfs&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;infect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[][] m, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; N, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; M)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || i &amp;gt;= N || j &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || j &amp;gt;= M || m[i][j] != &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// i，j没有越界，并且都为1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        m[i][j] = &lt;span class=&quot;string&quot;&gt;&amp;#x27;2&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        infect(m, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, j, N, M);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        infect(m, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, j, N, M);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        infect(m, i, j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, N, M);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        infect(m, i, j - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, N, M);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[][] m = &amp;#123;&amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CountIslands().numIslands(m));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;时间复杂度：在遍历阶段，每个位置遍历一次，感染阶段，每个位置只遍历4次（上下左右调用），&lt;code&gt;O(n*m)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何设计一个并行算法解决这个问题？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;并查集介绍&quot;&gt;&lt;a href=&quot;#并查集介绍&quot; class=&quot;headerlink&quot; title=&quot;并查集介绍&quot;&gt;&lt;/a&gt;并查集介绍&lt;/h3&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈希函数和哈希表</title>
    <link href="http://yoursite.com/2022/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2022/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</id>
    <published>2022-09-04T07:52:47.000Z</published>
    <updated>2022-09-06T16:22:29.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>out = f(in)</p><ol><li><p>in -&gt; 无穷，out -&gt; string 有限</p><ul><li>md5： 0 - 2^64^-1 </li><li>sha1： 0 - 2^128^-1</li></ul></li><li><p>same in -&gt; same out 不随机</p></li><li><p>different in -&gt; same out （哈希碰撞）</p></li><li><p>离散性和均匀性 （输入有规律，输出无规律）</p></li></ol><blockquote><p>in 通过hash函数得到 out 再取模 %m 就可以的带 <code>0 - (m-1)</code> 范围的数</p></blockquote><h3 id="题"><a href="#题" class="headerlink" title="题"></a>题</h3><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">一个大文件 无符号整数 (</span><span class="number">2</span><span class="keyword">^32</span><span class="keyword">^-1</span><span class="xml"> 就是 </span><span class="number">0</span><span class="xml">- </span><span class="number">42</span><span class="xml">亿范围）有</span><span class="number">40</span><span class="xml">亿个数，</span><span class="number">1</span><span class="xml">g内存求出现次数最多的数是哪一个？</span></span><br></pre></td></tr></table></figure><p>如果使用hash表来做 <code>key - value</code> ,key是(4B),value是int(4B), 一个数就要8B，如果40亿个数都不一样，就需要 320亿B（32G）。</p><p>对数据a 先使用 <code>hash函数</code>得到数 b，然后  <code>% 100</code>得到 0-99范围的数，相同的数据进同一个文件，不同的数种类上进不同文件。对每一个小文件使用hash表，然后求出这100个数的最大值。不怕同一种数太多，怕不同种的数太多，内存不够。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>表 + 链表（ in通过hash函数得到 out 再取模 %m 就）当 某条链表太长触发扩容 机制。n个字符串 ，会触发<code>logn</code>次扩容，最坏是<code>logN</code>。每一次扩容的代价是<code>O(N)</code>，每个数全部要计算hash，扩容的代价<code>O（N * logN）</code>。单次插入代价<code>O（N * logN）/ N</code> 就是<code>logN</code>，通过设置链表长度特别小，使<code>logN</code>特别小，就是O(1)。在使用的时候认为是O(1).</p><blockquote><p>jvm等虚拟机语言，可以做到在扩容时使用旧表，扩容完使用新表。离线计算。</p></blockquote><p>开放地址法</p><h3 id="题-1"><a href="#题-1" class="headerlink" title="题"></a>题</h3><p>1.设计RandomPool结构</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目】</span><br><span class="line">设计一种结构，在该结构中有如下三个功能:</span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">(key)</span></span>:将某个key加入到该结构，做到不重复加入</span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(key)</span></span>:将原本在结构中的某个key移除</span><br><span class="line"><span class="function"><span class="title">getRandom</span><span class="params">()</span></span>:等概率随机返回结构中的任何一个key。</span><br><span class="line"></span><br><span class="line">【要求】</span><br><span class="line">lnsert、 delete和getRandom方法的时间复杂度都是O(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>使用2张hash表</p><p>map1 (str -&gt; index), 存放”A” -&gt; 0…</p><p>map2 (index-&gt;str),  存放0 -&gt; “A”…</p><p>size,</p><p><code>getRandom()</code>如果存放了26个数，要等概率返回，使用系统提供的随机数生成，生成0-25的数，返回map2这个位置的str</p><p><code>delete(key)</code>删除时不能让index区域出现<strong>洞</strong>，保证连续性。删除时，让最后一条区域填补这个洞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Integer&gt; keyIndexMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, K&gt; indexKeyMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keyIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.indexKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没加过加入</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.keyIndexMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.keyIndexMap.put(key, <span class="keyword">this</span>.size);</span><br><span class="line">            <span class="keyword">this</span>.indexKeyMap.put(<span class="keyword">this</span>.size, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.keyIndexMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">int</span> deleteIndex = <span class="keyword">this</span>.keyIndexMap.get(key);</span><br><span class="line">            <span class="keyword">int</span> lastIndex = --<span class="keyword">this</span>.size;</span><br><span class="line">            K lastKey = <span class="keyword">this</span>.indexKeyMap.get(lastIndex);</span><br><span class="line">            <span class="keyword">this</span>.keyIndexMap.put(lastKey, deleteIndex);</span><br><span class="line">            <span class="keyword">this</span>.indexKeyMap.put(deleteIndex, lastKey);</span><br><span class="line">            <span class="keyword">this</span>.keyIndexMap.remove(key);</span><br><span class="line">            <span class="keyword">this</span>.indexKeyMap.remove(lastIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * <span class="keyword">this</span>.size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.indexKeyMap.get(random);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>解决黑名单过滤、对100亿url(64Byte)进行黑名单过滤过滤，如果使用hashset,需要640G内存。</p><p>爬虫去重，多个线程爬url, 如果已经爬过，就不要再爬，爬虫之间不要爬同一个。</p><p><strong>集合有添加、有查询，没有查询、极大程度减少内存使用，允许有一定程度失误率。</strong>如果一个数据不在布隆过滤器中，可能会误报，但一个数据在布隆过滤器中，一定不会误报。</p><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>bitmap, 基础类型数组,int[],long[]每一个占32bit、64bit</p><p><strong>bit[] 每一位占1bit</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 32bit * 10 320 bits</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// arr[0] int 0  - 31</span></span><br><span class="line">        <span class="comment">// arr[1] int 32 - 64</span></span><br><span class="line">        <span class="comment">// arr[2] int 64 - 95</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">178</span>; <span class="comment">//得到178个 bit</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numIndex = i / <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIndex = i % <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到178位 状态</span></span><br><span class="line">        <span class="keyword">int</span> s = ((arr[numIndex] &gt;&gt; bitIndex) &amp; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把178位状态改为1</span></span><br><span class="line">        arr[numIndex] = arr[numIndex] | (<span class="number">1</span> &lt;&lt; bitIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把178位状态改为0</span></span><br><span class="line">        arr[numIndex] = arr[numIndex] &amp; (~(<span class="number">1</span> &lt;&lt; bitIndex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>是一个超大的<strong>位数组</strong>和<strong>几个哈希函数</strong>,假设集合里面有 3 个元素 {x, y, z}，哈希函数的个数为 3。首先将位数组进行初始化，初始化状态的维数组的每个位都设置位 0。对于集合里面的每一个元素，将元素依次通过 3 个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为 1。</p><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p>将要添加的元素分别通过k个哈希函数计算得到k个哈希值，这k个hash值对应位数组上的k个位置，然后将这k个位置设置为1。</p><h5 id="查询元素"><a href="#查询元素" class="headerlink" title="查询元素"></a>查询元素</h5><p>将要查询的元素分别通过k个哈希函数计算<strong>得到k个哈希值</strong>，这k个hash值对应位数组上的k个位置，<strong>如果这k个位置中有一个位置为0，则此元素一定不存在集合中</strong>，如果这k个位置全部为1，则这个元素可能存在。</p><p>hash函数到底多少个，bitmap到底多长。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>相比于其它的数据结构，布隆过滤器在<strong>空间和时间</strong>方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（即hash函数的个数）</li><li>Hash 函数相互之间没有关系，方便由硬件并行实现</li><li>布隆过滤器<strong>不需要存储元素本身</strong>，在某些对保密要求非常严格的场合有优势</li><li>布隆过滤器可以<strong>表示全集</strong>，其它任何数据结构都不能。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>误算率（False Positive）是其中之一。随着存入的元素数量增加，<strong>误算率随之增加</strong>（误判补救方法是：再建立一个小的白名单，存储那些可能被误判的信息）。但是如果元素数量太少，则使用散列表足矣。</li><li>一般情况下<strong>不能从布隆过滤器中删除元素</strong>。我们很容易想到把位列阵变成整数数组，每插入一个元素相应的计数器加 1, 这样删除元素时将计数器减掉就可以了。然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</li></ul><h3 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h3><p>n = 样本量， P = 失误率 单样本大小</p><p><strong>m = - ( n * lnP / ln2^2^ )</strong> 需要多少空间 0.0001失误率 ，100亿url,需要^26G^</p><p><strong>k = （ln2 * (m/n) ）= 0.7 * (m/n)</strong> 向上取整</p><p>P真 = （1 - e^a^）(a = - n*k真/m真)</p><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>数据服务器怎么组织， 数据种类均匀分配。有3台服务器、一个数据同算hash然后取模方法，觉定这个数据在哪个服务器存储。hash key怎么选择，让高、中、低频的数据均匀分配的key，身份证之类。上面的算法好像可以把图片均衡地分配到不同的服务器,但<strong>增加和减少服务器时，如果要重新算hash会造成数据迁移</strong>。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>决分布式缓存的问题。 在移除或者添加一个服务器时，能够<strong>尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系</strong>。一致性哈希解决了简单哈希算法在分布式哈希表中存在的动态伸缩等问题 。</p><p>一致性hash算法会建立一个有2^32个槽点(0 - 2^32-1^)的hash环，假设现在有A、B、C三台服务器，以A为例，会进行hash(A)%2^32^，得到一个0 - 2^32-1^之间的数，然后映射到hash环上</p><p>接下来，我们以m1为例，我们照样算出hash(m1)%2^32^的值，然后映射到hash环上，然后以该点出发，<strong>顺时针遇到的第一个服务器，即为数据即将存储的服务器。</strong></p><p>如果这个时候在A - C之间插入了服务器D，请求获取getKey(m1)时，顺时针获得的服务器是D，从D上获取数据理所当然会失败，因为数据存在A上缓存。这样看缓存好像还是失效了。</p><p>虽然增加了节点D后，m1的缓存失效了，但是，分布在 A-B，B-C 以及 D-A上面的数据仍然有效，<strong>失效的只是C-D段的数据</strong>(数据存在A节点，但是顺时针获取的服务器是D)。这样就保证了缓存数据<strong>不会像hash算法那样大面积失效</strong>，同样起到减轻数据库压力的效果。</p><p><strong>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</strong></p><h4 id="hash偏斜"><a href="#hash偏斜" class="headerlink" title="hash偏斜"></a>hash偏斜</h4><p>A、B、C服务节点，如果接近于将hash环平均分配那固然理想，但是如果他们hash值十分相近,就会导致某一段直接会被大量分配，给某一节点大量分配，如果这时这个节点被删除，会有大量请求涌向相邻的节点，给这个节点带来巨大压力，这部分缓存也就失效了，导致了缓存雪崩。</p><p>如何保证节点的负载均衡？如何保证在添加节点后的负载均衡？</p><h4 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h4><p>如果我们的节点足够多，就应该可以防止服务器节点分布不均的问题了。</p><p>以A节点为例，虚拟构造出(A0,A1,A2….AN)，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为<strong>虚拟节点</strong>。<strong>只要是落在这些虚拟节点上的数据，都存入A节点</strong>。读取时也相同，顺时针获取的是A0虚拟节点，就到A节点上获取数据，这样就能解决数据分布不均的问题。</p><p>虚拟节点读写大概流程为:  数据读写 -&gt; 虚拟节点 -&gt; 真实节点 -&gt; 读写</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;哈希函数&quot;&gt;&lt;a href=&quot;#哈希函数&quot; class=&quot;headerlink&quot; title=&quot;哈希函数&quot;&gt;&lt;/a&gt;哈希函数&lt;/h2&gt;&lt;p&gt;out = f(in)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;in -&amp;gt; 无穷，out -&amp;gt; string 有限&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;md5： 0 - 2^64^-1 &lt;/li&gt;
&lt;li&gt;sha1： 0 - 2^128^-1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;same in -&amp;gt; same out 不随机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;different in -&amp;gt; same out （哈希碰撞）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;离散性和均匀性 （输入有规律，输出无规律）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;in 通过hash函数得到 out 再取模 %m 就可以的带 &lt;code&gt;0 - (m-1)&lt;/code&gt; 范围的数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;题&quot;&gt;&lt;a href=&quot;#题&quot; class=&quot;headerlink&quot; title=&quot;题&quot;&gt;&lt;/a&gt;题&lt;/h3&gt;&lt;figure class=&quot;highlight parser3&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;一个大文件 无符号整数 (&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;^32&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;^-1&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt; 就是 &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;亿范围）有&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;亿个数，&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;g内存求出现次数最多的数是哪一个？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果使用hash表来做 &lt;code&gt;key - value&lt;/code&gt; ,key是(4B),value是int(4B), 一个数就要8B，如果40亿个数都不一样，就需要 320亿B（32G）。&lt;/p&gt;
&lt;p&gt;对数据a 先使用 &lt;code&gt;hash函数&lt;/code&gt;得到数 b，然后  &lt;code&gt;% 100&lt;/code&gt;得到 0-99范围的数，相同的数据进同一个文件，不同的数种类上进不同文件。对每一个小文件使用hash表，然后求出这100个数的最大值。不怕同一种数太多，怕不同种的数太多，内存不够。&lt;/p&gt;
&lt;h2 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h2&gt;&lt;p&gt;表 + 链表（ in通过hash函数得到 out 再取模 %m 就）当 某条链表太长触发扩容 机制。n个字符串 ，会触发&lt;code&gt;logn&lt;/code&gt;次扩容，最坏是&lt;code&gt;logN&lt;/code&gt;。每一次扩容的代价是&lt;code&gt;O(N)&lt;/code&gt;，每个数全部要计算hash，扩容的代价&lt;code&gt;O（N * logN）&lt;/code&gt;。单次插入代价&lt;code&gt;O（N * logN）/ N&lt;/code&gt; 就是&lt;code&gt;logN&lt;/code&gt;，通过设置链表长度特别小，使&lt;code&gt;logN&lt;/code&gt;特别小，就是O(1)。在使用的时候认为是O(1).&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>RPC</title>
    <link href="http://yoursite.com/2022/06/25/%E5%88%86%E5%B8%83%E5%BC%8F/RPC/"/>
    <id>http://yoursite.com/2022/06/25/%E5%88%86%E5%B8%83%E5%BC%8F/RPC/</id>
    <published>2022-06-25T13:16:32.000Z</published>
    <updated>2022-06-25T13:16:42.422Z</updated>
    
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="RPC" scheme="http://yoursite.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>结果处理器</title>
    <link href="http://yoursite.com/2022/05/29/%E6%A1%86%E6%9E%B6/mybatis/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://yoursite.com/2022/05/29/%E6%A1%86%E6%9E%B6/mybatis/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2022-05-29T10:01:52.000Z</published>
    <updated>2022-05-29T10:24:55.174Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/29/%E6%A1%86%E6%9E%B6/mybatis/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8.png" alt="image-20220418233415695"></p><ul><li>ResultSetHandler：结果集处理器</li><li>ResultContext：结果提出</li><li>ResultHandler：结果处理器</li></ul><h4 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//包装结果集</span></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">//处理存储过程输出参数的</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleOutputParameters</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultResultSetHandler</code>，在默认的情况下都是通过这个类进行处理的。这个实现有些复杂，它涉及使用<code>JAVASSIST</code> 或者<code>CGLIB</code>作为<strong>延迟加载</strong>，然后通过<code>typeHandler</code>和<code>ObjectFactory</code><strong>进行组装结果再返回</strong>。</p><h4 id="ResultContext"><a href="#ResultContext" class="headerlink" title="ResultContext"></a>ResultContext</h4><p>控制结果的获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultContext</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//当前结果</span></span><br><span class="line">  <span class="function">T <span class="title">getResultObject</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//当前的数量</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getResultCount</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//当前是否停止</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isStopped</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">//停止</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ResultHandler"><a href="#ResultHandler" class="headerlink" title="ResultHandler"></a>ResultHandler</h4><p>纯粹对应的值这个默认实现只是把结果放入list中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(ResultContext&lt;? extends T&gt; resultContext)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/05/29/%E6%A1%86%E6%9E%B6/mybatis/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8.png&quot; alt=&quot;image-20220418233415695&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ResultSetHandler：结果集处理器&lt;/li&gt;
&lt;li&gt;ResultContext：结果提出&lt;/li&gt;
&lt;li&gt;ResultHandler：结果处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;ResultSetHandler&quot;&gt;&lt;a href=&quot;#ResultSetHandler&quot; class=&quot;headerlink&quot; title=&quot;ResultSetHandler&quot;&gt;&lt;/a&gt;ResultSetHandler&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ResultSetHandler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//包装结果集&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;E&amp;gt; &lt;span class=&quot;function&quot;&gt;List&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;handleResultSets&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Statement stmt)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//处理存储过程输出参数的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleOutputParameters&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CallableStatement cs)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;DefaultResultSetHandler&lt;/code&gt;，在默认的情况下都是通过这个类进行处理的。这个实现有些复杂，它涉及使用&lt;code&gt;JAVASSIST&lt;/code&gt; 或者&lt;code&gt;CGLIB&lt;/code&gt;作为&lt;strong&gt;延迟加载&lt;/strong&gt;，然后通过&lt;code&gt;typeHandler&lt;/code&gt;和&lt;code&gt;ObjectFactory&lt;/code&gt;&lt;strong&gt;进行组装结果再返回&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;ResultContext&quot;&gt;&lt;a href=&quot;#ResultContext&quot; class=&quot;headerlink&quot; title=&quot;ResultContext&quot;&gt;&lt;/a&gt;ResultContext&lt;/h4&gt;&lt;p&gt;控制结果的获取&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ResultContext&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//当前结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;getResultObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//当前的数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getResultCount&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//当前是否停止&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isStopped&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//停止&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;ResultHandler&quot;&gt;&lt;a href=&quot;#ResultHandler&quot; class=&quot;headerlink&quot; title=&quot;ResultHandler&quot;&gt;&lt;/a&gt;ResultHandler&lt;/h4&gt;&lt;p&gt;纯粹对应的值这个默认实现只是把结果放入list中&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>SqlSeesion缓存</title>
    <link href="http://yoursite.com/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/</id>
    <published>2022-04-04T16:01:47.000Z</published>
    <updated>2022-11-05T15:05:40.928Z</updated>
    
    <content type="html"><![CDATA[<p>SqlSession原理中介绍了在SQL查询时一级缓存和二级缓存的调用过程。这里介绍一下缓存的场景和失效。</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/Mybatis缓存.png" alt="image-20220405134607618" style="zoom:80%;"><h2 id="一、一级缓存"><a href="#一、一级缓存" class="headerlink" title="一、一级缓存"></a>一、一级缓存</h2><p>一级缓存与<code>SqlSession</code>相关，是一个<strong>会话级别的缓存</strong>，会话关闭清空缓存。在会话中一级缓存与运行时参数和操作配置相关</p><h3 id="命中场景"><a href="#命中场景" class="headerlink" title="命中场景"></a>命中场景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstCacheTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SQLException </span>&#123;</span><br><span class="line">        SqlSessionFactoryBuilder factoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        SqlSessionFactory build = factoryBuilder.build(inputStream);</span><br><span class="line">        configuration = build.getConfiguration();</span><br><span class="line">        sqlSession = build.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AccountMapper mapper = sqlSession.getMapper(AccountMapper.class);</span><br><span class="line">        List&lt;Account&gt; accounts1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        List&lt;Account&gt; accounts2 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(accounts1 == accounts2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存命中有几个运行时参数要求</p><ol><li>sql和参数必须相同</li><li>必须是相同的<code>statementID</code>，sql相同也不行</li><li><code>sqlSession</code>必须相同</li><li><code>RowBounds</code> 返回行返回必须相同</li></ol><p><strong>清理缓存之后就无法命中</strong>，默认采用的是simple执行器，编译2次，执行2次。建议采用的reuse执行器。只有有一条执行语句加入了<code>flushCache=true</code>等同于 <code>sqlSession.clearCache()</code>。共有4种操作配置导致缓存无法命中的场景：</p><ol><li>手动<code>sqlSession.clearCache()</code>,<code>sqlSession.commit()</code>, <code>sqlSession.rollback()</code></li><li>执行的方法上加入<code>flushCache=true</code></li><li>中间执行Update语句</li><li>缓存作用域不是<code>SESSION</code> 改为<code>STATEMENT</code>这里是嵌套查询（子查询）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AccountMapper mapper = sqlSession.getMapper(AccountMapper.class);</span><br><span class="line">    List&lt;Account&gt; accounts1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    sqlSession.clearCache();</span><br><span class="line">    List&lt;Account&gt; accounts2 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(accounts1 == accounts2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一级缓存源码解析"><a href="#一级缓存源码解析" class="headerlink" title="一级缓存源码解析"></a>一级缓存源码解析</h3><p><code>sqlSession</code>查询时的流程：</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/一级缓存.png" alt="image-20220405140905640" style="zoom:80%;"><h4 id="命中缓存"><a href="#命中缓存" class="headerlink" title="命中缓存"></a>命中缓存</h4><p>其中的<code>BaseExecutor</code>中的<code>localCache</code>的流程：</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/localCache.png" alt="image-20220405142235268" style="zoom: 50%;"><p><code>BaseExecutor</code>中的query源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">   <span class="comment">//query实现嵌套查询，查询中有子查询，这里就会变大</span></span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">      <span class="comment">//查询一级缓存</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    deferredLoads.clear(); <span class="comment">// issue 601</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      clearLocalCache(); <span class="comment">// issue 482</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询数据库</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="comment">//先占位，为了嵌套查询</span></span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//执行子类的查询</span></span><br><span class="line">      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">      localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一级缓存的key，只有都相同才能命中：</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/一级缓存key.png" alt="image-20220405143753736" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheKey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1146682552656046210L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CacheKey NULL_CACHE_KEY = <span class="keyword">new</span> NullCacheKey();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLYER = <span class="number">37</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> multiplier;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这5个参数分别为，statementID、分页上下限、sql语句、参数</p><h4 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h4><p>清空缓存的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">    localCache.clear();</span><br><span class="line">    localOutputParameterCache.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有4个地方调用了这个方法query、update、commit、rollback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">//如果第一次查询并且配置了查询前刷新缓存</span></span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123; <span class="comment">//清空缓存不能发生在子查询，子查询依赖了一级缓存</span></span><br><span class="line">        <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">            deferredLoad.load();</span><br><span class="line">        &#125;</span><br><span class="line">        deferredLoads.clear(); <span class="comment">// issue 601</span></span><br><span class="line">        <span class="comment">//如果缓存是作用域是 LocalCacheScope.STATEMENT也会去清空缓存</span></span><br><span class="line">        <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">            clearLocalCache(); <span class="comment">// issue 482</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Cannot commit, transaction is already closed&quot;</span>);</span><br><span class="line">  clearLocalCache();</span><br><span class="line">  flushStatements();</span><br><span class="line">  <span class="keyword">if</span> (required) &#123;</span><br><span class="line">    transaction.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">      flushStatements(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (required) &#123;</span><br><span class="line">        transaction.rollback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring一级缓存失效"><a href="#Spring一级缓存失效" class="headerlink" title="Spring一级缓存失效"></a>Spring一级缓存失效</h3><p>会话不相同，如果不配置事务，每次都会新建一个session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBySpring</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    AccountMapper mapper = context.getBean(AccountMapper.class);</span><br><span class="line">    List&lt;Account&gt; accounts1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    List&lt;Account&gt; accounts2 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(accounts1 == accounts2);  <span class="comment">//false 无法命中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>UserMapper</code>与从<code>SqlSession</code>取出的<code>UserMapper</code>不同，每次构造都会构造一个新会话，两次查询都是一个新会话。<code>SqlSession</code>和<code>Executor</code>是一对一的关系。每次查询的<code>Executor</code>不同。</p><p>开启事务,后就会有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBySpring</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    AccountMapper mapper = context.getBean(AccountMapper.class);</span><br><span class="line"></span><br><span class="line">    DataSourceTransactionManager transactionManager =(DataSourceTransactionManager) context.getBean(<span class="string">&quot;txManager&quot;</span>);</span><br><span class="line">    <span class="comment">//手动开启事务</span></span><br><span class="line">    TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());<span class="comment">// 获得事务状态</span></span><br><span class="line">    List&lt;Account&gt; accounts1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    List&lt;Account&gt; accounts2 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(accounts1 == accounts2);  <span class="comment">//false 无法命中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper -&gt; <code>SqlSessionTemplate</code> -&gt; <code>SqlSessionInterceptor</code> -&gt; <code>SqlSessionFactory</code></p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/一级缓存失效.png" alt="image-20220414222558730" style="zoom:80%;"><p>动态代理嵌入动态代理最终调用<code>Mybatis</code>的 <code>SqlSessionFactory</code></p><p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E8%B0%83%E8%AF%95.png" alt="image-20220414222932796"></p><p>这里的<code>sqlSession</code>是<code>SqlSessionTemplate</code>,<code>sqlSessionProxy</code>就是<code>SqlSessionInterceptor</code></p><h4 id="SqlSessionTemplate"><a href="#SqlSessionTemplate" class="headerlink" title="SqlSessionTemplate"></a>SqlSessionTemplate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionTemplate</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ExecutorType executorType;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy; <span class="comment">//这里还是一个SqlSession</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PersistenceExceptionTranslator exceptionTranslator;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="params"><span class="function">      PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    notNull(sqlSessionFactory, <span class="string">&quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;</span>);</span><br><span class="line">    notNull(executorType, <span class="string">&quot;Property &#x27;executorType&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">    <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">     <span class="comment">//JDK的动态代理，所有的都在SqlSessionInterceptor，这个就是动态代理</span></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(</span><br><span class="line">        SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[] &#123; SqlSession.class &#125;,</span><br><span class="line">        <span class="keyword">new</span> SqlSessionInterceptor());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过2层的动态代理，实现Spring的事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="comment">//从这里获取SqlSession</span></span><br><span class="line">    SqlSession sqlSession = getSqlSession(</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory,</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.executorType,</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object result = method.invoke(sqlSession, args);</span><br><span class="line">      <span class="keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory)) &#123;</span><br><span class="line">        <span class="comment">// force commit even on non-dirty sessions because some databases require</span></span><br><span class="line">        <span class="comment">// a commit/rollback before calling close()</span></span><br><span class="line">        sqlSession.commit(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      Throwable unwrapped = unwrapThrowable(t);</span><br><span class="line">      <span class="keyword">if</span> (SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator != <span class="keyword">null</span> &amp;&amp; unwrapped <span class="keyword">instanceof</span> PersistenceException) &#123;</span><br><span class="line">        <span class="comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span></span><br><span class="line">        closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">        sqlSession = <span class="keyword">null</span>;</span><br><span class="line">        Throwable translated = SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);</span><br><span class="line">        <span class="keyword">if</span> (translated != <span class="keyword">null</span>) &#123;</span><br><span class="line">          unwrapped = translated;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> unwrapped;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取会话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  notNull(sessionFactory, <span class="string">&quot;No SqlSessionFactory specified&quot;</span>);</span><br><span class="line">  notNull(executorType, <span class="string">&quot;No ExecutorType specified&quot;</span>);</span><br><span class="line">  <span class="comment">//SqlSessionHolder就是一个ThreadLocal变量,如果当前的事务是打开的，就可以获得事务</span></span><br><span class="line">  SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (holder != <span class="keyword">null</span> &amp;&amp; holder.isSynchronizedWithTransaction()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (holder.getExecutorType() != executorType) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TransientDataAccessResourceException(<span class="string">&quot;Cannot change the ExecutorType when there is an existing transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    holder.requested();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Fetched SqlSession [&quot;</span> + holder.getSqlSession() + <span class="string">&quot;] from current transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获得事务</span></span><br><span class="line">    <span class="keyword">return</span> holder.getSqlSession();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Creating a new SqlSession&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//获得新事务</span></span><br><span class="line">  SqlSession session = sessionFactory.openSession(executorType);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将断点打在holder，通过堆栈查看</p><p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%A0%86%E6%A0%88.png" alt="image-20220417141343151"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">    <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用SqlSessionTemplate的方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionProxy.&lt;E&gt; selectList(statement, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>invoke的动态代理是<code>Mybatis</code>的动态代理,<strong>这里的<code>sqlSession</code>是<code>SqlSessionTemplate</code></strong>,原本的<code>SqlSession</code>是<code>DefaultSqlSession</code>。发起会话的调用是会调用到<code>SqlSessionTemplate</code>的逻辑。但是<code>SqlSessionTemplate</code>没有能力发起对<code>Mybatis</code>代码的代用，所以最终还是会调用<code>DefaultSqlSession</code>中的逻辑，<strong>而<code>SqlSessionTemplate</code>中的每个方法都会打开会话构造<code>SqlSession</code></strong>，所以将这些方法中构造<code>DefaultSqlSession</code>的逻辑使用动态代理来实现。</p><p>而<code>getSqlSession</code>方法获取<code>SqlSession</code>,不使用事务时，每次从获取一个<code>SqlSession</code>都是null，都会使用工厂方法创建一个<code>SqlSession</code>，然后注册到事务上，当方法中<strong>不使用事务时，就会注册失败。</strong>每次的SqlSession都是新构建的，所以无法命中一级缓存。</p><h2 id="二、二级缓存"><a href="#二、二级缓存" class="headerlink" title="二、二级缓存"></a>二、二级缓存</h2><h3 id="定义和需求"><a href="#定义和需求" class="headerlink" title="定义和需求"></a>定义和需求</h3><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/缓存体系.png" alt="image-20220417143217651" style="zoom:80%;"><p><code>Mybatis</code>中是先走会话，再走二级缓存，再走一级缓存。</p><h4 id="二级缓存定义："><a href="#二级缓存定义：" class="headerlink" title="二级缓存定义："></a>二级缓存定义：</h4><p>二级缓存也称作是应用级缓存，与一级缓存不同的是它的<strong>作用范围是整个应用</strong>，而宜可以<strong>跨线程使用</strong>。所以二级缓存有更高的命中率，适合<strong>缓存一些修改较少的数据</strong>。</p><h4 id="二级缓存扩展性要求"><a href="#二级缓存扩展性要求" class="headerlink" title="二级缓存扩展性要求"></a>二级缓存扩展性要求</h4><p>因为二级缓存是应用级别的缓存，必然对缓存有所要求。</p><ol><li>存储：需要多种方式的缓存，分为内存、硬盘、第三方集成。</li><li>缓存策略：当缓存到容量上限时，就需要有一些策略淘汰其中的缓存。FIFO先进先出、LRU最近最少使用。</li><li>过期清理：缓存设置过期清理。</li><li>线程安全：多线程场景下，必须保证数据一致。</li><li>命中率统计：对缓存中数据进行命中统计。</li><li>序列化：跨线程使用，2个对象必须不一样。</li><li>…</li></ol><h3 id="二级缓存组件结构"><a href="#二级缓存组件结构" class="headerlink" title="二级缓存组件结构"></a>二级缓存组件结构</h3><p>MyBatis的缓存接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mybait的二级缓存采用了装饰器加责任链的设计模式。每一层都实现自己的功能，并通过代理的方式实现Cache的所有功能。</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/二级缓存实现.png" alt="image-20220417145818712" style="zoom:80%;"><h4 id="开启mybatis二级缓存"><a href="#开启mybatis二级缓存" class="headerlink" title="开启mybatis二级缓存"></a>开启mybatis二级缓存</h4><table><thead><tr><th>配置</th><th>解释</th></tr></thead><tbody><tr><td>cacheEnabled</td><td>全局缓存开关默认true</td></tr><tr><td>useCache</td><td>statement 缓存开关默认true</td></tr><tr><td>flushCache</td><td>清除默认:修改true、查询false</td></tr><tr><td><cache>或<br>@CacheNamespace</cache></td><td>声明缓存空间</td></tr><tr><td><cache-ref>或<br>@CacheNamespaceRef</cache-ref></td><td>引用缓存空间</td></tr></tbody></table><p>配置文件中加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mapper文件中加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>就开启了二级缓存</p><p>对应的sql语句加上useCache，flushCache就会开启响应策略</p><blockquote><p><cache>和@<code>CacheNamespace</code>不是一个命名空间</cache></p></blockquote><h4 id="测试二级缓存"><a href="#测试二级缓存" class="headerlink" title="测试二级缓存"></a>测试二级缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//cache就包含了若干个缓存节点。</span></span><br><span class="line">    Cache cache = configuration.getCache(<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper&quot;</span>);</span><br><span class="line">    Account account = <span class="keyword">new</span> Account();</span><br><span class="line">    account.setId(<span class="number">1</span>);</span><br><span class="line">    account.setMoney(<span class="number">1000.0</span>);</span><br><span class="line">    account.setName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    cache.putObject(<span class="string">&quot;lq&quot;</span>, account);</span><br><span class="line">    cache.getObject(<span class="string">&quot;lq&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession session1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    AccountMapper mapper1 = session1.getMapper(AccountMapper.class);</span><br><span class="line">    mapper1.selectById(<span class="number">1</span>);</span><br><span class="line">    session1.commit();</span><br><span class="line"></span><br><span class="line">    SqlSession session2 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    AccountMapper mapper2 = session2.getMapper(AccountMapper.class);</span><br><span class="line">    mapper2.selectById(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样设计Cache就可以屏蔽内部复杂性</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/二级缓存调试.png" alt="image-20220417163913111" style="zoom: 67%;"><h4 id="二级缓存的命中条件"><a href="#二级缓存的命中条件" class="headerlink" title="二级缓存的命中条件"></a>二级缓存的命中条件</h4><ol><li>会话提交之后</li><li>Sql语句、参数相同</li><li>相同的statementID</li><li>RowBounds相同</li></ol><h3 id="二级缓存源码分析"><a href="#二级缓存源码分析" class="headerlink" title="二级缓存源码分析"></a>二级缓存源码分析</h3><h4 id="二级缓存命中"><a href="#二级缓存命中" class="headerlink" title="二级缓存命中"></a>二级缓存命中</h4><p>为什么要提交后才能命中缓存?</p><p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/%E6%8F%90%E4%BA%A4%E5%90%8E%E5%91%BD%E4%B8%AD%E7%BC%93%E5%AD%98.png" alt="image-20220417170340680"></p><p>如果不提交就命中会产生脏数据。</p><p>会话中访问缓存空间</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/二级缓存空间.png" alt="image-20220417170801574" style="zoom:80%;"><p>每次执行mapper的方法时都会把代码提交到暂存区，只有当commit时才会提交到缓冲区。</p><p>这里的缓冲区就是<code>SynchronizedCache</code></p><h4 id="二级缓存执行流程"><a href="#二级缓存执行流程" class="headerlink" title="二级缓存执行流程"></a>二级缓存执行流程</h4><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/二级缓存执行流程.png" alt="image-20220417215007525" style="zoom:67%;"><h5 id="CachingExecutor"><a href="#CachingExecutor" class="headerlink" title="CachingExecutor"></a>CachingExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//获取缓存</span></span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//清空缓存</span></span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, parameterObject, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">          <span class="comment">//通过缓存管理器获取</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">          list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578. Query must be not synchronized to prevent deadlocks</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="TransactionalCacheManager缓存管理器，管理暂存区"><a href="#TransactionalCacheManager缓存管理器，管理暂存区" class="headerlink" title="TransactionalCacheManager缓存管理器，管理暂存区"></a>TransactionalCacheManager缓存管理器，管理暂存区</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap&lt;Cache, TransactionalCache&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取缓冲区作为key,暂存区作为value</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Cache cache, CacheKey key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getTransactionalCache(cache).getObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Cache cache, CacheKey key, Object value)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TransactionalCache <span class="title">getTransactionalCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    TransactionalCache txCache = transactionalCaches.get(cache);</span><br><span class="line">    <span class="keyword">if</span> (txCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">      txCache = <span class="keyword">new</span> TransactionalCache(cache);</span><br><span class="line">      transactionalCaches.put(cache, txCache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> txCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TransactionalCache暂存区"><a href="#TransactionalCache暂存区" class="headerlink" title="TransactionalCache暂存区"></a>TransactionalCache暂存区</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// issue #116</span></span><br><span class="line">     <span class="comment">//防止缓存穿透</span></span><br><span class="line">    Object object = delegate.getObject(key);</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123; <span class="comment">//填充一个值</span></span><br><span class="line">      entriesMissedInCache.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #146</span></span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123; <span class="comment">//二级缓存有值，但是已经清空了，还是返回一个null,在同一个会话中，当先执行修改时，会清空二级缓存，但是因为没有commit不会真正清空，而在这个会话中执行查询，查到的是脏数据，所有要返回一个null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//清空，并没有清空，只是加了一个标记</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">    entriesToAddOnCommit.clear(); <span class="comment">//只是清空了暂存区</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;SqlSession原理中介绍了在SQL查询时一级缓存和二级缓存的调用过程。这里介绍一下缓存的场景和失效。&lt;/p&gt;
&lt;img src=&quot;/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/Mybatis缓存.png&quot; alt=&quot;image-20220405134607618&quot; style=&quot;zoom:80%;&quot;&gt;

&lt;h2 id=&quot;一、一级缓存&quot;&gt;&lt;a href=&quot;#一、一级缓存&quot; class=&quot;headerlink&quot; title=&quot;一、一级缓存&quot;&gt;&lt;/a&gt;一、一级缓存&lt;/h2&gt;&lt;p&gt;一级缓存与&lt;code&gt;SqlSession&lt;/code&gt;相关，是一个&lt;strong&gt;会话级别的缓存&lt;/strong&gt;，会话关闭清空缓存。在会话中一级缓存与运行时参数和操作配置相关&lt;/p&gt;
&lt;h3 id=&quot;命中场景&quot;&gt;&lt;a href=&quot;#命中场景&quot; class=&quot;headerlink&quot; title=&quot;命中场景&quot;&gt;&lt;/a&gt;命中场景&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FirstCacheTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Configuration configuration;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; SqlSession sqlSession;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Before&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException, SQLException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SqlSessionFactoryBuilder factoryBuilder = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SqlSessionFactoryBuilder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        InputStream inputStream = Resources.getResourceAsStream(&lt;span class=&quot;string&quot;&gt;&amp;quot;mybatis-config.xml&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SqlSessionFactory build = factoryBuilder.build(inputStream);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        configuration = build.getConfiguration();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sqlSession = build.openSession();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AccountMapper mapper = sqlSession.getMapper(AccountMapper.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Account&amp;gt; accounts1 = mapper.selectById(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Account&amp;gt; accounts2 = mapper.selectById(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(accounts1 == accounts2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;缓存命中有几个运行时参数要求&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sql和参数必须相同&lt;/li&gt;
&lt;li&gt;必须是相同的&lt;code&gt;statementID&lt;/code&gt;，sql相同也不行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sqlSession&lt;/code&gt;必须相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RowBounds&lt;/code&gt; 返回行返回必须相同&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;清理缓存之后就无法命中&lt;/strong&gt;，默认采用的是simple执行器，编译2次，执行2次。建议采用的reuse执行器。只有有一条执行语句加入了&lt;code&gt;flushCache=true&lt;/code&gt;等同于 &lt;code&gt;sqlSession.clearCache()&lt;/code&gt;。共有4种操作配置导致缓存无法命中的场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手动&lt;code&gt;sqlSession.clearCache()&lt;/code&gt;,&lt;code&gt;sqlSession.commit()&lt;/code&gt;, &lt;code&gt;sqlSession.rollback()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行的方法上加入&lt;code&gt;flushCache=true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;中间执行Update语句&lt;/li&gt;
&lt;li&gt;缓存作用域不是&lt;code&gt;SESSION&lt;/code&gt; 改为&lt;code&gt;STATEMENT&lt;/code&gt;这里是嵌套查询（子查询）&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>SqlSeesion原理</title>
    <link href="http://yoursite.com/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-04T09:30:09.000Z</published>
    <updated>2022-11-05T15:21:38.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、sqlSession运行过程"><a href="#一、sqlSession运行过程" class="headerlink" title="一、sqlSession运行过程"></a>一、sqlSession运行过程</h2><p>SqlSession采用了门面模式，提供了API（增删改查），辅助API（提交关闭）。</p><p>核心执行组件Executor，执行操作。提供了（改和查的操作），维护缓存，辅助API（提交、关闭执行器、批处理刷新）</p><h3 id="映射器的动态代理"><a href="#映射器的动态代理" class="headerlink" title="映射器的动态代理"></a>映射器的动态代理</h3><p>Mapper映射是通过动态代理来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是动态代理</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[]&#123;<span class="keyword">this</span>.mapperInterface&#125;, mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">        MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy(sqlSession, <span class="keyword">this</span>.mapperInterface, <span class="keyword">this</span>.methodCache);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.newInstance(mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到动态代理对接口的绑定，它的<strong>作用是生成动态代理对象</strong>，代理的方法放入<code>MapperProxy</code>类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">        <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">        <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//判断它是否是一个类</span></span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</span><br><span class="line">            <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        MapperMethod mapperMethod = (MapperMethod)<span class="keyword">this</span>.methodCache.get(method);</span><br><span class="line">        <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mapperMethod = <span class="keyword">new</span> MapperMethod(<span class="keyword">this</span>.mapperInterface, method, <span class="keyword">this</span>.sqlSession.getConfiguration());</span><br><span class="line">            <span class="keyword">this</span>.methodCache.put(method, mapperMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapperMethod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mybatis使用的是<code>InvocationHandler</code>，是一个JDK动态代理。上面运用了invoke方法。<strong>一旦mapper是一个代理对象，那么它就会运行到invoke方法里面</strong>，invoke首先判断它是否是一个类，显然这里Mapper是一个接口不是类，所以判定失败。那么就会生成<code>MapperMethod</code>对象<strong>，它是通过<code>cachedMapperMethod</code>方法对其初始化的，然后执行execute方法，把sqlSession和当前运行的参数传递进去。</strong></p><p><code>MapperMethod</code>采用<strong>命令模式</strong>运行，根据上下文跳转，它可能跳转到许多方法中，我们不需要全部明白。我们可以看到里面的<code>executeForMany</code>方法，再看看它的实现，实际上它<strong>最后就是通过sqlSession对象去运行对象的SQL</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    List result;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.method.hasRowBounds()) &#123;</span><br><span class="line">        RowBounds rowBounds = <span class="keyword">this</span>.method.extractRowBounds(args);</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.method.getReturnType().isArray() ? <span class="keyword">this</span>.convertToArray(result) : <span class="keyword">this</span>.convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><p>Mybatis映射器的XML文件的命名空间<strong>对应的便是这个接口的全路径</strong>，那么它根据全路径<strong>和方法名便能够绑定起来，通过动态代理技术，让这个接口跑起来</strong>。而后<strong>采用命令模式，最后还是使用SqlSession接口的方法使得它能够执行查询</strong>，有了这层封装我们便可以使用接口编程，这样编程就更简单了。</p><h2 id="二、SqlSession的四大对象"><a href="#二、SqlSession的四大对象" class="headerlink" title="二、SqlSession的四大对象"></a>二、SqlSession的四大对象</h2><p>Mapper执行的过程是通过 <code>Executor</code>、<code>StatementHandler</code> 、<code>ParameterHandler</code> 和 <code>ResultHandler</code>来完成数据库操作和结果返回的。</p><ul><li><code>Executor</code> 代表执行器,由它来<strong>调度</strong>StatementHandler、ParameterHandler.ResultHandler等来执行对应的SQL。</li><li><code>StatementHandler</code>的作用是<strong>使用数据库的Statement (PreparedStatement)执行操作</strong>，它是四大对象的核心，起到承上启下的作用。</li><li><code>ParameterHandler</code> 用于SQL<strong>对参数的处理</strong>。</li><li><code>ResultHandler</code>是进行<strong>最后数据集（ResultSet）的封装返回处理</strong>的。</li></ul><h3 id="执行器（Executor）"><a href="#执行器（Executor）" class="headerlink" title="执行器（Executor）"></a>执行器（Executor）</h3><p>执行器（Executor）起到了至关重要的作用。它是一个真正执行Java和数据库交互的东西。在 MyBatis中存在三种执行器。我们可以在 MyBatis 的配置文件中进行选择</p><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/Executor.png" alt="image-20220404232203027" style="zoom:80%;"><ul><li><code>SIMPLE</code>，简易执行器，不配置它就是默认执行器。</li><li><code>REUSE</code>，是一种执行器<strong>重用预处理语句</strong>。</li><li><code>BATCH</code>，执行器<strong>重用语句和批量更新</strong>，它是针对批量专用的执行器。</li></ul><p><code>Configuration</code>类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction， ExecutorTypeexecutorType)</span></span>&#123;</span><br><span class="line">executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;executorType =executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="comment">//根据配置选择执行器</span></span><br><span class="line"><span class="keyword">if</span>(ExecutorType. BATCH == executorType) &#123;</span><br><span class="line">executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE ==executorType)&#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>,transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction) ;</span><br><span class="line"><span class="keyword">if</span> (cacheEnabled)&#123;</span><br><span class="line">executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//mybatus插件，这里为我们构建一层层的动态代理对象</span></span><br><span class="line">executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单执行器"><a href="#简单执行器" class="headerlink" title="简单执行器"></a>简单执行器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//根据Configuration来构建StatementHandler</span></span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      <span class="comment">// 使用prepareStatement方法,对SQL编译并对参数进行初始化</span></span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 调用StatementHandler的 prepare()进行了预编译和基础设置</span></span><br><span class="line">    stmt = handler.prepare(connection);</span><br><span class="line">    <span class="comment">//通过StatementHandler 的 parameterize()来设置参数并执行,resultHandler 再组装查询结果返回给调用者来完成一次查询</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Executor需要2个参数configuration和transaction，configuration是从配置文件中获取，由SqlSessionFactory获取，而事务是从connection中获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> JdbcTransaction jdbcTransaction;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">&quot;jdbc:mysql://localhost:3306/ssm&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SQLException </span>&#123;</span><br><span class="line">        SqlSessionFactoryBuilder factoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        SqlSessionFactory build = factoryBuilder.build(inputStream);</span><br><span class="line">        configuration = build.getConfiguration();</span><br><span class="line">        connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br><span class="line">        jdbcTransaction = <span class="keyword">new</span> JdbcTransaction(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Executor之后，就可以通过<code>executor.doQuery()</code>执行具体的查询语句。这里需要5个参数</p><ul><li><code>MappedStatement ms</code> : SQL声明</li><li><code>Object parameter</code>: 参数</li><li><code>RowBounds rowBounds</code>: 行范围，要不要分页</li><li><code>ResultHandler resultHandler</code>: 结果处理器</li><li><code>BoundSql boundSql</code>: 动态SQL语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单执行器</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    SimpleExecutor executor = <span class="keyword">new</span> SimpleExecutor(configuration, jdbcTransaction);</span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper.selectById&quot;</span>);</span><br><span class="line">    List&lt;Object&gt; objects = executor.doQuery(ms, <span class="number">1</span>, RowBounds.DEFAULT,</span><br><span class="line">            SimpleExecutor.NO_RESULT_HANDLER,</span><br><span class="line">            ms.getBoundSql(<span class="number">10</span>));</span><br><span class="line">    System.out.println(objects);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单执行器，无论SQL是否一样，每次都会进行预编译，浪费性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt;  Preparing: select id ,name ,money from account where id = ? </span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt; Parameters: 1(Integer)</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-&lt;==      Total: 1</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-ooo Using Connection [com.mysql.jdbc.JDBC4Connection@5bb21b69]</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt;  Preparing: select id ,name ,money from account where id = ? </span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt; Parameters: 1(Integer)</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-&lt;==      Total: 1</span><br></pre></td></tr></table></figure><h4 id="批处理执行器"><a href="#批处理执行器" class="headerlink" title="批处理执行器"></a>批处理执行器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批处理</span></span><br><span class="line"><span class="comment">//批处理执行器</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        BatchExecutor executor = <span class="keyword">new</span> BatchExecutor(configuration, jdbcTransaction);</span><br><span class="line">        MappedStatement ms = configuration.getMappedStatement(<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper.selectById&quot;</span>);</span><br><span class="line">        List&lt;Object&gt; objects = executor.doQuery(ms, <span class="number">1</span>, RowBounds.DEFAULT,</span><br><span class="line">                SimpleExecutor.NO_RESULT_HANDLER,</span><br><span class="line">                ms.getBoundSql(<span class="number">10</span>));</span><br><span class="line">        System.out.println(objects);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是打印日志还是显示2次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt;  Preparing: select id ,name ,money from account where id = ? </span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt; Parameters: 1(Integer)</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-&lt;==      Total: 1</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-ooo Using Connection [com.mysql.jdbc.JDBC4Connection@c46bcd4]</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt;  Preparing: select id ,name ,money from account where id = ? </span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt; Parameters: 1(Integer)</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-&lt;==      Total: 1</span><br></pre></td></tr></table></figure><p>批处理值针对修改操作才执行一次。必须要手动刷新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批处理执行器，必须进行手动刷新</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchUpdateTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    BatchExecutor executor = <span class="keyword">new</span> BatchExecutor(configuration, jdbcTransaction);</span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper.updateAccount&quot;</span>);</span><br><span class="line">    Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Account account = <span class="keyword">new</span> Account();</span><br><span class="line">    account.setId(<span class="number">1</span>);</span><br><span class="line">    account.setName(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    account.setMoney(<span class="number">2000.0</span>);</span><br><span class="line">    map.put(<span class="string">&quot;account&quot;</span>, account);</span><br><span class="line">    <span class="comment">//需要2个参数,SQL声明，具体参数</span></span><br><span class="line">    executor.doUpdate(ms, map);</span><br><span class="line">    executor.doUpdate(ms, map);</span><br><span class="line">    executor.flushStatements(<span class="keyword">false</span>); <span class="comment">//只是在设置参数，必须手动刷新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="基础执行器"><a href="#基础执行器" class="headerlink" title="基础执行器"></a>基础执行器</h4><p>基础执行器中包含了一级缓存，query和update，这两个方法都会调用具体的方法执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Transaction transaction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;</span><br><span class="line">    <span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line">    <span class="keyword">protected</span> PerpetualCache localOutputParameterCache;</span><br><span class="line">    <span class="keyword">protected</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> queryStack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> closed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">        <span class="comment">//创建缓存key</span></span><br><span class="line">        CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">        <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//走缓存的逻辑， localCache获取本地一级缓存</span></span><br><span class="line">      queryStack++;</span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//没有就会从数据库查询</span></span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//这里就会调用子类的doQuery方法</span></span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      deferredLoads.clear(); <span class="comment">// issue 601</span></span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        clearLocalCache(); <span class="comment">// issue 482</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>SimpleExecutor和ReuseExecutor都只会进行一次调用，相同的查询会走缓存的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">baseQueryTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    SimpleExecutor executor = <span class="keyword">new</span> SimpleExecutor(configuration, jdbcTransaction);</span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper.selectById&quot;</span>);</span><br><span class="line">    executor.query(ms, <span class="number">1</span>, RowBounds.DEFAULT,</span><br><span class="line">            SimpleExecutor.NO_RESULT_HANDLER);</span><br><span class="line">    executor.query(ms, <span class="number">1</span>, RowBounds.DEFAULT,</span><br><span class="line">            SimpleExecutor.NO_RESULT_HANDLER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CachingExecutor"><a href="#CachingExecutor" class="headerlink" title="CachingExecutor"></a>CachingExecutor</h4><p><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/CacheExecutor.png" alt="image-20220404235522241"></p><p>缓存执行器，二级缓存，装饰者模式<strong>装饰了具体的Executor</strong>。二级缓存和一级缓存不同，一级缓存执行过就会缓存。二级缓存必须提交之后才会有缓存。是一个跨线程的缓存。</p><p>先走二级缓存，再走一级缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheQueryTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        SimpleExecutor executor = <span class="keyword">new</span> SimpleExecutor(configuration, jdbcTransaction);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//装饰者模式，二级缓存相关逻辑</span></span><br><span class="line">        CachingExecutor cachingExecutor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line"></span><br><span class="line">        MappedStatement ms = configuration.getMappedStatement(<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper.selectById&quot;</span>);</span><br><span class="line">        cachingExecutor.query(ms, <span class="number">1</span>, RowBounds.DEFAULT,</span><br><span class="line">                SimpleExecutor.NO_RESULT_HANDLER);</span><br><span class="line">        cachingExecutor.commit(<span class="keyword">true</span>);</span><br><span class="line">        cachingExecutor.query(ms, <span class="number">1</span>, RowBounds.DEFAULT,</span><br><span class="line">                SimpleExecutor.NO_RESULT_HANDLER);</span><br><span class="line">        cachingExecutor.commit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数据库会话器"><a href="#数据库会话器" class="headerlink" title="数据库会话器"></a>数据库会话器</h3><p>数据库会话器(StatementHandler）就是<strong>专门处理数据库会话</strong>的</p><p>JDBC处理器,基于JDBC构建Slatement并设置参数,然后执行Sql。<strong>每调用会话当中一次SQL，都会有与之相对应的且唯一的Statemet实例。</strong></p><p><code>Configuration</code>类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建的真实对象是一个RoutingStatementHandler对象,和Executor一样，用代理对象做一层层的封装</span></span><br><span class="line">  StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RoutingStatementHandler</code>不是我们真实的服务对象，它是<strong>通过适配模式找到对应的</strong><code>StatementHandler</code> 来执行的。在 MyBatis 中，StatementHandler和Executor一样分为三种:普通<code>SimpleStatementHandler</code>、预处理<code>PreparedStatementHandler</code>、存储过程<code>CallableStatementHandler</code>。</p><p>在初始化 <code>RoutingStatementHandler</code>对象的时候它会根据上下文环境决定创建哪个<code>StatementHandler</code>对象，我们看看<code>RoutingStatementHandler</code> 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StatementHandler delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库会话器定义了一个<strong>对象的适配器<code>delegate</code></strong>,它是一个<code>StatementHandler</code>接口对象，构造方法<strong>根据配置来适配对应的StatementHandler对象</strong>。它的作用是<strong>给实现类对象的使用提供一个统一、简易的使用适配器</strong>。此为对象的适配模式，可以让<strong>我们使用现有的类和方法对外提供服务，也可以根据实际的需求对外屏蔽一些方法，甚至是加入新的服务</strong>。<br>我们现在以最常用的<code>PreparedStatementHandler</code>为例,看看MyBatis是怎么执行查询的。执行器有三个主要的方法，<strong>prepare、parameterize和 query</strong>，</p><p>先看他们的父类<code>BaseStatementHandler</code>，这个类主要用于处理共性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      statement = instantiateStatement(connection);</span><br><span class="line">        <span class="comment">//设置超时时间</span></span><br><span class="line">      setStatementTimeout(statement);</span><br><span class="line">        <span class="comment">//设置返回行数</span></span><br><span class="line">      setFetchSize(statement);</span><br><span class="line">      <span class="keyword">return</span> statement;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个抽象方法来具体实现statement</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instantiateStatement()</code>方法是<strong>对SQL进行了预编译</strong>。首先<strong>，做一些基础配置，比如超时，获取的最大行数等的设置。</strong>然后，Executor 会调用<code>parameterize()</code>方法去设置参数。这个时候它是调用<code>ParameterHandler</code>去完成的，这里先看<code>StatementHandler</code>的查询方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementHandler</span> <span class="keyword">extends</span> <span class="title">BaseStatementHandler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">        ps.execute();</span><br><span class="line">        <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用参数处理器设置参数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//创建statement</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">      String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">      <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() == ResultSetType.DEFAULT) &#123;</span><br><span class="line">       <span class="comment">//这里就会创建一个预处理的Statement</span></span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在执行前参数和SQL都被prepare()方法预编译，参数在<code>parameterize()</code>方法上已经进行了设置。所以到这里已经很简单了。我们<strong>只要执行SQL，然后返回结果就可以了</strong>。执行之后我们看到了<code>ResultSetHandler</code><strong>对结果的封装和返回</strong>。</p><p>一条查询SQL的执行流程：预编译、设置参数、执行、结果集映射</p><ol><li>Executor先调用<code>StatementHandler</code> 的 <code>prepare()</code>方法<strong>预编译SQL语句</strong>，同时设置一些基本运行的参数。</li><li>然后用<code>parameterize()</code>方法启用<code>ParameterHandler</code> 设置参数，完成预编译。</li><li>跟着就是执行查询，而update()也是这样的，最后如果需要查询，我们就用<code>ResultSetHandler</code>封装结果返回给调用者。</li></ol><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/Statement处理流程.png" alt="image-20220417224757303" style="zoom:80%;"><h3 id="参数处理器"><a href="#参数处理器" class="headerlink" title="参数处理器"></a>参数处理器</h3><p>完成对预编译参数的设置，javabean转换为jdbc</p><h4 id="参数转换"><a href="#参数转换" class="headerlink" title="参数转换"></a>参数转换</h4><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/参数处理.png" alt="image-20220417230107195" style="zoom:67%;"><p><code>ParamNameResolver</code>帮助我们把参数转换为Object就是查询的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//没有Param注解 并且参数为1直接返回</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">     <span class="comment">//多参数</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">      param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">      <span class="comment">// add generic param names (param1, param2, ...)</span></span><br><span class="line">       <span class="comment">//参数 key为param注解的值，value为具体的值</span></span><br><span class="line">      <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// ensure not to overwrite parameter named with @Param</span></span><br><span class="line">      <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">        param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数映射处理"><a href="#参数映射处理" class="headerlink" title="参数映射处理"></a>参数映射处理</h4><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/参数转换.png" alt="image-20220418231724430" style="zoom:80%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//作用是返回参数对象</span></span><br><span class="line">  <span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//设置预编译SQL语句参数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看实现类<code>DefaultParameterHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">    <span class="comment">//根据sql语句中参数？解析为parameterMappings参数映射就是#&#123;&#125;中的值</span></span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    MetaObject metaObject = parameterObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : configuration.newMetaObject(parameterObject);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">         <span class="comment">//获得参数名 例如id</span></span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//如果参数类型匹配，直接放入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> </span><br><span class="line">           <span class="comment">//只有单个值才会有单个值映射处理器</span></span><br><span class="line">          (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">            <span class="comment">//如果是一个map对象</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//把map对象换成一个metaObejct,这样就可以通过属性名称获取对应的值</span></span><br><span class="line">            <span class="comment">//属性名和映射名一一对应</span></span><br><span class="line">          value = metaObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">//通过TypeHandler设置对应的值</span></span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">          <span class="comment">//这里会根据类型，自动设置sql语句的类型 </span></span><br><span class="line">        typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是从<code>parameterObject</code>对象中取参数,然后使用<code>typeHandler</code>进行参数处理，如果你有设置typeHandler，那么它就会根据签名注册的<code>typeHandler</code>对参数进行处理。而typeHandler也是在 MyBatis初始化的时候，注册在Configuration里面的，我们需要的时候可以直接拿来用。这样就完成了参数的设置。</p><h3 id="结果处理器"><a href="#结果处理器" class="headerlink" title="结果处理器"></a>结果处理器</h3><p><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8.png" alt="image-20220418233415695"></p><ul><li>ResultSetHandler：结果集处理器</li><li>ResultContext：结果提出</li><li>ResultHandler：结果处理器</li></ul><h2 id="三、SqlSession运行总结"><a href="#三、SqlSession运行总结" class="headerlink" title="三、SqlSession运行总结"></a>三、SqlSession运行总结</h2><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/SqlSession运行.png" alt="image-20220404160855195" style="zoom:80%;"><p>SqlSession是<strong>通过Executor创建StatementHandler来运行</strong>的，而<code>StatementHandler</code>要经过下<br>面三步。</p><ul><li>prepared 预编译SQL。</li><li>parameterize设置参数。</li><li>query/update执行SQL。</li></ul><p>其中parameterize是调用<code>parameterHandler</code>的方法去设置的，而参数是根据类型处理器.<code>typeHandler</code>去处理的。<code>query/update</code> 方法是通过<code>resultHandler</code>进行处理结果的封装，如果是update的语句，它就<strong>返回整数</strong>，否则它就<strong>通过<code>typeHandler</code> 处理结果类型</strong>，然后用  <code>ObjectFactory</code>提供的规则<strong>组装对象</strong>，返回给调用者。这便是SqlSession 执行的过程。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、sqlSession运行过程&quot;&gt;&lt;a href=&quot;#一、sqlSession运行过程&quot; class=&quot;headerlink&quot; title=&quot;一、sqlSession运行过程&quot;&gt;&lt;/a&gt;一、sqlSession运行过程&lt;/h2&gt;&lt;p&gt;SqlSession采用了门面模式，提供了API（增删改查），辅助API（提交关闭）。&lt;/p&gt;
&lt;p&gt;核心执行组件Executor，执行操作。提供了（改和查的操作），维护缓存，辅助API（提交、关闭执行器、批处理刷新）&lt;/p&gt;
&lt;h3 id=&quot;映射器的动态代理&quot;&gt;&lt;a href=&quot;#映射器的动态代理&quot; class=&quot;headerlink&quot; title=&quot;映射器的动态代理&quot;&gt;&lt;/a&gt;映射器的动态代理&lt;/h3&gt;&lt;p&gt;Mapper映射是通过动态代理来实现的&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MapperProxyFactory&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; mapperInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Map&amp;lt;Method, MapperMethod&amp;gt; methodCache = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ConcurrentHashMap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MapperProxyFactory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Class&amp;lt;T&amp;gt; mapperInterface)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface = mapperInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Class&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;getMapperInterface&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Map&amp;lt;Method, MapperMethod&amp;gt; &lt;span class=&quot;title&quot;&gt;getMethodCache&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.methodCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//这里就是动态代理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MapperProxy&amp;lt;T&amp;gt; mapperProxy)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Proxy.newProxyInstance(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface.getClassLoader(), &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Class[]&amp;#123;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface&amp;#125;, mapperProxy);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(SqlSession sqlSession)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MapperProxy&amp;lt;T&amp;gt; mapperProxy = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MapperProxy(sqlSession, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.methodCache);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.newInstance(mapperProxy);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里可以看到动态代理对接口的绑定，它的&lt;strong&gt;作用是生成动态代理对象&lt;/strong&gt;，代理的方法放入&lt;code&gt;MapperProxy&lt;/code&gt;类中&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MapperProxy&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InvocationHandler&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; serialVersionUID = -&lt;span class=&quot;number&quot;&gt;6424540398559729838L&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; SqlSession sqlSession;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; mapperInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Map&amp;lt;Method, MapperMethod&amp;gt; methodCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MapperProxy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(SqlSession sqlSession, Class&amp;lt;T&amp;gt; mapperInterface, Map&amp;lt;Method, MapperMethod&amp;gt; methodCache)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sqlSession = sqlSession;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface = mapperInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.methodCache = methodCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//判断它是否是一个类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Object.class.equals(method.getDeclaringClass())) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; method.invoke(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            MapperMethod mapperMethod = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.cachedMapperMethod(method);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mapperMethod.execute(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sqlSession, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; MapperMethod &lt;span class=&quot;title&quot;&gt;cachedMapperMethod&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Method method)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MapperMethod mapperMethod = (MapperMethod)&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.methodCache.get(method);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mapperMethod == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mapperMethod = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MapperMethod(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface, method, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sqlSession.getConfiguration());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.methodCache.put(method, mapperMethod);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mapperMethod;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Mybatis使用的是&lt;code&gt;InvocationHandler&lt;/code&gt;，是一个JDK动态代理。上面运用了invoke方法。&lt;strong&gt;一旦mapper是一个代理对象，那么它就会运行到invoke方法里面&lt;/strong&gt;，invoke首先判断它是否是一个类，显然这里Mapper是一个接口不是类，所以判定失败。那么就会生成&lt;code&gt;MapperMethod&lt;/code&gt;对象&lt;strong&gt;，它是通过&lt;code&gt;cachedMapperMethod&lt;/code&gt;方法对其初始化的，然后执行execute方法，把sqlSession和当前运行的参数传递进去。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MapperMethod&lt;/code&gt;采用&lt;strong&gt;命令模式&lt;/strong&gt;运行，根据上下文跳转，它可能跳转到许多方法中，我们不需要全部明白。我们可以看到里面的&lt;code&gt;executeForMany&lt;/code&gt;方法，再看看它的实现，实际上它&lt;strong&gt;最后就是通过sqlSession对象去运行对象的SQL&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="http://yoursite.com/2022/04/04/%E5%85%B6%E4%BB%96/markdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2022/04/04/%E5%85%B6%E4%BB%96/markdown%E8%AF%AD%E6%B3%95/</id>
    <published>2022-04-04T08:30:52.000Z</published>
    <updated>2022-04-04T08:47:39.858Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><h2 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h2><ul><li><p>加粗：要加粗的文字左右分别用两个*号包起来</p></li><li><p>斜体：要倾斜的文字左右分别用一个*号包起来</p></li><li><p>斜体加粗：要倾斜和加粗的文字左右分别用三个*号包起来</p></li><li><p>删除线：要加删除线的文字左右分别用两个~~号包起来</p></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;，n个…<br>貌似可以一直加下去，但没神马卵用</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p>效果如下：</p><hr><hr><hr><hr><h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &#x27;&#x27;图片title&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><p>示例：<br>![blockchain](<a href="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/">https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</a><br>u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”)</p><p>上传本地图片直接点击导航栏的图片标志，选择图片即可</p><p>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。<br>关于图床的选择<br><a href="https://www.jianshu.com/p/ea1eb11db63f">https://www.jianshu.com/p/ea1eb11db63f</a></p><h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="http://jianshu.com">简书</a><br><a href="http://baidu.com">百度</a></p><p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h2><p>无序列表</p><p>语法：<br>无序列表用 - + * 任何一种都可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>语法：<br>数字加点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><p>列表嵌套</p><p>上一级和下一级之间敲三个空格即可</p><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">txt姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure><p>效果如下：<br>姓名|技能|排行<br>–|:–:|–:<br>刘备|哭|大哥<br>关羽|打|二哥<br>张飞|骂|三弟</p><h2 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h2><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><blockquote><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p></blockquote><h2 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;```</span><br></pre></td></tr></table></figure><p>效果如下：</p><pre><code class="flow">st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;```</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。&lt;/p&gt;
&lt;h2 id=&quot;一、标题&quot;&gt;&lt;a href=&quot;#一、标题&quot; class=&quot;headerlink&quot; title=&quot;一、标题&quot;&gt;&lt;/a&gt;一、标题&lt;/h2&gt;&lt;p&gt;在想要设置为标题的文字前面加#来表示&lt;br&gt;一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。&lt;/p&gt;
&lt;p&gt;注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 这是一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 这是二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 这是三级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 这是四级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 这是五级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### 这是六级标题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;二、字体&quot;&gt;&lt;a href=&quot;#二、字体&quot; class=&quot;headerlink&quot; title=&quot;二、字体&quot;&gt;&lt;/a&gt;二、字体&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;加粗：要加粗的文字左右分别用两个*号包起来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;斜体：要倾斜的文字左右分别用一个*号包起来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;斜体加粗：要倾斜和加粗的文字左右分别用三个*号包起来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除线：要加删除线的文字左右分别用两个~~号包起来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;**这是加粗的文字**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*这是倾斜的文字*`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***这是斜体加粗的文字***&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~~这是加删除线的文字~~&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis原理</title>
    <link href="http://yoursite.com/2022/04/03/%E6%A1%86%E6%9E%B6/mybatis/MyBatis%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2022/04/03/%E6%A1%86%E6%9E%B6/mybatis/MyBatis%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-03T14:56:26.000Z</published>
    <updated>2022-04-04T09:29:56.832Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis的解析和运行原理</p><p>MyBatis 的运行分为两大部分，第一部分是读取配置文件缓存到Configuration对象，用以创建SqISessionFactory,第二部分是SqISession的执行过程。</p><h2 id="构建SqlSessionFactory过程"><a href="#构建SqlSessionFactory过程" class="headerlink" title="构建SqlSessionFactory过程"></a>构建<code>SqlSessionFactory</code>过程</h2><ol><li>通过<code>org.apache.ibatis.builder.xm1.XMLConfigBuilder</code>解析配置的XML文件，读出配置参数，并将读取的数据存入这个<code>org.apache.ibatis.session.Configuration</code>类中。注意，<code>MyBatis</code> 几乎所有的配置都是存在这里的。</li><li>使用<code>Confinguration</code>对象去创建<code>SqISessionFactory</code>。<code>MyBatis</code>中的<code>SqISessionFactory</code>是一个接口，而不是实现类，为此 MyBatis 提供了一个默认的SqISessionFactory’实现类，我们一般都会使用它<code>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory</code>。</li></ol><p>这种创建的方式就是一种 Builder模式。对于复杂的对象而言，<strong>直接使用构造方法构建是有困难的</strong>，这会导致大量的逻辑放在构造方法中，由于对象的复杂性，在构建的时候，我们<strong>更希望一步步有秩序的来构建它，从而降低其复杂性</strong>。这个时候使用一个参数类总领全局，例如，Configuration类，然后分步构建，例如，DefaultSqSessionFactory类，就可以构建一个复杂的对象，例如，SqlSessionFactory。</p><h3 id="构建Configuration"><a href="#构建Configuration" class="headerlink" title="构建Configuration"></a>构建Configuration</h3><p>在SqlSessionFactory构建中，Configuration是最重要的，它的作用如下。</p><ul><li><strong>读入配置文件</strong>，包括基础配置的XML文件和映射器的XML文件。</li><li><strong>初始化基础配置</strong>，比如 MyBatis 的别名等，一些重要的类对象，例如，插件、映射器、ObjectFactory 和typeHandler对象。</li><li><strong>提供单例</strong>，为后续创建SessionFactory 服务并提供配置的参数。</li><li><strong>执行一些重要的对象方法</strong>，初始化配置信息。</li></ul><h3 id="映射器的内部组成"><a href="#映射器的内部组成" class="headerlink" title="映射器的内部组成"></a>映射器的内部组成</h3><p>映射器由3个部分构成</p><ul><li><code>MappedStatement</code>，它保存映射器的一个节点( <code>select|insert|delete|update</code>)。包括许多我们配置的SQL、SQL的id、缓存信息、resultMap、parameterType、resultType、languageDriver等重要配置内容。</li><li><code>SqlSource</code>，它是<strong>提供BoundSql对象的地方</strong>，它是<code>MappedStatement</code>的一个属性。</li><li><code>BoundSql</code>，它是<strong>建立SQL和参数的地方</strong>。它有3个常用的属性:SQL、parameterObject、parameterMappings。</li></ul><img src="/2022/04/03/%E6%A1%86%E6%9E%B6/mybatis/MyBatis%E5%8E%9F%E7%90%86/映射器.png" alt="image-20220404144713702" style="zoom:80%;">]]></content>
    
    
    <summary type="html">&lt;p&gt;MyBatis的解析和运行原理&lt;/p&gt;
&lt;p&gt;MyBatis 的运行分为两大部分，第一部分是读取配置文件缓存到Configuration对象，用以创建SqISessionFactory,第二部分是SqISession的执行过程。&lt;/p&gt;
&lt;h2 id=&quot;构建SqlSessionFactory过程&quot;&gt;&lt;a href=&quot;#构建SqlSessionFactory过程&quot; class=&quot;headerlink&quot; title=&quot;构建SqlSessionFactory过程&quot;&gt;&lt;/a&gt;构建&lt;code&gt;SqlSessionFactory&lt;/code&gt;过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;org.apache.ibatis.builder.xm1.XMLConfigBuilder&lt;/code&gt;解析配置的XML文件，读出配置参数，并将读取的数据存入这个&lt;code&gt;org.apache.ibatis.session.Configuration&lt;/code&gt;类中。注意，&lt;code&gt;MyBatis&lt;/code&gt; 几乎所有的配置都是存在这里的。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;Confinguration&lt;/code&gt;对象去创建&lt;code&gt;SqISessionFactory&lt;/code&gt;。&lt;code&gt;MyBatis&lt;/code&gt;中的&lt;code&gt;SqISessionFactory&lt;/code&gt;是一个接口，而不是实现类，为此 MyBatis 提供了一个默认的SqISessionFactory’实现类，我们一般都会使用它&lt;code&gt;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种创建的方式就是一种 Builder模式。对于复杂的对象而言，&lt;strong&gt;直接使用构造方法构建是有困难的&lt;/strong&gt;，这会导致大量的逻辑放在构造方法中，由于对象的复杂性，在构建的时候，我们&lt;strong&gt;更希望一步步有秩序的来构建它，从而降低其复杂性&lt;/strong&gt;。这个时候使用一个参数类总领全局，例如，Configuration类，然后分步构建，例如，DefaultSqSessionFactory类，就可以构建一个复杂的对象，例如，SqlSessionFactory。&lt;/p&gt;
&lt;h3 id=&quot;构建Configuration&quot;&gt;&lt;a href=&quot;#构建Configuration&quot; class=&quot;headerlink&quot; title=&quot;构建Configuration&quot;&gt;&lt;/a&gt;构建Configuration&lt;/h3&gt;&lt;p&gt;在SqlSessionFactory构建中，Configuration是最重要的，它的作用如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读入配置文件&lt;/strong&gt;，包括基础配置的XML文件和映射器的XML文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化基础配置&lt;/strong&gt;，比如 MyBatis 的别名等，一些重要的类对象，例如，插件、映射器、ObjectFactory 和typeHandler对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供单例&lt;/strong&gt;，为后续创建SessionFactory 服务并提供配置的参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行一些重要的对象方法&lt;/strong&gt;，初始化配置信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;映射器的内部组成&quot;&gt;&lt;a href=&quot;#映射器的内部组成&quot; class=&quot;headerlink&quot; title=&quot;映射器的内部组成&quot;&gt;&lt;/a&gt;映射器的内部组成&lt;/h3&gt;&lt;p&gt;映射器由3个部分构成&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis简介</title>
    <link href="http://yoursite.com/2022/03/30/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2022/03/30/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%AE%80%E4%BB%8B/</id>
    <published>2022-03-30T14:56:26.000Z</published>
    <updated>2022-04-04T13:40:10.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>JDBC是java提供的连接数据库的规范。</p><p>JDBC连接数据库的步骤：</p><ol><li>注册驱动和数据库信息</li><li>操作<code>Connection</code>，打开<code>Statement</code>对象</li><li>通过<code>Statement</code>执行SQL,返回结果到<code>ResultSet</code>中</li><li>使用<code>ResultSet</code>读取数据，通过代码转换为具体的POJO对象</li><li>关闭数据库。</li></ol><h3 id="ORM模型"><a href="#ORM模型" class="headerlink" title="ORM模型"></a>ORM模型</h3><p>操作数据库的过程复杂，ORM模型基于JDBC进行封装。ORM模型就是<strong>数据库的表和简单Java对象(Plain Ordinary Java Object,简称POJO)的映射关系模型</strong>，它主要解决数据库数据和POJO对象的相互映射。</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p><code>MyBatis</code>是一个半自动映射的框架。之所以称它为半自动，是因为它需要<strong>手工匹配提供POJO、SQL和映射关系</strong>。</p><h2 id="二、Mybatis的构成"><a href="#二、Mybatis的构成" class="headerlink" title="二、Mybatis的构成"></a>二、Mybatis的构成</h2><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul><li><code>SqlSessionFactoryBuilder</code>（构造器):它会<strong>根据配置信息</strong>或者代码来生成<code>SqlSessionFactory</code> （工厂接口)。</li><li><code>SqlSessionFactory</code>:依靠工厂来生成<code>SqlSession</code>(会话)。</li><li><code>SqlSession</code>:是一个既可以<strong>发送SQL去执行并返回结果</strong>,也可以获取 Mapper的接口。</li><li><code>SQL Mapper</code>:它是<code>MyBaits</code> 新设计的组件，它是<strong>由一个Java接口和XML文件(或注解）构成的</strong>，需要给出对应的SQL和映射规则。它负责发送SQL 去执行，并返回结果。</li></ul><p><img src="/2022/03/30/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%AE%80%E4%BB%8B/%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" alt="image-20220330230917222"></p><h4 id="构建SqlSessionFactory"><a href="#构建SqlSessionFactory" class="headerlink" title="构建SqlSessionFactory"></a>构建<code>SqlSessionFactory</code></h4><p>每个<code>MyBatis</code> 的应用都是以 <code>SqlSessionFactory</code> 的实例为中心的。<code>SqlSessionFactory</code> 的实例可以通过<code>SqlSessionFactoryBuilder</code> 获得。需要注意<code>SqISessionFactory</code>是一个<strong>工厂接口而不是现实类</strong>，它的任务是创建<code>SqlSession</code>。<code>SqISession</code>类似于一个JDBC 的Connection对象。<code>MyBatis</code>提供了两种模式去创建<code>SqlSessionFactory</code>:一种是XML 配置的方式,另一种是代码的方式。</p><img src="/2022/03/30/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%AE%80%E4%BB%8B/SqlSessionFactory实现类.png" alt="image-20220402194701463" style="zoom:80%;"><p>Configuration的类全限定名为<code>org.apache.ibatis.session.Configuration</code>，它在MyBatis 中将以一个<code>Configuration</code>类对象的形式存在，而这个对象将<strong>存在于整个MyBatis应用的生命期中</strong>，以便重复读取和运用。在内存中的数据是计算机系统中读取速度最快的,我们可以<strong>解析一次配置的XML文件保存到Configuration类对象中</strong>，方便我们从这个对象中读取配置信息，性能高。<strong>单例占用空间小，基本不占用存储空间，而且可以反复使用</strong>。Configuration类对象保存着我们配置在 MyBatis的信息。在MyBatis中提供了两个<code>SqlSessionFactory</code>的实现类，<code>DefaultSqISessionFactory</code>和 <code>SqISessionManager</code>。不过<code>SqlSessionManager</code>目前还没有使用，MyBatis 中目前使用的是DefaultSqISessionFactory。</p><h5 id="使用xml配置"><a href="#使用xml配置" class="headerlink" title="使用xml配置"></a>使用xml配置</h5><p>配置一个XML，包含获取数据库连接实例的数据源(<code>DataSource</code>)、决定事务范围和控制方式的事务管理器(<code>TransactionManager</code>)和映射器(SQL Mapper)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;role&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.learn.chapter2.po.Role&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义数据库信息，默认使用development数据库构建环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--采用jdbc事务管理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置数据库链接信息--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/number&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义映射器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/AccountMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>采用JDBC的事务管理模式</p><p>使用代码创建<code>SqlSessionFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseInitialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String config = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DatabaseInitialize instance = <span class="keyword">new</span> DatabaseInitialize();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DatabaseInitialize</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DatabaseInitialize <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream inputstream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputstream = Resources.getResourceAsStream(config);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputstream) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建SqlSession"><a href="#创建SqlSession" class="headerlink" title="创建SqlSession"></a>创建SqlSession</h4><p>在MyBatis 中 SqlSession接口的实现类有两个，分别是<code>DefaultSqlSession</code>和 <code>SqlSessionManager</code>。我们构建了<code>SqlSessionFactory</code>，然后生成 <code>MyBatis</code> 的门面接口 <code>SqlSession</code>。<code>SqlSession</code>接口<strong>类似于一个JDBC中的Connection接口对象</strong>，需要保证每次用完正常关闭它，所以正确的做法是把关闭<code>SqlSession</code>接口的代码写在 finally语句中保证每次都会关闭<code>SqlSession</code>，让连接资源归还给数据库。如果我们不及时关闭资源，数据库的连接资源将很快被耗尽，系统很快因为数据库资源的匮乏而瘫痪。让我们看看实现的伪代码，如代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义sqlSession</span></span><br><span class="line">sqlsession sqlsession = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//打开sqlsession会话</span></span><br><span class="line">sqlsession = sqlSessionFactory.openSession ();</span><br><span class="line">    <span class="comment">//some code ....</span></span><br><span class="line">sqlsession.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">system.err.println (ex.getMessage ( ));</span><br><span class="line">    sqlSession.rollback();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//在finally语句中确保资源被顺利关闭</span></span><br><span class="line">    <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>)&#123;</span><br><span class="line">    sqlsession.close();</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;Account&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.lq.mybatis.bean.Account&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>  <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;money&quot;</span> <span class="attr">column</span>=<span class="string">&quot;money&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;Account&quot;</span>&gt;</span></span><br><span class="line">        select id ,name ,money from account where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p>SqlSessionFactoryBuilder是利用XML或者Java编码获得资源来构建<code>SqISessionFactory</code>的，通过它可以构建多个SessionFactory。它的作用就是一个<strong>构建器</strong>，一旦我们构建了<code>SqlSessionFactory</code>，它的作用就已经完结，失去了存在的意义。所以它的<strong>生命周期只存在于方法的局部</strong>，它的作用就是生成<code>sqlSessionFactory</code>对象。</p><h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p><code>SqlSessionFactory</code>的作用是<strong>创建SqlSession</strong>,而<code>SqlSession</code>就是一个会话,相当于JDBC中的Connection对象。每次应用程序需要访问数据库，我们就要通过SqlSessionFactory 创建SqISession，所以 SqlSessionFactory应该在MyBatis应用的整个生命周期中。而如果我们多次创建同一个数据库的<code>SqlSessionFactory</code>,则每次创建<code>SqlSessionFactory</code> 会打开更多的数据库连接(Connection）资源，那么连接资源就很快会被耗尽。<strong>因此<code>SqlSessionFactory</code>的责任是唯一的，它的责任就是创建SqlSession，所以我们果断采用单例模式</strong>。</p><h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p><strong>SqlSession是一个会话</strong>，相当于JDBC的一个Connection对象，它的生命周期应该是在<strong>请求数据库处理事务的过程中</strong>。它<strong>是一个线程不安全的对象</strong>，在涉及多线程的时候我们需要特别的当心，操作数据库需要注意其隔离级别，数据库锁等高级特性。此外，每次创建的SqlSession都必须及时关闭它，它长期存在就会使数据库连接池的活动资源减少，对系统性能的影响很大。它<strong>存活于一个应用的请求和操作</strong>，可以执行多条SQL，保证事务的一致性。</p><h4 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h4><p>Mapper是一个接口，而没有任何实现类，它的<strong>作用是发送SQL</strong>，然后<strong>返回我们需要的结果</strong>，或者执行SQL从而修改数据库的数据，因此它应该<strong>在一个 SqISession事务方法之内,是一个方法级别的东西</strong>。它就如同JDBC中的一条SQL语句的执行，它最大的范围和SqlSession是相同的。</p><h2 id="三、MyBatis的解析和运行原理"><a href="#三、MyBatis的解析和运行原理" class="headerlink" title="三、MyBatis的解析和运行原理"></a>三、MyBatis的解析和运行原理</h2><p>MyBatis 的运行分为两大部分，第一部分是读取配置文件缓存到Configuration对象，用以创建SqISessionFactory,第二部分是SqISession的执行过程。</p><h3 id="构建SqlSessionFactory过程"><a href="#构建SqlSessionFactory过程" class="headerlink" title="构建SqlSessionFactory过程"></a>构建<code>SqlSessionFactory</code>过程</h3><ol><li>通过<code>org.apache.ibatis.builder.xm1.XMLConfigBuilder</code>解析配置的XML文件，读出配置参数，并将读取的数据存入这个<code>org.apache.ibatis.session.Configuration</code>类中。注意，<code>MyBatis</code> 几乎所有的配置都是存在这里的。</li><li>使用<code>Confinguration</code>对象去创建<code>SqISessionFactory</code>。<code>MyBatis</code>中的<code>SqISessionFactory</code>是一个接口，而不是实现类，为此 MyBatis 提供了一个默认的SqISessionFactory’实现类，我们一般都会使用它<code>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory</code>。</li></ol><p>这种创建的方式就是一种 Builder模式。对于复杂的对象而言，<strong>直接使用构造方法构建是有困难的</strong>，这会导致大量的逻辑放在构造方法中，由于对象的复杂性，在构建的时候，我们<strong>更希望一步步有秩序的来构建它，从而降低其复杂性</strong>。这个时候使用一个参数类总领全局，例如，Configuration类，然后分步构建，例如，DefaultSqSessionFactory类，就可以构建一个复杂的对象，例如，SqlSessionFactory。</p><h4 id="构建Configuration"><a href="#构建Configuration" class="headerlink" title="构建Configuration"></a>构建Configuration</h4><p>在SqlSessionFactory构建中，Configuration是最重要的，它的作用如下。</p><ul><li><strong>读入配置文件</strong>，包括基础配置的XML文件和映射器的XML文件。</li><li><strong>初始化基础配置</strong>，比如 MyBatis 的别名等，一些重要的类对象，例如，插件、映射器、ObjectFactory 和typeHandler对象。</li><li><strong>提供单例</strong>，为后续创建SessionFactory 服务并提供配置的参数。</li><li><strong>执行一些重要的对象方法</strong>，初始化配置信息。</li></ul><h4 id="映射器的内部组成"><a href="#映射器的内部组成" class="headerlink" title="映射器的内部组成"></a>映射器的内部组成</h4><p>映射器由3个部分构成</p><ul><li><code>MappedStatement</code>，它保存映射器的一个节点( <code>select|insert|delete|update</code>)。包括许多我们配置的SQL、SQL的id、缓存信息、resultMap、parameterType、resultType、languageDriver等重要配置内容。</li><li><code>SqlSource</code>，它是<strong>提供BoundSql对象的地方</strong>，它是<code>MappedStatement</code>的一个属性。</li><li><code>BoundSql</code>，它是<strong>建立SQL和参数的地方</strong>。它有3个常用的属性:SQL、parameterObject、parameterMappings。</li></ul><img src="/2022/03/30/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%AE%80%E4%BB%8B/映射器.png" alt="image-20220404144713702" style="zoom:80%;"><h3 id="sqlSession运行过程"><a href="#sqlSession运行过程" class="headerlink" title="sqlSession运行过程"></a>sqlSession运行过程</h3><h4 id="映射器的动态代理"><a href="#映射器的动态代理" class="headerlink" title="映射器的动态代理"></a>映射器的动态代理</h4><p>Mapper映射是通过动态代理来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是动态代理</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[]&#123;<span class="keyword">this</span>.mapperInterface&#125;, mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">        MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy(sqlSession, <span class="keyword">this</span>.mapperInterface, <span class="keyword">this</span>.methodCache);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.newInstance(mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到动态代理对接口的绑定，它的<strong>作用是生成动态代理对象</strong>，代理的方法放入<code>MapperProxy</code>类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">        <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">        <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//判断它是否是一个类</span></span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</span><br><span class="line">            <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        MapperMethod mapperMethod = (MapperMethod)<span class="keyword">this</span>.methodCache.get(method);</span><br><span class="line">        <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mapperMethod = <span class="keyword">new</span> MapperMethod(<span class="keyword">this</span>.mapperInterface, method, <span class="keyword">this</span>.sqlSession.getConfiguration());</span><br><span class="line">            <span class="keyword">this</span>.methodCache.put(method, mapperMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapperMethod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mybatis使用的是<code>InvocationHandler</code>，是一个JDK动态代理。上面运用了invoke方法。<strong>一旦mapper是一个代理对象，那么它就会运行到invoke方法里面</strong>，invoke首先判断它是否是一个类，显然这里Mapper是一个接口不是类，所以判定失败。那么就会生成<code>MapperMethod</code>对象<strong>，它是通过<code>cachedMapperMethod</code>方法对其初始化的，然后执行execute方法，把sqlSession和当前运行的参数传递进去。</strong></p><p><code>MapperMethod</code>采用<strong>命令模式</strong>运行，根据上下文跳转，它可能跳转到许多方法中，我们不需要全部明白。我们可以看到里面的<code>executeForMany</code>方法，再看看它的实现，实际上它<strong>最后就是通过sqlSession对象去运行对象的SQL</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    List result;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.method.hasRowBounds()) &#123;</span><br><span class="line">        RowBounds rowBounds = <span class="keyword">this</span>.method.extractRowBounds(args);</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.method.getReturnType().isArray() ? <span class="keyword">this</span>.convertToArray(result) : <span class="keyword">this</span>.convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><p>Mybatis映射器的XML文件的命名空间<strong>对应的便是这个接口的全路径</strong>，那么它根据全路径<strong>和方法名便能够绑定起来，通过动态代理技术，让这个接口跑起来</strong>。而后<strong>采用命令模式，最后还是使用SqlSession接口的方法使得它能够执行查询</strong>，有了这层封装我们便可以使用接口编程，这样编程就更简单了。</p><h3 id="SqlSession的四大对象"><a href="#SqlSession的四大对象" class="headerlink" title="SqlSession的四大对象"></a>SqlSession的四大对象</h3><p>Mapper执行的过程是通过 <code>Executor</code>、<code>StatementHandler</code> 、<code>ParameterHandler</code> 和 <code>ResultHandler</code>来完成数据库操作和结果返回的。</p><ul><li><code>Executor</code> 代表执行器,由它来<strong>调度</strong>StatementHandler、ParameterHandler.ResultHandler等来执行对应的SQL。</li><li><code>StatementHandler</code>的作用是<strong>使用数据库的Statement (PreparedStatement)执行操作</strong>，它是四大对象的核心，起到承上启下的作用。</li><li><code>ParameterHandler</code> 用于SQL<strong>对参数的处理</strong>。</li><li><code>ResultHandler</code>是进行<strong>最后数据集（ResultSet）的封装返回处理</strong>的。</li></ul><h4 id="执行器（Executor）"><a href="#执行器（Executor）" class="headerlink" title="执行器（Executor）"></a>执行器（Executor）</h4><p>执行器（Executor）起到了至关重要的作用。它是一个真正执行Java和数据库交互的东西。在 MyBatis中存在三种执行器。我们可以在 MyBatis 的配置文件中进行选择</p><ul><li><code>SIMPLE</code>，简易执行器，不配置它就是默认执行器。</li><li><code>REUSE</code>，是一种执行器<strong>重用预处理语句</strong>。</li><li><code>BATCH</code>，执行器<strong>重用语句和批量更新</strong>，它是针对批量专用的执行器。</li></ul><p><code>Configuration</code>类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction， ExecutorTypeexecutorType)</span></span>&#123;</span><br><span class="line">executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;executorType =executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="comment">//根据配置选择执行器</span></span><br><span class="line"><span class="keyword">if</span>(ExecutorType. BATCH == executorType) &#123;</span><br><span class="line">executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE ==executorType)&#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>,transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction) ;</span><br><span class="line"><span class="keyword">if</span> (cacheEnabled)&#123;</span><br><span class="line">executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//mybatus插件，这里为我们构建一层层的动态代理对象</span></span><br><span class="line">executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<code>SimpleExecutor</code>为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//根据Configuration来构建StatementHandler</span></span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      <span class="comment">// 使用prepareStatement方法,对SQL编译并对参数进行初始化</span></span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 调用StatementHandler的 prepare()进行了预编译和基础设置</span></span><br><span class="line">    stmt = handler.prepare(connection);</span><br><span class="line">    <span class="comment">//通过StatementHandler 的 parameterize()来设置参数并执行,resultHandler 再组装查询结果返回给调用者来完成一次查询</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据库会话器"><a href="#数据库会话器" class="headerlink" title="数据库会话器"></a>数据库会话器</h4><p>数据库会话器(StatementHandler）就是<strong>专门处理数据库会话</strong>的</p><p><code>Configuration</code>类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建的真实对象是一个RoutingStatementHandler对象,和Executor一样，用代理对象做一层层的封装</span></span><br><span class="line">  StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RoutingStatementHandler</code>不是我们真实的服务对象，它是<strong>通过适配模式找到对应的</strong><code>StatementHandler</code> 来执行的。在 MyBatis 中，StatementHandler和Executor一样分为三种:<code>SimpleStatementHandler</code>、<code>PreparedStatementHandler</code>、<code>CallableStatementHandler</code>。</p><p>在初始化 <code>RoutingStatementHandler</code>对象的时候它会根据上下文环境决定创建哪个<code>StatementHandler</code>对象，我们看看<code>RoutingStatementHandler</code> 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StatementHandler delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库会话器定义了一个<strong>对象的适配器<code>delegate</code></strong>,它是一个<code>StatementHandler</code>接口对象，构造方法<strong>根据配置来适配对应的StatementHandler对象</strong>。它的作用是<strong>给实现类对象的使用提供一个统一、简易的使用适配器</strong>。此为对象的适配模式，可以让<strong>我们使用现有的类和方法对外提供服务，也可以根据实际的需求对外屏蔽一些方法，甚至是加入新的服务</strong>。<br>我们现在以最常用的<code>PreparedStatementHandler</code>为例,看看MyBatis是怎么执行查询的。执行器有三个主要的方法，prepare、parameterize和 query，</p><p>先看他们的父类<code>BaseStatementHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      statement = instantiateStatement(connection);</span><br><span class="line">      setStatementTimeout(statement);</span><br><span class="line">      setFetchSize(statement);</span><br><span class="line">      <span class="keyword">return</span> statement;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instantiateStatement()</code>方法是<strong>对SQL进行了预编译</strong>。首先<strong>，做一些基础配置，比如超时，获取的最大行数等的设置。</strong>然后，Executor 会调用<code>parameterize()</code>方法去设置参数。这个时候它是调用<code>ParameterHandler</code>去完成的，这里先看<code>StatementHandler</code>的查询方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementHandler</span> <span class="keyword">extends</span> <span class="title">BaseStatementHandler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">        ps.execute();</span><br><span class="line">        <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在执行前参数和SQL都被prepare()方法预编译，参数在<code>parameterize()</code>方法上已经进行了设置。所以到这里已经很简单了。我们<strong>只要执行SQL，然后返回结果就可以了</strong>。执行之后我们看到了<code>ResultSetHandler</code><strong>对结果的封装和返回</strong>。</p><p>一条查询SQL的执行流程</p><ol><li>Executor先调用<code>StatementHandler</code> 的 <code>prepare()</code>方法<strong>预编译SQL语句</strong>，同时设置一些基本运行的参数。</li><li>然后用<code>parameterize()</code>方法启用<code>ParameterHandler</code> 设置参数，完成预编译。</li><li>跟着就是执行查询，而update()也是这样的，最后如果需要查询，我们就用<code>ResultSetHandler</code>封装结果返回给调用者。</li></ol><h4 id="参数处理器"><a href="#参数处理器" class="headerlink" title="参数处理器"></a>参数处理器</h4><p>完成对预编译参数的设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//作用是返回参数对象</span></span><br><span class="line">  <span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//设置预编译SQL语句参数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看实现类<code>DefaultParameterHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    MetaObject metaObject = parameterObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : configuration.newMetaObject(parameterObject);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          value = metaObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">        typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是从<code>parameterObject</code>对象中取参数,然后使用<code>typeHandler</code>进行参数处理，如果你有设置typeHandler，那么它就会根据签名注册的<code>typeHandler</code>对参数进行处理。而typeHandler也是在 MyBatis初始化的时候，注册在Configuration里面的，我们需要的时候可以直接拿来用。这样就完成了参数的设置。</p><h4 id="结果处理器"><a href="#结果处理器" class="headerlink" title="结果处理器"></a>结果处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//包装结果集</span></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">//处理存储过程输出参数的</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleOutputParameters</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultResultSetHandler</code>，在默认的情况下都是通过这个类进行处理的。这个实现有些复杂，它涉及使用<code>JAVASSIST</code> 或者<code>CGLIB</code>作为<strong>延迟加载</strong>，然后通过<code>typeHandler</code>和<code>ObjectFactory</code><strong>进行组装结果再返回</strong>，因为我们需要改变它们的概率很小。</p><h3 id="SqlSession运行总结"><a href="#SqlSession运行总结" class="headerlink" title="SqlSession运行总结"></a>SqlSession运行总结</h3><img src="/2022/03/30/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%AE%80%E4%BB%8B/SqlSession运行.png" alt="image-20220404160855195" style="zoom:80%;"><p>SqlSession是<strong>通过Executor创建StatementHandler来运行</strong>的，而<code>StatementHandler</code>要经过下<br>面三步。</p><ul><li>prepared 预编译SQL。</li><li>parameterize设置参数。</li><li>query/update执行SQL。</li></ul><p>其中parameterize是调用<code>parameterHandler</code>的方法去设置的，而参数是根据类型处理器.<code>typeHandler</code>去处理的。<code>query/update</code> 方法是通过<code>resultHandler</code>进行处理结果的封装，如果是update的语句，它就<strong>返回整数</strong>，否则它就<strong>通过<code>typeHandler</code> 处理结果类型</strong>，然后用  <code>ObjectFactory</code>提供的规则<strong>组装对象</strong>，返回给调用者。这便是SqlSession 执行的过程。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;h3 id=&quot;JDBC&quot;&gt;&lt;a href=&quot;#JDBC&quot; class=&quot;headerlink&quot; title=&quot;JDBC&quot;&gt;&lt;/a&gt;JDBC&lt;/h3&gt;&lt;p&gt;JDBC是java提供的连接数据库的规范。&lt;/p&gt;
&lt;p&gt;JDBC连接数据库的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册驱动和数据库信息&lt;/li&gt;
&lt;li&gt;操作&lt;code&gt;Connection&lt;/code&gt;，打开&lt;code&gt;Statement&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Statement&lt;/code&gt;执行SQL,返回结果到&lt;code&gt;ResultSet&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;ResultSet&lt;/code&gt;读取数据，通过代码转换为具体的POJO对象&lt;/li&gt;
&lt;li&gt;关闭数据库。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;ORM模型&quot;&gt;&lt;a href=&quot;#ORM模型&quot; class=&quot;headerlink&quot; title=&quot;ORM模型&quot;&gt;&lt;/a&gt;ORM模型&lt;/h3&gt;&lt;p&gt;操作数据库的过程复杂，ORM模型基于JDBC进行封装。ORM模型就是&lt;strong&gt;数据库的表和简单Java对象(Plain Ordinary Java Object,简称POJO)的映射关系模型&lt;/strong&gt;，它主要解决数据库数据和POJO对象的相互映射。&lt;/p&gt;
&lt;h3 id=&quot;Mybatis&quot;&gt;&lt;a href=&quot;#Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Mybatis&quot;&gt;&lt;/a&gt;Mybatis&lt;/h3&gt;&lt;p&gt;&lt;code&gt;MyBatis&lt;/code&gt;是一个半自动映射的框架。之所以称它为半自动，是因为它需要&lt;strong&gt;手工匹配提供POJO、SQL和映射关系&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二、Mybatis的构成&quot;&gt;&lt;a href=&quot;#二、Mybatis的构成&quot; class=&quot;headerlink&quot; title=&quot;二、Mybatis的构成&quot;&gt;&lt;/a&gt;二、Mybatis的构成&lt;/h2&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper源码</title>
    <link href="http://yoursite.com/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/</id>
    <published>2022-03-27T05:53:21.000Z</published>
    <updated>2022-03-30T12:28:19.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据存储"><a href="#一、数据存储" class="headerlink" title="一、数据存储"></a>一、数据存储</h2><p>持久化</p><p>Leader 和 Follower 中的数据会在<strong>内存和磁盘中各保存一份</strong>。所以需要将内存中的数据持久化到磁盘中。<br>在<code>org.apache.zookeeper.server.persistence</code>包下的相关类都是序列化相关的代码。</p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/持久化.png" alt="image-20220327142001515" style="zoom: 67%;"><p>处理日志接口<code>TxnLog</code></p><p>处理快照接口<code>SnapShot</code></p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/序列化.png" alt="image-20220327143155959" style="zoom: 67%;"><p><code>zookeeper-jute</code>代码是关于Zookeeper序列化相关源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface InputArchive</span><br><span class="line">interface OutputArchive</span><br></pre></td></tr></table></figure><h2 id="二、服务端初始源码"><a href="#二、服务端初始源码" class="headerlink" title="二、服务端初始源码"></a>二、服务端初始源码</h2><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/zk%E5%90%AF%E5%8A%A8.png" alt="image-20220327144747642"></p><h3 id="zkServer-sh"><a href="#zkServer-sh" class="headerlink" title="zkServer.sh"></a>zkServer.sh</h3><p>从zk的脚本看加载的类是<code>org.apache.zookeeper.server.quorum.QuorumPeerMain</code></p><p>加载的配置的<code>zkEnv.sh</code>中的<code>zoo.cfg</code></p><h3 id="QuorumPeerMain"><a href="#QuorumPeerMain" class="headerlink" title="QuorumPeerMain"></a>QuorumPeerMain</h3><ol><li><p>main方法中初始化一个<code>QuorumPeerMain</code>对象，调用<code>initializeAndRun()</code>方法王超初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeAndRun</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ConfigException, IOException, AdminServerException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QuorumPeerConfig config = <span class="keyword">new</span> QuorumPeerConfig();</span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">        config.parse(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start and schedule the the purge task</span></span><br><span class="line">    DatadirCleanupManager purgeMgr = <span class="keyword">new</span> DatadirCleanupManager(config</span><br><span class="line">            .getDataDir(), config.getDataLogDir(), config</span><br><span class="line">            .getSnapRetainCount(), config.getPurgeInterval());</span><br><span class="line">    purgeMgr.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span> &amp;&amp; config.isDistributed()) &#123;</span><br><span class="line">        runFromConfig(config);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Either no config or no quorum defined in config, running &quot;</span></span><br><span class="line">                + <span class="string">&quot; in standalone mode&quot;</span>);</span><br><span class="line">        <span class="comment">// there is only server in the quorum -- run as standalone</span></span><br><span class="line">        ZooKeeperServerMain.main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>initializeAndRun</code>的第一步就是new一个<code>QuorumPeerConfig</code>对象，调用<code>parse</code>解析参数，通过文件流的方式读取参数， <code>parseProperties</code>方法读取参数，最后调用<code>setupQuorumPeerConfig</code>进一步解析参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupQuorumPeerConfig</span><span class="params">(Properties prop, <span class="keyword">boolean</span> configBackwardCompatibilityMode)</span> <span class="keyword">throws</span> IOException, ConfigException </span>&#123;</span><br><span class="line">    quorumVerifier = parseDynamicConfig(prop, electionAlg, <span class="keyword">true</span>, configBackwardCompatibilityMode);</span><br><span class="line">    setupMyId();  <span class="comment">//读取myid赋值给serverId</span></span><br><span class="line">    setupClientPort();<span class="comment">//设置客户端端口</span></span><br><span class="line">    setupPeerType();</span><br><span class="line">    checkValidity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二步new一个 <code>DatadirCleanupManager</code>，执行过期快照删除的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> DatadirCleanupManager purgeMgr = <span class="keyword">new</span> DatadirCleanupManager(config</span><br><span class="line">            .getDataDir(), config.getDataLogDir(), config</span><br><span class="line">            .getSnapRetainCount(), config.getPurgeInterval());</span><br><span class="line">    purgeMgr.start();</span><br><span class="line"><span class="comment">//config.getSnapRetainCount() 最少保留的快照数3</span></span><br><span class="line"><span class="comment">//config.getPurgeInterval() 执行删除历史快照</span></span><br></pre></td></tr></table></figure><p><code>DatadirCleanupManager</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatadirCleanupManager</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (PurgeTaskStatus.STARTED == purgeTaskStatus) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Purge task is already running.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Don&#x27;t schedule the purge task with zero or negative purge interval.</span></span><br><span class="line">        <span class="keyword">if</span> (purgeInterval &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;Purge task is not scheduled.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer = <span class="keyword">new</span> Timer(<span class="string">&quot;PurgeTask&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//启动一个线程，执行清理任务</span></span><br><span class="line">        TimerTask task = <span class="keyword">new</span> PurgeTask(dataLogDir, snapDir, snapRetainCount);</span><br><span class="line">        timer.scheduleAtFixedRate(task, <span class="number">0</span>, TimeUnit.HOURS.toMillis(purgeInterval));</span><br><span class="line"></span><br><span class="line">        purgeTaskStatus = PurgeTaskStatus.STARTED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第4步<code>runFromConfig(config)</code>,创建通信工厂，启动通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.getClientPortAddress() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">    cnxnFactory.configure(config.getClientPortAddress(),</span><br><span class="line">            config.getMaxClientCnxns(),</span><br><span class="line">            <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建通信工厂默认NIO， <code>NIOServerCnxnFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> ServerCnxnFactory <span class="title">createFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String serverCnxnFactoryName =</span><br><span class="line">        System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);</span><br><span class="line">    <span class="keyword">if</span> (serverCnxnFactoryName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)</span><br><span class="line">                .getDeclaredConstructor().newInstance();</span><br><span class="line">        LOG.info(<span class="string">&quot;Using &#123;&#125; as server connection factory&quot;</span>, serverCnxnFactoryName);</span><br><span class="line">        <span class="keyword">return</span> serverCnxnFactory;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        IOException ioe = <span class="keyword">new</span> IOException(<span class="string">&quot;Couldn&#x27;t instantiate &quot;</span></span><br><span class="line">                + serverCnxnFactoryName);</span><br><span class="line">        ioe.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ioe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>configure()</code>,初始化NIO的socket，绑定2181端口</p><p>启动对应zk</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quorumPeer.initialize();</span><br><span class="line">quorumPeer.start();</span><br><span class="line">quorumPeer.join();</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、服务端加载数据"><a href="#三、服务端加载数据" class="headerlink" title="三、服务端加载数据"></a>三、服务端加载数据</h2><ol><li>zk中的数据模型，是一棵树，<code>DataTree</code>，每个节点，叫做<code>DataNode</code></li><li>zk集群中的<code>DataTree</code>.时刻保持状态同步</li><li>Zookeeper集群中每个zk节点中，数据在内存和磁盘中都有一份完整的数据。<ul><li>内存数据:<code>DataTrees</code></li><li>磁盘数据:<strong>快照文件＋编辑日志</strong></li></ul></li></ol><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/加载数据源.png" alt="image-20220327201531840" style="zoom: 67%;"><p><code>QuorumPeer.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getView().containsKey(myid)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;My id &quot;</span> + myid + <span class="string">&quot; not in the peer list&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    loadDataBase();</span><br><span class="line">    startServerCnxnFactory();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        adminServer.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AdminServerException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Problem starting AdminServer&quot;</span>, e);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    startLeaderElection();</span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDataBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        zkDb.loadDataBase();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load the epochs</span></span><br><span class="line">        <span class="keyword">long</span> lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;</span><br><span class="line">        <span class="keyword">long</span> epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">           <span class="comment">// pick a reasonable epoch number</span></span><br><span class="line">           <span class="comment">// this should only happen once when moving to a</span></span><br><span class="line">           <span class="comment">// new code version</span></span><br><span class="line">           currentEpoch = epochOfZxid;</span><br><span class="line">           LOG.info(CURRENT_EPOCH_FILENAME</span><br><span class="line">                   + <span class="string">&quot; not found! Creating with a reasonable default of &#123;&#125;. This should only happen when you are upgrading your installation&quot;</span>,</span><br><span class="line">                   currentEpoch);</span><br><span class="line">           writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (epochOfZxid &gt; currentEpoch) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;The current epoch, &quot;</span> + ZxidUtils.zxidToString(currentEpoch) + <span class="string">&quot;, is older than the last zxid, &quot;</span> + lastProcessedZxid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">           <span class="comment">// pick a reasonable epoch number</span></span><br><span class="line">           <span class="comment">// this should only happen once when moving to a</span></span><br><span class="line">           <span class="comment">// new code version</span></span><br><span class="line">           acceptedEpoch = epochOfZxid;</span><br><span class="line">           LOG.info(ACCEPTED_EPOCH_FILENAME</span><br><span class="line">                   + <span class="string">&quot; not found! Creating with a reasonable default of &#123;&#125;. This should only happen when you are upgrading your installation&quot;</span>,</span><br><span class="line">                   acceptedEpoch);</span><br><span class="line">           writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acceptedEpoch &lt; currentEpoch) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;The accepted epoch, &quot;</span> + ZxidUtils.zxidToString(acceptedEpoch) + <span class="string">&quot; is less than the current epoch, &quot;</span> + ZxidUtils.zxidToString(currentEpoch));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException ie) &#123;</span><br><span class="line">        LOG.error(<span class="string">&quot;Unable to load database on disk&quot;</span>, ie);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unable to run quorum server &quot;</span>, ie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">loadDataBase</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//加载数据</span></span><br><span class="line">    <span class="keyword">long</span> zxid = snapLog.restore(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> zxid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//restore方法 </span></span><br><span class="line"><span class="comment">//将磁盘的数据反序列化到磁盘中</span></span><br><span class="line"><span class="comment">//如何从编辑日志中恢复数据</span></span><br></pre></td></tr></table></figure><h2 id="四、选举"><a href="#四、选举" class="headerlink" title="四、选举"></a>四、选举</h2><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95.png" alt="image-20220327203528530"></p><p>流程</p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/选举源码.png" alt="image-20220328222437258"><h3 id="选举准备"><a href="#选举准备" class="headerlink" title="选举准备"></a>选举准备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getView().containsKey(myid)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;My id &quot;</span> + myid + <span class="string">&quot; not in the peer list&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    loadDataBase();</span><br><span class="line">    startServerCnxnFactory();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        adminServer.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AdminServerException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Problem starting AdminServer&quot;</span>, e);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    startLeaderElection(); <span class="comment">//开始选举</span></span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startLeaderElection</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLeaderElection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//创建选票，myid,zxid事务id，epoch任期</span></span><br><span class="line">       <span class="keyword">if</span> (getPeerState() == ServerState.LOOKING) &#123;</span><br><span class="line">           currentVote = <span class="keyword">new</span> Vote(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">       RuntimeException re = <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">       re.setStackTrace(e.getStackTrace());</span><br><span class="line">       <span class="keyword">throw</span> re;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// if (!getView().containsKey(myid)) &#123;</span></span><br><span class="line">  <span class="comment">//      throw new RuntimeException(&quot;My id &quot; + myid + &quot; not in the peer list&quot;);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (electionType == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            udpSocket = <span class="keyword">new</span> DatagramSocket(getQuorumAddress().getPort());</span><br><span class="line">            responder = <span class="keyword">new</span> ResponderThread();</span><br><span class="line">            responder.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createElectionAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Election <span class="title">createElectionAlgorithm</span><span class="params">(<span class="keyword">int</span> electionAlgorithm)</span></span>&#123;</span><br><span class="line">    Election le=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> use a factory rather than a switch</span></span><br><span class="line">    <span class="keyword">switch</span> (electionAlgorithm) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        le = <span class="keyword">new</span> LeaderElection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="comment">//创建通讯，相关队列，创建各种队列</span></span><br><span class="line">        QuorumCnxManager qcm = createCnxnManager();</span><br><span class="line">        QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);</span><br><span class="line">        <span class="keyword">if</span> (oldQcm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Clobbering already-set QuorumCnxManager (restarting leader election?)&quot;</span>);</span><br><span class="line">            oldQcm.halt();</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//启动监听，一下线程，客户端会一直接收消息，阻塞</span></span><br><span class="line">        QuorumCnxManager.Listener listener = qcm.listener;</span><br><span class="line">        <span class="keyword">if</span>(listener != <span class="keyword">null</span>)&#123;</span><br><span class="line">            listener.start();</span><br><span class="line">            <span class="comment">//创建FastLeaderElection，创建发送队列，发送选票，创建接收队列接收选票</span></span><br><span class="line">            FastLeaderElection fle = <span class="keyword">new</span> FastLeaderElection(<span class="keyword">this</span>, qcm);</span><br><span class="line">            fle.start();</span><br><span class="line">            le = fle;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Null listener when initializing cnx manager&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> le;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选举执行"><a href="#选举执行" class="headerlink" title="选举执行"></a>选举执行</h3><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/%E9%80%89%E6%8B%A9%E6%89%A7%E8%A1%8C.png" alt="image-20220328225324352"></p><p>start方法中的<code>super.start();</code>启动线程中的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    updateThreadName();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Main loop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (running) &#123; </span><br><span class="line">            <span class="keyword">switch</span> (getPeerState()) &#123;</span><br><span class="line">            <span class="keyword">case</span> LOOKING:</span><br><span class="line">                LOG.info(<span class="string">&quot;LOOKING&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;readonlymode.enabled&quot;</span>)) &#123;</span><br><span class="line">                    LOG.info(<span class="string">&quot;Attempting to start ReadOnlyZooKeeperServer&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Create read-only server but don&#x27;t start it immediately</span></span><br><span class="line">                    <span class="keyword">final</span> ReadOnlyZooKeeperServer roZk =</span><br><span class="line">                        <span class="keyword">new</span> ReadOnlyZooKeeperServer(logFactory, <span class="keyword">this</span>, <span class="keyword">this</span>.zkDb);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Instead of starting roZk immediately, wait some grace</span></span><br><span class="line">                    <span class="comment">// period before we decide we&#x27;re partitioned.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// Thread is used here because otherwise it would require</span></span><br><span class="line">                    <span class="comment">// changes in each of election strategy classes which is</span></span><br><span class="line">                    <span class="comment">// unnecessary code coupling.</span></span><br><span class="line">                    Thread roZkMgr = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// lower-bound grace period to 2 secs</span></span><br><span class="line">                                sleep(Math.max(<span class="number">2000</span>, tickTime));</span><br><span class="line">                                <span class="keyword">if</span> (ServerState.LOOKING.equals(getPeerState())) &#123;</span><br><span class="line">                                    roZk.startup();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                LOG.info(<span class="string">&quot;Interrupted while attempting to start ReadOnlyZooKeeperServer, not started&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                LOG.error(<span class="string">&quot;FAILED to start ReadOnlyZooKeeperServer&quot;</span>, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        roZkMgr.start();</span><br><span class="line">                        reconfigFlagClear();</span><br><span class="line">                        <span class="keyword">if</span> (shuttingDownLE) &#123;</span><br><span class="line">                            shuttingDownLE = <span class="keyword">false</span>;</span><br><span class="line">                            startLeaderElection();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//设置当前选票</span></span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// If the thread is in the the grace period, interrupt</span></span><br><span class="line">                        <span class="comment">// to come out of waiting.</span></span><br><span class="line">                        roZkMgr.interrupt();</span><br><span class="line">                        roZk.shutdown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                       reconfigFlagClear();</span><br><span class="line">                        <span class="keyword">if</span> (shuttingDownLE) &#123;</span><br><span class="line">                           shuttingDownLE = <span class="keyword">false</span>;</span><br><span class="line">                           startLeaderElection();</span><br><span class="line">                           &#125;</span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           ...</span><br><span class="line">            start_fle = Time.currentElapsedTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;QuorumPeer main thread exited&quot;</span>);</span><br><span class="line">        MBeanRegistry instance = MBeanRegistry.getInstance();</span><br><span class="line">        instance.unregister(jmxQuorumBean);</span><br><span class="line">        instance.unregister(jmxLocalPeerBean);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) &#123;</span><br><span class="line">            instance.unregister(remotePeerBean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jmxQuorumBean = <span class="keyword">null</span>;</span><br><span class="line">        jmxLocalPeerBean = <span class="keyword">null</span>;</span><br><span class="line">        jmxRemotePeerBean = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lookForLeader</code>寻找Leader时</p><p>第一步,更新选择人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    logicalclock.incrementAndGet();</span><br><span class="line">    updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：发送选票<code>sendNotifications</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendNotifications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> sid : self.getCurrentAndNextConfigVoters()) &#123;</span><br><span class="line">            QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">            ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</span><br><span class="line">                    proposedLeader,</span><br><span class="line">                    proposedZxid,</span><br><span class="line">                    logicalclock.get(),</span><br><span class="line">                    QuorumPeer.ServerState.LOOKING,</span><br><span class="line">                    sid,</span><br><span class="line">                    proposedEpoch, qv.toString().getBytes());</span><br><span class="line">            <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</span><br><span class="line">                LOG.debug(<span class="string">&quot;Sending Notification: &quot;</span> + proposedLeader + <span class="string">&quot; (n.leader), 0x&quot;</span>  +</span><br><span class="line">                      Long.toHexString(proposedZxid) + <span class="string">&quot; (n.zxid), 0x&quot;</span> + Long.toHexString(logicalclock.get())  +</span><br><span class="line">                      <span class="string">&quot; (n.round), &quot;</span> + sid + <span class="string">&quot; (recipient), &quot;</span> + self.getId() +</span><br><span class="line">                      <span class="string">&quot; (myid), 0x&quot;</span> + Long.toHexString(proposedEpoch) + <span class="string">&quot; (n.peerEpoch)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//由队列发送消息</span></span><br><span class="line">            sendqueue.offer(notmsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第三步：由内部类<code>WorkerSender</code>负责发送选票，循环处理消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ToSend m = sendqueue.poll(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span>(m == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            process(m);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(<span class="string">&quot;WorkerSender is down&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ToSend m)</span> </span>&#123;</span><br><span class="line">    ByteBuffer requestBuffer = buildMsg(m.state.ordinal(),</span><br><span class="line">                                        m.leader,</span><br><span class="line">                                        m.zxid,</span><br><span class="line">                                        m.electionEpoch,</span><br><span class="line">                                        m.peerEpoch,</span><br><span class="line">                                        m.configData);</span><br><span class="line"><span class="comment">//由具体管理者发送</span></span><br><span class="line">    manager.toSend(m.sid, requestBuffer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步 由具体manager发送这里是QuorumCnxManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toSend</span><span class="params">(Long sid, ByteBuffer b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If sending message to myself, then simply enqueue it (loopback).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mySid == sid) &#123; <span class="comment">//发送给自己，添加到自己的接收队列中</span></span><br><span class="line">         b.position(<span class="number">0</span>);</span><br><span class="line">         addToRecvQueue(<span class="keyword">new</span> Message(b.duplicate(), sid));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Otherwise send to the corresponding thread to send.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//向外发</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * Start a new connection if doesn&#x27;t have one already.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         ArrayBlockingQueue&lt;ByteBuffer&gt; bq = <span class="keyword">new</span> ArrayBlockingQueue&lt;ByteBuffer&gt;(</span><br><span class="line">            SEND_CAPACITY);</span><br><span class="line">         ArrayBlockingQueue&lt;ByteBuffer&gt; oldq = queueSendMap.putIfAbsent(sid, bq);</span><br><span class="line">         <span class="keyword">if</span> (oldq != <span class="keyword">null</span>) &#123;</span><br><span class="line">             addToSendQueue(oldq, b); <span class="comment">//添加到发送队列</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             addToSendQueue(bq, b);</span><br><span class="line">         &#125;</span><br><span class="line">         connectOne(sid); <span class="comment">//连接发送的节点</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步：连接到节点,创建socket连接、接收和发送的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connectOne</span><span class="params">(<span class="keyword">long</span> sid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (senderWorkerMap.get(sid) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;There is a connection already for server &quot;</span> + sid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (self.QV_LOCK) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> knownId = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// Resolve hostname for the remote server before attempting to</span></span><br><span class="line">        <span class="comment">// connect in case the underlying ip address has changed.</span></span><br><span class="line">        self.recreateSocketAddresses(sid);</span><br><span class="line">        Map&lt;Long, QuorumPeer.QuorumServer&gt; lastCommittedView = self.getView();</span><br><span class="line">        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();</span><br><span class="line">        Map&lt;Long, QuorumPeer.QuorumServer&gt; lastProposedView = lastSeenQV.getAllMembers();</span><br><span class="line">        <span class="keyword">if</span> (lastCommittedView.containsKey(sid)) &#123;</span><br><span class="line">            knownId = <span class="keyword">true</span>;</span><br><span class="line">            LOG.debug(<span class="string">&quot;Server &#123;&#125; knows &#123;&#125; already, it is in the lastCommittedView&quot;</span>, self.getId(), sid);</span><br><span class="line">            <span class="keyword">if</span> (connectOne(sid, lastCommittedView.get(sid).electionAddr))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastSeenQV != <span class="keyword">null</span> &amp;&amp; lastProposedView.containsKey(sid)</span><br><span class="line">                &amp;&amp; (!knownId || (lastProposedView.get(sid).electionAddr !=</span><br><span class="line">                lastCommittedView.get(sid).electionAddr))) &#123;</span><br><span class="line">            knownId = <span class="keyword">true</span>;</span><br><span class="line">            LOG.debug(<span class="string">&quot;Server &#123;&#125; knows &#123;&#125; already, it is in the lastProposedView&quot;</span>, self.getId(), sid);</span><br><span class="line">            <span class="keyword">if</span> (connectOne(sid, lastProposedView.get(sid).electionAddr))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!knownId) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Invalid server id: &quot;</span> + sid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步：创建<code>SendWork</code>和<code>RecvWorker</code>，<code>SendWork</code>不断向外进行写操作，<code>RecvWorker</code>会不断接收消息添加到<code>recvQueue</code>队列中。</p><p>第七不：选举类中的<code>WorkerReceiver</code>,会不断从<code>recvQueue</code>中取得数据，处理，然后发送到接收队列<code>recequeue</code>中，选举算法就会统计这些选票有没有超过半数，超过就会成为Leader</p><h2 id="五、Follower和Leader进行状态同步"><a href="#五、Follower和Leader进行状态同步" class="headerlink" title="五、Follower和Leader进行状态同步"></a>五、Follower和Leader进行状态同步</h2><p>当选举结束后，每个节点都需要根据自己的角色更新自己的状态。<strong>选举出的Leader 更</strong><br><strong>新自己状态为Leader，其他节点更新自己状态为Follower。</strong><br>Leader 更新状态入口:<code>leader.lead()</code><br>Follower更新状态入口: <code>follower.followerLeader()</code><br>注意:</p><ol><li><strong>follower 必须要让leader 知道自己的状态</strong>: epoch、zxid、sid.<br>必须要找出谁是leader;<br>发起请求连接leader;e发送自己的信息给leader;<br>leader接收到信息，必须要返回对应的信息给follower。</li><li>当leader得知 follower的状态了,就<strong>确定需要做何种方式的数据同步</strong>DIFF、TRUNC、SNAP</li><li>执行数据同步</li><li>当leader <strong>接收到超过半数follower的 ack 之后，进入正常工作状态</strong>，集群启动完</li></ol><p>最终总结同步的方式:e</p><ol><li><code>DIFF</code> 咱两一样，不需要做什么</li><li><code>TRUNC</code> follower 的 <code>zxid</code>比 leader 的 <code>zxid</code>大，所以<strong>Follower要回滚</strong></li><li>COMMIT leader的 <code>zxid</code>,比 follower 的<code>zxid</code>,大，发送Proposal 给follower,提交执行</li><li>如果follower并没有任何数据，直接使用<code>SNAP</code>的方式来执行数据同步（直接把数裾全部序列到follower) </li></ol><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86.png" alt="image-20220328230724600"></p><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/%E5%90%8C%E6%AD%A5%E6%BA%90%E7%A0%81.png" alt="image-20220328231026796"></p><h3 id="状态变更后"><a href="#状态变更后" class="headerlink" title="状态变更后"></a>状态变更后</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> FOLLOWING:</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       LOG.info(<span class="string">&quot;FOLLOWING&quot;</span>);</span><br><span class="line">        setFollower(makeFollower(logFactory));</span><br><span class="line">        follower.followLeader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>,e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       follower.shutdown();</span><br><span class="line">       setFollower(<span class="keyword">null</span>);</span><br><span class="line">       updateServerState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> LEADING:</span><br><span class="line">    LOG.info(<span class="string">&quot;LEADING&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setLeader(makeLeader(logFactory));</span><br><span class="line">        leader.lead();</span><br><span class="line">        setLeader(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>,e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            leader.shutdown(<span class="string">&quot;Forcing shutdown&quot;</span>);</span><br><span class="line">            setLeader(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        updateServerState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Leader，会调用<code>leader.lead()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lead</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">        <span class="comment">//对每个节点创建接收，得到follower的注册</span></span><br><span class="line">     cnxAcceptor = <span class="keyword">new</span> LearnerCnxAcceptor();</span><br><span class="line">     cnxAcceptor.start();</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">         Socket s = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">boolean</span> error = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             s = ss.accept();</span><br><span class="line"></span><br><span class="line">             <span class="comment">// start with the initLimit, once the ack is processed</span></span><br><span class="line">             <span class="comment">// in LearnerHandler switch to the syncLimit</span></span><br><span class="line">             s.setSoTimeout(self.tickTime * self.initLimit);</span><br><span class="line">             s.setTcpNoDelay(nodelay);</span><br><span class="line"></span><br><span class="line">             BufferedInputStream is = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                 s.getInputStream());</span><br><span class="line">             <span class="comment">//为每个follower创建LearnerHandler</span></span><br><span class="line">             LearnerHandler fh = <span class="keyword">new</span> LearnerHandler(s, is, Leader.<span class="keyword">this</span>);</span><br><span class="line">             <span class="comment">//这里会接收到对应的消息，这里会把epochid发送给对方，并等待对方的应答，并且会通过syncFollower选择同步策略，2阶段提交</span></span><br><span class="line">             fh.start();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>FOLLOWING，<code>follower.followLeader();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">followLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">//找到leader</span></span><br><span class="line">    QuorumServer leaderServer = findLeader(); </span><br><span class="line">    <span class="comment">//连接leader</span></span><br><span class="line">    connectToLeader(leaderServer.addr, leaderServer.hostname);</span><br><span class="line">    <span class="comment">//注册，把自己的信息发送给leader，获得对应的数据</span></span><br><span class="line">    <span class="keyword">long</span> newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);</span><br><span class="line">    <span class="comment">//同步数据</span></span><br><span class="line">    syncWithLeader(newEpochZxid); </span><br><span class="line">    <span class="comment">//一直读取服务器的信息并处理 2阶段提交。提案和提交</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.isRunning()) &#123;</span><br><span class="line">        readPacket(qp);</span><br><span class="line">        processPacket(qp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> QuorumServer <span class="title">findLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QuorumServer leaderServer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Find the leader by id</span></span><br><span class="line">        Vote current = self.getCurrentVote();</span><br><span class="line">        <span class="keyword">for</span> (QuorumServer s : self.getView().values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.id == current.getId()) &#123;</span><br><span class="line">                <span class="comment">// Ensure we have the leader&#x27;s correct IP address before</span></span><br><span class="line">                <span class="comment">// attempting to connect.</span></span><br><span class="line">                s.recreateSocketAddresses();</span><br><span class="line">                leaderServer = s;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leaderServer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Couldn&#x27;t find the leader with id = &quot;</span></span><br><span class="line">                    + current.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leaderServer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="服务器Leader启动"><a href="#服务器Leader启动" class="headerlink" title="服务器Leader启动"></a>服务器Leader启动</h3><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/Leader%E5%90%AF%E5%8A%A8.png" alt="image-20220328233155546"></p><p>集群同步之后就启动服务<code>startZkServer()</code></p><p>调用Zookeeper中的<code>startup()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sessionTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">        createSessionTracker();</span><br><span class="line">    &#125;</span><br><span class="line">    startSessionTracker();</span><br><span class="line">    setupRequestProcessors();</span><br><span class="line"></span><br><span class="line">    registerJMX();</span><br><span class="line"></span><br><span class="line">    setState(State.RUNNING);</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</span><br><span class="line">    RequestProcessor syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>,</span><br><span class="line">            finalProcessor);</span><br><span class="line">    ((SyncRequestProcessor)syncProcessor).start();</span><br><span class="line">    <span class="comment">//预处理线程，会一直等待请求，并根据请求执行相关操作</span></span><br><span class="line">    firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, syncProcessor);</span><br><span class="line">    ((PrepRequestProcessor)firstProcessor).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器Follower启动"><a href="#服务器Follower启动" class="headerlink" title="服务器Follower启动"></a>服务器Follower启动</h3><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/Follower启动.png" alt="image-20220328233709486" style="zoom:80%;"><h3 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h3><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8.png" alt="image-20220328233901984"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、数据存储&quot;&gt;&lt;a href=&quot;#一、数据存储&quot; class=&quot;headerlink&quot; title=&quot;一、数据存储&quot;&gt;&lt;/a&gt;一、数据存储&lt;/h2&gt;&lt;p&gt;持久化&lt;/p&gt;
&lt;p&gt;Leader 和 Follower 中的数据会在&lt;strong&gt;内存和磁盘中各保存一份&lt;/strong&gt;。所以需要将内存中的数据持久化到磁盘中。&lt;br&gt;在&lt;code&gt;org.apache.zookeeper.server.persistence&lt;/code&gt;包下的相关类都是序列化相关的代码。&lt;/p&gt;
&lt;img src=&quot;/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/持久化.png&quot; alt=&quot;image-20220327142001515&quot; style=&quot;zoom: 67%;&quot;&gt;

&lt;p&gt;处理日志接口&lt;code&gt;TxnLog&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;处理快照接口&lt;code&gt;SnapShot&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;序列化&quot;&gt;&lt;a href=&quot;#序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化&quot;&gt;&lt;/a&gt;序列化&lt;/h3&gt;&lt;img src=&quot;/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/序列化.png&quot; alt=&quot;image-20220327143155959&quot; style=&quot;zoom: 67%;&quot;&gt;

&lt;p&gt;&lt;code&gt;zookeeper-jute&lt;/code&gt;代码是关于Zookeeper序列化相关源码&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;interface InputArchive&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;interface OutputArchive&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>分布式算法</title>
    <link href="http://yoursite.com/2022/03/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2022/03/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-26T14:35:14.000Z</published>
    <updated>2022-03-30T13:37:47.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、拜占庭将军问题"><a href="#一、拜占庭将军问题" class="headerlink" title="一、拜占庭将军问题"></a>一、拜占庭将军问题</h2><p>Zookeeper是<strong>如何保证数据一致性的</strong>?这也是困扰分布式系统框架的一个难题。</p><p>拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。<strong>叛徒可以任意行动以达到以下目标:欺骗某些将军采取进攻行动，促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动;或者迷惑某些将军，使他们无法做出决定</strong>。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。</p><h2 id="二、CAP理论"><a href="#二、CAP理论" class="headerlink" title="二、CAP理论"></a>二、CAP理论</h2><p>CAP理论告诉我们，一个分布式系统不可能同时满足以下三种</p><ul><li><strong>一致性</strong>(C:Consistency)</li><li><strong>可用性</strong>(A:Available）</li><li><strong>分区容错性</strong>（P:Partition Tolerance )</li></ul><p>这三个基本需求，最多只能同时满足其中的两项，因为P是必须的，因此往往选择就在<strong>CP</strong>或者<strong>AP</strong>中。</p><ol><li><strong>一致性</strong>(C:Consistency)：在分布式环境中，一致性是指数据在<strong>多个副本之间是否能够保持数据一致的特性</strong>。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。</li><li><strong>可用性</strong>(A:Available）：可用性是指系统提供的服务必须<strong>一直处于可用的状态</strong>，对于用户的每一个操作请求总是能够<strong>在有限的时间内返回结果</strong>。</li><li><strong>分区容错性</strong>（P:Partition Tolerance )：分布式系统在遇到任何网络分区故障的时候，<strong>仍然需要能够保证对外提供满足一致性和可用性的服务</strong>，除非是整个网络环境都发生了故障。</li></ol><h3 id="ZooKeeper保证的是CP"><a href="#ZooKeeper保证的是CP" class="headerlink" title="ZooKeeper保证的是CP"></a>ZooKeeper保证的是CP</h3><ol><li><code>ZooKeeper</code>不能保证每次服务请求的可用性。(注:<strong>在极端环境下，<code>ZooKeeper</code>可能会丢弃一些请求</strong>，消费者程序需要重新请求才能获得结果）。所以说，<code>ZooKeeper</code>不能保证服务可用性。</li><li>进行Leader<strong>选举时集群都是不可用</strong>。</li></ol><h2 id="三、2PC和3PC"><a href="#三、2PC和3PC" class="headerlink" title="三、2PC和3PC"></a>三、2PC和3PC</h2><p>当一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的ACID特性，就需要引入一个称为“<strong>协调者(Coordinator)</strong>”的组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点则被称为“参与者”(Participant)。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。</p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>二阶段提交。目前绝大多数关系型数据库采用二阶段提交完成分布式事务。将书屋分为2个阶段来进行处理。</p><h4 id="阶段一：提交事务请求"><a href="#阶段一：提交事务请求" class="headerlink" title="阶段一：提交事务请求"></a>阶段一：提交事务请求</h4><ol><li><strong>事务询问</strong><br><strong>协调者</strong>向所有的参与者发送事务内容，<strong>询问是否可以执行事务提交操作</strong>，并开始等待各参与者的响应。</li><li><strong>执行事务。</strong><br>各参与者节点执行事务操作，并将<code>Undo</code>和 <code>Redo</code>信息记入事务日志中。</li><li><strong>各参与者向协调者反馈事务询问的响应。</strong><br>如果参与者成功执行了事务操作，那么就反馈给协调者Yes 响应，表示事务可以执行﹔如果参与者没有成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行。</li></ol><p>阶段一被称为“投票阶段”，各参与者投票表明是否要继续执行下去。</p><h4 id="阶段二：执行事务提交"><a href="#阶段二：执行事务提交" class="headerlink" title="阶段二：执行事务提交"></a>阶段二：执行事务提交</h4><p>协调组根据参与者的反馈情况决定是否可以进行事务提交操作。</p><h5 id="执行事务提交"><a href="#执行事务提交" class="headerlink" title="执行事务提交"></a>执行事务提交</h5><ol><li><strong>发送提交请求</strong><br>协调者向<strong>所有参与者节点发出Commit 请求</strong>。</li><li><strong>事务提交。</strong><br>参与者接收到Commit请求后，会<strong>正式执行事务提交操作</strong>，并在完成提交之后释放在整个事务执行期间占用的事务资源。</li><li><strong>反馈事务提交结果。</strong><br>参与者在完成事务提交之后，向协调者发送 Ack 消息。</li><li><strong>完成事务。</strong><br>协调者接<strong>收到所有参与者反馈的Ack 消息后</strong>，完成事务。</li></ol><h5 id="中断事务"><a href="#中断事务" class="headerlink" title="中断事务"></a>中断事务</h5><p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p><ol><li><strong>发送回滚请求</strong>。<br>协调者向所有参与者节点发出<code>Rollback</code> 请求。</li><li><strong>事务回滚</strong>。<br>参与者接收到Rollback 请求后，会利用其在<strong>阶段一中记录的Undo信息来执行事务回滚操作</strong>，并在完成回滚之后释放在整个事务执行期间占用的资源。</li><li><strong>反馈事务回滚结果</strong>。<br>参与者在完成事务回滚之后，向协调者发送 Ack 消息。</li><li><strong>中断事务</strong>。<br>协调者接收到所有参与者反馈的Ack 消息后，完成事务中断。</li></ol><p>二阶段提交核心是采用先尝试后提交的处理方式，二阶段提交是一个强一致性算法</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：简单，实现方便</p><p>缺点：同步阻塞、单点问题、脑裂、太过保守</p><ol><li><strong>同步阻塞</strong><br>最明显也是最大的一个问题就是同步阻塞,这会极大地限制分布式系统的性能。在二阶段<strong>提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态</strong>。</li><li><strong>单点问题</strong><br>协调者的角色在整个二阶段提交协议中起到了非常重要的作用。<strong>一旦协调者出现问题，那么整个二阶段提交流程将无法运转</strong>，更为严重的是，如果协调者是在<strong>阶段二中出现问题</strong>的话，那么其他参与者将会·<strong>一直处于锁定事务资源的状态</strong>中，而无法继续完成事务操作。</li><li><strong>数据不一致</strong><br>在二阶段提交协议的阶段二，执行事务提交的时候，当协调者向所有的参与者发送Commit请求之后，发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终<strong>只有部分参与者收到了Commit请求</strong>。于是，这部分收到了Commit请求的参与者就会进行事务的提交，而其他没有收到Commit请求的参与者则无法进行事务提交。</li><li><strong>太过保守</strong><br>如果在协调者指示参与者进行事务提交询问的过程中,参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务。二阶段提交协议没有设计较为完善的容错机制,<strong>任意一个节点的失败都会导致整个事务的失败。</strong></li></ol><h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>3PC，是Three-Phase Commit的缩写，即三阶段提交,将二阶段提交协议的“<strong>提交事务请求</strong>“过程一分为二,形成了由<code>CanCommit</code>, <code>PreCommit</code>和 <code>do Commit</code></p><h4 id="CanCommit"><a href="#CanCommit" class="headerlink" title="CanCommit"></a><code>CanCommit</code></h4><ol><li><strong>事务询问。</strong><br>协调者向所有的参与者发送一个包含事务内容的 <code>canCommit</code> 请求，询问<strong>是否可以执行事务提交操作</strong>，并开始等待各参与者的响应。</li><li><strong>各参与者向协调者反馈事务询问的响应。</strong><br>参与者在接收到来自协调者的<code>canCommit</code>请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈Yes响应，并进入预备状态，否则反馈No响应。</li></ol><h4 id="PreCommit"><a href="#PreCommit" class="headerlink" title="PreCommit"></a><code>PreCommit</code></h4><p>在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的<code>PreCommit</code>操作，正常情况下，包含两种可能。</p><h5 id="执行事务预提交"><a href="#执行事务预提交" class="headerlink" title="执行事务预提交"></a>执行事务预提交</h5><p>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务预提交。</p><ol><li><strong>发送预提交请求。</strong><br>协调者向所有参与者节点发出<code>preCommit</code>的请求，并<strong>进入Prepared阶段</strong>。</li><li><strong>事务预提交。</strong><br>参与者接收到<code>preCommit</code>请求后，会执行事务操作，并将<strong>Undo和Redo信息记录到事务日志中。</strong></li><li><strong>各参与者向协调者反馈事务执行的响应。</strong><br>如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令:提交(commit)或中止 (abort)。</li></ol><h5 id="中断事务-1"><a href="#中断事务-1" class="headerlink" title="中断事务"></a>中断事务</h5><p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么<strong>就会中断事务</strong>。</p><ol><li><p><strong>发送中断请求。</strong><br>协调者向所有参与者节点发出abort请求。</p></li><li><p><strong>中断事务。</strong></p><p>无论是收到来自协调者的abort请求,或者是在等待协调者请求过程中出现超时，参与者都会中断事务。</p></li></ol><h4 id="do-Commit"><a href="#do-Commit" class="headerlink" title="do Commit"></a><code>do Commit</code></h4><h5 id="执行提交"><a href="#执行提交" class="headerlink" title="执行提交"></a>执行提交</h5><ol><li><strong>发送提交请求。</strong><br>进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将<strong>从“预提交”状态转换到“提交”状态</strong>，并向所有的参与者发送<code>doCommit</code>请求。</li><li><strong>事务提交。</strong><br>参与者接收到<code>doCommit</code>请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</li><li><strong>反馈事务提交结果。</strong><br>参与者在完成事务提交之后，向协调者发送 Ack 消息。</li><li><strong>完成事务。</strong><br>协调者接收到所有参与者反馈的Ack 消息后，完成事务。</li></ol><h5 id="中断事务-2"><a href="#中断事务-2" class="headerlink" title="中断事务"></a>中断事务</h5><p>进入这一阶段，假设协调者处于正常工作状态，并且有<strong>任意一个参与者向协调者反馈了No响应</strong>,或者在等待超时之后,协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p><ol><li><strong>发送中断请求</strong>。<br>协调者向所有的参与者节点发送abort 请求。</li><li><strong>事务回滚。</strong><br>参与者接收到abort请求后，会利用其在阶段二中记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</li><li><strong>反锁事务回滚结果</strong>。<br>参与者在完成事务回滚之后，向协调者发送 Ack 消息。</li><li><strong>中断事务。</strong><br>协调者接收到所有参与者反馈的Ack 消息后，中断事务。</li></ol><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：相较于二阶段提交协议，三阶段提交协议最大的优点就是<strong>降低了参与者的阻塞范围</strong>，并且能够在出现单点故障后继续达成一致。<br>缺点:三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在<strong>参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信</strong>，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性。</p><h2 id="四、Paxos算法"><a href="#四、Paxos算法" class="headerlink" title="四、Paxos算法"></a>四、Paxos算法</h2><p><code>Paxos</code>算法:一种基于消息传递且具有高度容错特性的<strong>一致性算法</strong>。</p><p><code>Paxos</code>算法解决的问题:就是如何快速正确的在一个分布式系统中对某个数据值达成一致，并且保证不论发生任何异常，都不会破坏整个系统的一致性。</p><p><img src="/2022/03/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98.png" alt="image-20220326224050431"></p><p>在一个<code>Paxos</code>系统中，首先将所有节点划分为<strong>Proposer(提议者)</strong>，<strong>Acceptor(接受者)</strong>，和<strong>Learner(学习者)</strong>。(注意:每个节点都可以身兼数职)。</p><p><strong>一个完整的<code>Paxos</code>算法流程分为三个阶段:</strong></p><ul><li>Prepare准备阶段<ol><li>Proposer向多个Acceptor发出Propose请求Promise(承诺). </li><li>Acceptor针对收到的Propose请求进行Promise(承诺)</li></ol></li><li>Accept接受阶段<ol><li>Proposer收到多数Acceptor承 诺的Promise后，向Acceptor发出Propose请求 </li><li>Acceptor针对收到的Propose请求进行Accept处理</li></ol></li><li>Learn学习阶段:<ol><li>Proposer将形成的决议发送给所有Learners</li></ol></li></ul><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol><li><strong>Prepare</strong>: Proposer生成<strong>全局唯一且递增的Proposal ID</strong>，向所有Acceptor发送Propose请求，这里无需携带提案内容，只携带Proposal ID即可。</li><li>Promise: Acceptor收到Propose请求后，做出”<strong>两个承诺，一个应答</strong>“。<ul><li>不再接受Proposal ID<strong>小于等于（注意:这里是&lt;=）当前请求的Propose请求</strong>。</li><li>不再接受Proposal ID<strong>小于（注意:这里是&lt;）当前请求的Accept请求</strong>。</li><li>不违背以前做出的承诺下，回复已经Accept过的提案中<strong>Proposal ID最大的那个提案的Value和Proposal ID</strong>，没有则返回空值。</li></ul></li><li>Propose: Proposer收到多数Acceptor的Promise应答后，从<strong>应答中选择Proposal ID最大的提案的Value，作为本次要发起的提案</strong>。如果所有应答的提案Value均为空值，则可以自己随意决定提案Value。然后携带当前Proposal ID，向所有Acceptor发送Propose请求。</li><li>Accept: Acceptor收到Propose请求后，<strong>在不违背自己之前做出的承诺下，接受并持久化当前Proposal ID和提案Value</strong>。</li><li>Learn: Proposer收到多数Acceptor的Accept后，决议形成，将形成的决议发送给所有Learner</li></ol><h3 id="3种情况"><a href="#3种情况" class="headerlink" title="3种情况"></a>3种情况</h3><p>A1,A2,A3,A4,A5发起提案</p><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p>A1发起税率10%的提案</p><ol><li>A1发起1号Proposal的Propose，等待Promise承诺;</li><li>A2-A5回应Promise;</li><li>A1在收到两份回复时就会发起税率10%的Proposal;</li><li>A2-A5回应Accept;</li></ol><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>A1发起税率10%的提案，A5发起税率20%的提案</p><ol><li>A1，A5同时发起Propose(序号分别为1，2)</li><li>A2承诺A1，A4承诺A5，A3行为成为关键</li><li>情况1:A3先收到A1消息，承诺A1。</li><li>A1发起Proposal (1,10%)，A2，A3接受。</li><li>之后<strong>A3又收到A5消息，回复A1:(1，10%)，并承诺A5。</strong></li><li>A5发起Proposal (2，20%)，A3，A4接受。之后A1，A5同时广播决议。</li></ol><h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><p>A1发起税率10%的提案，A5发起税率20%的提案</p><ol><li>A1，A5同时发起Propose(序号分别为1，2)</li><li>A2承诺A1，A4承诺A5，A3行为成为关键</li><li>情况2:<strong>A3先收到A1消息，承诺A1。之后立刻收到A5消息，承诺A5。</strong></li><li>A1发起Proposal（1，10%)，无足该响应，A1重新Propose (序号3)，A3再次承诺A1</li><li>A5发起Proposal(2，20%），无足够相应，A5重新Propose(.序号4〕 ，A3再次承诺A5</li><li>…</li></ol><p>造成这种情况的原囚是系统中<strong>有一个以上的Proposer</strong>,<strong>多个Proposers 相互争夺Acceptor</strong>,造成迟迟无法达成一致的情况。针对这种情况，一种改进的<code>Paxos</code>,算法被提出:<strong>从系统中选出一个节点作为Leader，只有Leader 能够发起提案</strong>。这样，一次<code>Paxos</code>流程中只有一个Proposer，不会出现活锁的情况，此时只会出现例子中第一种情况。</p><h2 id="五、ZAB协议"><a href="#五、ZAB协议" class="headerlink" title="五、ZAB协议"></a>五、ZAB协议</h2><p><code>Zab</code> 借鉴了<code>Paxos</code>算法，是特别为Zookeeper设计的<strong>支持崩溃恢复的原子广播协议</strong>。基于该协议，Zookeeper设计为<strong>只有一台客户端（Leader）负责处理外部的写事务请求</strong>，然后Leader 客户端将数据同步到其他Follower节点。即Zookeeper 只有一个Leader可以发起提案。</p><p><code>Zab</code>协议包括两种基本的模式:<strong>消息广播</strong>、<strong>崩溃恢复</strong>。</p><h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><img src="/2022/03/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/消息广播.png" alt="image-20220327131940966" style="zoom:80%;"><ol><li>客户端发起一个写操作请求。</li><li>Leader服务器将客户端的请求转化为事务<strong>Proposal提案</strong>，同时为每个Proposal分配一个全局的ID，即<code>zxid</code>。</li><li>Leader服务器为每个Follower服务器<strong>分配一个单独的队列</strong>，然后将需要广播的Proposal依次放到队列中去，并且根据FIFO策略进行消息发送</li><li>Follower接收到Proposal后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向Leader反馈一个Ack响应消息。</li><li>Leader接收到超过半数以上Follower的Ack响应消息后，即认为消息发送成功，可以发送commit消息。</li><li>Leader<strong>向所有Follower广播commit消息</strong>，同时自身也会完成事务提交。Follower按收到commit消息后，会将上一条事务提交。</li><li>Zookeeper采用<code>Zab</code>协议的核心，就是<strong>只要有一台服务器提交了Proposal，就要确保所有的服务器最终都能正确提交Proposals</strong></li></ol><p>ZAB协议针对事务请求的处理过程类似于一个两阶段提交过程</p><ol><li>广播事务阶段</li><li>广播提交操作</li></ol><h3 id="奔溃恢复"><a href="#奔溃恢复" class="headerlink" title="奔溃恢复"></a>奔溃恢复</h3><h4 id="异常假设"><a href="#异常假设" class="headerlink" title="异常假设"></a>异常假设</h4><p>这两阶段提交模型，有可能因为Leader宕机带来数据不一致，比如</p><ol><li><p>假设<strong>一个事务在Leader提出之后，Leader挂了</strong>。</p></li><li><p>一个事务<strong>在Leader上提交了</strong>，并且<strong>过半的Follower都响应Ack了</strong>，但是<strong>Leader在Commit消息发出之前挂了</strong>。</p><img src="/2022/03/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/奔溃恢复.png" alt="image-20220327133025139" style="zoom:80%;"></li></ol><p>奔溃恢复满足两个要求：</p><ol><li>确保已经被Leader提交的提案Proposal，必须最终被所有的Follower服务器提交。(已经产生的提案，<strong>Follower必须执行</strong>。</li><li>确保<strong>丢弃</strong>已经被Leader提出的，但是没有被提交的Proposal。(丢弃胎死腹中的提案)</li></ol><h4 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h4><img src="/2022/03/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/Leader选举.png" alt="image-20220327133547020" style="zoom:80%;"><ol><li>新选举出来的Leader不能包含未提交的Proposal。即<strong>新Leader必须都是已经提交了Proposal的Follower服务器节点。</strong></li><li>新选举的Leader节点中<strong>含有最大的<code>zxid</code></strong>。这样做的好处是可以<strong>避免Leader服务器检查Proposal的提交和丢弃工作。</strong></li></ol><h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><ol><li>完成Leader选举后，在正式开始工作之前（接收事务请求，然后提出新的Proposal),Leader服务器会首先<strong>确认事务日志中的所有的Proposal是否己经被集群中过半的服务器Commit</strong>。</li><li>Leader服务器需要确保所有的Follower服务器能够接收到每一条事务的Proposal，并且能将所有已经提交的事务Proposal应用到内存数据中。<strong>等到Follower将所有尚未同步的事务Proposal都从Leader服务器上同步过，并且应用到内存数据中以后，Leader才会把该Follower加入到真正可用的Follower列表中。</strong></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、拜占庭将军问题&quot;&gt;&lt;a href=&quot;#一、拜占庭将军问题&quot; class=&quot;headerlink&quot; title=&quot;一、拜占庭将军问题&quot;&gt;&lt;/a&gt;一、拜占庭将军问题&lt;/h2&gt;&lt;p&gt;Zookeeper是&lt;strong&gt;如何保证数据一致性的&lt;/strong&gt;?这也是困扰分布式系统框架的一个难题。&lt;/p&gt;
&lt;p&gt;拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。&lt;strong&gt;叛徒可以任意行动以达到以下目标:欺骗某些将军采取进攻行动，促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动;或者迷惑某些将军，使他们无法做出决定&lt;/strong&gt;。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。&lt;/p&gt;
&lt;h2 id=&quot;二、CAP理论&quot;&gt;&lt;a href=&quot;#二、CAP理论&quot; class=&quot;headerlink&quot; title=&quot;二、CAP理论&quot;&gt;&lt;/a&gt;二、CAP理论&lt;/h2&gt;&lt;p&gt;CAP理论告诉我们，一个分布式系统不可能同时满足以下三种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt;(C:Consistency)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用性&lt;/strong&gt;(A:Available）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分区容错性&lt;/strong&gt;（P:Partition Tolerance )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三个基本需求，最多只能同时满足其中的两项，因为P是必须的，因此往往选择就在&lt;strong&gt;CP&lt;/strong&gt;或者&lt;strong&gt;AP&lt;/strong&gt;中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt;(C:Consistency)：在分布式环境中，一致性是指数据在&lt;strong&gt;多个副本之间是否能够保持数据一致的特性&lt;/strong&gt;。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用性&lt;/strong&gt;(A:Available）：可用性是指系统提供的服务必须&lt;strong&gt;一直处于可用的状态&lt;/strong&gt;，对于用户的每一个操作请求总是能够&lt;strong&gt;在有限的时间内返回结果&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分区容错性&lt;/strong&gt;（P:Partition Tolerance )：分布式系统在遇到任何网络分区故障的时候，&lt;strong&gt;仍然需要能够保证对外提供满足一致性和可用性的服务&lt;/strong&gt;，除非是整个网络环境都发生了故障。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;ZooKeeper保证的是CP&quot;&gt;&lt;a href=&quot;#ZooKeeper保证的是CP&quot; class=&quot;headerlink&quot; title=&quot;ZooKeeper保证的是CP&quot;&gt;&lt;/a&gt;ZooKeeper保证的是CP&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ZooKeeper&lt;/code&gt;不能保证每次服务请求的可用性。(注:&lt;strong&gt;在极端环境下，&lt;code&gt;ZooKeeper&lt;/code&gt;可能会丢弃一些请求&lt;/strong&gt;，消费者程序需要重新请求才能获得结果）。所以说，&lt;code&gt;ZooKeeper&lt;/code&gt;不能保证服务可用性。&lt;/li&gt;
&lt;li&gt;进行Leader&lt;strong&gt;选举时集群都是不可用&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper简介</title>
    <link href="http://yoursite.com/2022/03/22/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2022/03/22/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E7%AE%80%E4%BB%8B/</id>
    <published>2022-03-22T14:37:09.000Z</published>
    <updated>2022-03-26T14:34:08.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、入门"><a href="#一、入门" class="headerlink" title="一、入门"></a>一、入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Zookeeper从设计模式角度来理解:是一个基于观察者模式设计的分布式服务管理框架，它负责<strong>存储和管理大家都关心的数据</strong>，然后<strong>接受观察者的注册</strong>，一旦这些数据的状态发生变化，Zookeeper就将<strong>负责通知已经在Zookeeper上注册的那些观察者</strong>做出相应的反应。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p>Zookeeper:一个领导者(Leader)，多个跟随者(Follower）组成的集群。</p></li><li><p>集群中只要有<strong>半数以上</strong>节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。</p></li><li><p>全局数据一致:每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。</p></li><li><p>更新请求<strong>顺序执行</strong>，来自同一个Client的更新请求按其发送顺序依次执行。</p></li><li><p>数据更新<strong>原子性</strong>，一次数据更新要么成功，要么失败。</p></li></ol><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>ZooKeeper数据模型的结构与<strong>Unix 文件系统很类似</strong>，整体上可以看作是一棵树，每个节点称做一个ZNode。每一个ZNode，默认能够存储<strong>1MB</strong>的数据，每个ZNode都可以通过其路径唯一标识。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>提供的服务包括:</p><ol><li><p><strong>统一命名服务</strong>：在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。例如nginx</p></li><li><p><strong>统一配置管理</strong>：</p><blockquote><p>需求:</p><ol><li>一般要求一个集群中，所有节点的配置信息是一致的，比如Kafka集群。</li><li>对配置文件修改后，希望能够快速同步到各个节点上。</li></ol></blockquote><p>将配置信息写入ZooKeeper的一个Znode,每个客户端监听Znode,一旦配置修改，zk就会通知其他客户端服务器</p></li><li><p><strong>统一集群管理</strong>：</p><blockquote><p> 需求:分布式环境中，实时掌握每个节点的状态是必须的，根据节点状态做出一些调整。</p></blockquote><p>zk可将节点信息写入ZooKeeper上的一个ZNode。监听这个ZNode可<strong>获取它的实时状态变化</strong>。</p></li><li><p>服务器节点动态上下线</p><blockquote><p>​    需求：客户端实时洞察客户端上下线变化</p></blockquote><ol><li><strong>服务端</strong>启动时去zk注册信息(创建都是临时节点)。</li><li><strong>客户端</strong>获取到当前在线服务器列表，并且注册监听。</li><li>当服务器节点下线，zk将服务器节点下线通知到客户端。</li><li>客户端在去获取服务器列表，并且注册监听。</li></ol></li><li><p><strong>软负载均衡</strong>：zk记录录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求（Nginx）</p></li></ol><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p><h2 id="二、zookeeper操作"><a href="#二、zookeeper操作" class="headerlink" title="二、zookeeper操作"></a>二、zookeeper操作</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>上传zookeeper安装包包服务器，解压。配置zoo.cfg</p><p>启动服务端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zkServer.sh start</span><br></pre></td></tr></table></figure><p>启动客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zkCli.sh</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick 心跳</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take leader和follower</span></span><br><span class="line"><span class="comment"># 初始化的时候进行通信，10次心跳之后如果没有通信就失败</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement </span></span><br><span class="line"><span class="comment"># Leader和Follower之间通信如果超过这时间，就失败</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="comment"># zookeeper数据</span></span><br><span class="line">dataDir=/opt/software/zk/apache-zookeeper-3.5.9-bin/zkData</span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="comment"># 客户端连接端口 </span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to &quot;0&quot; to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br></pre></td></tr></table></figure><h3 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h3><p>在zk数据目录下创建一个<code>myid</code>文件，添加对应的编号。</p><p>所有zookeeper的机器都创建对应的myid,并分别添加2,3,4。</p><p>在zoo.cfg中添加集群配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#A为myid中数字，B是服务器地址，C是Follower和Leader服务器交换信息的端口，D万一集群Leader挂了，需要一个端口进行选举，进行选举时的配置。</span></span><br><span class="line">server.A=B:C:D</span><br><span class="line">server.2=192.168.1.101:2888:3888</span><br><span class="line">server.3=192.168.1.102:2888:3888</span><br><span class="line">server.4=192.168.1.103:2888:3888</span><br></pre></td></tr></table></figure><p>启动对应集群，查看集群状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bin/zkServer.sh status</span></span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /opt/software/zk/apache-zookeeper-3.5.9-bin/bin/../conf/zoo.cfg</span><br><span class="line">Client port found: 2181. Client address: localhost. Client SSL: <span class="literal">false</span>.</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure><h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><h4 id="第一次选举"><a href="#第一次选举" class="headerlink" title="第一次选举"></a>第一次选举</h4><ol><li>服务器1启动，<strong>发起一次选举</strong>。服务器1投自己一票。此时服务器1票数一票，不够半数以上(3票），选举无法完成，服务器1状态保持为LOOKING;</li><li>服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息:<strong>此时服务器1发现服务器2的myid比自己目前投票推举的（服务器1)大，更改选票为推举服务器2</strong>。此时服务器1票数0票，服务器2票数2票，没有半数以上结果，选举无法完成，服务器1，2状态保持LOOKING</li><li>服务器3启动，发起一次选举。<strong>此时服务器1和2都会更改选票为服务器3</strong>。此次投票结果:服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数，服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING;</li><li>服务器4启动，发起一次选举。<strong>此时服务器1，2，3已经不是LOOKNG状态</strong>，<strong>不会更改选票信息</strong>。交换选票信息结果﹔服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING;</li></ol><p>客户端（client）每次写操作都有事务<code>id(zxid)</code></p><ul><li><strong>SID:服务器ID</strong>。用来唯一标识一台ZooKeeper集群中的机器,每台机器不能重复，<strong>和myid一致</strong>。</li><li><strong>ZXID:事务ID</strong>。<strong>ZXID是一个事务ID，用来标识一次服务器状态的变更</strong>。在某一时刻，集群中的每台机器的ZXID值不一定完全一致,这和ZooKeeper服务器对于客户端“更新请求”的处理逻辑有关。</li><li><strong>Epoch:每个Leader任期的代号。</strong>没有Leader时同一轮投票过程中的<strong>逻辑时钟值是相同的</strong>。每投完一次票这个数据就会增加。</li></ul><h4 id="非第一次选举"><a href="#非第一次选举" class="headerlink" title="非第一次选举"></a>非第一次选举</h4><ol><li><p>当ZooKeeper集群中的一台服务器出现以下两种情况之一时，就会开始进入Leader选举:·</p><ul><li>服务器<strong>初始化启动</strong>。</li><li>服务器<strong>运行期间无法和Leader保持连接</strong>。</li></ul></li><li><p>而当一台机器进入Leader选举流程时，当前集群也可能会处于以下两种状态:·</p><ul><li><p>集群中本来就已经存在一个Leader。<br>对于第一种已经存在Leader的情况，机器试图<strong>去选举Leader时，会被告知当前服务器的Leader信息</strong>，对于该机器来说，仅仅需要和Leade机器建立连接，并进行状态同步即可。</p></li><li><p>集群中<strong>确实不存在Leader</strong>。<br>假设LooKeeper由5台服务器组成，SID分别为1、2、3、4、5.ZXID分别为8、8、8、7、7，并且此时<strong>SID为3的服务器是Leader</strong>。某一时刻，<strong>3和5服务器出现故障</strong>，因此开始进行Leader选举。</p><p>SID为1、2、4的机器投票情况:(EPOCH，ZXID，SID )</p><ul><li>1 ：(1,8,2)</li><li>2 ：(1,8,2)</li><li>4 ：(1,7,4)</li></ul><blockquote><p>选举Leader规则</p><p>①EPOCH大的直接胜出<br>②EPOCH相同，事务id大的胜出<br>③事务id相同,服务器id大的胜出</p></blockquote></li></ul></li></ol><h3 id="启停脚本"><a href="#启停脚本" class="headerlink" title="启停脚本"></a>启停脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">node=(192.168.1.101 192.168.1.102 192.168.1.103)</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">&quot;start&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;node[@]&#125;</span> </span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;zookeeper <span class="variable">$i</span> start&quot;</span></span><br><span class="line">        ssh <span class="variable">$i</span> <span class="string">&quot;/opt/software/zk/apache-zookeeper-3.5.9-bin/bin/zkServer.sh start&quot;</span></span><br><span class="line">    <span class="keyword">done</span> </span><br><span class="line">&#125;</span><br><span class="line">;;</span><br><span class="line"><span class="string">&quot;stop&quot;</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;node[@]&#125;</span> </span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;zookeeper <span class="variable">$i</span> stop&quot;</span></span><br><span class="line">        ssh <span class="variable">$i</span> <span class="string">&quot;/opt/software/zk/apache-zookeeper-3.5.9-bin/bin/zkServer.sh stop&quot;</span></span><br><span class="line">    <span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">;;</span><br><span class="line"><span class="string">&quot;status&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;node[@]&#125;</span>  </span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;zookeeper <span class="variable">$i</span> status&quot;</span></span><br><span class="line">        ssh <span class="variable">$i</span> <span class="string">&quot;/opt/software/zk/apache-zookeeper-3.5.9-bin/bin/zkServer.sh status&quot;</span></span><br><span class="line">    <span class="keyword">done</span> </span><br><span class="line">&#125;</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h3 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h3><h4 id="命令行语法"><a href="#命令行语法" class="headerlink" title="命令行语法"></a>命令行语法</h4><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tbody><tr><td>help</td><td>显示所有操作命令</td></tr><tr><td>ls path</td><td>使用ls 命令来查看当前znode的子节点[可监听]<br>-w  监听子节点变化<br>-s   附加次级信息</td></tr><tr><td>create</td><td>普通创建<br>-s  含有序列<br>-e  临时(重启或者超时消失）</td></tr><tr><td>get path</td><td>获得节点的值[可监听]<br>-w  监听节点内容变化<br>-s   附加次级信息</td></tr><tr><td>set</td><td>设置节点的具体值</td></tr><tr><td>stat</td><td>查看节点状态-</td></tr><tr><td>delete</td><td>删除节点</td></tr><tr><td>deleteall</td><td>递归删除节点</td></tr></tbody></table><h4 id="znode节点数据信息"><a href="#znode节点数据信息" class="headerlink" title="znode节点数据信息"></a>znode节点数据信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ls -s /</span><br><span class="line">[zookeeper]cZxid = 0x0<span class="comment">#创建节点是的事务zxid</span></span><br><span class="line"><span class="comment">#每次修改zk状态都会产生一个事务id,是所有修改的总的次序。每次修改都有唯一的zxid，如果zxid1小于zxid2,那个</span></span><br><span class="line">ctime = Thu Jan 01 08:00:00 CST 1970<span class="comment">#被创建的毫秒值</span></span><br><span class="line">mZxid = 0x0<span class="comment">#最后更新的失误zxid</span></span><br><span class="line">mtime = Thu Jan 01 08:00:00 CST 1970<span class="comment">#最后更新的ms数</span></span><br><span class="line">pZxid = 0x0<span class="comment">#znode最后更新的子节点zxid</span></span><br><span class="line">cversion = -1<span class="comment">#znode子节点变化号，znode子节点修改次数</span></span><br><span class="line">dataVersion = 0<span class="comment">#znode数据变化号</span></span><br><span class="line">aclVersion = 0<span class="comment">#访问控制列表的变化号</span></span><br><span class="line">ephemeralOwner = 0x0<span class="comment">#果是临时节点，这个是 znode,拥有者的session id。如果不是备时节点则是0。</span></span><br><span class="line">dataLength = 0<span class="comment">#数据长度(11)</span></span><br><span class="line">numChildren = 1<span class="comment"># znode子节点数量</span></span><br></pre></td></tr></table></figure><h4 id="节点类型（持久-短暂-有序号-无序号）"><a href="#节点类型（持久-短暂-有序号-无序号）" class="headerlink" title="节点类型（持久/短暂/有序号/无序号）"></a>节点类型（持久/短暂/有序号/无序号）</h4><ul><li><p>持久(Persistent）:客户端和服务器端断开连接后，<strong>创建的节点不删除短暂</strong></p></li><li><p>Ephemeral):客户端和服务器端断开连接后，<strong>创建的节点自己删除</strong></p></li></ul><img src="/2022/03/22/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E7%AE%80%E4%BB%8B/节点类型.png" alt="image-20220326135956270" style="zoom:80%;"><ol><li><p>持久化目录节点<br>客户端与Zookeeper断开连接后，该节点依旧存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /sanguo/weiguo <span class="string">&quot;caocao&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>持久化顺序编号日录节点<br>客户端与Zookeeper断开连接后，该节点依旧存在，只是Zookeeper<strong>给该节点名称进行顺序编号</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s /sanguo/weiguo <span class="string">&quot;caocao&quot;</span></span><br></pre></td></tr></table></figure></li></ol><p>说明:创建znode时设置顺序标识，<strong>znode名称后会附加一个值</strong>，顺序号是一个单调递增的计数器，由父节点维护</p><blockquote><p> 注意:在分布式系统中，顺序号可以被用于为<strong>所有的事件进行全局排序</strong>，这样客户端可以通过顺序号<strong>推断事件的顺序</strong></p></blockquote><ol start="3"><li><p>临时目录节点<br>客户端与Zookeeper断开连接后，该节点被删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e /sanguo/weiguo <span class="string">&quot;caocao&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>临时顺序编号目录节点<br>客户端与Zookeeper断开连接后，该节点被删除，只Zookeeper给该节点名称进行顺序编号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -e -s /sanguo/weiguo <span class="string">&quot;caocao&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="监听器原理"><a href="#监听器原理" class="headerlink" title="监听器原理"></a>监听器原理</h4><p>客户端注册监听它关心的目录节点，当<strong>目录节点发生变化</strong>（数据改变、节点删除、子目录节点增加删除）时，<strong>ZooKeeper会通知客户端</strong>。监听机制保证ZooKeeper,.保存的任何的数据的任何改变都能快速的响应到监听了该节点的应用程序。</p><h5 id="监听原理"><a href="#监听原理" class="headerlink" title="监听原理"></a>监听原理</h5><ol><li>首先要有一个main()线程</li><li>在main线程中<strong>创建Zookeeper客户端</strong>，这时就会创建两个线程，一个负责<strong>网络连接通信</strong>（connet) ，一个<strong>负责监听</strong>(listener)。</li><li>通过connect线程<strong>将注册的监听事件发送给Zookeeper</strong>。</li><li>在Zookeeper的注册监听器列表中<strong>将注册的监听事件添加到列表中</strong>。</li><li>Zookeeper监听到有数据或路径变化，就会<strong>将这个消息发送给listener线程</strong>。</li><li>listener线程内部<strong>调用了process()方法</strong>。</li></ol><h5 id="常见的监听"><a href="#常见的监听" class="headerlink" title="常见的监听"></a>常见的监听</h5><ol><li><p>监听节点数据的变化 <code>get path [watch]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注册监听</span></span><br><span class="line">get -w /sanguo</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改值</span></span><br><span class="line"><span class="built_in">set</span> /sanguo <span class="string">&quot;xishi&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#收到监听</span></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeDataChanged path:/sanguo</span><br></pre></td></tr></table></figure><blockquote><p>注意:节点再多次修改/sanguo的值，客户端上不会再收到监听。因为<strong>注册一次，只能监听一次。</strong>想再次监听，需要再次注册。</p></blockquote></li><li><p>监听子节点增减的变化 <code>ls path [watch]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注册监听</span></span><br><span class="line">ls -w /sanguo</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改值</span></span><br><span class="line">create /sanguo/shuguo <span class="string">&quot;liubei&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#收到监听</span></span><br><span class="line">WATCHER::</span><br><span class="line"></span><br><span class="line">WatchedEvent state:SyncConnected <span class="built_in">type</span>:NodeChildrenChanged path:/sanguo</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、客户端API操作"><a href="#三、客户端API操作" class="headerlink" title="三、客户端API操作"></a>三、客户端API操作</h2><h3 id="zookeeper依赖"><a href="#zookeeper依赖" class="headerlink" title="zookeeper依赖"></a>zookeeper依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="日志依赖"><a href="#日志依赖" class="headerlink" title="日志依赖"></a>日志依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>resource目录下创建log4j.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">INFO,stdout</span></span><br><span class="line"><span class="meta">loa4i.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">loq4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d %p [%c] - %m%n</span></span><br><span class="line"><span class="meta">log4i.appender.logfile</span>=<span class="string">org.apache.log4j.FileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.logfile.File</span>=<span class="string">target/spring.log </span></span><br><span class="line"><span class="meta">loq4j.appender.logfile.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">loa4j.appender.logfile.layout.ConversionPattern</span>=<span class="string">%d %p [%c] - %m%n</span></span><br></pre></td></tr></table></figure><h3 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String connectionString = <span class="string">&quot;192.168.1.101:2181,192.168.1.102:2181,192.168.1.103:2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        zkClient = <span class="keyword">new</span> ZooKeeper(connectionString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        String nodeCreate = zkClient.create(<span class="string">&quot;/lq&quot;</span>, <span class="string">&quot;test&quot;</span>.getBytes(),</span><br><span class="line">                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册监听"><a href="#注册监听" class="headerlink" title="注册监听"></a>注册监听</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String connectionString = <span class="string">&quot;192.168.1.101:2181,192.168.1.102:2181,192.168.1.103:2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每次获取都会注册</span></span><br><span class="line">        zkClient = <span class="keyword">new</span> ZooKeeper(connectionString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                List&lt;String&gt; children = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    children = zkClient.getChildren(<span class="string">&quot;/&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                children.stream().forEach(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChildren</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断节点是否存在"><a href="#判断节点是否存在" class="headerlink" title="判断节点是否存在"></a>判断节点是否存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exist</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">    Stat stat = zkClient.exists(<span class="string">&quot;/lq&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">    System.out.println(stat == <span class="keyword">null</span> ? <span class="string">&quot;not exist&quot;</span> : <span class="string">&quot; exist&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端向服务端写数据流程"><a href="#客户端向服务端写数据流程" class="headerlink" title="客户端向服务端写数据流程"></a>客户端向服务端写数据流程</h3><h4 id="直接发送Leader"><a href="#直接发送Leader" class="headerlink" title="直接发送Leader"></a>直接发送Leader</h4><p><img src="/2022/03/22/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E7%AE%80%E4%BB%8B/客户端向Leader写数据.png" alt="image-20220326194754393" style="zoom:80%;">z</p><h4 id="发送客户端"><a href="#发送客户端" class="headerlink" title="发送客户端"></a>发送客户端</h4><img src="/2022/03/22/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E7%AE%80%E4%BB%8B/客户端向Follower写数据.png" alt="image-20220326195136310" style="zoom:80%;"><h2 id="四、服务器动态上下线"><a href="#四、服务器动态上下线" class="headerlink" title="四、服务器动态上下线"></a>四、服务器动态上下线</h2><img src="/2022/03/22/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E7%AE%80%E4%BB%8B/服务器动态上下线.png" alt="image-20220326195541294" style="zoom:80%;"><h3 id="服务器注册"><a href="#服务器注册" class="headerlink" title="服务器注册"></a>服务器注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String connectionString = <span class="string">&quot;192.168.1.101:2181,192.168.1.102:2181,192.168.1.103:2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        DistributeServer server = <span class="keyword">new</span> DistributeServer();</span><br><span class="line">        <span class="comment">//1.连接</span></span><br><span class="line">        server.getConnection();</span><br><span class="line">        <span class="comment">//2.注册服务器</span></span><br><span class="line">        server.register(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//3.启动业务</span></span><br><span class="line">        server.business();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//临时节点</span></span><br><span class="line">        zkClient.create(<span class="string">&quot;/servers/&quot;</span> + hostname, hostname.getBytes(),</span><br><span class="line">                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">        System.out.println(hostname + <span class="string">&quot;is online&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        zkClient = <span class="keyword">new</span> ZooKeeper(connectionString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端监听"><a href="#客户端监听" class="headerlink" title="客户端监听"></a>客户端监听</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String connectionString = <span class="string">&quot;192.168.1.101:2181,192.168.1.102:2181,192.168.1.103:2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        DistributeClient client = <span class="keyword">new</span> DistributeClient();</span><br><span class="line">        <span class="comment">//1. 获取zk连接</span></span><br><span class="line">        client.getConnection();</span><br><span class="line">        <span class="comment">//2. 监听</span></span><br><span class="line">        client.getServersList();</span><br><span class="line">        <span class="comment">//3. 业务逻辑</span></span><br><span class="line">        client.business();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread.sleep(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getServersList</span><span class="params">()</span> <span class="keyword">throws</span> KeeperException, InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; children = zkClient.getChildren(<span class="string">&quot;/servers&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        ArrayList&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String child : children)&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = zkClient.getData(<span class="string">&quot;/servers/&quot;</span> + child, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            servers.add(<span class="keyword">new</span> String(data));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(servers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        zkClient = <span class="keyword">new</span> ZooKeeper(connectionString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    getServersList();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、分布式锁"><a href="#五、分布式锁" class="headerlink" title="五、分布式锁"></a>五、分布式锁</h2><h3 id="什么做分布式锁"><a href="#什么做分布式锁" class="headerlink" title="什么做分布式锁"></a>什么做分布式锁</h3><p>比如说”进程1”在使用该资源的时候，会先去获得锁，”进程1<strong>“获得锁以后会对该资源保持独占</strong>，这样其他进程就无法访问该资源，”进程1”用完该资源以后就将锁释放掉，让其他进程来获得锁，那么通过这个锁机制，我们就能<strong>保证了分布式系统中多个进程能够有序的访问该临界资源</strong>。</p><img src="/2022/03/22/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E7%AE%80%E4%BB%8B/分布式锁.png" alt="image-20220326203620509" style="zoom:80%;"><h3 id="分布式锁代码"><a href="#分布式锁代码" class="headerlink" title="分布式锁代码"></a>分布式锁代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String connectionString = <span class="string">&quot;192.168.1.101:2181,192.168.1.102:2181,192.168.1.103:2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZooKeeper zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch connectLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch waitLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String waitPath;</span><br><span class="line">    <span class="keyword">private</span> String currentNode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistributedLock</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException, KeeperException </span>&#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        zkClient = <span class="keyword">new</span> ZooKeeper(connectionString, sessionTimeout, <span class="keyword">new</span> Watcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent watchedEvent)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//释放连接对象</span></span><br><span class="line">                <span class="keyword">if</span> (watchedEvent.getState() == Event.KeeperState.SyncConnected)&#123;</span><br><span class="line">                    connectLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//删除操作，并且是前一个类型</span></span><br><span class="line">                <span class="keyword">if</span> (watchedEvent.getType() == Event.EventType.NodeDeleted</span><br><span class="line">                        &amp;&amp; watchedEvent.getPath().equals(waitPath))&#123;</span><br><span class="line">                    waitLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//连接正常</span></span><br><span class="line">        connectLatch.await();</span><br><span class="line">        <span class="comment">//判断根节点/locks</span></span><br><span class="line">        Stat stat = zkClient.exists(<span class="string">&quot;/locks&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (stat == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//创建一下根节点</span></span><br><span class="line">            zkClient.create(<span class="string">&quot;/locks&quot;</span>,<span class="string">&quot;locks&quot;</span>.getBytes(),</span><br><span class="line">                    ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zkLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            currentNode = zkClient.create(<span class="string">&quot;/locks/&quot;</span> + <span class="string">&quot;seq-&quot;</span>, <span class="keyword">null</span>,</span><br><span class="line">                    ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);</span><br><span class="line">            List&lt;String&gt; children = zkClient.getChildren(<span class="string">&quot;/locks&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//只有一个值，就直接获取锁，如果有多个节点，需要判断是不是最小节点</span></span><br><span class="line">            <span class="keyword">if</span> (children.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Collections.sort(children);</span><br><span class="line">                <span class="comment">//获取节点</span></span><br><span class="line">                String thisNode = currentNode.substring(<span class="string">&quot;/locks/&quot;</span>.length());</span><br><span class="line">                <span class="comment">//通过对前一个节点在集合中位置</span></span><br><span class="line">                <span class="keyword">int</span> index = children.indexOf(thisNode);</span><br><span class="line">                <span class="keyword">if</span> (index == -<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;数据异常&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//获取锁</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//监听前一个节点</span></span><br><span class="line">                    waitPath = <span class="string">&quot;/locks/&quot;</span> + children.get(index - <span class="number">1</span>);</span><br><span class="line">                    zkClient.getData(waitPath, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">                    waitLatch.await();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断节点是不是最小的节点，如果不是，就监听</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unZkLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//删除节点</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            zkClient.delete(currentNode, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (KeeperException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributeLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException, KeeperException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DistributedLock lock1 = <span class="keyword">new</span> DistributedLock();</span><br><span class="line">        <span class="keyword">final</span> DistributedLock lock2 = <span class="keyword">new</span> DistributedLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock1.zkLock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1获取到锁&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock1.unZkLock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1释放到锁&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock2.zkLock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2获取到锁&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            lock2.unZkLock();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2释放到锁&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Curator实现分布式锁"><a href="#使用Curator实现分布式锁" class="headerlink" title="使用Curator实现分布式锁"></a>使用Curator实现分布式锁</h3><h4 id="原生创建的问题"><a href="#原生创建的问题" class="headerlink" title="原生创建的问题"></a>原生创建的问题</h4><ol><li>会话连接是异步的，需要自己去处理。比如使用CountDownLatch</li><li>Watch<strong>需要重复注册</strong>，不然就不能生效&lt;</li><li>开发的复杂性还是比较高的</li><li><strong>不支持多节点删除和创建</strong>。需要自己去递归</li></ol><p><a href="https://curator.apache.org/index.html">https://curator.apache.org/index.html</a></p><p><a href="https://blog.csdn.net/weixin_37778801/article/details/84704262">https://blog.csdn.net/weixin_37778801/article/details/84704262</a></p><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String connectionString = <span class="string">&quot;192.168.1.101:2181,192.168.1.102:2181,192.168.1.103:2181&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sessionTimeout = <span class="number">30000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建分布式锁</span></span><br><span class="line">        InterProcessMutex lock1 = <span class="keyword">new</span> InterProcessMutex(getCuratorFramework(), <span class="string">&quot;/locks&quot;</span>);</span><br><span class="line">        InterProcessMutex lock2 = <span class="keyword">new</span> InterProcessMutex(getCuratorFramework(), <span class="string">&quot;/locks&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock1.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1获取到锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                lock1.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1再次获取到锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                lock1.release();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1释放到锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                lock1.release();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1再次释放到锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock2.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2获取到锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                lock2.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2再次获取到锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                lock2.release();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2释放到锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                lock2.release();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2再次释放到锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> CuratorFramework <span class="title">getCuratorFramework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExponentialBackoffRetry policy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">3000</span>, <span class="number">3</span>);</span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.builder().connectString(connectionString)</span><br><span class="line">                .connectionTimeoutMs(sessionTimeout)</span><br><span class="line">                .sessionTimeoutMs(sessionTimeout)</span><br><span class="line">                .retryPolicy(policy).build();</span><br><span class="line">        client.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;zookeeper 启动成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、入门&quot;&gt;&lt;a href=&quot;#一、入门&quot; class=&quot;headerlink&quot; title=&quot;一、入门&quot;&gt;&lt;/a&gt;一、入门&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Zookeeper从设计模式角度来理解:是一个基于观察者模式设计的分布式服务管理框架，它负责&lt;strong&gt;存储和管理大家都关心的数据&lt;/strong&gt;，然后&lt;strong&gt;接受观察者的注册&lt;/strong&gt;，一旦这些数据的状态发生变化，Zookeeper就将&lt;strong&gt;负责通知已经在Zookeeper上注册的那些观察者&lt;/strong&gt;做出相应的反应。&lt;/p&gt;
&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Zookeeper:一个领导者(Leader)，多个跟随者(Follower）组成的集群。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;集群中只要有&lt;strong&gt;半数以上&lt;/strong&gt;节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;全局数据一致:每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更新请求&lt;strong&gt;顺序执行&lt;/strong&gt;，来自同一个Client的更新请求按其发送顺序依次执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据更新&lt;strong&gt;原子性&lt;/strong&gt;，一次数据更新要么成功，要么失败。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h3&gt;&lt;p&gt;ZooKeeper数据模型的结构与&lt;strong&gt;Unix 文件系统很类似&lt;/strong&gt;，整体上可以看作是一棵树，每个节点称做一个ZNode。每一个ZNode，默认能够存储&lt;strong&gt;1MB&lt;/strong&gt;的数据，每个ZNode都可以通过其路径唯一标识。&lt;/p&gt;
&lt;h3 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h3&gt;&lt;p&gt;提供的服务包括:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;统一命名服务&lt;/strong&gt;：在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。例如nginx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;统一配置管理&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需求:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一般要求一个集群中，所有节点的配置信息是一致的，比如Kafka集群。&lt;/li&gt;
&lt;li&gt;对配置文件修改后，希望能够快速同步到各个节点上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;将配置信息写入ZooKeeper的一个Znode,每个客户端监听Znode,一旦配置修改，zk就会通知其他客户端服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;统一集群管理&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 需求:分布式环境中，实时掌握每个节点的状态是必须的，根据节点状态做出一些调整。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;zk可将节点信息写入ZooKeeper上的一个ZNode。监听这个ZNode可&lt;strong&gt;获取它的实时状态变化&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器节点动态上下线&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;​    需求：客户端实时洞察客户端上下线变化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;服务端&lt;/strong&gt;启动时去zk注册信息(创建都是临时节点)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端&lt;/strong&gt;获取到当前在线服务器列表，并且注册监听。&lt;/li&gt;
&lt;li&gt;当服务器节点下线，zk将服务器节点下线通知到客户端。&lt;/li&gt;
&lt;li&gt;客户端在去获取服务器列表，并且注册监听。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;软负载均衡&lt;/strong&gt;：zk记录录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求（Nginx）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Go操作软件</title>
    <link href="http://yoursite.com/2022/03/19/Go/go%E6%93%8D%E4%BD%9C%E8%BD%AF%E4%BB%B6/"/>
    <id>http://yoursite.com/2022/03/19/Go/go%E6%93%8D%E4%BD%9C%E8%BD%AF%E4%BB%B6/</id>
    <published>2022-03-19T06:05:47.000Z</published>
    <updated>2022-03-20T05:21:49.773Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Go操作Redis"><a href="#一、Go操作Redis" class="headerlink" title="一、Go操作Redis"></a>一、Go操作Redis</h2><p>redis第3方库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/garyburd/redigo/redis</span><br></pre></td></tr></table></figure><h3 id="连接redis"><a href="#连接redis" class="headerlink" title="连接redis"></a>连接redis</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//1.建立连接</span></span><br><span class="line">conn, err := redis.Dial(<span class="string">&quot;tcp&quot;</span>,</span><br><span class="line"><span class="string">&quot;127.0.0.1:6379&quot;</span>,</span><br><span class="line">redis.DialPassword(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;redis.Dial err=&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">//GetString(conn)</span></span><br><span class="line"><span class="comment">//GetHash(conn)</span></span><br><span class="line"><span class="comment">//GetMHash(conn)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作string"><a href="#操作string" class="headerlink" title="操作string"></a>操作string</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetString</span><span class="params">(conn redis.Conn)</span></span>&#123;</span><br><span class="line">   <span class="comment">//2. 通过go向redis写入数据</span></span><br><span class="line">   _, err := conn.Do(<span class="string">&quot;Set&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;tom&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;set err=&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//返回的结果是interface&#123;&#125;</span></span><br><span class="line">   name, err := redis.String(conn.Do(<span class="string">&quot;Get&quot;</span>, <span class="string">&quot;name&quot;</span>))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;set err=&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Get name=&quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作hash"><a href="#操作hash" class="headerlink" title="操作hash"></a>操作hash</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetHash</span><span class="params">(conn redis.Conn)</span></span>&#123;</span><br><span class="line">   <span class="comment">//2. 通过go向redis写入数据</span></span><br><span class="line">   _, err := conn.Do(<span class="string">&quot;HSet&quot;</span>, <span class="string">&quot;user01&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;tom&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;HSet err=&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   _, err = conn.Do(<span class="string">&quot;HSet&quot;</span>, <span class="string">&quot;user01&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">1</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;HSet err=&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//返回的结果是interface&#123;&#125;</span></span><br><span class="line">   name, err := redis.String(conn.Do(<span class="string">&quot;HGet&quot;</span>, <span class="string">&quot;user01&quot;</span>, <span class="string">&quot;name&quot;</span>))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;HSet err=&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   age, err := redis.Int(conn.Do(<span class="string">&quot;HGet&quot;</span>, <span class="string">&quot;user01&quot;</span>, <span class="string">&quot;age&quot;</span>))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;HSet err=&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;HGet name=%v, age=%v\n&quot;</span>, name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMHash</span><span class="params">(conn redis.Conn)</span></span>&#123;</span><br><span class="line">   <span class="comment">//2. 通过go向redis写入数据</span></span><br><span class="line">   _, err := conn.Do(<span class="string">&quot;HMSet&quot;</span>, <span class="string">&quot;user02&quot;</span>,</span><br><span class="line">      <span class="string">&quot;name&quot;</span>, <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">      <span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;HMSet err=&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//返回的结果是interface&#123;&#125;</span></span><br><span class="line">   r, err := redis.Strings(conn.Do(<span class="string">&quot;HMGet&quot;</span>, <span class="string">&quot;user01&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>))</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;HMGet err=&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> i, v := <span class="keyword">range</span> r&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;HMGet r[%d]=%s\n&quot;</span>, i, v)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redis连接池"><a href="#redis连接池" class="headerlink" title="redis连接池"></a>redis连接池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool = &amp; redis.Pool&#123;</span><br><span class="line">   MaxIdle: <span class="number">8</span>, <span class="comment">//最大空闲连接数</span></span><br><span class="line">   MaxActive: <span class="number">0</span>, <span class="comment">//数据库最大连接数, 0表示没有限制</span></span><br><span class="line">   IdleTimeout: <span class="number">100</span>, <span class="comment">//最大空闲时间</span></span><br><span class="line">   Dial: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(redis.Conn, error)</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> redis.Dial(<span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">         <span class="string">&quot;127.0.0.1:6379&quot;</span>,</span><br><span class="line">      redis.DialPassword(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、Go操作Redis&quot;&gt;&lt;a href=&quot;#一、Go操作Redis&quot; class=&quot;headerlink&quot; title=&quot;一、Go操作Redis&quot;&gt;&lt;/a&gt;一、Go操作Redis&lt;/h2&gt;&lt;p&gt;redis第3方库&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;go get github.com/garyburd/redigo/redis&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;连接redis&quot;&gt;&lt;a href=&quot;#连接redis&quot; class=&quot;headerlink&quot; title=&quot;连接redis&quot;&gt;&lt;/a&gt;连接redis&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//1.建立连接&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	conn, err := redis.Dial(&lt;span class=&quot;string&quot;&gt;&amp;quot;tcp&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;string&quot;&gt;&amp;quot;127.0.0.1:6379&amp;quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		redis.DialPassword(&lt;span class=&quot;string&quot;&gt;&amp;quot;123456&amp;quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;redis.Dial err=&amp;quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; conn.Close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//GetString(conn)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//GetHash(conn)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//GetMHash(conn)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;操作string&quot;&gt;&lt;a href=&quot;#操作string&quot; class=&quot;headerlink&quot; title=&quot;操作string&quot;&gt;&lt;/a&gt;操作string&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GetString&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(conn redis.Conn)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//2. 通过go向redis写入数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   _, err := conn.Do(&lt;span class=&quot;string&quot;&gt;&amp;quot;Set&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;tom&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;set err=&amp;quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//返回的结果是interface&amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   name, err := redis.String(conn.Do(&lt;span class=&quot;string&quot;&gt;&amp;quot;Get&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;set err=&amp;quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;Get name=&amp;quot;&lt;/span&gt;, name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;操作hash&quot;&gt;&lt;a href=&quot;#操作hash&quot; class=&quot;headerlink&quot; title=&quot;操作hash&quot;&gt;&lt;/a&gt;操作hash&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GetHash&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(conn redis.Conn)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//2. 通过go向redis写入数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   _, err := conn.Do(&lt;span class=&quot;string&quot;&gt;&amp;quot;HSet&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;user01&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;tom&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;HSet err=&amp;quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   _, err = conn.Do(&lt;span class=&quot;string&quot;&gt;&amp;quot;HSet&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;user01&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;age&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;HSet err=&amp;quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//返回的结果是interface&amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   name, err := redis.String(conn.Do(&lt;span class=&quot;string&quot;&gt;&amp;quot;HGet&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;user01&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;HSet err=&amp;quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   age, err := redis.Int(conn.Do(&lt;span class=&quot;string&quot;&gt;&amp;quot;HGet&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;user01&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;age&amp;quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;HSet err=&amp;quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fmt.Printf(&lt;span class=&quot;string&quot;&gt;&amp;quot;HGet name=%v, age=%v\n&amp;quot;&lt;/span&gt;, name, age)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;批量操作&quot;&gt;&lt;a href=&quot;#批量操作&quot; class=&quot;headerlink&quot; title=&quot;批量操作&quot;&gt;&lt;/a&gt;批量操作&lt;/h3&gt;</summary>
    
    
    
    <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
    <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go文件测试反射和网络</title>
    <link href="http://yoursite.com/2022/03/12/Go/Go%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%8F%8D%E5%B0%84%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2022/03/12/Go/Go%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%8F%8D%E5%B0%84%E5%92%8C%E7%BD%91%E7%BB%9C/</id>
    <published>2022-03-12T08:38:16.000Z</published>
    <updated>2022-03-15T16:05:31.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、文件"><a href="#一、文件" class="headerlink" title="一、文件"></a>一、文件</h2><h4 id="打开关闭"><a href="#打开关闭" class="headerlink" title="打开关闭"></a>打开关闭</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file,err:= os.open(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br></pre></td></tr></table></figure><h3 id="带缓冲的读取"><a href="#带缓冲的读取" class="headerlink" title="带缓冲的读取"></a>带缓冲的读取</h3><p>默认的相对路径是工程下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufferReader</span><span class="params">()</span></span>&#123;</span><br><span class="line">   file, err := os.Open(<span class="string">&quot;./src/file/d.txt&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;open file err=&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> file.Close()</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   创建一 *Reader, 是带缓冲的</span></span><br><span class="line"><span class="comment">   defaultBufSize = 4096 //默认缓冲为4096</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   reader := bufio.NewReader(file)</span><br><span class="line">   <span class="keyword">for</span>  &#123;</span><br><span class="line">      str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//读到换行结束</span></span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123; <span class="comment">//表示文件的末尾</span></span><br><span class="line">         fmt.Print(str)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//输出内容</span></span><br><span class="line">      fmt.Print(str)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;文件读取结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一次性读取文件"><a href="#一次性读取文件" class="headerlink" title="一次性读取文件"></a>一次性读取文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">   file := <span class="string">&quot;./src/file/d.txt&quot;</span></span><br><span class="line">   <span class="comment">//读取到的是一个byte[],封装了open和close</span></span><br><span class="line">   content, err:= ioutil.ReadFile(file)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;read file err=&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%v&quot;</span>, <span class="keyword">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">()</span></span>&#123;</span><br><span class="line">   filePath := <span class="string">&quot;./src/file/a.txt&quot;</span></span><br><span class="line">   file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;open file err=&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   str := <span class="string">&quot;hello,world&quot;</span></span><br><span class="line">   <span class="comment">//写入时，使用带缓存的 *Writer</span></span><br><span class="line">   writer := bufio.NewWriter(file)</span><br><span class="line">   writer.WriteString(str)</span><br><span class="line">   <span class="comment">//带缓存，没有写入</span></span><br><span class="line">   writer.Flush()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件打开方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   <span class="comment">// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.</span></span><br><span class="line">   O_RDONLY <span class="keyword">int</span> = syscall.O_RDONLY <span class="comment">// open the file read-only.</span></span><br><span class="line">   O_WRONLY <span class="keyword">int</span> = syscall.O_WRONLY <span class="comment">// open the file write-only.</span></span><br><span class="line">   O_RDWR   <span class="keyword">int</span> = syscall.O_RDWR   <span class="comment">// open the file read-write.</span></span><br><span class="line">   <span class="comment">// The remaining values may be or&#x27;ed in to control behavior.</span></span><br><span class="line">   O_APPEND <span class="keyword">int</span> = syscall.O_APPEND <span class="comment">// append data to the file when writing.</span></span><br><span class="line">   O_CREATE <span class="keyword">int</span> = syscall.O_CREAT  <span class="comment">// create a new file if none exists.</span></span><br><span class="line">   O_EXCL   <span class="keyword">int</span> = syscall.O_EXCL   <span class="comment">// used with O_CREATE, file must not exist.</span></span><br><span class="line">   O_SYNC   <span class="keyword">int</span> = syscall.O_SYNC   <span class="comment">// open for synchronous I/O.</span></span><br><span class="line">   O_TRUNC  <span class="keyword">int</span> = syscall.O_TRUNC  <span class="comment">// truncate regular writable file when opened.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="判断文件是否存在"><a href="#判断文件是否存在" class="headerlink" title="判断文件是否存在"></a>判断文件是否存在</h3><p>golang判断文件或文件夹是否存在的方法为使用<code>os.stat()</code>函数返回的错误值进行判断:</p><ol><li>如果返回的错误为nil,说明文件或文件夹存在</li><li>如果返回的错误类型使用<code>os.IsNotExist()</code>判断为true,说明文件或文件夹不存在</li><li>如果返回的错误为其它类型,则不确定是否在存在</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PathExists</span><span class="params">(path <span class="keyword">string</span>)</span><span class="params">(<span class="keyword">bool</span>,error)</span></span> &#123;</span><br><span class="line">err := os.Stat(path)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> os.lsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><p>可以完成包括图片视频的拷贝</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstFileName <span class="keyword">string</span>, srcFileName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span>&#123;</span><br><span class="line">   <span class="comment">//打开源文件</span></span><br><span class="line">   srcfile, err := os.Open(srcFileName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span>  srcfile.Close()</span><br><span class="line">   reader:= bufio.NewReader(srcfile)</span><br><span class="line">   <span class="comment">//目标文件</span></span><br><span class="line">   dstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span>  dstFile.Close()</span><br><span class="line">   writer := bufio.NewWriter(dstFile)</span><br><span class="line">   <span class="keyword">return</span> io.Copy(writer, reader)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testCopy</span><span class="params">()</span></span>&#123;</span><br><span class="line">   srcFile := <span class="string">&quot;./src/file/d.txt&quot;</span></span><br><span class="line">   dstFile := <span class="string">&quot;./src/file/b.txt&quot;</span></span><br><span class="line">   _, err := CopyFile(dstFile, srcFile)</span><br><span class="line">   <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;拷贝完成&quot;</span>)</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计字符"><a href="#统计字符" class="headerlink" title="统计字符"></a>统计字符</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CharCount <span class="keyword">struct</span> &#123;</span><br><span class="line">   ChCount <span class="keyword">int</span> <span class="comment">//记录英文</span></span><br><span class="line">   NumCount <span class="keyword">int</span> <span class="comment">//数字</span></span><br><span class="line">   SpaceCount <span class="keyword">int</span>     <span class="comment">//记录空格</span></span><br><span class="line">   OtherCount <span class="keyword">int</span> <span class="comment">//其他字符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">charCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//打开源文件</span></span><br><span class="line">   fileName := <span class="string">&quot;./src/file/d.txt&quot;</span></span><br><span class="line">   srcfile, err := os.Open(fileName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;open file err=%v\n&quot;</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span>  srcfile.Close()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> count CharCount</span><br><span class="line">   reader := bufio.NewReader(srcfile)</span><br><span class="line">   <span class="comment">//循环读取</span></span><br><span class="line">   <span class="keyword">for</span>  &#123;</span><br><span class="line">      str, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> _, v := <span class="keyword">range</span> str&#123;</span><br><span class="line">         <span class="keyword">switch</span> &#123;</span><br><span class="line">         <span class="keyword">case</span> v &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;z&#x27;</span>:</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">         <span class="keyword">case</span> v &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">            count.ChCount++</span><br><span class="line">         <span class="keyword">case</span> v == <span class="string">&#x27; &#x27;</span> || v == <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">            count.SpaceCount++</span><br><span class="line">         <span class="keyword">case</span> v &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; v &lt;= <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            count.NumCount++</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">            count.OtherCount++</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;ChCount=%v, SpaceCount=%v, NumCount=%v, OtherCount=%v&quot;</span>,</span><br><span class="line">      count.ChCount,count.SpaceCount,count.NumCount,count.OtherCount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>flag包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">args</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> user <span class="keyword">string</span></span><br><span class="line">   <span class="keyword">var</span> pwd <span class="keyword">string</span></span><br><span class="line">   <span class="keyword">var</span> host <span class="keyword">string</span></span><br><span class="line">   <span class="keyword">var</span> port <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//接收命令行参数 -u后面的参数值</span></span><br><span class="line">   flag.StringVar(&amp;user, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="string">&quot;用户名，默认为空&quot;</span> )</span><br><span class="line">   flag.StringVar(&amp;pwd, <span class="string">&quot;p&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="string">&quot;密码，默认为空&quot;</span> )</span><br><span class="line">   flag.StringVar(&amp;host, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;主机，默认为localhost&quot;</span> )</span><br><span class="line">   flag.IntVar(&amp;port, <span class="string">&quot;port&quot;</span>, <span class="number">3306</span>,<span class="string">&quot;端口，默认为3306&quot;</span> )</span><br><span class="line">   <span class="comment">//必须调用，转换</span></span><br><span class="line">   flag.Parse()</span><br><span class="line">   fmt.Printf(<span class="string">&quot;user=%v,pwd=%v,host=%v,port=%v&quot;</span>,user,pwd,host,port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build -o test.exe start.go args.go</span><br><span class="line">test.exe -u a -p 1</span><br><span class="line">user=a,<span class="built_in">pwd</span>=1,host=localhost,port=3306</span><br></pre></td></tr></table></figure><h3 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h3><p>将有key-value结构的数据类型(比如<strong>结构体、map、切片</strong>序列化成json字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">   Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testJson</span><span class="params">()</span></span>&#123;</span><br><span class="line">   student := Student&#123;</span><br><span class="line">      Name: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">      Age:  <span class="number">18</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   data, err := json.Marshal(&amp;student)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;序列化错误，err=%v&quot;</span>,err)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="keyword">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用tag将字段转换的名称更改,这里使用了反射机制</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">   Age <span class="keyword">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unmarshalStruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">   str := <span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;a\&quot;,\&quot;age\&quot;:18&#125;&quot;</span></span><br><span class="line">   <span class="keyword">var</span> student Student</span><br><span class="line">   err := json.Unmarshal([]<span class="keyword">byte</span>(str), &amp;student)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;序列化错误，err=%v&quot;</span>,err)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(student)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//&#123;a 18&#125;</span></span><br></pre></td></tr></table></figure><h2 id="二、单元测试"><a href="#二、单元测试" class="headerlink" title="二、单元测试"></a>二、单元测试</h2><p>Go语言中自带有一个轻量级的测试框架<code>testing</code>和自带的<code>go test</code>命令来实现单元测试和性能测试，testing框架和其他语言中的测试框架类似，可以<strong>基于这个框架写针对相应函数的测试用例</strong>，也可以基于该框架写相应的压力测试用例。通过单元测试，可以解决如下问题:</p><ol><li>确保每个函数是可运行，并且运行结果是正确的</li><li>确保写出来的代码<strong>性能是好</strong>的，</li><li>单元测试能及时的发现程序设计或实现的逻辑错误，使问题及早暴露，便于问题的定位解决，而性能测试的重点在于发现程序设计上的一些问题，让程序能够在高并发的情况下还能保持稳定</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestXXX</span><span class="params">(t *testing.T)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>要编写一个新的测试套件，需要<strong>创建一个名称以_test go结尾的文件</strong>，该文件包含<code>TestXxx</code>函数，如上所述。将该<strong>文件放在与被测试的包相同的包</strong>中，<strong>该文件将被排除在正常的程序包之外</strong>，但在<strong>运行go test命令时将被包含</strong>。有关详细信息，<br>如果有需要，可以调用T和*B的Skip方法，跳过该测试或基准测试︰</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//被测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addUpper</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   res := <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n;i++&#123;</span><br><span class="line">      res +=i</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAddUpper</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">   res := addUpper(<span class="number">10</span>)</span><br><span class="line">   <span class="keyword">if</span> res != <span class="number">55</span> &#123;</span><br><span class="line">      t.Fatalf(<span class="string">&quot;AddUpper执行失败,期望值=%v, 实际值=%v&quot;</span>,<span class="number">55</span>, res)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//正确</span></span><br><span class="line">   t.Logf(<span class="string">&quot;AddUpper执行成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将文件写在cal_test中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -v</span><br><span class="line">=== RUN   TestAddUpper</span><br><span class="line">    cal_test.go:21: AddUpper执行成功</span><br><span class="line">--- PASS: TestAddUpper (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      unittest        0.389s</span><br></pre></td></tr></table></figure><h2 id="三、反射"><a href="#三、反射" class="headerlink" title="三、反射"></a>三、反射</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>反射可以用来做适配器方法,在框架中特别多</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">testi = <span class="function"><span class="keyword">func</span><span class="params">(v1 <span class="keyword">int</span>, v2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">t.Log(v1,v2)</span><br><span class="line">&#125;</span><br><span class="line">test2 := <span class="function"><span class="keyword">func</span><span class="params">(v1 <span class="keyword">int</span>, v2 <span class="keyword">int</span>, s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    t.Log(v1,v2,s)</span><br><span class="line">&#125;</span><br><span class="line">bridge= fund(call interfacet,args ...<span class="keyword">interface</span>&#123;&#125;)&#123;<span class="comment">//内容</span></span><br><span class="line">W√</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现调用test1对应的函数</span></span><br><span class="line">bridge(test1,<span class="number">1</span>,<span class="number">2</span>) </span><br><span class="line"><span class="comment">//实现调用test2对应的函数</span></span><br><span class="line">bridge(test2,<span class="number">1</span>,<span class="number">2</span>, <span class="string">&quot;test2&quot;</span>)</span><br></pre></td></tr></table></figure><ol><li>反射可以在运行时<strong>动态获取变量的各种信息，比如变量的类型(type)，类别(kind)</strong></li><li>如果是结构体变量，还可以获取到结构体本身的信息(包括<strong>结构体的字段、方法</strong>)</li><li>通过反射，可以修改变量的值,可以调用关联的方法。</li></ol><ul><li><code>reflect.Type(v)</code>返回接口，获取变量类型</li><li><code>reflect.Value(v)</code>返回结构体，获取变量的值</li></ul><p>变量、<code>interface&#123;&#125;</code>和<code>reflect.Value</code>是可以相互转换的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量</span></span><br><span class="line"><span class="keyword">var</span> student stu</span><br><span class="line"></span><br><span class="line"><span class="comment">//专门用于做反射，将student传入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将interface转成reflect.Value</span></span><br><span class="line">    rVal := reflect.ValueOf(b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.reflect.Value转为interface&#123;&#125;</span></span><br><span class="line">    iVal := rVal.<span class="keyword">interface</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.将interface&#123;&#125;转成原理的变量类型，类型断言</span></span><br><span class="line">    v := iVal.(Stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="基本类型操作"><a href="#基本类型操作" class="headerlink" title="基本类型操作"></a>基本类型操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line"><span class="comment">//获取传入变量的type，kind</span></span><br><span class="line">rT := reflect.TypeOf(b)</span><br><span class="line">fmt.Println(<span class="string">&quot;rType =&quot;</span>,rT) <span class="comment">//rType = int</span></span><br><span class="line"></span><br><span class="line">rV := reflect.ValueOf(b)</span><br><span class="line">fmt.Println(<span class="string">&quot;rValue =&quot;</span>,rV)<span class="comment">//rValue = 100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取具体值</span></span><br><span class="line">    iV := rV.Interface()</span><br><span class="line">num := iV.(<span class="keyword">int</span>)</span><br><span class="line">fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">reflectTest(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体操作"><a href="#结构体操作" class="headerlink" title="结构体操作"></a>结构体操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">   Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectTest02</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line"><span class="comment">//1.获取传入变量的type</span></span><br><span class="line">rT := reflect.TypeOf(b)</span><br><span class="line">fmt.Println(<span class="string">&quot;rType =&quot;</span>,rT)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取传入变量的value</span></span><br><span class="line">rV := reflect.ValueOf(b)</span><br><span class="line">fmt.Println(<span class="string">&quot;rValue =&quot;</span>,rV)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取传入变量的Kind </span></span><br><span class="line">fmt.Printf(<span class="string">&quot;kind1=%v, kind2=%v \n&quot;</span>, rT.Kind(), rV.Kind())</span><br><span class="line"></span><br><span class="line">iV := rV.Interface()</span><br><span class="line">fmt.Printf(<span class="string">&quot;iv = %v, iV = %T&quot;</span>, iV, iV)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">stu := Student&#123;</span><br><span class="line">Name : <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">Age : <span class="number">18</span> ,</span><br><span class="line">&#125;</span><br><span class="line">reflectTest02(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改变量"><a href="#修改变量" class="headerlink" title="修改变量"></a>修改变量</h4><p>Elem返回v持有的接口<strong>保管的值的Value封装</strong>，或者v<strong>持有的指针指向的值的value封装</strong>。如果v的Kind不是Interface或Ptr会panic;如果v持有的值为nil，会返回value零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">   modifyNum(&amp;num)</span><br><span class="line">   fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyNum</span><span class="params">(b <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">   rV := reflect.ValueOf(b)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;kind=%v\n&quot;</span>, rV.Kind()) <span class="comment">//ptr</span></span><br><span class="line">   rV.Elem().SetInt(<span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射实践"><a href="#反射实践" class="headerlink" title="反射实践"></a>反射实践</h3><ol><li>通过反射变量结构体的字段，调研结构体方法，并获得结构体标签的值</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name   <span class="keyword">string</span>        <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">   Age    <span class="keyword">int</span>       <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">   Score  <span class="keyword">float32</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">   Sex    <span class="keyword">string</span>        <span class="string">`json:&quot;sex&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;-----start----&quot;</span>)</span><br><span class="line">   fmt.Println(s)</span><br><span class="line">   fmt.Println(<span class="string">&quot;-----end----&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span> <span class="title">GetSum</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Monster)</span> <span class="title">Set</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   score <span class="keyword">float32</span>, sex <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   s.Name = name</span><br><span class="line">   s.Age = age</span><br><span class="line">   s.Score = score</span><br><span class="line">   s.Sex = sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestStruct</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">   typ := reflect.TypeOf(a)</span><br><span class="line">   val := reflect.ValueOf(a)</span><br><span class="line">   kd := val.Kind()</span><br><span class="line">   <span class="keyword">if</span> kd != reflect.Struct &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;expect struct&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//结构体字段</span></span><br><span class="line">   num := val.NumField()</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Field %d = %v \n&quot;</span>, i,  val.Field(i))</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Field %d:%v tag=%v \n&quot;</span>, i, typ.Field(i), typ.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   method := val.NumMethod()</span><br><span class="line">   fmt.Printf(<span class="string">&quot;methodNum=%v\n&quot;</span>, method)</span><br><span class="line">   <span class="keyword">var</span> params []reflect.Value</span><br><span class="line">   params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">   params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">20</span>))</span><br><span class="line">   <span class="comment">//方法按字母排序</span></span><br><span class="line">   res := val.Method(<span class="number">0</span>).Call(params) <span class="comment">//传入参数 reflect.Value</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;res=&quot;</span>,res[<span class="number">0</span>].Int())   <span class="comment">//返回结果 reflect.Value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testMonster</span><span class="params">()</span></span>&#123;</span><br><span class="line">   monster := Monster&#123;</span><br><span class="line">      Name:  <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">      Age:   <span class="number">18</span>,</span><br><span class="line">      Score: <span class="number">30</span>,</span><br><span class="line">      Sex:   <span class="string">&quot;man&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   TestStruct(monster)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>适配器</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bridge</span><span class="params">(call <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">   n := <span class="built_in">len</span>(args)</span><br><span class="line">   inValue := <span class="built_in">make</span>([]reflect.Value, n)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">      inValue[i] = reflect.ValueOf(args[i])</span><br><span class="line">   &#125;</span><br><span class="line">   function := reflect.ValueOf(call)</span><br><span class="line">   function.Call(inValue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReflectFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">   call1 := <span class="function"><span class="keyword">func</span><span class="params">(v1 ,v2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      fmt.Println(v1,v2)</span><br><span class="line">   &#125;</span><br><span class="line">   call2 := <span class="function"><span class="keyword">func</span><span class="params">(v1 ,v2 <span class="keyword">int</span>,s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">      fmt.Println(v1,v2,s)</span><br><span class="line">   &#125;</span><br><span class="line">   bridge(call1, <span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">   bridge(call2, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;s&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、网络编程"><a href="#四、网络编程" class="headerlink" title="四、网络编程"></a>四、网络编程</h2><p>Golang的主要设计目标之一就是面向大规模后端服务程序，网络通信这块是服务端程序必不可少也是至关重要的一部分。</p><p>服务端的处理流程</p><ol><li><p>监听端口</p></li><li><p>接收客户端的tcp链接，建立客户端和服务器端的链接.</p></li><li><p>创建goroutine，处理该链接的请求(通常客户端会通过链接发送请求包)</p></li></ol><p>客户端的处理流程</p><ol><li>建立与服务端的链接</li><li>发送请求数据，接收服务器端返回的结果数据</li><li>关闭链接</li></ol><p>server.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">   <span class="comment">//循环接收</span></span><br><span class="line">   <span class="keyword">defer</span> conn.Close() <span class="comment">//关闭</span></span><br><span class="line">   <span class="keyword">for</span>  &#123;</span><br><span class="line">      <span class="comment">//创建切片</span></span><br><span class="line">      buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">      <span class="comment">//等等客户端发送数据,这里会一直阻塞</span></span><br><span class="line">      fmt.Printf(<span class="string">&quot;等等客户端数据：%v\n&quot;</span>, conn.RemoteAddr())</span><br><span class="line">      n, err := conn.Read(buf) <span class="comment">//读取数据</span></span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;客户端退出&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;服务器开始监听&quot;</span>)</span><br><span class="line">   listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8888&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;listen err=&quot;</span>,err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> listen.Close()</span><br><span class="line">   fmt.Printf(<span class="string">&quot;listen suc=%v\n&quot;</span>, listen)</span><br><span class="line"></span><br><span class="line">   <span class="comment">//循环等待</span></span><br><span class="line">   <span class="keyword">for</span>  &#123;</span><br><span class="line">      <span class="comment">//等待客户端</span></span><br><span class="line">      fmt.Println(<span class="string">&quot;等待客户端&quot;</span>)</span><br><span class="line">      conn, err := listen.Accept()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;Accept err=&quot;</span>,err)</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         fmt.Printf(<span class="string">&quot;Accept suc=%v,client ip=%v \n&quot;</span>, conn, conn.RemoteAddr())</span><br><span class="line">         <span class="keyword">go</span> process(conn)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8888&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;client dial err=&quot;</span>,err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;conn suc=%v\n&quot;</span>, conn)</span><br><span class="line">   <span class="comment">//发送数据</span></span><br><span class="line">   <span class="comment">//从终端获取</span></span><br><span class="line">   reader := bufio.NewReader(os.Stdin)</span><br><span class="line">   <span class="keyword">for</span>  &#123;</span><br><span class="line">      line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;ReadString err=&quot;</span>,err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//exit退出</span></span><br><span class="line">      <span class="keyword">if</span> strings.Trim(line, <span class="string">&quot;\r\n&quot;</span>) == <span class="string">&quot;exit&quot;</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;客户端退出&quot;</span>)</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//发送消息</span></span><br><span class="line">      n, err := conn.Write([]<span class="keyword">byte</span>(line))</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;Write err=&quot;</span>, err)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;发送了 %d 字节的数据\n&quot;</span>, n)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、文件&quot;&gt;&lt;a href=&quot;#一、文件&quot; class=&quot;headerlink&quot; title=&quot;一、文件&quot;&gt;&lt;/a&gt;一、文件&lt;/h2&gt;&lt;h4 id=&quot;打开关闭&quot;&gt;&lt;a href=&quot;#打开关闭&quot; class=&quot;headerlink&quot; title=&quot;打开关闭&quot;&gt;&lt;/a&gt;打开关闭&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;file,err:= os.open(&lt;span class=&quot;string&quot;&gt;&amp;quot;test.txt&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; file.Close()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;带缓冲的读取&quot;&gt;&lt;a href=&quot;#带缓冲的读取&quot; class=&quot;headerlink&quot; title=&quot;带缓冲的读取&quot;&gt;&lt;/a&gt;带缓冲的读取&lt;/h3&gt;&lt;p&gt;默认的相对路径是工程下&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bufferReader&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   file, err := os.Open(&lt;span class=&quot;string&quot;&gt;&amp;quot;./src/file/d.txt&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;open file err=&amp;quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; file.Close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   创建一 *Reader, 是带缓冲的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   defaultBufSize = 4096 //默认缓冲为4096&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   reader := bufio.NewReader(file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      str, err := reader.ReadString(&lt;span class=&quot;string&quot;&gt;&amp;#x27;\n&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;//读到换行结束&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err == io.EOF &amp;#123; &lt;span class=&quot;comment&quot;&gt;//表示文件的末尾&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         fmt.Print(str)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;//输出内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      fmt.Print(str)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;文件读取结束&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;一次性读取文件&quot;&gt;&lt;a href=&quot;#一次性读取文件&quot; class=&quot;headerlink&quot; title=&quot;一次性读取文件&quot;&gt;&lt;/a&gt;一次性读取文件&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;readAll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   file := &lt;span class=&quot;string&quot;&gt;&amp;quot;./src/file/d.txt&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//读取到的是一个byte[],封装了open和close&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   content, err:= ioutil.ReadFile(file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;read file err=&amp;quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fmt.Printf(&lt;span class=&quot;string&quot;&gt;&amp;quot;%v&amp;quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;(content))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;写文件&quot;&gt;&lt;a href=&quot;#写文件&quot; class=&quot;headerlink&quot; title=&quot;写文件&quot;&gt;&lt;/a&gt;写文件&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;writeFile&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   filePath := &lt;span class=&quot;string&quot;&gt;&amp;quot;./src/file/a.txt&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, &lt;span class=&quot;number&quot;&gt;0666&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;open file err=&amp;quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   str := &lt;span class=&quot;string&quot;&gt;&amp;quot;hello,world&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//写入时，使用带缓存的 *Writer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   writer := bufio.NewWriter(file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   writer.WriteString(str)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;//带缓存，没有写入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   writer.Flush()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
    <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go面向对象</title>
    <link href="http://yoursite.com/2022/02/23/Go/Go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2022/02/23/Go/Go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-02-23T14:52:21.000Z</published>
    <updated>2022-03-07T15:20:43.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Go的面向对象"><a href="#一、Go的面向对象" class="headerlink" title="一、Go的面向对象"></a>一、Go的面向对象</h2><ul><li><p>Golang也支持面向对象编程(OOP)，但是和传统的面向对象编程有区别，并不是纯粹的面向对象语言。所以我们说Golang<strong>支持面向对象编程特性</strong>是比较准确的。</p></li><li><p>Golang<strong>没有类(class)</strong>，Go语言的结构体(struct)和其它编程语言的类(class)有同等的地位，你可以理解Golang是基于struct来实现OOP特性的。</p></li><li><p>Golang面向对象编程非常简洁，去<strong>掉了传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针</strong>等等</p></li><li><p>Golang仍然有面向对象编程的继承，封装和多态的特性，只是<strong>实现的方式和其它OOP语言不一样</strong>，比如继承: Golang<strong>没有extends 关键字</strong>，继承是通过<strong>匿名字段</strong>来实现。</p></li><li><p>Golang面向对象(OOP)很优雅，OOP本身就是语言类型系统(type system)的一部分，<strong>通过接口(interface)关联</strong>，<strong>耦合性低</strong>，也非常灵活。后面同学们会充分体会到这个特点。也就是说在Golang中<strong>面向接口编程</strong>是非常重要的特性。</p></li></ul><h2 id="二、struct"><a href="#二、struct" class="headerlink" title="二、struct"></a>二、struct</h2><p>定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建一个结构体变量后，如果没有给字段赋值，都对应一个零值(默认值)<br>布尔类型是false ，数值是0，字符串是””。<br>数组类型的默认值和它的元素类型相关，比如score [3]int则为[0,0,0]，<strong>指针，slice，和map的零值都是nil ，即还没有分配空间。</strong></p><p>结构体中如果是引用类型，不要补个结构体之间赋值会改变内容</p><p>创建结构体变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> person Person</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">p2 := Person&#123;<span class="string">&quot;a&quot;</span>, <span class="number">20</span>&#125;</span><br><span class="line"><span class="comment">//p2.Age = 18</span></span><br><span class="line"><span class="comment">//p2.Name = &quot;a&quot;</span></span><br><span class="line">fmt.Println(p2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 </span></span><br><span class="line"><span class="keyword">var</span> p3 *Person = <span class="built_in">new</span>(Person)</span><br><span class="line">p3.Name=<span class="string">&quot;smith&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="keyword">var</span> p4 *Person = &amp;Person&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>第3种和第4种坊式返回的是结构体指针。</li><li>结构体指针访问字段的标准方式应该是:<strong>(*结构体指针).字段名</strong>，比如<code>(*person).Name = &quot;tom&quot;</code></li><li>但go做了一个简化，也支持结构体指针.字段名,比如<code>person.Name = &quot;tom&quot;</code>。更加符合程序员使用的习惯，go<strong>编译器底层对person.Name做了转化(*person).Name</strong></li></ul><p>struct的每个字段上，可以写上一个tag，该tag可以通过反射机制获取，常见的使用场景就是<strong>序列号和反序列化。</strong></p><p>问题: json处理后的字段名也是首字母大写，这样如果我们是将json后的字符串返回给其它程序使用，比如jquery,php等,那么可能他们的不习惯这个命名方式,怎么办?<br>解决方案</p><ol><li>将Monster的字段首字母小写，这个行不通，你会发现处理后,返回的是空字符串,因为<code>json.Marshal</code> 相当于在其它包访问monster结构体，<strong>你首字母小写，就不能在其它包访问。</strong></li><li>使用<strong>tag标签</strong>来解决</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Monster <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="keyword">string</span>    <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">   Age <span class="keyword">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useJson</span><span class="params">()</span></span>&#123;</span><br><span class="line">   monster := Monster&#123;<span class="string">&quot;a&quot;</span>,<span class="number">16</span>&#125;</span><br><span class="line">   <span class="comment">//字母只能是大写,否则访问不到</span></span><br><span class="line">   jsonMonster, _ := json.Marshal(monster)</span><br><span class="line">   <span class="comment">//fmt.Println(jsonMonster)</span></span><br><span class="line">   <span class="comment">//[123 34 78 97 109 101 34 58 34 97 34 44 34 65 103 101 34 58 49 54 125]</span></span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(jsonMonster))</span><br><span class="line">    <span class="comment">//&#123;&quot;name&quot;:&quot;a&quot;,&quot;age&quot;:16&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、方法"><a href="#三、方法" class="headerlink" title="三、方法"></a>三、方法</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Golang中的方法是<strong>作用在指定的数据类型</strong>上的(即。和<strong>指定的数据类型绑定</strong>)，因此自定义类型，都可以有方法，而不仅仅是struct。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">   Num <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(a.Num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a A</span><br><span class="line">    a.test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在通过一个变量去调用方法时，其调用机制和函数─样。不一样的地方时，变量调用方法时，该变量本身也会作为一个参数传递到方法(如果变量是值类型，则进行值拷贝，如果变量是引用类型，则进行地质拷贝)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recevier <span class="keyword">type</span>)</span> <span class="title">methodName</span><span class="params">(参数列表)</span><span class="params">(返回值列表)</span></span>&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="comment">//return 返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>为了提高效率通常使用指针的传递</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">   radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(c *Circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> c Circle</span><br><span class="line">    <span class="comment">//标准 (&amp;c).area()</span></span><br><span class="line">    c.area()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>Golang中的方法作用在指定的数据类型上的(即:和指定的数据类型绑定)，因此<strong>自定义类型,都可以有方法</strong>，而不仅仅是struct，比如int , float32等都可以有方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Integer <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(i Integer)</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testInteger</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> i Integer = <span class="number">10</span></span><br><span class="line">   i.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法的访问范围控制的规则，和函数一样。<strong>方法名首字母小写，只能在本包访问，方法首字母大写，可以在本包和其它包访问。</strong></p></li><li><p>如果一个变量实现了<code>string()</code>这个方法，那么<strong>fmt.Println默认会调用这个变量的String()进行输出</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">   b <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">   str := fmt.Sprintf(<span class="string">&quot;b=[%v]&quot;</span>,b.b)</span><br><span class="line">   <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testString</span><span class="params">()</span></span>&#123;</span><br><span class="line">   b := B&#123;</span><br><span class="line">      b :<span class="number">1</span>,</span><br><span class="line">   &#125; </span><br><span class="line">   fmt.Println(&amp;b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法和函数的区别"><a href="#方法和函数的区别" class="headerlink" title="方法和函数的区别"></a>方法和函数的区别</h3><ol><li><p>调用方式不一样函数的调用方式:<code>函数名(实参列表)</code><br>方法的调用方式:<code>变量.方法名(实参列表)</code></p></li><li><p>对于普通函数，接收者为值类型时，<strong>不能将指针类型的数据直接传递</strong>，反之亦然</p></li><li><p>对于方法（如struct的方法），接收者为值类型时，<strong>可以直接用指针类型的变量调用方法</strong>,反过来同样也可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里才能觉得是值传递函数指针传递</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b B)</span> <span class="title">testPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">   b.b = <span class="number">10</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;method&quot;</span>,b.b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">   b := B&#123;<span class="number">1</span>&#125;</span><br><span class="line">   (&amp;b).testPointer()<span class="comment">//这里只是将指针的值传递了过去</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;main&quot;</span>,b.b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//method 10</span></span><br><span class="line"><span class="comment">//main 1</span></span><br></pre></td></tr></table></figure><p>不管调用形式如何，真正决定是值拷贝还是地址拷贝，看这个方法是和哪个类型绑定.<br>如果是和值类型，比如(p Person)，则是值拷贝，如果和指针类型，比如是(p*Person)则是地址拷贝。</p></li></ol><h2 id="四、工厂模式"><a href="#四、工厂模式" class="headerlink" title="四、工厂模式"></a>四、工厂模式</h2><p>Golang的结构体<strong>没有构造函数，</strong>通常可以使用工厂模式来解决这个问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span>..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里的Student的首字母s是大写的,如果我们想在其它包创建Student 的实例(比如main包),引入model包后，就可以直接创建Student结构体的变量(实例)。但是问题来了，如果首字母是小写的，比如是type student struct …就不不行了，怎么办-工工厂模式来解决.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">   Name <span class="keyword">string</span></span><br><span class="line">   Score <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(n <span class="keyword">string</span>, s <span class="keyword">float64</span>)</span> *<span class="title">student</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;student&#123;</span><br><span class="line">      Name: n,</span><br><span class="line">      Score: s,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、继承"><a href="#五、继承" class="headerlink" title="五、继承"></a>五、继承</h2><p>继承可以<strong>解决代码复用</strong></p><p>当多个结构体存在相同的属性(字段)和方法时,可以从这些结构体中抽象出结构体(比如刚才的Student),在该结构体中定义这些相同的属性和方法。</p><p>也就是说:在Golang中，如果一个struct嵌套了另一个匿名结构体，那么<strong>这个结构体可以直接访问匿名结构体的字段和方法</strong>，从而实现了继承特性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Goods <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span>&#123;</span><br><span class="line">    Goods</span><br><span class="line">    Writer <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>结构体可以使用嵌套匿名结构体所有的字段和方法，即:首字母大写或者小写的字段、方法,都可以使用。</p></li><li><p>当我们直接通过b 访问字段或方法时，其执行流程如下比如<code>b.Name</code>,编译器会<strong>先看b对应的类型有没有Name</strong>，如果有，则直接调用B类型的Name字段,如果没有就去看B中嵌入的匿名结构体A有没有声明Name字段,如果有就调用,如果没有继续查找..如果都找不到就报错.</p></li><li><p>当结构体和匿名结构体有<strong>相同的字段或者方法</strong>时，编译器采用<strong>就近访问原则</strong>访问，如希望访问匿名结构体的字段和方法，可以<strong>通过匿名结构体名来区分</strong>.</p></li><li><p>如果一个struct<strong>嵌套了一个有名结构体</strong>，这种模式就是<strong>组合</strong>，如果是组合关系，那么在访问组合的结构体的字段或方法时，<strong>必须带上结构体的名字</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span>&#123;</span><br><span class="line">    good Goods</span><br><span class="line">    Writer <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="六、接口"><a href="#六、接口" class="headerlink" title="六、接口"></a>六、接口</h2><p>interface类型可以定义一组方法，但是这些不需要实现。并且interface<strong>不能包含任何变量</strong>。到某个自定义类型(比如结构体Phone)要使用的时候,在根据具体情况把这些方法写出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span>&#123;</span><br><span class="line">method1(参数列表)返回值列表</span><br><span class="line">    method2(参数列表)返回值列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法。接口体现了程序设计的<strong>多态和高内聚低偶合</strong>的思想。</li><li>Golang中的接口，<strong>不需要显式的实现。只要一个变量</strong>，<strong>含有接口类型中的所有方法</strong>，那么<strong>这个变量就实现这个接口</strong>。因此，Golang中没有implement这样的关键字</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Usb <span class="keyword">interface</span> &#123;</span><br><span class="line">   Start()</span><br><span class="line">   Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;手机开始工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Phone)</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;手机停止工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Computer <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Computer)</span> <span class="title">Working</span><span class="params">(usb Usb)</span></span>&#123;</span><br><span class="line">   usb.Start()</span><br><span class="line">   usb.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testUsb</span><span class="params">()</span></span>&#123;</span><br><span class="line">   c := Computer&#123;&#125;</span><br><span class="line">   p := Phone&#123;&#125;</span><br><span class="line">   c.Working(p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手机开始工作</span></span><br><span class="line"><span class="comment">//手机停止工作</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>接口本身<strong>不能创建实例</strong>,但是可以指<strong>向一个实现了该接口</strong>的自定义类型的变量(实例)</li><li>接口中所有的方法都<strong>没有方法体</strong>,即都是没有实现的方法。</li><li>在Golang中，一个自定义类型需要将某个接口的所有方法都实现，我们说这个自定义类型实现了该接口。</li><li>一个自定义类型<strong>只有实现了某个接口，才能将该自定义类型的实例(变量)赋给接口类型</strong>。</li><li>只要是自定义数据类型，<strong>就可以实现接口</strong>，不仅仅是结构体类型。</li><li>一个自定义类型可以实现多个接口</li><li>Golang接口中<strong>不能有任何变量</strong></li><li>一个接口(比如A接口)可以继承多个别的接口(比如B,C接口)，这时如果要实现A接口,也必须将B,c接口的方法也全部实现。</li><li>interface类型默认是一个指针,I如果没有对interface初始化就使用，那么会输出nil</li><li>空接口interface没有任何方法，所以所有类型都实现了空接口</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>  Test <span class="keyword">interface</span> &#123;</span><br><span class="line">   Say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Stu <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(stc *Stu)</span> <span class="title">Say</span><span class="params">()</span></span>&#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Say&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> stu Stu = Stu&#123;&#125;</span><br><span class="line">    <span class="comment">//报错，没有实现Stu，*Stu实现了接口</span></span><br><span class="line">   <span class="comment">//var t Test= stu</span></span><br><span class="line">    <span class="keyword">var</span> t Test= &amp;stu</span><br><span class="line">   t.Say()</span><br><span class="line">   fmt.Println(<span class="string">&quot;here&quot;</span>,t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口和继承"><a href="#接口和继承" class="headerlink" title="接口和继承"></a>接口和继承</h3><ul><li>接口和继承解决的解决的问题不同<br>继承的价值主要在于:<strong>解决代码的复用性和可维护性</strong>。<br>接口的价值主要在于:<strong>设计，设计好各种规范(方法)</strong>，让其它自定义类型去实现这些方法。</li><li>接口比继承更加灵活<br>接口比继承更加灵活，继承是满足 <strong>is - a</strong>的关系，而接口只需满足 <strong>like - a</strong>的关系。</li><li>接口在一定程度上实现代码解耦</li></ul><h2 id="七、多态"><a href="#七、多态" class="headerlink" title="七、多态"></a>七、多态</h2><p>变量(实例)具有多种形态。面向对象的第三大特征，在Go语言，<strong>多态特征是通过接口实现的</strong>。可以按照<strong>统一的接口来调用不同的实现</strong>。这时<strong>接口变量就呈现不同的形态</strong>。</p><ul><li>多态参数<br>在前面的Usb接口案例，Usb usb，即可以接收手机变量，又可以接收相机变量，就体现了Usb接口多态</li><li>多态数组<br>给Usb数组中，存放Phone 结构体和Camera结构体变量</li></ul><h2 id="八、类型断言"><a href="#八、类型断言" class="headerlink" title="八、类型断言"></a>八、类型断言</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">   x <span class="keyword">int</span></span><br><span class="line">   y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useAssert</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">var</span> point Point = Point&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">   a = point <span class="comment">//oK</span></span><br><span class="line">   <span class="comment">//如何将a赋给一个Point变量?</span></span><br><span class="line">   <span class="comment">// b = a不可以</span></span><br><span class="line">   <span class="keyword">var</span> b Point</span><br><span class="line">   b = a.(Point)</span><br><span class="line">   fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将一个接口变量，赋给自定义类型的变量.=&gt;引出类型断言.</p><p>类型断言判断</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y, ok := x.(<span class="keyword">float64</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;y的类型是%T值是=%v&quot;</span>, y. y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、Go的面向对象&quot;&gt;&lt;a href=&quot;#一、Go的面向对象&quot; class=&quot;headerlink&quot; title=&quot;一、Go的面向对象&quot;&gt;&lt;/a&gt;一、Go的面向对象&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Golang也支持面向对象编程(OOP)，但是和传统的面向对象编程有区别，并不是纯粹的面向对象语言。所以我们说Golang&lt;strong&gt;支持面向对象编程特性&lt;/strong&gt;是比较准确的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Golang&lt;strong&gt;没有类(class)&lt;/strong&gt;，Go语言的结构体(struct)和其它编程语言的类(class)有同等的地位，你可以理解Golang是基于struct来实现OOP特性的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Golang面向对象编程非常简洁，去&lt;strong&gt;掉了传统OOP语言的继承、方法重载、构造函数和析构函数、隐藏的this指针&lt;/strong&gt;等等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Golang仍然有面向对象编程的继承，封装和多态的特性，只是&lt;strong&gt;实现的方式和其它OOP语言不一样&lt;/strong&gt;，比如继承: Golang&lt;strong&gt;没有extends 关键字&lt;/strong&gt;，继承是通过&lt;strong&gt;匿名字段&lt;/strong&gt;来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Golang面向对象(OOP)很优雅，OOP本身就是语言类型系统(type system)的一部分，&lt;strong&gt;通过接口(interface)关联&lt;/strong&gt;，&lt;strong&gt;耦合性低&lt;/strong&gt;，也非常灵活。后面同学们会充分体会到这个特点。也就是说在Golang中&lt;strong&gt;面向接口编程&lt;/strong&gt;是非常重要的特性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;二、struct&quot;&gt;&lt;a href=&quot;#二、struct&quot; class=&quot;headerlink&quot; title=&quot;二、struct&quot;&gt;&lt;/a&gt;二、struct&lt;/h2&gt;&lt;p&gt;定义&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Cat &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Name &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Age &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在创建一个结构体变量后，如果没有给字段赋值，都对应一个零值(默认值)&lt;br&gt;布尔类型是false ，数值是0，字符串是””。&lt;br&gt;数组类型的默认值和它的元素类型相关，比如score [3]int则为[0,0,0]，&lt;strong&gt;指针，slice，和map的零值都是nil ，即还没有分配空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结构体中如果是引用类型，不要补个结构体之间赋值会改变内容&lt;/p&gt;
&lt;p&gt;创建结构体变量&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person Person&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p2 := Person&amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//p2.Age = 18&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//p2.Name = &amp;quot;a&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fmt.Println(p2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//3 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p3 *Person = &lt;span class=&quot;built_in&quot;&gt;new&lt;/span&gt;(Person)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p3.Name=&lt;span class=&quot;string&quot;&gt;&amp;quot;smith&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p4 *Person = &amp;amp;Person&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;第3种和第4种坊式返回的是结构体指针。&lt;/li&gt;
&lt;li&gt;结构体指针访问字段的标准方式应该是:&lt;strong&gt;(*结构体指针).字段名&lt;/strong&gt;，比如&lt;code&gt;(*person).Name = &amp;quot;tom&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;但go做了一个简化，也支持结构体指针.字段名,比如&lt;code&gt;person.Name = &amp;quot;tom&amp;quot;&lt;/code&gt;。更加符合程序员使用的习惯，go&lt;strong&gt;编译器底层对person.Name做了转化(*person).Name&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
    <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>数组、切片和map</title>
    <link href="http://yoursite.com/2022/02/21/Go/%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E5%92%8Cmap/"/>
    <id>http://yoursite.com/2022/02/21/Go/%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E5%92%8Cmap/</id>
    <published>2022-02-21T13:06:06.000Z</published>
    <updated>2022-02-23T14:51:44.178Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>var 数组名[数组大小]数据类型 <code>var a [5]int</code></p><p>4种初始化方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numsArrays01 [<span class="number">3</span>]<span class="keyword">int</span> = [<span class="number">3</span>]<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> numsArrays02 = [<span class="number">3</span>]<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> numsArrays03 = [...]<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> numsArrays04  = [<span class="number">3</span>]<span class="keyword">string</span> &#123;<span class="number">1</span>:<span class="string">&quot;1&quot;</span>,<span class="number">2</span>:<span class="string">&quot;2&quot;</span>,<span class="number">0</span>:<span class="string">&quot;3&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="for-range遍历"><a href="#for-range遍历" class="headerlink" title="for-range遍历"></a>for-range遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> numsArrays03 = [...]<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">   <span class="keyword">for</span> index, value := <span class="keyword">range</span> numsArrays03 &#123;</span><br><span class="line">      fmt.Println(index,value)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个返回值index是数组的下标第，二个value是该下标位置的值。<br>他们都是仅在 for循环内部可见的局部变量。<br>遍历数组元素的时候，如果不想使用下标index，可以直接把下标index标为下划线。<br>index和value的名称不是固定的.可以z自行指定。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><code>var arr []int</code>是一个<strong>slice切片</strong></li><li>数组创建之后有默认值</li><li>Go的数组属值类型，在默认情况下是<strong>值传递</strong>，因此会进行值拷贝。数组间不会相互影响如想<strong>在其它函数中，去修改原来的数组，可以使用引用传递(</strong>指针方式)</li><li><strong>长度是数组的一部分，在传递函数参数时，需要考虑数组的长度</strong>。</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求:随机生成五个数,并将其反转打印</span></span><br><span class="line"><span class="comment">//1．随机生成五个数, rand.Intn()函数</span></span><br><span class="line"><span class="comment">//2．当我们得到随机数后，就放到一个数组int数组</span></span><br><span class="line"><span class="comment">//3．反转打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randArr</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> intArr [<span class="number">5</span>] <span class="keyword">int</span></span><br><span class="line"><span class="comment">//需要加入随机数种子</span></span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span> ;i &lt; <span class="built_in">len</span>(intArr); i++ &#123;</span><br><span class="line">intArr[i] = rand.Intn(<span class="number">100</span>) <span class="comment">// 0&lt;=x&lt;100</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(intArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><ul><li>切片是数组的一个引用，因此切片是<strong>引用类型</strong>，在进行传递时，遵守引用传递的机制。</li><li>切片的使用和数组类似，遍历切片、访问切片的元素和求切片长度len(slice)都一样。</li><li>切片的<strong>长度是可以变化的</strong>，因此切片是一个<strong>可以动态变化数组</strong>。</li><li>切片定义的基本语法:<br><code>var变量名[类型]</code>比如: <code>var a []int</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> intArr [<span class="number">5</span>]<span class="keyword">int</span> = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">22</span>,<span class="number">3</span>,<span class="number">33</span>,<span class="number">4</span>&#125;</span><br><span class="line">   </span><br><span class="line">   slice :=  intArr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">   fmt.Println(<span class="built_in">len</span>(slice))<span class="comment">//长度</span></span><br><span class="line">   fmt.Println(<span class="built_in">cap</span>(slice))<span class="comment">//容量 ，不定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p><img src="/2022/02/21/Go/%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E5%92%8Cmap/%E5%88%87%E7%89%87%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="image-20220221232718199"></p><ol><li><p>slice的确是一个<strong>引用类型</strong>,容量是动态变化的</p></li><li><p>slice从底层来说，其实就是一个<strong>数据结构</strong>(struct结构体)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">ptr *[<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li><p>定义一个切片，然后让切片去引用一个已经创建好的数组。</p></li><li><p>第二种方式:通过make来创建切片.<br>基本语法: <code>var切片名[]type = make([], len,[cap])</code><br>参数说明: type:就是数据类型len :大小cap:指定切片容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []float= <span class="built_in">make</span>([]<span class="keyword">float64</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p>定义一个切片，直接就指定具体数组，使用原理类似make的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []sting = []<span class="keyword">string</span>&#123;<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;mary&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>方式一和方式2的区别：</p><p>方式1是<strong>直接引用数组</strong>，这个数组是事先存在的，程序员是可见的。<br>方式2是通过make来创建切片，make也会创建一个数组，是<strong>由切片在底层进行维护</strong>,程序员是看不见的。</p></blockquote><p>切片和数组的变量方式相同</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li><p>切片初始化时<code>var slice = arr[startlndex:endIndex]</code><br>说明:从arr数组下标为<code>startIndex</code>，取到下标为<code>endIndex</code>的元素(<strong>不含arr[endIndex</strong>])<br>切片初始化时，仍然不能越界。范围在[O-len(arr)]之间，但是<strong>可以动态增长</strong>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = arr[<span class="number">0</span>:end]</span><br><span class="line"><span class="comment">//可以简写</span></span><br><span class="line"><span class="keyword">var</span> slice = arr[:end]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice = arr[start:<span class="built_in">len</span>(arr)]</span><br><span class="line"><span class="comment">//可以简写:</span></span><br><span class="line"><span class="keyword">var</span> slice = arr[start:]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> slice = arr[<span class="number">0</span>:<span class="built_in">len</span>(arr)]</span><br><span class="line"><span class="comment">//可以简写:</span></span><br><span class="line"><span class="keyword">var</span> slice = arr[:]</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>cap是一个内置函数，用于统计切片的容量，即最大可以存放多少个元素。</p></li><li><p>切片定义完后，<strong>还不能使用，因为本身是一个空的</strong>，需要让其引用到一个数组，或者make一个空间供切片来使用</p></li><li><p>切片<strong>可以继续切片</strong></p></li><li><p>使用append内置函数，可以对切片进行<strong>动态追加</strong></p><p>切片append操作的底层原理分析:</p><ol><li>切片append操作的本质就是<strong>对数组扩容</strong></li><li>go底层会<strong>创建一下新的数组newArr</strong>(安装扩容后大小)</li><li>将slice原来包含的元素<strong>拷贝到新的数组newArr</strong></li></ol><p>4) slice<strong>重新引用到newArr</strong><br>5) 注意newArr是在<strong>底层来维护的</strong>，程序员不可见.</p></li><li><p>使用内置函数<code>copy</code>完成拷贝</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(slice,a) <span class="comment">//把a拷贝到slice</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="string和slice"><a href="#string和slice" class="headerlink" title="string和slice"></a>string和slice</h3><p>string底层<strong>是一个byte数组</strong>，因此string<strong>也可以进行切片处理</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;helloworld&quot;</span></span><br><span class="line">slice := str[<span class="number">6</span>:]</span><br></pre></td></tr></table></figure><p>string是<strong>不可变的</strong>，也就说不能通过<code>str[0]= 2</code>方式来修改字符串</p><p>如果需要修改字符串，可以先将<code>string -&gt; []byte</code>/或者<strong>[]rune -&gt;修改→重写转成string</strong>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr1 :=[ ]<span class="keyword">byte</span>(str)</span><br><span class="line">arr1[e]= <span class="string">&#x27;z&#x27;</span></span><br><span class="line">str = <span class="keyword">string</span>(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment">//中文</span></span><br><span class="line">arr1 :=[ ]<span class="keyword">rune</span>(str)</span><br><span class="line">arr1[e]= <span class="string">&#x27;北&#x27;</span></span><br><span class="line">str = <span class="keyword">string</span>(arr1)</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span>[][]</span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>var map变量名 map[keytype]valuetype</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">   a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)</span><br><span class="line">   </span><br><span class="line">    b := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">    </span><br><span class="line">    c := <span class="keyword">map</span>[<span class="keyword">string</span>][<span class="keyword">string</span>]&#123;</span><br><span class="line">        <span class="string">&quot;1&quot;</span>:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map在使用前一定要make</li><li>map的key是不能重复，如果重复了，则以最后这个key-value为准</li><li>map的 value是可以相同的.</li><li>map的 key-value是无序</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li><p>增加和更新： map[“key”]=value</p></li><li><p>删除 delete(map.”key),</p><p>全部删除可以直接创建一个新的map</p></li><li><p>查找 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val,ok := a[<span class="string">&quot;1&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">    fmt.<span class="built_in">println</span>(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tarverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">   a := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">   a[<span class="string">&quot;1&quot;</span>] = <span class="string">&quot;1&quot;</span></span><br><span class="line">   a[<span class="string">&quot;2&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">   a[<span class="string">&quot;3&quot;</span>] = <span class="string">&quot;3&quot;</span></span><br><span class="line">   <span class="keyword">for</span> k,v := <span class="keyword">range</span> a &#123;</span><br><span class="line">      fmt.Println(k,v)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="map排序"><a href="#map排序" class="headerlink" title="map排序"></a>map排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">   a := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">   a[<span class="string">&quot;1&quot;</span>] = <span class="string">&quot;1&quot;</span></span><br><span class="line">   a[<span class="string">&quot;2&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line">   a[<span class="string">&quot;4&quot;</span>] = <span class="string">&quot;4&quot;</span></span><br><span class="line">   a[<span class="string">&quot;3&quot;</span>] = <span class="string">&quot;3&quot;</span></span><br><span class="line">   <span class="keyword">var</span> keys []<span class="keyword">string</span></span><br><span class="line">   <span class="keyword">for</span> k,_ := <span class="keyword">range</span> a&#123;</span><br><span class="line">      keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">   &#125;</span><br><span class="line">   sort.Strings(keys)</span><br><span class="line">   <span class="keyword">for</span> _ , k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">      fmt.Println(a[k])</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用切片辅助排序</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul><li>map是<strong>引用类型</strong>，遵守引用类型传递的机制，在一个函数接收map，修改后，会直接修改原来的map</li><li>map的容量达到后,再想map增加元素,会自动扩容，并不会发生panic，也就是说<strong>map能动态的增长键值对</strong>(key-value)</li><li>map的value也经常使用struct类型，更<strong>适合管理复杂的数据</strong></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;var 数组名[数组大小]数据类型 &lt;code&gt;var a [5]int&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4种初始化方式&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; numsArrays01 [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; numsArrays02 = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; numsArrays03 = [...]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; numsArrays04  = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&amp;quot;1&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&amp;quot;2&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&amp;quot;3&amp;quot;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;for-range遍历&quot;&gt;&lt;a href=&quot;#for-range遍历&quot; class=&quot;headerlink&quot; title=&quot;for-range遍历&quot;&gt;&lt;/a&gt;for-range遍历&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;traverse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; numsArrays03 = [...]&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; index, value := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; numsArrays03 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      fmt.Println(index,value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;第一个返回值index是数组的下标第，二个value是该下标位置的值。&lt;br&gt;他们都是仅在 for循环内部可见的局部变量。&lt;br&gt;遍历数组元素的时候，如果不想使用下标index，可以直接把下标index标为下划线。&lt;br&gt;index和value的名称不是固定的.可以z自行指定。&lt;/p&gt;
&lt;h3 id=&quot;注意&quot;&gt;&lt;a href=&quot;#注意&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;注意&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;var arr []int&lt;/code&gt;是一个&lt;strong&gt;slice切片&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;数组创建之后有默认值&lt;/li&gt;
&lt;li&gt;Go的数组属值类型，在默认情况下是&lt;strong&gt;值传递&lt;/strong&gt;，因此会进行值拷贝。数组间不会相互影响如想&lt;strong&gt;在其它函数中，去修改原来的数组，可以使用引用传递(&lt;/strong&gt;指针方式)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;长度是数组的一部分，在传递函数参数时，需要考虑数组的长度&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;案例&quot;&gt;&lt;a href=&quot;#案例&quot; class=&quot;headerlink&quot; title=&quot;案例&quot;&gt;&lt;/a&gt;案例&lt;/h3&gt;</summary>
    
    
    
    <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
    <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go简介</title>
    <link href="http://yoursite.com/2022/01/20/Go/Go%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2022/01/20/Go/Go%E7%AE%80%E4%BB%8B/</id>
    <published>2022-01-20T09:47:21.000Z</published>
    <updated>2022-02-20T14:58:30.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go的基本介绍"><a href="#Go的基本介绍" class="headerlink" title="Go的基本介绍"></a>Go的基本介绍</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>Go语言保证了既能到达静态编译语言的安全和性能，又达到了动态语言开发维护的高效率，使用一个表达式来形容Go语言:Go =C+ Python，说明Go语言既有c静态语言程<br>序的运行速度，又能达到Python动态语言的快速开发。</p><ol><li><p>从c语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指<br>针等等，也<strong>保留了和c语言一样的编保执行方式及弱化的指针</strong>。</p></li><li><p>引入包的概念，用于组织程序结构，Go语言的一个文件都要归属于一个包，而不能单独存在。</p></li><li><p>垃圾回收机制，内存自动回收，不需开发人员管理</p></li><li><p>天然并发</p><ol><li>从语言层面支持并发，实现简单</li><li>goroutine，轻量级线程，可实现大并发处理，高效利用多核。</li><li>基于CPS并发模型(Communicating Sequential Processes )实现</li></ol></li><li><p>吸收了管道通信机制，形成Go语言特有的管道channel，通过管道channel，可以实现不同的goroute之间的相互通信。</p></li><li><p>函数返回多个值</p></li><li><p>新的创新:比如切片、延时执行defer等</p></li></ol><h3 id="程序开发"><a href="#程序开发" class="headerlink" title="程序开发"></a>程序开发</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;hello,world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hello.go</code>所在的包是main，在go中，文件必须归属一个包。</p><p>在命令行可以通过build命令进行编译,在main包下执行下面命令可以得到一个执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build hello.go</span><br></pre></td></tr></table></figure><p>通过run也可以直接运行源码程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run hello.go</span><br></pre></td></tr></table></figure><p>2种编译方式区别</p><blockquote><p>如果我们先编译生成了可执行文件，那么我们可以将该可执行文件拷贝到<strong>没有go开发环境的机器上，仍然可以运行</strong><br>如果我们是直接<code>go fun go</code>源代码，那么如果要在另外一个机器上这么运行，也需要go开发环境，否则无法执行。<br>在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以，可执行文件变大了很多。</p></blockquote><p>go语言提供了大量的标准库：<code>https://studygolang.com/pkgdoc</code></p><p>这些标准库在go语言的<code>src</code>目录下</p><h2 id="GO语法"><a href="#GO语法" class="headerlink" title="GO语法"></a>GO语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h4><ol><li><p>指定变量类型，声明后若不赋值,<strong>使用默认值</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> </span><br></pre></td></tr></table></figure></li><li><p>根据值自行判定变量类型(类型推导)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10.11</span></span><br></pre></td></tr></table></figure></li><li><p>省略var,注意.<code>:=</code>左侧的变量不应该是已经声明过的，否则会导致编译错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//var string name = &quot;&quot;</span></span><br><span class="line">name := <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="一次性声明多个变量"><a href="#一次性声明多个变量" class="headerlink" title="一次性声明多个变量"></a>一次性声明多个变量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1, n2 ,n3 <span class="keyword">int</span> </span><br><span class="line"><span class="keyword">var</span> n1, name, n3 = <span class="number">100</span>, <span class="string">&quot;&quot;</span>, <span class="number">888</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">n3 = <span class="number">300</span></span><br><span class="line">    n4 = <span class="number">900</span></span><br><span class="line">    name2 = <span class="string">&quot;mary&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.数值型</span><br><span class="line">1.1 整数类型(int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,byte)</span><br><span class="line">1.2 浮点型（float32,float64)默认float64</span><br><span class="line">2.字符型(没有专门字符类型，使用byte保存单个字母字符)</span><br><span class="line">3.布尔型(bool)</span><br><span class="line">4.字符串(string)</span><br></pre></td></tr></table></figure><h5 id="字符变量"><a href="#字符变量" class="headerlink" title="字符变量"></a>字符变量</h5><p>Go的字符串是<strong>由字节组成</strong>，对于ascii码的值可以保存到<code>byte,</code>大于255可以保存到<code>int</code>类型.</p><p>go语言字符使用<code>utf-8</code>，在Go中字符是一个整数，直接输出是该字符的码值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//演示golang中字符类型使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c1 <span class="keyword">byte</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">//当我们直接输出byte值，就是输出了的对应的字符的码值</span></span><br><span class="line">fmt.Println(<span class="string">&quot;c1=&quot;</span>, c1)</span><br><span class="line"><span class="comment">//如果我们希望输出对应字符,需要使用格式化输出</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;c1=%c c2=%c\n&quot;</span>, c1,c2)</span><br><span class="line"><span class="comment">//var c3 byte =‘北’/ /overflow溢出</span></span><br><span class="line">    <span class="keyword">var</span> c3 <span class="keyword">int</span> =<span class="string">&quot;北’</span></span><br><span class="line"><span class="string">    fmt.Printf(&quot;</span>c3=%c %d<span class="string">&quot;, c3, c3)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>Golang的字符串是<strong>不可变</strong>的</p><p>字符串的表示形式</p><ul><li>双引号，识别转义。</li><li>反引号，原生形式输出。</li></ul><h4 id="派生-复杂数据类型"><a href="#派生-复杂数据类型" class="headerlink" title="派生/复杂数据类型"></a>派生/复杂数据类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.指针(Pointer)</span><br><span class="line">2.数组</span><br><span class="line">3.结构体(struct)</span><br><span class="line">4.管道(Channel)</span><br><span class="line">5.函数(也是一种类型)</span><br><span class="line">6.切片(slice)</span><br><span class="line">7.接口(interface)</span><br><span class="line">8.map</span><br></pre></td></tr></table></figure><h4 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h4><p>需要<strong>显示转换</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int32</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> n1 = <span class="keyword">float32</span>(i)</span><br></pre></td></tr></table></figure><h5 id="基本数据类型和string的转换"><a href="#基本数据类型和string的转换" class="headerlink" title="基本数据类型和string的转换"></a>基本数据类型和string的转换</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> = <span class="number">90</span></span><br><span class="line">str = fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, num1)</span><br></pre></td></tr></table></figure><p>还可以使用<code>strconv</code>包的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = strconv.FormatInt(<span class="keyword">int64</span>(num3), <span class="number">10</span>); <span class="comment">//把原类型转换为int64，以10进制转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点类型,f格式，10小数点后保留10位，float64</span></span><br><span class="line">str = strconv.FormatFloat(num4, <span class="string">&#x27;f&#x27;</span>, <span class="number">10</span>, <span class="number">64</span>);</span><br></pre></td></tr></table></figure><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ul><li>基本数据类型，变量<strong>存的就是值</strong>，也叫值类型</li><li>获取变量的地址，用&amp;，比如: <code>var nim int</code>,获取num的地址:<code>&amp;num</code></li><li>指针类型，变量<strong>存的是一个地址</strong>，这个地址指向的空间存的才是值比如: <code>var ptr *int = &amp;num</code></li><li>获取指针类型所指向的值，使用: <code>*</code>，比如: <code>var ptr int</code>,使用ptr获取p指向的</li></ul><p>使用细节</p><ul><li><p>值类型:基本数据类型int系列, float系列, bool, string、数组和结构体struct</p><p>变量直接存储值，内存通常在<strong>栈中分配</strong></p></li><li><p>引用类型:指针、slice切片、map、管道chan、interface等都是引用类型</p><p>变量存储的是一个<strong>地址</strong>，这个地址<strong>对应的空间才真正存储数据</strong>(值)，内存通常在<strong>堆上分配</strong>，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收。</p></li></ul><h4 id="标识符命名"><a href="#标识符命名" class="headerlink" title="标识符命名"></a>标识符命名</h4><ul><li>保持package的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，不要和标准库不要冲突fmt。</li><li>变量名、函数名、常量名:采用驼峰法。</li><li>如果变量名、函数名、常量名首字母大写，则<strong>可以被其他的包访间</strong>;如果首字母小则<strong>只能在本包中使用</strong>（注:可以简单的理解成，首字母大写是公有的，首字母小写私有的)</li></ul><p>模块化支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GO111MODULE=off</span><br></pre></td></tr></table></figure><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p> go的每一个文件都是属于一个包的，也就是说go是以<strong>包的形式来管理文件和项目目录结构</strong>的</p><ul><li>区分相同名字的函数、</li><li>变量等标识符当程序文件很多时,可以很好的管理项目</li><li>控制函数、变量等访问范围，即作用域</li></ul><ol><li><p>在给一个文件打包时，该包对应一个文件夹，比如这里的utils文件夫对应的包名就是utils,文件的包名通常和文件所在的文件夹名一致,—般为小写字母。</p></li><li><p>当一个文件要使用其它包函数或变量时，需要先引入对应的包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span><span class="string">&quot;包名&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;包名&quot;</span></span><br><span class="line"><span class="string">&quot;包名&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>package指令在文件第一行，然后是import指令。</p><p>在import包时，路径从$GOPATH的 src下开始，不用带src ,编译器会自动从src下开始引入</p></li><li><p>为了让其它包的文件，可以访问到本包的函数，则该函数名的<strong>首字母需要大写</strong>，类似其它<br>语言的public ,这样才能跨包访问。</p></li><li><p>主访问其它包函数时，其语法是<strong>包名.函数名</strong>。</p></li><li><p>如果包名较长，Go支持给包取别名，注意细节。取别名后，原来的包名就不能使用了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">别名 <span class="string">&quot;包名&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>同一个包下不能有相同的函数名。</p></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li><p>函数的形参列表可以是多个，返回值列表也可以是多个。</p></li><li><p>形参列表和返回值列表的数据类型可以是值类型和引用类型。</p></li><li><p>函数的命名遵循标识符命名规范，首字母<strong>不能是数字</strong>，首字母大写该函数可以被本包文件和其它包文件使用，类似public ，首字母小写，只能被本包文件使用，其它包文件不能使用，类似private.</p></li><li><p>函数中的变量是局部的,函数外不生效</p></li><li><p>基本数据类型和数组默认都是<strong>值传递的</strong>，即进行值拷贝。在函数内修改，不会影响到原来的值。</p></li><li><p>如果希望函数内的变量能修改函数外的变量，可以<strong>传入变量的地址&amp;</strong>，函数内以指针的方式操作变量。从效果上看类似引用</p></li><li><p>Go函数<strong>不支持重载</strong>。空接口</p></li><li><p>在Go中，函数<strong>也是一种数据类型</strong>，可以赋值给一个变量，则该变量就是一个函数类型的变量了。通过该变量可以对函数调用。</p></li><li><p>函数既然是一种数据类型，因此在Go中，<strong>函数可以作为形参</strong>，并且调用!</p></li><li><p>为了简化数据类型定义，Go支持自定义数据类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本语法:type自定义数据类型名数据类型理解:相当于一个别名</span></span><br><span class="line"><span class="keyword">type</span> mylnt <span class="keyword">int</span> <span class="comment">//这时mylnt就等价int来使用了.</span></span><br><span class="line"><span class="keyword">type</span> mySum <span class="function"><span class="keyword">func</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>//这时<span class="title">mySum</span>就等价一个函数类型<span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">in</span></span></span><br></pre></td></tr></table></figure></li><li><p>支持对函数返回值命名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(n1 <span class="keyword">int</span>,n2 <span class="keyword">int</span>)</span><span class="params">(sum <span class="keyword">int</span>, sub <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    sum = n1+n2</span><br><span class="line">    sub = n1-n2</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Go支持<strong>可变参数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持0到多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(args... <span class="keyword">int</span>)</span> <span class="title">sum</span> <span class="title">int</span></span> &#123;&#125;</span><br><span class="line"><span class="comment">//支持1到多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>, args... <span class="keyword">int</span>)</span> <span class="title">sum</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>args<strong>是slice</strong>,通过args[index]可以访间到各个值。</p></li></ul><h4 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h4><p>每一个源文件都可以包含一个init函数，该函数会<strong>在main函数执行前</strong>，被Go运行框架调用，也就是说init会在main函数前被调用。</p><ul><li><p>如果一个文件同时包含全局变量定义，init函数和main函数，则执行的流程是<strong>变量定义-&gt;init函数-&gt;main函数</strong></p></li><li><p>init函数最主要的作用，就是完成一些初始化的工作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> age = test()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test</span><br><span class="line">init</span><br><span class="line">main</span><br></pre></td></tr></table></figure></li><li><p>如果main.go和util.go定义了变量和init</p><p>首先执行util.go的变量定义和init函数，然后执行main的变量定义和main函数。</p></li></ul><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包就是<strong>一个函数和与其相关的引用环境</strong>组合的一个整体(实体)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加器</span></span><br><span class="line"><span class="function">func <span class="title">AddUpper</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">int</span></span>&#123;</span><br><span class="line">   <span class="keyword">var</span> n <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">   <span class="keyword">return</span> func(x <span class="keyword">int</span>) <span class="keyword">int</span> &#123;</span><br><span class="line">      n = n + x</span><br><span class="line">      <span class="keyword">return</span>  n</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">func <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">f := AddUpper()</span><br><span class="line">fmt.Println(f(<span class="number">1</span>)) <span class="comment">//11</span></span><br><span class="line">    fmt.Println(f(<span class="number">2</span>))<span class="comment">//13</span></span><br><span class="line">    fmt.Println(f(<span class="number">3</span>))<span class="comment">//16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的是一个匿名函数，但是这个匿名函数引用到函数外的n ,因此这个匿名函数就和n形成一个整体，构成闭包。</p><p>当我们反复的调用f函数时，因为<strong>n是初始化一次</strong>，因此每调用一次就进行累计。</p><p>我们要搞清楚闭包的关键，就是要<strong>分析出返回的函数它使用(引用)到哪些变量</strong>，因为函数和它引用到的变量共同构成闭包。l</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编写一个函数makeSuffix(suffix string)可以接收一个文件后缀名(比如.jpg)，并返回一个闭包</span><br><span class="line">调用闭包，可以传入一个文件名，如果该文件名没有指定的后缀(比如.jpg) ,则返回文件名.jpg，如果已经有.jpg后缀，则返回原文件名。</span><br><span class="line">strings.HasSuffix</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSuffix</span><span class="params">(suffix <span class="keyword">string</span>)</span> <span class="title">func</span> <span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> !strings.HasSuffix(name,suffix)&#123;</span><br><span class="line">         <span class="keyword">return</span> name + suffix</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   f := makeSuffix(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">   fmt.Println(f(<span class="string">&quot;winter&quot;</span>))</span><br><span class="line">   fmt.Println(f(<span class="string">&quot;bird.jpg&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的<strong>匿名函数和makeSuffix (suffix string)的suffix变量</strong>组合成一个闭包,因为返回的函数引用到suffix这个变量<br>我们体会一下闭包的好处，如果使用传统的方法，也可以轻松实现这个功能，但是传统方法需要<strong>每次都传入后缀名</strong>，比如 .jpg ,而闭包<strong>因为可以保留上次引用的某个值</strong>，所以我们传入—次就可以反复使用。</p><h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>在函数中，程序员经常需要创建资源(比如，数据库连接、文件句柄、锁等)，为了在函数执行完毕后,及时的释放资源，Go的设计者提供defer(延时机制)。</p><p>当执行到defer时，暂时不执行，会将defer后面的语句（包括数据）压入到独立的栈(defer栈)。当函数执行完毕后,再从defer栈,按照<strong>先入后出</strong>的方式出栈,执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n1 <span class="keyword">int</span>, n2 <span class="keyword">int</span>)</span><span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;n1=&quot;</span>, n1)</span><br><span class="line">   <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;n2=&quot;</span>, n2)</span><br><span class="line">   n1++</span><br><span class="line">   n2++</span><br><span class="line">   res := n1 + n2</span><br><span class="line">   fmt.Println(<span class="string">&quot;res=&quot;</span>, res)</span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(sum(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把数据也同时压入</span></span><br></pre></td></tr></table></figure><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><ul><li>函数内部声明/定义的变量叫局部变量，作用域仅限于函数内部。</li><li>函数外部声明/定义的变量叫全局变量，作用域<strong>在整个包都有效</strong>，如果其<strong>首字母为大写，则作用域在整个程序有效。</strong></li><li>如果变量是在一个代码块，比如 for / if中，那么这个变量的的作用域就在该代码块</li></ul><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">package</span> main</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">import</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="string">&quot;fmt&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="string">&quot;strconv&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="string">&quot;strings&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">func <span class="title">used</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//1.字符串长度</span></span><br><span class="line">   str := <span class="string">&quot;hello北&quot;</span></span><br><span class="line">   fmt.Println(<span class="string">&quot;str :&quot;</span>, len(str))</span><br><span class="line">   <span class="comment">//2.遍历中文</span></span><br><span class="line">   r := []rune(str)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(r); i++ &#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;字符:=%c\n&quot;</span>, r[i])</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.字符串转整数,校验数据类型</span></span><br><span class="line">   n, err := strconv.Atoi(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != nil&#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;转换的结果：&quot;</span>, n)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//4. 整数转字符串</span></span><br><span class="line">   str2 := strconv.Itoa(<span class="number">123</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str=%v, str=%T\n&quot;</span>, str2, str2)</span><br><span class="line">   <span class="comment">//5.字符串转byte</span></span><br><span class="line">   <span class="keyword">var</span> bytes = []<span class="keyword">byte</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;bytes=%v\n&quot;</span>, bytes)</span><br><span class="line">   <span class="comment">//6.byte转字符串</span></span><br><span class="line">   str = string([]<span class="keyword">byte</span>&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str=%v\n&quot;</span>, str)</span><br><span class="line">   <span class="comment">//7. 10进制转2进制</span></span><br><span class="line">   str = strconv.FormatInt(<span class="number">123</span>, <span class="number">2</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;123对应的二进制是=%v\n&quot;</span>, str)</span><br><span class="line">   str = strconv.FormatInt(<span class="number">123</span>, <span class="number">16</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;123对应的二进制是=%v\n&quot;</span>, str)</span><br><span class="line">   <span class="comment">//8. 是否包含</span></span><br><span class="line">   b := strings.Contains(<span class="string">&quot;seafood&quot;</span>, <span class="string">&quot;sea&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;b=%v\n&quot;</span>, b)</span><br><span class="line">   <span class="comment">//9. 统计一个字符串有几个子串</span></span><br><span class="line">   num := strings.Count(<span class="string">&quot;ceheee&quot;</span>, <span class="string">&quot;e&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;num=%v\n&quot;</span>, num)</span><br><span class="line">   <span class="comment">//10. 不区分大小写 ==区分字母大小写</span></span><br><span class="line">   b = strings.EqualFold(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;ABC&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;b=%v\n&quot;</span>, b)</span><br><span class="line">   <span class="comment">//11. 返回子串第一次出现的index值</span></span><br><span class="line">   index := strings.Index(<span class="string">&quot;NTL_abc&quot;</span>,<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;index=%v\n&quot;</span>, index)</span><br><span class="line">   <span class="comment">//12. 最后一次出现</span></span><br><span class="line">   index = strings.LastIndex(<span class="string">&quot;go golang&quot;</span>,<span class="string">&quot;go&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;index=%v\n&quot;</span>, index)</span><br><span class="line">   <span class="comment">//13.)将指定的子串替换成另外一个子串: n可以指定你希望替换几个，如果n=-1表示全部替换</span></span><br><span class="line">   str= strings.Replace(<span class="string">&quot;go go hello&quot;</span>,<span class="string">&quot;go&quot;</span>,<span class="string">&quot;go语言&quot;</span>,<span class="number">1</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str=%v\n&quot;</span>, str)</span><br><span class="line">   <span class="comment">//14.按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组﹔</span></span><br><span class="line">   strArr := strings.Split(<span class="string">&quot;hello,world,ok&quot;</span>,<span class="string">&quot;.&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;strArr=%v\n&quot;</span>, strArr)</span><br><span class="line">   <span class="comment">//15.将字符串的字母进行大小写的转换: strings.ToLower(&quot;Go&quot;)</span></span><br><span class="line">   str = strings.ToUpper(<span class="string">&quot;Go&quot;</span>)</span><br><span class="line">   fmt.Printf(<span class="string">&quot;str=%v\n&quot;</span>, str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usedTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//1.获取当前时间</span></span><br><span class="line">   now := time.Now()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.通过now获取年日月</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;年=%v\n&quot;</span>, now.Year())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;月=%v\n&quot;</span>, now.Month())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;日=%v\n&quot;</span>, now.Day())</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3， 格式化日期</span></span><br><span class="line">   dateStr := fmt.Sprintf(<span class="string">&quot;%d-%d-%d %d:%d:%d\n&quot;</span>, now.Year(),now.Month(),</span><br><span class="line">      now.Day(),now.Hour(),now.Minute(),now.Second())</span><br><span class="line">   fmt.Printf(<span class="string">&quot;dateStr=%v&quot;</span>,dateStr)</span><br><span class="line">   <span class="comment">//只能用这个时间，根据这个时间然后可以输出对应的位置</span></span><br><span class="line">   fmt.Printf(now.Format(<span class="string">&quot;2006-01/02 15:04:05&quot;</span>))</span><br><span class="line">   fmt.Println()</span><br><span class="line">   fmt.Printf(now.Format(<span class="string">&quot;01&quot;</span>)) <span class="comment">//月</span></span><br><span class="line">   fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间常量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">   Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">   Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">   Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">   Minute               = <span class="number">60</span> * Second</span><br><span class="line">   Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br><span class="line"><span class="number">100</span> * time.Millisecond</span><br><span class="line"></span><br><span class="line"><span class="comment">//休眠</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sleep</span><span class="params">(d Duration)</span></span></span><br></pre></td></tr></table></figure><p>获取unix时间戳</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now.Unix(),nowUnixNano()</span><br></pre></td></tr></table></figure><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h5><p>Golang 设计者为了编程方便，提供了一些函数，这些函数可以直接使用，我们称为Go的内置函数。文档: <code>https://studygolang.com/pkgdoc</code> -&gt; builtin</p><p>make:用来分配内存，主要用来分配引用类型，比如channel、map、slice。</p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>在默认情况下，当发生错误后(panic)程序就会退出（崩溃.)I</p><p>如果我们希望:当发生错误后，可以捕获到错误，并进行处理，保证程序可以继续执行。</p><p>Go语言追求简洁优雅，所以，Go语言不支持传统的try…catch…finally这种处理。</p><p>Go中引入的处理方式为: <strong>defer，panic, recover</strong></p><p>这几个异常的使用场景可以这么简单描述:Go中可以抛出一个panic的异常，然后在defer中通过<strong>recover捕获这个异常</strong>，然后正常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">error</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function">defer <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      err := recover() <span class="comment">//捕获异常</span></span><br><span class="line">      <span class="keyword">if</span> err != nil &#123;    <span class="comment">//说明捕获到错误</span></span><br><span class="line">         fmt.Println(<span class="string">&quot;err=&quot;</span>,err)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line">   num1 := <span class="number">10</span></span><br><span class="line">   num2 := <span class="number">0</span></span><br><span class="line">   res := num1 / num2</span><br><span class="line">   fmt.Println(<span class="string">&quot;res=&quot;</span>,res)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//err= runtime error: integer divide by zero</span></span><br></pre></td></tr></table></figure><h5 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h5><p>使用<code>errors.New</code> 和 panic内置函数。</p><p>1) errors.New(“错误说明””),会返回一个error类型的值，表示一个错误<br>2) panic内置函数,接收一个<code>interface&#123;&#125;</code>类型的值（也就是任何值了）作为参数。可以接收error类型的变量,输出错误信息,并退出程序.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">readConf</span><span class="params">(name string)</span><span class="params">(err error)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> name == <span class="string">&quot;config.ini&quot;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nil</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errors.New(<span class="string">&quot;读取文件错误...&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">   err := readConf(<span class="string">&quot;config.ini&quot;</span>)</span><br><span class="line">   <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">      panic(err)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(<span class="string">&quot;执行&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Go的基本介绍&quot;&gt;&lt;a href=&quot;#Go的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;Go的基本介绍&quot;&gt;&lt;/a&gt;Go的基本介绍&lt;/h2&gt;&lt;h3 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h3&gt;&lt;p&gt;Go语言保证了既能到达静态编译语言的安全和性能，又达到了动态语言开发维护的高效率，使用一个表达式来形容Go语言:Go =C+ Python，说明Go语言既有c静态语言程&lt;br&gt;序的运行速度，又能达到Python动态语言的快速开发。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从c语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指&lt;br&gt;针等等，也&lt;strong&gt;保留了和c语言一样的编保执行方式及弱化的指针&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;引入包的概念，用于组织程序结构，Go语言的一个文件都要归属于一个包，而不能单独存在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;垃圾回收机制，内存自动回收，不需开发人员管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;天然并发&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从语言层面支持并发，实现简单&lt;/li&gt;
&lt;li&gt;goroutine，轻量级线程，可实现大并发处理，高效利用多核。&lt;/li&gt;
&lt;li&gt;基于CPS并发模型(Communicating Sequential Processes )实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;吸收了管道通信机制，形成Go语言特有的管道channel，通过管道channel，可以实现不同的goroute之间的相互通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数返回多个值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新的创新:比如切片、延时执行defer等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;程序开发&quot;&gt;&lt;a href=&quot;#程序开发&quot; class=&quot;headerlink&quot; title=&quot;程序开发&quot;&gt;&lt;/a&gt;程序开发&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//hello.go&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   fmt.Println(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello,world!&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;hello.go&lt;/code&gt;所在的包是main，在go中，文件必须归属一个包。&lt;/p&gt;
&lt;p&gt;在命令行可以通过build命令进行编译,在main包下执行下面命令可以得到一个执行文件&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;go build hello.go&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;通过run也可以直接运行源码程序&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
    <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-职责链模式</title>
    <link href="http://yoursite.com/2022/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2022/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-18T15:21:05.000Z</published>
    <updated>2022-01-19T09:41:36.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">学校OA系统的采购审批项目:需求是</span><br><span class="line">1)采购员采购教学器材</span><br><span class="line">2)如果金额小于等于5000,由教学主任审批</span><br><span class="line">3)如果金额小于等于10000,由院长审批</span><br><span class="line">4)如果金额小于等于30000,由副校长审批</span><br><span class="line">5)如果金额超过30000以上，有校长审批请设计程序完成采购审批项目</span><br></pre></td></tr></table></figure><h4 id="传统方案解决oA系统审批问题"><a href="#传统方案解决oA系统审批问题" class="headerlink" title="传统方案解决oA系统审批问题"></a>传统方案解决oA系统审批问题</h4><ul><li>传统方式是:接收到一个采购请求后，<strong>根据采购金额来调用对应的Approver</strong> (审批人)完成审批。</li><li>传统方式的问题分析:客户端这里会使用到分支判断(比如switch)来对不同的采购请求处理，这样就存在如下问题<ol><li>如果各个级别的人员审批金额发生变化，在客户端的也需要变化</li><li>客户端必须明确的知道有多少个审批级别和访问</li></ol></li><li>这样对一个<strong>采购请求进行处理和Approver(审批人)就存在强耦合关系</strong>，不利于代码的扩展和维护</li></ul><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>职责链模式( Chain ofResponsibility iattern) ,又叫责任链模式，<strong>为请求创建了一个接收者对象的链</strong>。这种模式对请求的发送者和接收者进行解耦。</li><li>职责链模式通常每个接收者<strong>都包含对另一个接收者的引用</strong>。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<br>这种类型的设计模式属于行为型模式</li></ul><img src="/2022/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/类图.gif" alt="责任链模式的结构图" style="zoom:80%;"><ul><li><strong>Handler</strong> :抽象的处理者，定义了一个处理请求的接口，同时含义另外Handler</li><li><strong>ConcreteHandlerA , B</strong>是具体的处理者，处理它自己负责的请求，可以访问它的后继者(即下一个处理者)，如果可以处理当前请求，则处理，否则就将该请求交个后继者去处理，从而形成一个职责链</li><li><strong>Request</strong> ,含义很多属性,表示一个请求</li></ul><img src="/2022/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/责任链.gif" alt="责任链" style="zoom:80%;"><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止.</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><ol><li><p>请求类,这个类是一个请求类，用于在责任链中传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PurchaseRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type = <span class="number">0</span>; <span class="comment">//请求类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PurchaseRequest</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">float</span> price, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>责任链抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Approve</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Approve approve;  <span class="comment">//下一个处理者</span></span><br><span class="line">    String name; <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Approve</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApprove</span><span class="params">(Approve approve)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.approve = approve;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理审批的方法，得到一个请求，处理是子类完成</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>主任类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentApprove</span> <span class="keyword">extends</span> <span class="title">Approve</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepartmentApprove</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (purchaseRequest.getPrice() &lt;= <span class="number">5000</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求编号 id=&quot;</span> +</span><br><span class="line">                    purchaseRequest.getId()+ <span class="string">&quot; 被 &quot;</span>+<span class="keyword">this</span>.name + <span class="string">&quot;处理&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//其他人处理</span></span><br><span class="line">            approve.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>院长类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollegeApprove</span> <span class="keyword">extends</span> <span class="title">Approve</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CollegeApprove</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(PurchaseRequest purchaseRequest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (purchaseRequest.getPrice() &lt;= <span class="number">10000</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求编号 id=&quot;</span> +</span><br><span class="line">                    purchaseRequest.getId()+ <span class="string">&quot; 被 &quot;</span>+<span class="keyword">this</span>.name + <span class="string">&quot;处理&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//其他人处理</span></span><br><span class="line">            approve.processRequest(purchaseRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>客户端调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求</span></span><br><span class="line">        PurchaseRequest purchaseRequest = <span class="keyword">new</span> PurchaseRequest(<span class="number">1</span>, <span class="number">10000</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建相关审批人</span></span><br><span class="line">        DepartmentApprove departmentApprove = <span class="keyword">new</span> DepartmentApprove(<span class="string">&quot;主任&quot;</span>);</span><br><span class="line">        CollegeApprove collegeApprove = <span class="keyword">new</span> CollegeApprove(<span class="string">&quot;院长&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置，构成环状</span></span><br><span class="line">        departmentApprove.setApprove(collegeApprove);</span><br><span class="line">        collegeApprove.setApprove(departmentApprove);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        departmentApprove.processRequest(purchaseRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h4><p><code>HandlerExecutionChain</code> 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">FrameworkServlet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line">                <span class="comment">//2.拿到过滤器链</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">//3.调用过滤器链的PreHandle，如果调用成功就直接return</span></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line">               <span class="comment">//4.调用postHandle</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用拦截器的preHandle</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">       <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">              <span class="comment">//获取拦截器</span></span><br><span class="line">             HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">              <span class="comment">//调用拦截器的preHandle方法</span></span><br><span class="line">             <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="keyword">this</span>.handler)) &#123;</span><br><span class="line">                <span class="comment">//调用After</span></span><br><span class="line">                 triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">this</span>.interceptorIndex = i;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用拦截器的postHandle</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, ModelAndView mv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line"><span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">interceptor.postHandle(request, response, <span class="keyword">this</span>.handler, mv);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Exception ex)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line"><span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">interceptor.afterCompletion(request, response, <span class="keyword">this</span>.handler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Springmvc 请求的流程图中，执行了拦截器相关方法interceptor.preHandler等等在处理</li><li>SpringMvc请求时，使用到职责链模式<strong>还使用到适配器模式</strong></li><li>HandlerExecutionChain主要负责的是<strong>请求拦截器的执行和请求处理,但是他本身不处理请求，只是将请求分配给链上注册处理器执行</strong>，这是职责链实现方式,减少职责链本身与处理逻辑之间的耦合,规范了处理流程</li><li>HandlerExecutionChain维护了<strong>HandlerInterceptor的集合</strong>，可以向其中注册相应的拦截器.</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>将请求和处理分开，实现解耦，提高系统的灵活性</li><li>简化了对象，使对象<strong>不需要知道链的结构</strong></li><li>性能会受到影响，特别是在链比较长的时候，因此<strong>需控制链中最大节点数量，一般通过在Handler中设置一个最大节点数量</strong>，在setNext()方法中判断是否已经超过阀值，超过则不允许该链建立，避免出现超长链无意识地破坏系统性能</li><li>调试不方便。采用了类似递归的方式，调试时逻辑可能比较复杂</li><li>最佳应用场景:有<strong>多个对象可以处理同一个请求</strong>时，比如:多级请求、请假/加薪等审批流程、Java Web中Tomcat对Encoding的处理、拦截器</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;职责链模式&quot;&gt;&lt;a href=&quot;#职责链模式&quot; class=&quot;headerlink&quot; title=&quot;职责链模式&quot;&gt;&lt;/a&gt;职责链模式&lt;/h2&gt;&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;学校OA系统的采购审批项目:需求是&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1)采购员采购教学器材&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2)如果金额小于等于5000,由教学主任审批&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3)如果金额小于等于10000,由院长审批&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4)如果金额小于等于30000,由副校长审批&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5)如果金额超过30000以上，有校长审批请设计程序完成采购审批项目&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;传统方案解决oA系统审批问题&quot;&gt;&lt;a href=&quot;#传统方案解决oA系统审批问题&quot; class=&quot;headerlink&quot; title=&quot;传统方案解决oA系统审批问题&quot;&gt;&lt;/a&gt;传统方案解决oA系统审批问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;传统方式是:接收到一个采购请求后，&lt;strong&gt;根据采购金额来调用对应的Approver&lt;/strong&gt; (审批人)完成审批。&lt;/li&gt;
&lt;li&gt;传统方式的问题分析:客户端这里会使用到分支判断(比如switch)来对不同的采购请求处理，这样就存在如下问题&lt;ol&gt;
&lt;li&gt;如果各个级别的人员审批金额发生变化，在客户端的也需要变化&lt;/li&gt;
&lt;li&gt;客户端必须明确的知道有多少个审批级别和访问&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;这样对一个&lt;strong&gt;采购请求进行处理和Approver(审批人)就存在强耦合关系&lt;/strong&gt;，不利于代码的扩展和维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;职责链模式( Chain ofResponsibility iattern) ,又叫责任链模式，&lt;strong&gt;为请求创建了一个接收者对象的链&lt;/strong&gt;。这种模式对请求的发送者和接收者进行解耦。&lt;/li&gt;
&lt;li&gt;职责链模式通常每个接收者&lt;strong&gt;都包含对另一个接收者的引用&lt;/strong&gt;。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。&lt;br&gt;这种类型的设计模式属于行为型模式&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/2022/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/类图.gif&quot; alt=&quot;责任链模式的结构图&quot; style=&quot;zoom:80%;&quot;&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Handler&lt;/strong&gt; :抽象的处理者，定义了一个处理请求的接口，同时含义另外Handler&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcreteHandlerA , B&lt;/strong&gt;是具体的处理者，处理它自己负责的请求，可以访问它的后继者(即下一个处理者)，如果可以处理当前请求，则处理，否则就将该请求交个后继者去处理，从而形成一个职责链&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Request&lt;/strong&gt; ,含义很多属性,表示一个请求&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/2022/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/责任链.gif&quot; alt=&quot;责任链&quot; style=&quot;zoom:80%;&quot;&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="http://yoursite.com/2022/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2022/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-18T09:51:58.000Z</published>
    <updated>2022-01-18T15:20:17.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">鸭子问题</span><br><span class="line">有各种鸭子(比如野鸭、北京鸭、水鸭等，鸭子有各种行为，比如叫、飞行等)</span><br><span class="line">显示鸭子的信息</span><br></pre></td></tr></table></figure><h4 id="传统方式解决问题"><a href="#传统方式解决问题" class="headerlink" title="传统方式解决问题"></a>传统方式解决问题</h4><p>定义一个抽象类，用多个类去继承。</p><ul><li>其它鸭子，都继承了Duck类，所以fly<strong>让所有子类都会飞</strong>了，这是不正确的</li><li>上面说的1的问题，其实是继承带来的问题:对类的局部改动，尤其<strong>超类的局部改动，会影响其他部分</strong>。会有溢出效应</li><li>为了改进1问题，我们可以通过覆盖fly 方法来解决=&gt;覆盖解决</li><li>问题又来了，如果我们有一个玩具鸭子ToyDuck，这样就需要ToyDuck去覆盖Duck的所有实现的方法=&gt;解决思路策略模式</li></ul><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>策略模式(Strategy Pattern）中，定义算法族，分别封装起来，<strong>让他们之间可以互相替换</strong>，此模式<strong>让算法的变化独立于使用算法的客户</strong>。</li><li>这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来;第二、针对接口编程而不是具体类（定义了策略接口);第三、多用组合/聚合，少用继承（客户通过组合方式使用策略)。</li></ul><p><img src="/2022/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/strategy_pattern_uml_diagram.jpg" alt="策略模式的 UML 图"></p><p><em>Context</em> 是一个使用了某种策略的类。</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><ol><li><p>定义飞行接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>不会飞行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoFlyBehavior</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不会飞行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>飞的好</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodFlyBehavior</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;飞行技术高超&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>飞的一般</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadFlyBehavior</span> <span class="keyword">implements</span> <span class="title">FlyBehavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;飞行技术一般&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>定义鸭子抽象类,在抽象类中集成策略接口，具体子类实现具体策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//策略接口</span></span><br><span class="line">    FlyBehavior flyBehavior;</span><br><span class="line">    <span class="comment">//其他属性，</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸭子嘎嘎叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;鸭子会游泳&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flyBehavior != <span class="keyword">null</span>)&#123;</span><br><span class="line">            flyBehavior.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>2个具体的context</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PekingDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PekingDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> NoFlyBehavior();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;北京鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WildDuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> GoodFlyBehavior();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;野鸭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WildDuck wildDuck = <span class="keyword">new</span> WildDuck();</span><br><span class="line">        wildDuck.fly();</span><br><span class="line"></span><br><span class="line">        PekingDuck pekingDuck = <span class="keyword">new</span> PekingDuck();</span><br><span class="line">        pekingDuck.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p>JDK的<code>arrays</code>的<code>Comparator</code>使用了策略模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<code>Comparator</code>接口，匿名类，这个对象是一个实现了策略接口的对象，实现的方法就是具体的策略方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> comparator&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">( Integer o1，Integer o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (o1 &gt; o2) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">Arrays.sort(data,comparator)</span><br></pre></td></tr></table></figure><p>这里就是使用率具体的策略接口进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;<span class="comment">//没有排序接口，就默认排序</span></span><br><span class="line">        sort(a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, c);<span class="comment">//使用策略对象c</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>策略模式的关键是:<strong>分析项目中变化部分与不变部分</strong></li><li>策略模式的核心思想是:<strong>多用组合/聚合少用继承</strong>;用行为类组合，而不是行为的继承。更有弹性</li><li>体现了“<strong>对修改关闭，对扩展开放</strong>”原则，客户端增加行为不用修改原有代码，<strong>只要添加一种策略（或者行为）即可</strong>，避免了使用多重转移语句(if..else if..else)</li><li>提供了可以<strong>替换继承关系</strong>的办法:策略模式<strong>将算法封装在独立的Strategy类</strong>中使得你<strong>可以独立于其Context改变它</strong>，使它易于切换、易于理解、易于扩展</li><li>需要注意的是:每添加一个策略就要增加一个类，<strong>当策略过多是会导致类数目庞大</strong></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;鸭子问题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有各种鸭子(比如野鸭、北京鸭、水鸭等，鸭子有各种行为，比如叫、飞行等)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;显示鸭子的信息&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;传统方式解决问题&quot;&gt;&lt;a href=&quot;#传统方式解决问题&quot; class=&quot;headerlink&quot; title=&quot;传统方式解决问题&quot;&gt;&lt;/a&gt;传统方式解决问题&lt;/h4&gt;&lt;p&gt;定义一个抽象类，用多个类去继承。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其它鸭子，都继承了Duck类，所以fly&lt;strong&gt;让所有子类都会飞&lt;/strong&gt;了，这是不正确的&lt;/li&gt;
&lt;li&gt;上面说的1的问题，其实是继承带来的问题:对类的局部改动，尤其&lt;strong&gt;超类的局部改动，会影响其他部分&lt;/strong&gt;。会有溢出效应&lt;/li&gt;
&lt;li&gt;为了改进1问题，我们可以通过覆盖fly 方法来解决=&amp;gt;覆盖解决&lt;/li&gt;
&lt;li&gt;问题又来了，如果我们有一个玩具鸭子ToyDuck，这样就需要ToyDuck去覆盖Duck的所有实现的方法=&amp;gt;解决思路策略模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;策略模式(Strategy Pattern）中，定义算法族，分别封装起来，&lt;strong&gt;让他们之间可以互相替换&lt;/strong&gt;，此模式&lt;strong&gt;让算法的变化独立于使用算法的客户&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来;第二、针对接口编程而不是具体类（定义了策略接口);第三、多用组合/聚合，少用继承（客户通过组合方式使用策略)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/2022/01/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/strategy_pattern_uml_diagram.jpg&quot; alt=&quot;策略模式的 UML 图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Context&lt;/em&gt; 是一个使用了某种策略的类。&lt;/p&gt;
&lt;h3 id=&quot;解决问题&quot;&gt;&lt;a href=&quot;#解决问题&quot; class=&quot;headerlink&quot; title=&quot;解决问题&quot;&gt;&lt;/a&gt;解决问题&lt;/h3&gt;</summary>
    
    
    
    <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
