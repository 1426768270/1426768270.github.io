<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>naive的博客</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-01-30T14:26:47.172Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>naive</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图</title>
    <link href="http://yoursite.com/2023/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E5%9B%BE/"/>
    <id>http://yoursite.com/2023/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E5%9B%BE/</id>
    <published>2023-01-29T10:03:54.000Z</published>
    <updated>2023-01-30T14:26:47.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的存储方式"><a href="#图的存储方式" class="headerlink" title="图的存储方式"></a>图的存储方式</h2><ul><li>邻接表法，每个点记录自己的直接邻居，以点集作为单位</li><li>邻接矩阵</li></ul><p>题目中给的结构不是常见的结构，将其转换为常见的结构再调用算法</p><p>数据结构</p><ul><li>图</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 点集、边集</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span></span>&#123;</span><br><span class="line">        nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> in;      <span class="comment">//入度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> out;     <span class="comment">//出度</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;   <span class="comment">// 直接邻居</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;   <span class="comment">// 点属于的边</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">        nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>边</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> Node from;</span><br><span class="line">    <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> weight, Node from, Node to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图的生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from to weight矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Graph <span class="title">createGraph</span><span class="params">(Integer[][] matrix)</span> </span>&#123;</span><br><span class="line">    Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        Integer from = matrix[i][<span class="number">0</span>];</span><br><span class="line">        Integer to = matrix[i][<span class="number">1</span>];</span><br><span class="line">        Integer weight = matrix[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (!graph.nodes.containsKey(from))&#123;</span><br><span class="line">            graph.nodes.put(from, <span class="keyword">new</span> Node(from));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!graph.nodes.containsKey(to))&#123;</span><br><span class="line">            graph.nodes.put(to, <span class="keyword">new</span> Node(to));</span><br><span class="line">        &#125;</span><br><span class="line">        Node fromNode = graph.nodes.get(from);</span><br><span class="line">        Node toNode = graph.nodes.get(to);</span><br><span class="line">        Edge newEdge = <span class="keyword">new</span> Edge(weight, fromNode, toNode);</span><br><span class="line">        fromNode.nexts.add(toNode);</span><br><span class="line">        fromNode.out ++ ;</span><br><span class="line">        toNode.in++;</span><br><span class="line">        fromNode.edges.add(newEdge);</span><br><span class="line">        graph.edges.add(newEdge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="图的深度优先DFS"><a href="#图的深度优先DFS" class="headerlink" title="图的深度优先DFS"></a>图的深度优先DFS</h3><ol><li>利用栈实现</li><li>从源节点开始把节点按照深度放入栈,然后弹出</li><li>每弹出一个点,把该节点下一个没有进过栈的邻接点放入栈</li><li>直到栈变空</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    stack.add(node);</span><br><span class="line">    set.add(node);</span><br><span class="line">    System.out.println(node.nexts);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Node cur = stack.pop();</span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                stack.push(next);</span><br><span class="line">                set.add(next);</span><br><span class="line">                System.out.println(next.value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图的广度优先BFS"><a href="#图的广度优先BFS" class="headerlink" title="图的广度优先BFS"></a>图的广度优先BFS</h3><ol><li>利用队列实现</li><li>从源节点开始依次按照宽度进队列，然后弹出</li><li>每弹出一个点,把该节点所有没有进过队列的邻接点放入队列</li><li>直到队列变空</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    queue.add(node);</span><br><span class="line">    set.add(node);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        System.out.println(cur.value);</span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next))&#123;</span><br><span class="line">                set.add(next);</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>要求①有向图②有入度为0的节点③没有环，可以判断<strong>有向图是否有环</strong></p><p>分析：在程序编译时，往往会有头文件互相依赖的情况，在图中箭头被指向的节点可以看做依赖于指向它的节点。如a依赖于b,c,d，而b又依赖c,k;d依赖k，那么拓扑排序的输出顺序是不依赖别的点的先输出。先输出k,c,删去k,c这时没有别的节点指向b,d了，输出b,d，最后，节点只剩下a再输出。<br>在图中可以用入度表示依赖情况，入度为零就是没有别的点指向它，可以先输出。输出后其指向的节点入度减一视为删去输出的点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">sortedTopology</span><span class="params">(Graph graph)</span></span>&#123;</span><br><span class="line">    <span class="comment">// key node</span></span><br><span class="line">    <span class="comment">// value 剩余的入度</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; inMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Queue&lt;Node&gt; zeroInQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values())&#123;</span><br><span class="line">        inMap.put(node, node.in);</span><br><span class="line">        <span class="keyword">if</span> (node.in == <span class="number">0</span>)&#123;</span><br><span class="line">            zeroInQueue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拓扑排序的结果，依次加入result</span></span><br><span class="line">    List&lt;Node&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!zeroInQueue.isEmpty())&#123;</span><br><span class="line">        Node cur = zeroInQueue.poll();</span><br><span class="line">        result.add(cur);</span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts)&#123;</span><br><span class="line">            inMap.put(next, inMap.get(next)-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (inMap.get(next) == <span class="number">0</span>)&#123;</span><br><span class="line">                zeroInQueue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>定义：使<strong>无向图</strong>所有节点连通且权重最小的边集，是最小权重生成树的简称。<br>算法：kruskal算法、prim算法</p><h3 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;图的存储方式&quot;&gt;&lt;a href=&quot;#图的存储方式&quot; class=&quot;headerlink&quot; title=&quot;图的存储方式&quot;&gt;&lt;/a&gt;图的存储方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;邻接表法，每个点记录自己的直接邻居，以点集作为单位&lt;/li&gt;
&lt;li&gt;邻接矩阵&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;题目中给的结构不是常见的结构，将其转换为常见的结构再调用算法&lt;/p&gt;
&lt;p&gt;数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Graph&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 点集、边集&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; HashMap&amp;lt;Integer, Node&amp;gt; nodes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; HashSet&amp;lt;Edge&amp;gt; edges;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Graph&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nodes = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        edges = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;点&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; in;      &lt;span class=&quot;comment&quot;&gt;//入度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; out;     &lt;span class=&quot;comment&quot;&gt;//出度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ArrayList&amp;lt;Node&amp;gt; nexts;   &lt;span class=&quot;comment&quot;&gt;// 直接邻居&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ArrayList&amp;lt;Edge&amp;gt; edges;   &lt;span class=&quot;comment&quot;&gt;// 点属于的边&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        in = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        out = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nexts = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        edges = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;边&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Edge&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; weight;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Node from;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Node to;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Edge&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; weight, Node from, Node to)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.weight = weight;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.from = from;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.to = to;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2023/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2023/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-01-29T10:03:22.636Z</published>
    <updated>2023-01-29T10:03:22.636Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>中级提升班下1</title>
    <link href="http://yoursite.com/2023/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD%E4%B8%8B/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD%E4%B8%8B1/"/>
    <id>http://yoursite.com/2023/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD%E4%B8%8B/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD%E4%B8%8B1/</id>
    <published>2023-01-23T05:31:15.000Z</published>
    <updated>2023-01-23T10:52:06.423Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目一-LRU"><a href="#题目一-LRU" class="headerlink" title="题目一 LRU"></a>题目一 LRU</h2><p>设计LRU缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能。set(key, value):将记录(key, value)插入该结构。<br>get(key):返回key对应的value值。<br>【要求】<br>1.set和get方法的时间复杂度为0(1)<br>⒉.某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的3.当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的<br>【举例】</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设缓存结构的实例是<span class="selector-tag">cache</span>，大小为<span class="selector-tag">3</span>，并依次发生如下行为<span class="selector-tag">1</span><span class="selector-class">.cache</span>. <span class="selector-tag">set</span> (<span class="string">&quot;A&quot;</span>，<span class="number">1</span>)。最常使用的记录为(<span class="string">&quot;A&quot;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="selector-tag">2</span><span class="selector-class">.cache</span><span class="selector-class">.set</span>(<span class="string">&quot;B&quot;</span>,<span class="number">2</span>)。最常使用的记录为(<span class="string">&quot;B&quot;</span>,<span class="number">2</span>)，(<span class="string">&quot;A&quot;</span>,<span class="number">1</span>)变为最不常使用的</span><br><span class="line"><span class="selector-tag">3</span><span class="selector-class">.cache</span><span class="selector-class">.set</span>(<span class="string">&quot;C&quot;</span>,<span class="number">3</span>)。最常使用的记录为(<span class="string">&quot;C&quot;</span>,<span class="number">2</span>)，(<span class="string">&quot;A&quot;</span>,<span class="number">1</span>)还是最不常使用的</span><br><span class="line"><span class="selector-tag">4</span><span class="selector-class">.cache</span>. <span class="selector-tag">get</span>(<span class="string">&quot;A&quot;</span>)。最常使用的记录为(<span class="string">&quot;A&quot;</span>,<span class="number">1</span>)，(<span class="string">&quot;B&quot;</span>,<span class="number">2</span>)变为最不常使用的</span><br><span class="line"><span class="selector-tag">5</span><span class="selector-class">.cache</span><span class="selector-class">.set</span>(<span class="string">&quot;D&quot;</span>,<span class="number">4</span>)。大小超过了<span class="selector-tag">3</span>，所以移除此时最不常使用的记录(<span class="string">&quot;B&quot;</span>,<span class="number">2</span>)，加入记录(<span class="string">&quot;D&quot;</span>,<span class="number">4</span>)，并且为最常使用的记录，然后(<span class="string">&quot;C&quot;</span>,<span class="number">2</span>)变为最不常使用的记录。</span><br></pre></td></tr></table></figure><p><strong>解</strong></p><p>使用hash表+双向链表的方式来实现LRU，hash可以快速定位元素，双向链表可以快速的新增，删除，修改节点的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> K key;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;K, V&gt; last;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeDoubleLinkedList</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; head;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeDoubleLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个新节点，到尾部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(Node&lt;K, V&gt; newNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = newNode;</span><br><span class="line">            <span class="keyword">this</span>.tail = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.tail.next = newNode;</span><br><span class="line">            newNode.last = <span class="keyword">this</span>.tail;</span><br><span class="line">            <span class="keyword">this</span>.tail = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// node放尾巴</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveNodeToTail</span><span class="params">(Node&lt;K,V&gt; node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tail == node)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == node)&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = node.next;</span><br><span class="line">            <span class="keyword">this</span>.head.last = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            node.last.next = node.next;</span><br><span class="line">            node.next.last = node.last;</span><br><span class="line">        &#125;</span><br><span class="line">        node.last = <span class="keyword">this</span>.tail;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.tail.next = node;</span><br><span class="line">        <span class="keyword">this</span>.tail = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 淘汰头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;K,V&gt; <span class="title">removeHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;K,V&gt; res = head;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.head == <span class="keyword">this</span>.tail)&#123;</span><br><span class="line">            <span class="keyword">this</span>.tail =<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.head = res.next;</span><br><span class="line">            res.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.head.last = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, Node&lt;K,V&gt;&gt; keyNodeMap;</span><br><span class="line">    <span class="keyword">private</span> NodeDoubleLinkedList&lt;K,V&gt; nodeList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;should be more than 0.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.keyNodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.nodeList = <span class="keyword">new</span> NodeDoubleLinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.keyNodeMap.containsKey(key))&#123;</span><br><span class="line">            Node&lt;K,V&gt; res = <span class="keyword">this</span>.keyNodeMap.get(key);</span><br><span class="line">            <span class="keyword">this</span>.nodeList.moveNodeToTail(res);</span><br><span class="line">            <span class="keyword">return</span> res.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.keyNodeMap.containsKey(key))&#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">this</span>.keyNodeMap.get(key);</span><br><span class="line">            node.value = val;</span><br><span class="line">            <span class="keyword">this</span>.nodeList.moveNodeToTail(node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(key, val);</span><br><span class="line">            <span class="keyword">this</span>.keyNodeMap.put(key, newNode);</span><br><span class="line">            <span class="keyword">this</span>.nodeList.addNode(newNode);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.keyNodeMap.size() == <span class="keyword">this</span>.capacity +<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.removeMostUnusedCache();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeMostUnusedCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; removeNode = <span class="keyword">this</span>.nodeList.removeHead();</span><br><span class="line">        <span class="keyword">this</span>.keyNodeMap.remove(removeNode.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目一-LRU&quot;&gt;&lt;a href=&quot;#题目一-LRU&quot; class=&quot;headerlink&quot; title=&quot;题目一 LRU&quot;&gt;&lt;/a&gt;题目一 LRU&lt;/h2&gt;&lt;p&gt;设计LRU缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能。set(key, value):将记录(key, value)插入该结构。&lt;br&gt;get(key):返回key对应的value值。&lt;br&gt;【要求】&lt;br&gt;1.set和get方法的时间复杂度为0(1)&lt;br&gt;⒉.某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的3.当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的&lt;br&gt;【举例】&lt;/p&gt;
&lt;figure class=&quot;highlight less&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;假设缓存结构的实例是&lt;span class=&quot;selector-tag&quot;&gt;cache&lt;/span&gt;，大小为&lt;span class=&quot;selector-tag&quot;&gt;3&lt;/span&gt;，并依次发生如下行为&lt;span class=&quot;selector-tag&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cache&lt;/span&gt;. &lt;span class=&quot;selector-tag&quot;&gt;set&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)。最常使用的记录为(&lt;span class=&quot;string&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cache&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.set&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;B&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)。最常使用的记录为(&lt;span class=&quot;string&quot;&gt;&amp;quot;B&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)，(&lt;span class=&quot;string&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)变为最不常使用的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cache&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.set&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;C&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)。最常使用的记录为(&lt;span class=&quot;string&quot;&gt;&amp;quot;C&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)，(&lt;span class=&quot;string&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)还是最不常使用的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cache&lt;/span&gt;. &lt;span class=&quot;selector-tag&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;)。最常使用的记录为(&lt;span class=&quot;string&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)，(&lt;span class=&quot;string&quot;&gt;&amp;quot;B&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)变为最不常使用的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.cache&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.set&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;D&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)。大小超过了&lt;span class=&quot;selector-tag&quot;&gt;3&lt;/span&gt;，所以移除此时最不常使用的记录(&lt;span class=&quot;string&quot;&gt;&amp;quot;B&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)，加入记录(&lt;span class=&quot;string&quot;&gt;&amp;quot;D&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)，并且为最常使用的记录，然后(&lt;span class=&quot;string&quot;&gt;&amp;quot;C&amp;quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)变为最不常使用的记录。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用hash表+双向链表的方式来实现LRU，hash可以快速定位元素，双向链表可以快速的新增，删除，修改节点的位置&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; K key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; V value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Node&amp;lt;K, V&amp;gt; last;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Node&amp;lt;K, V&amp;gt; next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(K key, V value)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.key = key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 双向链表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NodeDoubleLinkedList&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Node&amp;lt;K, V&amp;gt; head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Node&amp;lt;K, V&amp;gt; tail;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NodeDoubleLinkedList&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.head = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tail = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 添加一个新节点，到尾部&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;addNode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Node&amp;lt;K, V&amp;gt; newNode)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (newNode == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (head == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.head = newNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tail = newNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tail.next = newNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            newNode.last = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tail;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tail = newNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// node放尾巴&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;moveNodeToTail&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Node&amp;lt;K,V&amp;gt; node)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tail == node)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.head == node)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.head = node.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.head.last = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            node.last.next = node.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            node.next.last = node.last;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        node.last = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tail;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        node.next = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tail.next = node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tail = node;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 淘汰头节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span class=&quot;title&quot;&gt;removeHead&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.head == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node&amp;lt;K,V&amp;gt; res = head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.head == &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tail)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.tail =&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.head = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.head = res.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res.next = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.head.last = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyCache&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;K&lt;/span&gt;,&lt;span class=&quot;title&quot;&gt;V&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Map&amp;lt;K, Node&amp;lt;K,V&amp;gt;&amp;gt; keyNodeMap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; NodeDoubleLinkedList&amp;lt;K,V&amp;gt; nodeList;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; capacity;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyCache&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; capacity)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (capacity &amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;string&quot;&gt;&amp;quot;should be more than 0.&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keyNodeMap = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.nodeList = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NodeDoubleLinkedList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.capacity = capacity;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; V &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(K key)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keyNodeMap.containsKey(key))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Node&amp;lt;K,V&amp;gt; res = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keyNodeMap.get(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.nodeList.moveNodeToTail(res);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res.value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(K key, V val)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keyNodeMap.containsKey(key))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Node&amp;lt;K,V&amp;gt; node = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keyNodeMap.get(key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            node.value = val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.nodeList.moveNodeToTail(node);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Node&amp;lt;K,V&amp;gt; newNode = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(key, val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keyNodeMap.put(key, newNode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.nodeList.addNode(newNode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keyNodeMap.size() == &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.capacity +&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.removeMostUnusedCache();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;removeMostUnusedCache&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node&amp;lt;K, V&amp;gt; removeNode = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.nodeList.removeHead();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keyNodeMap.remove(removeNode.key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>中级提升班8</title>
    <link href="http://yoursite.com/2023/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD8/"/>
    <id>http://yoursite.com/2023/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD8/</id>
    <published>2023-01-22T07:37:26.000Z</published>
    <updated>2023-01-23T05:27:02.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目二-express的组合"><a href="#题目二-express的组合" class="headerlink" title="题目二 express的组合"></a>题目二 express的组合</h2><p>给定一个只由0(假)、1(真)、&amp;(逻辑与)、|(逻辑或)和^(异或)五种字符组成的字符串express，再给定一个布尔值desired。返回express能有多少种组合方式，可以达到desired的结果。<br>【举例】<br><code>express=&quot;1^0|0l1&quot;，desired=false</code><br>只有<code>1^((0|0)|1)和1^(0|(0/1))</code>的组合可以得到false，返回2。</p><p><code>express=&quot;1&quot;，desired=false</code><br>无组合则可以得到false，返回0</p><p>解：</p><p>写一个函数，这个函数负责计算在L-R上满足desired的可能性有多少种,<strong>范围尝试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">num1</span><span class="params">(String express, <span class="keyword">boolean</span> desired)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (express == <span class="keyword">null</span> || express.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] exp = express.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (!isValid(exp)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p(exp, desired, <span class="number">0</span>, exp.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偶数位置的字符不是0就是1，奇数位必须是逻辑运算符</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[] exp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((exp.length &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exp.length; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exp[i] != <span class="string">&#x27;1&#x27;</span> &amp;&amp; exp[i] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; exp.length; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exp[i] != <span class="string">&#x27;&amp;&#x27;</span> &amp;&amp; exp[i] != <span class="string">&#x27;|&#x27;</span> &amp;&amp; exp[i] != <span class="string">&#x27;^&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// exp[L,R] 返回期待为desired的组合方法数</span></span><br><span class="line"><span class="comment">// L和R不要是符号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">char</span>[] exp, <span class="keyword">boolean</span> desired, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// basecase</span></span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exp[L] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> desired ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> desired ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (desired) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt; R; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (exp[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">                    res += p(exp, <span class="keyword">true</span>, L, i - <span class="number">1</span>) * p(exp, <span class="keyword">true</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                    res += p(exp, <span class="keyword">true</span>, L, i - <span class="number">1</span>) * p(exp, <span class="keyword">false</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    res += p(exp, <span class="keyword">false</span>, L, i - <span class="number">1</span>) * p(exp, <span class="keyword">true</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    res += p(exp, <span class="keyword">true</span>, L, i - <span class="number">1</span>) * p(exp, <span class="keyword">true</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    res += p(exp, <span class="keyword">true</span>, L, i - <span class="number">1</span>) * p(exp, <span class="keyword">false</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    res += p(exp, <span class="keyword">false</span>, L, i - <span class="number">1</span>) * p(exp, <span class="keyword">true</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L + <span class="number">1</span>; i &lt; R; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (exp[i]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">                    res += p(exp, <span class="keyword">true</span>, L, i - <span class="number">1</span>) * p(exp, <span class="keyword">false</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    res += p(exp, <span class="keyword">false</span>, L, i - <span class="number">1</span>) * p(exp, <span class="keyword">true</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    res += p(exp, <span class="keyword">false</span>, L, i - <span class="number">1</span>) * p(exp, <span class="keyword">false</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                    res += p(exp, <span class="keyword">false</span>, L, i - <span class="number">1</span>) * p(exp, <span class="keyword">false</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                    res += p(exp, <span class="keyword">true</span>, L, i - <span class="number">1</span>) * p(exp, <span class="keyword">true</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    res += p(exp, <span class="keyword">false</span>, L, i - <span class="number">1</span>) * p(exp, <span class="keyword">false</span>, i + <span class="number">1</span>, R);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为动态规划</p><p>看可变参数，3个可变参数， L，R，desired</p><p>2张2维表，true表和false表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dpLive</span><span class="params">(String express, <span class="keyword">boolean</span> desired)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = express.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> N = str.length;</span><br><span class="line">    <span class="keyword">int</span>[][] tDP = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    <span class="keyword">int</span>[][] fDP = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">        tDP[i][i] = str[i] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        fDP[i][i] = str[i] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// L &lt; R L和R不可能为奇数</span></span><br><span class="line">    <span class="comment">// 从左到右，从下向上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = N - <span class="number">3</span>; row &gt;= <span class="number">0</span>; row -= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = row + <span class="number">2</span>; col &lt; N; col += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 符号位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = row + <span class="number">1</span>; i &lt; col; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">                        tDP[row][col] += tDP[row][i - <span class="number">1</span>] * tDP[i - <span class="number">1</span>][col];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                        tDP[row][col] = tDP[row][i - <span class="number">1</span>] * fDP[i - <span class="number">1</span>][col];</span><br><span class="line">                        tDP[row][col] = fDP[row][i - <span class="number">1</span>] * tDP[i - <span class="number">1</span>][col];</span><br><span class="line">                        tDP[row][col] = tDP[row][i - <span class="number">1</span>] * tDP[i - <span class="number">1</span>][col];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                        tDP[row][col] = tDP[row][i - <span class="number">1</span>] * fDP[i - <span class="number">1</span>][col];</span><br><span class="line">                        tDP[row][col] = fDP[row][i - <span class="number">1</span>] * tDP[i - <span class="number">1</span>][col];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">                        fDP[row][col] = tDP[row][i - <span class="number">1</span>] * fDP[i - <span class="number">1</span>][col];</span><br><span class="line">                        fDP[row][col] = fDP[row][i - <span class="number">1</span>] * tDP[i - <span class="number">1</span>][col];</span><br><span class="line">                        fDP[row][col] = fDP[row][i - <span class="number">1</span>] * fDP[i - <span class="number">1</span>][col];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:</span><br><span class="line">                        fDP[row][col] = fDP[row][i - <span class="number">1</span>] * fDP[i - <span class="number">1</span>][col];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">                        fDP[row][col] = tDP[row][i - <span class="number">1</span>] * tDP[i - <span class="number">1</span>][col];</span><br><span class="line">                        tDP[row][col] = fDP[row][i - <span class="number">1</span>] * fDP[i - <span class="number">1</span>][col];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> desired ? tDP[<span class="number">0</span>][N - <span class="number">1</span>] : fDP[<span class="number">0</span>][N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p>在数据加密和数据压缩中常需要对特殊的字符串进行编码。给定的字母表A由26个小写英文字母组成，即A={a, b…z}。该字母表产生的长序字符串是指定字符串中字母从左到右出现的次序与字母在字母表中出现的次序相同，且每个字符最多出现1次。例如，a，b，ab，bc，xyz等字符串是升序字符串。对字母表A产生的所有长度不超过6的升序字符串按照字典排列编码如下: a(1)，b(2)，c(3)……，z(26)，ab(27)，<br>ac(28)……对于任意长度不超过16的升序字符串，迅速计算出它在上述字典中的编码。<br>输入描述:<br>第1行是一个正整数N，表示接下来共有N行，在接下来的N行中，每行给出一个字符串。输出描述:输出N行，每行对应于一个字符串编码。<br>示例1:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="selector-tag">a</span></span><br><span class="line"><span class="selector-tag">b</span></span><br><span class="line">ab</span><br><span class="line">输出</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="题目四-最长无重复子串"><a href="#题目四-最长无重复子串" class="headerlink" title="题目四 最长无重复子串"></a>题目四 最长无重复子串</h2><p>在一个字符串中找到没有重复字符子串中最长的长度。例如:<br>abcabcbb没有重复字符的最长子串是abc，长度为3bbbbb，答案是b，长度为1<br>pwwkew，答案是wke，长度是3<br>要求:答案必须是子串，“pwke”是一个子字符序列但不是一个子字符串。</p><p>解：</p><p>以每个字符结尾的情况下，最长无重复子串是多少</p><ol><li>i位置上次出现的位置</li><li>i-1结尾的时候，最长无重复子串</li></ol><p>2个瓶颈谁近，谁是最长无重复子串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxUnique</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != chars.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(chars[i]))&#123;</span><br><span class="line">            <span class="comment">// 位置的最大值，pre i向前的位置，字符上次出现的位置</span></span><br><span class="line">            pre = Math.max(pre, map.get(chars[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        cur = i - pre;</span><br><span class="line">        len = Math.max(len, cur);</span><br><span class="line">        map.put(chars[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目五-编辑距离"><a href="#题目五-编辑距离" class="headerlink" title="题目五 编辑距离"></a>题目五 编辑距离</h2><p>给定两个字符串str1和str2，再给定三个整数ic、dc和rc，分别代表插入、删除和替换一个字符的代价，返回将str1编辑成str2的最小代价。<br>【举例】<br><code>str1=&quot;abc&quot;,str2=&quot;adc&quot;,ic=5，dc=3，rc=2</code><br>从”abc”编辑成”adc”，把”b’替换成’d’是代价最小的，所以返回2</p><p><code>str1=&quot;abc&quot;,str2=&quot;adc&quot;,ic=5，dc=3，rc=100</code><br>从”abc”编辑成”adc”，先删除’b’，然后插入’d’是代价最小的，所以返回8</p><p><code>str1=&quot;abc&quot;,str2=&quot;abc&quot;,ic=5，dc=3，rc=2</code><br>不用编辑了，本来就是一样的字符串，所以返回0</p><p>解：</p><p>准备一个mxn的数组，str[i]编辑为str[j]的代价为多少，<code>str1[0,i-1]</code>编辑为<code>str2[0,i-1]</code>的代价是多少</p><p>准备basecase，第一行由空串变为str2[0,i]代价为插入<code>i*插入代价</code>，第一列为<code>i*删除代价</code></p><p>普遍情况的可能性：</p><ul><li>str1[0,i]的0,i-2变为前面，然后删除最后一位,<code>dp[i-1][j]+del</code></li><li>str1[0,i]的0,i-1变为前面，然后新增最后一位,<code>dp[i][j-1]+add</code></li><li>str1[0,i]的0,i-2变为前面，然后修改最后一位,<code>dp[i-1][j-1]+replace</code></li><li>i-1与j-1相同，把i-1变为j-1,<code>dp[i-1][j-1]</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(String str1, String str2, <span class="keyword">int</span> ic, <span class="keyword">int</span> dc, <span class="keyword">int</span> rc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="keyword">null</span> || str2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str1.length() == <span class="number">0</span> &amp;&amp; str2.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs1 = str1.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] chs2 = str2.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> row = chs1.length + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> col = chs2.length + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dc * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = ic * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chs1[i - <span class="number">1</span>] == chs2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + rc;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j], dp[i][j - <span class="number">1</span>] + ic);</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j] + dc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目六-无重复字典序最小"><a href="#题目六-无重复字典序最小" class="headerlink" title="题目六 无重复字典序最小"></a>题目六 无重复字典序最小</h2><p>给定一个全是小写字母的字符串str，删除多余字符，使得每种字符只保留一个，并让最终结果字符串的字典序最小<br>【举例】<br>str = “acbc”，删掉第一个’c’，得到”abc”，是所有结果字符串中字典序最小的。<br>str = “dbcacbca”，删掉第一个’b’、第一个’c’、第二个’c’、第二个’a’，得到”dabc”，是所有结果字符串中字典序最小的。</p><p><strong>解</strong></p><p>建立词频表，从开始位置向右扩充字符串，直到，有一个词频全部出现，删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">remove</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        map.put(str.charAt(i), map.getOrDefault(str.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minASCIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        minASCIndex = str.charAt(minASCIndex) &gt; str.charAt(i) ? i : minASCIndex;</span><br><span class="line">        <span class="keyword">if</span> (map.get(str.charAt(i)) - <span class="number">1</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ascii最小且靠左的位置</span></span><br><span class="line">        map.put(str.charAt(i), map.get(str.charAt(i)) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// minACSIndex + &#123;minASCIndex +1&#125; 去掉minASCIndex字符</span></span><br><span class="line">    <span class="keyword">return</span> str.charAt(minASCIndex) +</span><br><span class="line">            remove(str.substring(minASCIndex +<span class="number">1</span>)</span><br><span class="line">                    .replaceAll(String.valueOf(str.charAt(minASCIndex)),</span><br><span class="line">                            <span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目二-express的组合&quot;&gt;&lt;a href=&quot;#题目二-express的组合&quot; class=&quot;headerlink&quot; title=&quot;题目二 express的组合&quot;&gt;&lt;/a&gt;题目二 express的组合&lt;/h2&gt;&lt;p&gt;给定一个只由0(假)、1(真)、&amp;amp;(逻辑与)、|(逻辑或)和^(异或)五种字符组成的字符串express，再给定一个布尔值desired。返回express能有多少种组合方式，可以达到desired的结果。&lt;br&gt;【举例】&lt;br&gt;&lt;code&gt;express=&amp;quot;1^0|0l1&amp;quot;，desired=false&lt;/code&gt;&lt;br&gt;只有&lt;code&gt;1^((0|0)|1)和1^(0|(0/1))&lt;/code&gt;的组合可以得到false，返回2。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;express=&amp;quot;1&amp;quot;，desired=false&lt;/code&gt;&lt;br&gt;无组合则可以得到false，返回0&lt;/p&gt;
&lt;p&gt;解：&lt;/p&gt;
&lt;p&gt;写一个函数，这个函数负责计算在L-R上满足desired的可能性有多少种,&lt;strong&gt;范围尝试&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String express, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; desired)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (express == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || express.equals(&lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[] exp = express.toCharArray();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!isValid(exp)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; p(exp, desired, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, exp.length - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 偶数位置的字符不是0就是1，奇数位必须是逻辑运算符&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isValid&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[] exp)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((exp.length &amp;amp; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; exp.length; i = i + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (exp[i] != &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt; &amp;amp;&amp;amp; exp[i] != &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; exp.length; i = i + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (exp[i] != &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;amp;&amp;#x27;&lt;/span&gt; &amp;amp;&amp;amp; exp[i] != &lt;span class=&quot;string&quot;&gt;&amp;#x27;|&amp;#x27;&lt;/span&gt; &amp;amp;&amp;amp; exp[i] != &lt;span class=&quot;string&quot;&gt;&amp;#x27;^&amp;#x27;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// exp[L,R] 返回期待为desired的组合方法数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// L和R不要是符号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[] exp, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; desired, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; R)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// basecase&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (L == R) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (exp[L] == &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; desired ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; desired ? &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; res = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (desired) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = L + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; R; i += &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (exp[i]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;amp;&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res += p(exp, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, L, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * p(exp, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, R);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;|&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res += p(exp, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, L, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * p(exp, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, R);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res += p(exp, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, L, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * p(exp, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, R);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res += p(exp, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, L, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * p(exp, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, R);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;^&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res += p(exp, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, L, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * p(exp, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, R);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res += p(exp, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, L, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * p(exp, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, R);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = L + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; R; i += &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (exp[i]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;amp;&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res += p(exp, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, L, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * p(exp, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, R);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res += p(exp, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, L, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * p(exp, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, R);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res += p(exp, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, L, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * p(exp, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, R);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;|&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res += p(exp, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, L, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * p(exp, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, R);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;^&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res += p(exp, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, L, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * p(exp, &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, R);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res += p(exp, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, L, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * p(exp, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, R);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;改为动态规划&lt;/p&gt;
&lt;p&gt;看可变参数，3个可变参数， L，R，desired&lt;/p&gt;
&lt;p&gt;2张2维表，true表和false表&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dpLive&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String express, &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; desired)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[] str = express.toCharArray();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; N = str.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] tDP = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[N][N];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] fDP = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[N][N];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; i += &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tDP[i][i] = str[i] == &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        fDP[i][i] = str[i] == &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// L &amp;lt; R L和R不可能为奇数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 从左到右，从下向上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; row = N - &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;; row &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; row -= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; col = row + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;; col &amp;lt; N; col += &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 符号位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = row + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt; col; i += &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (str[i]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;amp;&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        tDP[row][col] += tDP[row][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * tDP[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][col];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;|&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        tDP[row][col] = tDP[row][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * fDP[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][col];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        tDP[row][col] = fDP[row][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * tDP[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][col];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        tDP[row][col] = tDP[row][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * tDP[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][col];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;^&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        tDP[row][col] = tDP[row][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * fDP[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][col];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        tDP[row][col] = fDP[row][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * tDP[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][col];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (str[i]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;amp;&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        fDP[row][col] = tDP[row][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * fDP[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][col];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        fDP[row][col] = fDP[row][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * tDP[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][col];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        fDP[row][col] = fDP[row][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * fDP[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][col];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;|&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        fDP[row][col] = fDP[row][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * fDP[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][col];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;^&amp;#x27;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        fDP[row][col] = tDP[row][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * tDP[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][col];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        tDP[row][col] = fDP[row][i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] * fDP[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][col];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; desired ? tDP[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][N - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] : fDP[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][N - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>中级提升班7</title>
    <link href="http://yoursite.com/2023/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD7/"/>
    <id>http://yoursite.com/2023/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD7/</id>
    <published>2023-01-17T13:26:41.000Z</published>
    <updated>2023-01-22T07:36:47.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>把一个数字用中文表示出来。数字范围为[0, 99999]。<br>为了方便输出，使用字母替换相应的中文，万W千Q百B十S 零L。使用数字取代中文数字注:对于11应该表示为一十一(1S1)，而不是十一(S1)<br>输入描述:<br>数字0（包含）到99999(包含）。输出描述:<br>用字母替换相应的中文，万W千Q百B 十S 零L示例1:<br>输入<br>12001输出1W2QL1</p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>给定一个整数数组A，长度为n，有1&lt;= A[i] &lt;=n，且对于[1,n]的整数，其中部分整数会重复出现而部分不会出现。<br>实现算法找到[1, n]中所有未出现在A中的整数。<br>提示:尝试实现0(n)的时间复杂度和0(1)的空间复杂度（返回值不计入空间复杂度）。<br>输入描述:<br>一行数字，全部为整数，空格分隔A0 A1 A2 A3.. .<br>输出描述:<br>一行数字，全部为整数，空格分隔RO R1 R2 R3.. .</p><p>示例1:<br>输入1 3 4 3输出2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumberNotInArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做到i位置上，放的数是i+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> value:arr)&#123;</span><br><span class="line">        modify(value, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;arr.length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != i+<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[value - <span class="number">1</span>] != value)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[value - <span class="number">1</span>];</span><br><span class="line">        arr[value - <span class="number">1</span>] = value;</span><br><span class="line">        value = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三-数量被3整除"><a href="#题目三-数量被3整除" class="headerlink" title="题目三 数量被3整除"></a>题目三 数量被3整除</h2><p>小Q得到一个神奇的数列:<code>1,12,123,. ..12345678910,1234567891011...</code>。</p><p>并且小Q对于能否被3整除这个性质很感兴趣。<br>小Q现在希望你能帮他计算一下从数列的第I个到第r个(包含端点)有多少个数可以被3整除。输入描述:<br>输入包括两个整数l和r(<code>1&lt;= l &lt;= r &lt;= 1e9</code>)，表示要求解的区间两端。输出描述:<br>输出一个整数,表示区间内能被3整除的数字个数。示例1:<br>输入2 5<br>输出3</p><p>解：</p><p>看<code>1+2...+10</code>是否能被整除</p><p>1034%3转换为(1+0+3+4) %3等效</p><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><p>CC里面有一个土豪很喜欢一位女直播Kiki唱歌，平时就经常给她点赞、送礼、私聊。最近CC直播平台在举行中秋之星主播唱歌比赛，假设一开始该女主播的初始人气值为start，能够晋升下一轮人气需要刚好达到end土豪给主播增加人气的可以采取的方法有:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a. 点赞花费<span class="keyword">x</span> <span class="keyword">c</span>币，人气+<span class="number">2</span></span><br><span class="line">b. 送礼花费y <span class="keyword">c</span>币，人气*<span class="number">2</span></span><br><span class="line"><span class="keyword">c</span>. 私聊花费z C币，人气<span class="number">-2</span></span><br></pre></td></tr></table></figure><p>其中end远大于start且end为偶数，请写一个程序帮助土豪计算一下，最少花费多少C币就能帮助该主播Kiki将人气刚好达到end，从而能够晋级下一轮?</p><p>输入描述:<br>第一行输入5个数据，分别为: x y z start end，每项数据以空格分开。其中:0&lt;x,y，z&lt;=10000，0&lt;start, end&lt;=1000000</p><p>输出描述:<br>需要花费的最少c币。</p><p>示例1:<br>输入 3 100 1 2 6<br>输出 6</p><p>解：</p><p>找到剪枝的方法，</p><h2 id="题目五-完全二叉树节点个数"><a href="#题目五-完全二叉树节点个数" class="headerlink" title="题目五 完全二叉树节点个数"></a>题目五 完全二叉树节点个数</h2><p>完全二叉树节点个数</p><p><strong>解</strong></p><p>找到左子树最深和右子树最深，如果一样，左树为完全二叉树，不一样右树为完全二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode left = root.left;</span><br><span class="line">    <span class="keyword">int</span> leftHigh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        left = left.left;</span><br><span class="line">        leftHigh++;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode right = root.right;</span><br><span class="line">    <span class="keyword">int</span> rightHigh = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        right = right.left;</span><br><span class="line">        rightHigh++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左子树是完全二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (leftHigh == rightHigh) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, leftHigh) - <span class="number">1</span> + countNodes(root.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//右子树是完全二叉树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, rightHigh) - <span class="number">1</span>+ countNodes(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目六-最大奖励"><a href="#题目六-最大奖励" class="headerlink" title="题目六 最大奖励"></a>题目六 最大奖励</h2><p>CC直播的运营部门组织了很多运营活动，每个活动需要花费一定的时间参与，主播每参加完一个活动即可得到一定的奖励，参与活动可以从任意活动开始，但一旦开始，就需要将后续活动参加完毕（注意:最后一个活动必须参与)，活动之间存在一定的依赖关系（不存在环的情况），现在给出所有的活动时间与依赖关系，以及给出有限的时间，请帮主播计算在有限的时候内，能获得的最大奖励，以及需要的最少时长。</p><p>如上图数据所示，给定有限时间为10天。可以获取得最大奖励为n 11700，需要的时长为t 9天。参加的活动为BDCFH四个。<br>输入描述:</p><p>第一行输入数据N与D，表示有N顷活动。D表示给予的时长。0&lt;N&lt;=1000，0&lt;D&lt;=10000.<br>从第二行开始到N+1行，每行福述一个活动的信息，其中第一项表示当前活动需要花费的时间t。第二项表示可以获得的奖励a，之后有N真数据，表示当前活动与其他活动的依赖关系，1表示有依赖，0表示无依赖。每项数据用空格分开。</p><p>输出措述:<br>输出两项数据A与T，用空格分割。A表示所获得的最大奖励，T表示所需要的时长。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入8 10</span><br><span class="line">3<span class="number"> 2000 </span>0<span class="number"> 1 </span>1<span class="number"> 0 </span>0<span class="number"> 0 </span>0 0</span><br><span class="line">3<span class="number"> 4000 </span>0<span class="number"> 0 </span>0<span class="number"> 1 </span>1<span class="number"> 0 </span>0<span class="number"> 0 </span></span><br><span class="line">2<span class="number"> 2500 </span>0<span class="number"> 0 </span>0<span class="number"> 1 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span></span><br><span class="line">1<span class="number"> 1600 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>1<span class="number"> 1 </span>1 0</span><br><span class="line">4<span class="number"> 3800 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0 1</span><br><span class="line">2<span class="number"> 2600 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0 1</span><br><span class="line">4<span class="number"> 4000 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0 1</span><br><span class="line">3<span class="number"> 3500 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0<span class="number"> 0 </span>0 0</span><br><span class="line">输出</span><br><span class="line">11700 9</span><br></pre></td></tr></table></figure><p>解：</p><p>从最后一个点出发，每个节点准备一个有序表，key为到最后的的总天数，value为钱。</p><p>利用bfs推出每个点的有序表，并且利用剪枝的方法，减去时间长但挣钱少的分支，保证每个节点的表，天数变大，收益必须变大。最后得到所有点的结果后，合并在一起，再清洗数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m活动， limit时长</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] maxRewardMinDays(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> limit) &#123;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();<span class="comment">//天数:奖励</span></span><br><span class="line">    builtTreeMap(m, treeMap);</span><br><span class="line">    <span class="keyword">int</span> day = treeMap.floorKey(limit); <span class="comment">//返回小于等于limit的最大键</span></span><br><span class="line">    <span class="keyword">int</span> reward = treeMap.get(day);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;day, reward&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">builtTreeMap</span><span class="params">(<span class="keyword">int</span>[][] m, TreeMap&lt;Integer, Integer&gt; treeMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = m.length;</span><br><span class="line">    <span class="comment">//对于每一个节点,都需要创造一张属于它自己的(天数:奖励)表</span></span><br><span class="line">    TreeMap&lt;Integer, Integer&gt;[] maps = <span class="keyword">new</span> TreeMap[len];</span><br><span class="line">    <span class="comment">//初始化,最后一个结点的表为它自己的天数:奖励</span></span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    map.put(m[len - <span class="number">1</span>][<span class="number">0</span>], m[len - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    maps[len - <span class="number">1</span>] = map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        maps[i] = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; m[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取后序节点进行计算</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : maps[j - <span class="number">2</span>].entrySet()) &#123;</span><br><span class="line">                update(m[i][<span class="number">0</span>] + entry.getKey(),</span><br><span class="line">                        m[i][<span class="number">1</span>] + entry.getValue(),</span><br><span class="line">                        maps[i]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有结果整合到最后结果中</span></span><br><span class="line">    <span class="keyword">for</span> (Map&lt;Integer, Integer&gt; mp : maps) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : mp.entrySet()) &#123;</span><br><span class="line">            update(entry.getKey(), entry.getValue(), treeMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按关系策略更新</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> day, <span class="keyword">int</span> reword,</span></span></span><br><span class="line"><span class="params"><span class="function">                    TreeMap&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isAdd = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (map.floorKey(day) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.put(day, reword);</span><br><span class="line">        isAdd = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到了小的</span></span><br><span class="line">        <span class="keyword">int</span> ceilDay = map.floorKey(day);</span><br><span class="line">        <span class="keyword">int</span> ceilRead = map.get(ceilDay);</span><br><span class="line">        <span class="keyword">if</span> (reword &gt; ceilRead) &#123;</span><br><span class="line">            map.put(day, reword);</span><br><span class="line">            isAdd = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整map使其保证单调性</span></span><br><span class="line">    <span class="keyword">if</span> (isAdd) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="comment">// 删除时间长钱少的</span></span><br><span class="line">            <span class="keyword">if</span> (entry.getKey() &gt; day &amp;&amp; entry.getValue() &lt;= reword) &#123;</span><br><span class="line">                map.remove(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">2000</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">4000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">2500</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1600</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">3800</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">2600</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">4000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">3500</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    P06MaxRewardMinDays p06MaxRewardMinDays = <span class="keyword">new</span> P06MaxRewardMinDays();</span><br><span class="line">    System.out.println(Arrays.toString(p06MaxRewardMinDays.maxRewardMinDays(matrix, <span class="number">10</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目七-最长递增子序列"><a href="#题目七-最长递增子序列" class="headerlink" title="题目七 最长递增子序列"></a>题目七 最长递增子序列</h2><blockquote><p>leetcode 300. 最长递增子序列</p></blockquote><p>解</p><p>使用dp数组，每一位<code>dp[i]</code>表示子序列必须以i结尾的情况下最长递增子序列长度，找到前面<strong>所有</strong>比他小的数，dp[i]最大的，然后+1就是当前位置最大的子序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 找到比他小的值 + 1</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用辅助数组优化，<strong>构建单调性</strong>，加入ends数组代表所有长度为i+1的递增子序列中最小结尾是统计谁，所有都是无效区，有效区中没有比自己大的就扩充，有就更新，统计左侧连同自己有几个数，就是答案</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3<span class="number"> 2 </span>4<span class="number"> 5 </span>1<span class="number"> 7 </span></span><br><span class="line">数组更新如下</span><br><span class="line">3 </span><br><span class="line">2 </span><br><span class="line">2<span class="number"> 4 </span>扩充有效区</span><br><span class="line">2<span class="number"> 4 </span>5 </span><br><span class="line">1<span class="number"> 4 </span>5 </span><br><span class="line">1<span class="number"> 4 </span>5<span class="number"> 7 </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目一&quot;&gt;&lt;a href=&quot;#题目一&quot; class=&quot;headerlink&quot; title=&quot;题目一&quot;&gt;&lt;/a&gt;题目一&lt;/h2&gt;&lt;p&gt;把一个数字用中文表示出来。数字范围为[0, 99999]。&lt;br&gt;为了方便输出，使用字母替换相应的中文，万W千Q百B十S 零L。使用数字取代中文数字注:对于11应该表示为一十一(1S1)，而不是十一(S1)&lt;br&gt;输入描述:&lt;br&gt;数字0（包含）到99999(包含）。输出描述:&lt;br&gt;用字母替换相应的中文，万W千Q百B 十S 零L示例1:&lt;br&gt;输入&lt;br&gt;12001输出1W2QL1&lt;/p&gt;
&lt;h2 id=&quot;题目二&quot;&gt;&lt;a href=&quot;#题目二&quot; class=&quot;headerlink&quot; title=&quot;题目二&quot;&gt;&lt;/a&gt;题目二&lt;/h2&gt;&lt;p&gt;给定一个整数数组A，长度为n，有1&amp;lt;= A[i] &amp;lt;=n，且对于[1,n]的整数，其中部分整数会重复出现而部分不会出现。&lt;br&gt;实现算法找到[1, n]中所有未出现在A中的整数。&lt;br&gt;提示:尝试实现0(n)的时间复杂度和0(1)的空间复杂度（返回值不计入空间复杂度）。&lt;br&gt;输入描述:&lt;br&gt;一行数字，全部为整数，空格分隔A0 A1 A2 A3.. .&lt;br&gt;输出描述:&lt;br&gt;一行数字，全部为整数，空格分隔RO R1 R2 R3.. .&lt;/p&gt;
&lt;p&gt;示例1:&lt;br&gt;输入1 3 4 3输出2&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printNumberNotInArray&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arr == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || arr.length==&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 做到i位置上，放的数是i+1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value:arr)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        modify(value, arr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt;arr.length ; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arr[i] != i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;modify&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (arr[value - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] != value)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; tmp = arr[value - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        arr[value - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        value = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;题目三-数量被3整除&quot;&gt;&lt;a href=&quot;#题目三-数量被3整除&quot; class=&quot;headerlink&quot; title=&quot;题目三 数量被3整除&quot;&gt;&lt;/a&gt;题目三 数量被3整除&lt;/h2&gt;&lt;p&gt;小Q得到一个神奇的数列:&lt;code&gt;1,12,123,. ..12345678910,1234567891011...&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;并且小Q对于能否被3整除这个性质很感兴趣。&lt;br&gt;小Q现在希望你能帮他计算一下从数列的第I个到第r个(包含端点)有多少个数可以被3整除。输入描述:&lt;br&gt;输入包括两个整数l和r(&lt;code&gt;1&amp;lt;= l &amp;lt;= r &amp;lt;= 1e9&lt;/code&gt;)，表示要求解的区间两端。输出描述:&lt;br&gt;输出一个整数,表示区间内能被3整除的数字个数。示例1:&lt;br&gt;输入2 5&lt;br&gt;输出3&lt;/p&gt;
&lt;p&gt;解：&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Go实现内存缓存系统</title>
    <link href="http://yoursite.com/2023/01/10/Go/%E5%B0%8F%E7%BB%83%E6%89%8B/%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2023/01/10/Go/%E5%B0%8F%E7%BB%83%E6%89%8B/%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-01-10T14:47:30.000Z</published>
    <updated>2023-01-10T14:51:41.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ol><li>支持设定过期时间，精度到秒</li><li>支持设定最大内存，当内存超出时做出合适的处理</li><li>支持并发安全</li><li>按照以下接口要求实现</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cache <span class="number">1</span>ntertace &#123;</span><br><span class="line"> <span class="comment">//size : 1KB 100KB 1MB 2MB 1GB</span></span><br><span class="line">    SetMaxMemory(size <span class="keyword">string</span>) <span class="keyword">bool</span>/</span><br><span class="line">    <span class="comment">//将value写入缓存</span></span><br><span class="line">Set(key <span class="keyword">string</span>, val <span class="keyword">interface</span>&#123;&#125;, expire time. Duration) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">//根据key值获取value</span></span><br><span class="line">Get(key <span class="keyword">string</span>)(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span><br><span class="line">    <span class="comment">//删除key值</span></span><br><span class="line">Del(key <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">//判断key是否存在</span></span><br><span class="line">Exists(key <span class="keyword">string</span>) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">//清空所有key</span></span><br><span class="line">Flush() <span class="keyword">bool</span></span><br><span class="line"><span class="comment">//获取缓存中所有key的数量</span></span><br><span class="line">    Keys() <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用示例</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cache := NewMemcache()</span><br><span class="line">cache.SetMaxMemory(<span class="string">&quot;100MB&quot;</span>)</span><br><span class="line">cache.Set(<span class="string">&quot;int&quot;</span>, <span class="number">1</span>)</span><br><span class="line">cache.set(<span class="string">&quot;bool&quot;</span>,<span class="literal">false</span>)</span><br><span class="line">cache.Set(<span class="string">&quot;data&quot;</span>, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>()&#123;<span class="string">&quot;a&quot;</span> : <span class="number">1</span>&#125;)</span><br><span class="line">cache.Get(<span class="string">&quot;int&quot;</span>)</span><br><span class="line">cache.Del(<span class="string">&quot;int&quot;</span>)</span><br><span class="line">cache.Flush()</span><br><span class="line">cache.Keys()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;支持设定过期时间，精度到秒&lt;/li&gt;
&lt;li&gt;支持设定最大内存，当内存超出时做出合适的处理&lt;/li&gt;
&lt;li&gt;支持并发安全&lt;/li&gt;
&lt;li&gt;按照以下接口要求实现&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; cache &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;ntertace &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 	&lt;span class=&quot;comment&quot;&gt;//size : 1KB 100KB 1MB 2MB 1GB&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SetMaxMemory(size &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//将value写入缓存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Set(key &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;, val &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;&amp;#123;&amp;#125;, expire time. Duration) &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//根据key值获取value&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Get(key &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;)(&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;&amp;#123;&amp;#125;, &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//删除key值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Del(key &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//判断key是否存在&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Exists(key &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//清空所有key&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Flush() &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//获取缓存中所有key的数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Keys() &lt;span class=&quot;keyword&quot;&gt;int64&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;使用示例&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cache := NewMemcache()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.SetMaxMemory(&lt;span class=&quot;string&quot;&gt;&amp;quot;100MB&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.Set(&lt;span class=&quot;string&quot;&gt;&amp;quot;int&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.set(&lt;span class=&quot;string&quot;&gt;&amp;quot;bool&amp;quot;&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.Set(&lt;span class=&quot;string&quot;&gt;&amp;quot;data&amp;quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt;]&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;()&amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.Get(&lt;span class=&quot;string&quot;&gt;&amp;quot;int&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.Del(&lt;span class=&quot;string&quot;&gt;&amp;quot;int&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.Flush()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cache.Keys()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

</summary>
    
    
    
    <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
    <category term="goproject" scheme="http://yoursite.com/tags/goproject/"/>
    
  </entry>
  
  <entry>
    <title>Go实现Ping操作</title>
    <link href="http://yoursite.com/2023/01/10/Go/%E5%B0%8F%E7%BB%83%E6%89%8B/%E5%AE%9E%E7%8E%B0Ping%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2023/01/10/Go/%E5%B0%8F%E7%BB%83%E6%89%8B/%E5%AE%9E%E7%8E%B0Ping%E6%93%8D%E4%BD%9C/</id>
    <published>2023-01-10T12:01:30.000Z</published>
    <updated>2023-01-10T14:46:24.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><h3 id="ICMP报文结构"><a href="#ICMP报文结构" class="headerlink" title="ICMP报文结构"></a>ICMP报文结构</h3><p><img src="/2023/01/10/Go/%E5%B0%8F%E7%BB%83%E6%89%8B/%E5%AE%9E%E7%8E%B0Ping%E6%93%8D%E4%BD%9C/ICMP%E6%8A%A5%E6%96%87.png" alt="image-20230110200620314"></p><h3 id="ICMP校验和算法"><a href="#ICMP校验和算法" class="headerlink" title="ICMP校验和算法"></a>ICMP校验和算法</h3><ol><li>报文内容，相邻两个字节拼接到一起组成一个16bit数，将这些数累加求和</li><li>若长度为奇数，则将剩余的1个字节，也累加到求和</li><li>得出总和之后，将和值的高16位与低16位不断求和，直到高16位为</li><li>以上三步得出结果后，取反，即为校验和</li></ol><p>例如 ：根据ICMP的报文可以得出以下的格式</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">8</span> | <span class="number">0</span> | <span class="number">0</span> <span class="number">0</span> | <span class="number">0</span> <span class="number">1</span> | <span class="number">0</span> <span class="number">1</span> | <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>相邻两个字节拼接到一起组成一个16bit数</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">80 </span>+ <span class="number">00</span> + <span class="number">01</span> + <span class="number">01</span> + <span class="number">11</span> + <span class="number">11</span> + <span class="number">11</span> + <span class="number">11</span> </span><br></pre></td></tr></table></figure><p>求和后是一个int32的数，将高16位和低16位求和，直到高位为0</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;bytes&quot;</span></span><br><span class="line">   <span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line">   <span class="string">&quot;flag&quot;</span></span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;log&quot;</span></span><br><span class="line">   <span class="string">&quot;math&quot;</span></span><br><span class="line">   <span class="string">&quot;net&quot;</span></span><br><span class="line">   <span class="string">&quot;os&quot;</span></span><br><span class="line">   <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">   timeout      <span class="keyword">int64</span></span><br><span class="line">   size         <span class="keyword">int</span></span><br><span class="line">   count        <span class="keyword">int</span></span><br><span class="line">   typ          <span class="keyword">uint8</span> = <span class="number">8</span></span><br><span class="line">   code         <span class="keyword">uint8</span> = <span class="number">0</span></span><br><span class="line">   sendCount    <span class="keyword">int</span></span><br><span class="line">   successCount <span class="keyword">int</span></span><br><span class="line">   failCount    <span class="keyword">int</span></span><br><span class="line">   minTx        <span class="keyword">int64</span> = math.MaxInt64</span><br><span class="line">   maxTx        <span class="keyword">int64</span> = math.MinInt32</span><br><span class="line">   totalTx      <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ICMP <span class="keyword">struct</span> &#123;</span><br><span class="line">   Type        <span class="keyword">uint8</span></span><br><span class="line">   Code        <span class="keyword">uint8</span></span><br><span class="line">   CheckSum    <span class="keyword">uint16</span></span><br><span class="line">   ID          <span class="keyword">uint16</span></span><br><span class="line">   SequenceNum <span class="keyword">uint16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   parseCommandArgs()</span><br><span class="line">   desIp := os.Args[<span class="built_in">len</span>(os.Args)<span class="number">-1</span>]</span><br><span class="line">   conn, err := net.DialTimeout(<span class="string">&quot;ip:icmp&quot;</span>, desIp, time.Duration(timeout)*time.Millisecond)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">defer</span> conn.Close()</span><br><span class="line">   fmt.Printf(<span class="string">&quot;正在 Ping %s [%s] 具有 %d 字节的数据:\n&quot;</span>, desIp, conn.RemoteAddr(), size)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; count; i++ &#123;</span><br><span class="line">      sendCount++</span><br><span class="line">      startTime := time.Now()</span><br><span class="line">      icmp := &amp;ICMP&#123;</span><br><span class="line">         Type:        typ,</span><br><span class="line">         Code:        code,</span><br><span class="line">         CheckSum:    <span class="number">0</span>,</span><br><span class="line">         ID:          <span class="number">1</span>,</span><br><span class="line">         SequenceNum: <span class="number">1</span>,</span><br><span class="line">      &#125;</span><br><span class="line">      data := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size) <span class="comment">//所有元素为0</span></span><br><span class="line">      <span class="keyword">var</span> buffer bytes.Buffer</span><br><span class="line">      <span class="comment">// 大端写入</span></span><br><span class="line">      binary.Write(&amp;buffer, binary.BigEndian, icmp)</span><br><span class="line">      <span class="comment">// icmp写入buffer</span></span><br><span class="line">      buffer.Write(data)</span><br><span class="line">      data = buffer.Bytes()</span><br><span class="line">      checkSum := checkSum(data)</span><br><span class="line">      data[<span class="number">2</span>] = <span class="keyword">byte</span>(checkSum &gt;&gt; <span class="number">8</span>) <span class="comment">// 高8位</span></span><br><span class="line">      data[<span class="number">3</span>] = <span class="keyword">byte</span>(checkSum)      <span class="comment">// 低8位</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 读写</span></span><br><span class="line">      conn.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Millisecond))</span><br><span class="line">      n, err := conn.Write(data)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         failCount++</span><br><span class="line">         log.Println(<span class="string">&quot;write err:&quot;</span>, err)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">65535</span>)</span><br><span class="line">      n, err = conn.Read(buf)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">         failCount++</span><br><span class="line">         log.Println(<span class="string">&quot;read err:&quot;</span>, err)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      ts := time.Since(startTime).Milliseconds()</span><br><span class="line">      successCount++</span><br><span class="line">      totalTx += ts</span><br><span class="line">      <span class="keyword">if</span> minTx &gt; ts &#123;</span><br><span class="line">         minTx = ts</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> maxTx &lt; ts &#123;</span><br><span class="line">         maxTx = ts</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;来自 %d.%d.%d.%d 的回复: 字节=%d 时间=%d ms TTL=%d\n&quot;</span>,</span><br><span class="line">         buf[<span class="number">12</span>], buf[<span class="number">13</span>], buf[<span class="number">14</span>], buf[<span class="number">15</span>], n<span class="number">-28</span>, ts, buf[<span class="number">8</span>])</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%s 的 Ping 统计信息:\n    数据包: 已发送 = %d，已接收 = %d，丢失 = %d (%.2f%% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n    最短 = %dms，最长 = %dms，平均 = %dms&quot;</span>,</span><br><span class="line">      conn.RemoteAddr(), sendCount, successCount, failCount, <span class="keyword">float64</span>(failCount)/<span class="keyword">float64</span>(sendCount), minTx, maxTx, totalTx/<span class="keyword">int64</span>(sendCount))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseCommandArgs</span><span class="params">()</span></span> &#123;</span><br><span class="line">   flag.Int64Var(&amp;timeout, <span class="string">&quot;w&quot;</span>, <span class="number">1000</span>, <span class="string">&quot;请求超时时长，单位ms&quot;</span>)</span><br><span class="line">   flag.IntVar(&amp;size, <span class="string">&quot;l&quot;</span>, <span class="number">32</span>, <span class="string">&quot;请求缓冲区大小，单位字节&quot;</span>)</span><br><span class="line">   flag.IntVar(&amp;count, <span class="string">&quot;n&quot;</span>, <span class="number">4</span>, <span class="string">&quot;发送请求数&quot;</span>)</span><br><span class="line">   flag.Parse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkSum</span><span class="params">(data []<span class="keyword">byte</span>)</span> <span class="title">uint16</span></span> &#123;</span><br><span class="line">   length := <span class="built_in">len</span>(data)</span><br><span class="line">   index := <span class="number">0</span></span><br><span class="line">   <span class="keyword">var</span> sum <span class="keyword">uint32</span></span><br><span class="line">   <span class="keyword">for</span> length &gt; <span class="number">1</span> &#123;</span><br><span class="line">      sum += <span class="keyword">uint32</span>(data[index])&lt;&lt;<span class="number">8</span> + <span class="keyword">uint32</span>(data[index+<span class="number">1</span>])</span><br><span class="line">      length -= <span class="number">2</span></span><br><span class="line">      index += <span class="number">2</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 奇数</span></span><br><span class="line">   <span class="keyword">if</span> length != <span class="number">0</span> &#123;</span><br><span class="line">      sum += <span class="keyword">uint32</span>(data[index])</span><br><span class="line">   &#125;</span><br><span class="line">   h16 := sum &gt;&gt; <span class="number">16</span></span><br><span class="line">   <span class="keyword">for</span> h16 != <span class="number">0</span> &#123;</span><br><span class="line">      sum = h16 + <span class="keyword">uint32</span>(<span class="keyword">uint16</span>(sum))</span><br><span class="line">      h16 = sum &gt;&gt; <span class="number">16</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">uint16</span>(^sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ICMP&quot;&gt;&lt;a href=&quot;#ICMP&quot; class=&quot;headerlink&quot; title=&quot;ICMP&quot;&gt;&lt;/a&gt;ICMP&lt;/h2&gt;&lt;h3 id=&quot;ICMP报文结构&quot;&gt;&lt;a href=&quot;#ICMP报文结构&quot; class=&quot;headerlink&quot; title=&quot;ICMP报文结构&quot;&gt;&lt;/a&gt;ICMP报文结构&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2023/01/10/Go/%E5%B0%8F%E7%BB%83%E6%89%8B/%E5%AE%9E%E7%8E%B0Ping%E6%93%8D%E4%BD%9C/ICMP%E6%8A%A5%E6%96%87.png&quot; alt=&quot;image-20230110200620314&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;ICMP校验和算法&quot;&gt;&lt;a href=&quot;#ICMP校验和算法&quot; class=&quot;headerlink&quot; title=&quot;ICMP校验和算法&quot;&gt;&lt;/a&gt;ICMP校验和算法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;报文内容，相邻两个字节拼接到一起组成一个16bit数，将这些数累加求和&lt;/li&gt;
&lt;li&gt;若长度为奇数，则将剩余的1个字节，也累加到求和&lt;/li&gt;
&lt;li&gt;得出总和之后，将和值的高16位与低16位不断求和，直到高16位为&lt;/li&gt;
&lt;li&gt;以上三步得出结果后，取反，即为校验和&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如 ：根据ICMP的报文可以得出以下的格式&lt;/p&gt;
&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;8&lt;/span&gt; | &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; | &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; | &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; | &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; | &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;相邻两个字节拼接到一起组成一个16bit数&lt;/p&gt;
&lt;figure class=&quot;highlight basic&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;80 &lt;/span&gt;+ &lt;span class=&quot;number&quot;&gt;00&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;01&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;01&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;求和后是一个int32的数，将高16位和低16位求和，直到高位为0&lt;/p&gt;</summary>
    
    
    
    <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
    <category term="goproject" scheme="http://yoursite.com/tags/goproject/"/>
    
  </entry>
  
  <entry>
    <title>中级提升班6</title>
    <link href="http://yoursite.com/2023/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD6/"/>
    <id>http://yoursite.com/2023/01/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD6/</id>
    <published>2023-01-08T12:59:24.000Z</published>
    <updated>2023-01-17T13:25:32.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目一-打印目录"><a href="#题目一-打印目录" class="headerlink" title="题目一 打印目录"></a>题目一 打印目录</h2><p>给你一个字符串类型的数组arr，譬如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123; <span class="string">&quot;b\\cst&quot;</span>, <span class="string">&quot;d\\&quot;</span>, <span class="string">&quot;a\\d\\e&quot;</span>, <span class="string">&quot;a\\b\\c”&#125;;</span></span><br></pre></td></tr></table></figure><p>你把这些路径中蕴含的目录结构给画出来，子目录直接列在父目录下面，并比父目录向右进两格，就像这样:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span></span><br><span class="line">  <span class="selector-tag">b</span></span><br><span class="line">    c</span><br><span class="line">  d</span><br><span class="line">    e</span><br><span class="line"><span class="selector-tag">b</span></span><br><span class="line">  cst</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p>同一级的需要按字母顺序排列，不能乱。</p><p><strong>解</strong></p><p>经典前缀树题目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">// 有序打印</span></span><br><span class="line">    <span class="keyword">public</span> TreeMap&lt;String, Node&gt; nextMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        nextMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String[] folderPaths)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (folderPaths == <span class="keyword">null</span> ||folderPaths.length == <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node header = generateFolderTree(folderPaths);</span><br><span class="line">    printProcess(header, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">generateFolderTree</span><span class="params">(String[] folderPaths)</span> </span>&#123;</span><br><span class="line">    Node head = <span class="keyword">new</span> Node(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String foldPath : folderPaths) &#123;</span><br><span class="line">        String[] paths = foldPath.split(<span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">for</span> (String path : paths) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!cur.nextMap.containsKey(path)) &#123;</span><br><span class="line">                cur.nextMap.put(path, <span class="keyword">new</span> Node(path));</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.nextMap.get(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printProcess</span><span class="params">(Node node, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level != <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(get2nSpace(level) + node.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Node next : node.nextMap.values()) &#123;</span><br><span class="line">        printProcess(next, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">get2nSpace</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; n++) &#123;</span><br><span class="line">        res += <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二-搜索二叉树转换双向链表"><a href="#题目二-搜索二叉树转换双向链表" class="headerlink" title="题目二 搜索二叉树转换双向链表"></a>题目二 搜索二叉树转换双向链表</h2><p>双向链表节点结构和二叉树节点结构是一样的，如果你把last认为是left，next认为是next的话。<br>给定一个搜索二叉树的头节点head，请转化成一条有序的双向链表，并返回链表的头节点。</p><blockquote><p>剑指 Offer 36. 二叉搜索树与双向链表</p></blockquote><p><strong>解</strong></p><p>使每个节点左子树形成链表，右子树形成链表，使当前节点与左链表的尾节点和有链表的首节点相连。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val, Node _left, Node _right)</span> </span>&#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        left = _left;</span><br><span class="line">        right = _right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  搜索二叉树转为为双向链表后，头和尾返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node start;</span><br><span class="line">    <span class="keyword">public</span> Node end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(Node start, Node end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以x为头的整棵搜索二叉树，请全部以有序双向链表的方式，连好</span></span><br><span class="line"><span class="comment">// 并且返回，整个有序双向链表的头节点和尾节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Info left = process(x.left);</span><br><span class="line">    Info right = process(x.right);</span><br><span class="line">    <span class="keyword">if</span> (left.end != <span class="keyword">null</span>) &#123;</span><br><span class="line">        left.end.right = x;</span><br><span class="line">    &#125;</span><br><span class="line">    x.left = left.end;</span><br><span class="line">    x.right = right.start;</span><br><span class="line">    <span class="keyword">if</span> (right.start != <span class="keyword">null</span>) &#123;</span><br><span class="line">        right.start.left = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(left.start != <span class="keyword">null</span> ? left.start : x, right.end != <span class="keyword">null</span> ? right.end : x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Info info = process(root);</span><br><span class="line">    Node header = info.start;</span><br><span class="line">    Node tail = info.end;</span><br><span class="line">    header.left = tail;</span><br><span class="line">    tail.right = header;</span><br><span class="line">    <span class="keyword">return</span> header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三-最大搜索二叉子树"><a href="#题目三-最大搜索二叉子树" class="headerlink" title="题目三 最大搜索二叉子树"></a>题目三 最大搜索二叉子树</h2><p>找到一棵二叉树中，最大的搜索二叉子树，返回最大搜索二叉子树的节点个数。</p><p><strong>解</strong></p><p>一个节点，左树是搜索二叉树，右树也是搜索二叉树，那么左树的最大值小与当前节点，右树的最小值大于当前节点。</p><p>递归需要4个值，子树的投节点，是否是搜索二叉树，最大值，最小值，二叉搜索子树的大小</p><p>已知一棵二叉树中没有重复节点，并且给定了这棵树的中序遍历数组和先序遍历数组，返回后序遍历数组。<br>比如给定:。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span>[] pre = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>.<span class="number">5</span>, <span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span> &#125; ;int[] in = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span> &#125;;</span><br></pre></td></tr></table></figure><p>返回:<br>{4,5,2,6,7,3,1}</p><h2 id="题目四-二叉树先序中序还原后序"><a href="#题目四-二叉树先序中序还原后序" class="headerlink" title="题目四 二叉树先序中序还原后序"></a>题目四 二叉树先序中序还原后序</h2><p>已知一棵二叉树中没有重复节点，并且给定了这棵树的中序遍历数组和先序遍历数组，返回后序遍历数组。<br>比如给定:<br>int[] pre = { <code>1,2,4,5,3,6,7</code> } ;int[] in = { <code>4,2,5,1,6,3,7</code> };返回:<br>{<code>4,5,2,6,7,3,1</code>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getPostArray(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = pre.length;</span><br><span class="line">    <span class="keyword">int</span>[] pos = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    set(pre, in, pos, <span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用pre[prei...prej] 结合in[ini...inj]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in, <span class="keyword">int</span>[] pos, <span class="keyword">int</span> prei, <span class="keyword">int</span> prej, <span class="keyword">int</span> ini, <span class="keyword">int</span> inj, <span class="keyword">int</span> posi, <span class="keyword">int</span> posj)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prei &gt; prej) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prei == prej) &#123;</span><br><span class="line">        pos[posi] = pre[prei];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pos[posj] = pre[prei];</span><br><span class="line">    <span class="keyword">int</span> find = ini;</span><br><span class="line">    <span class="keyword">for</span> (; find &lt;= inj; find++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[find] == pre[prei]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    set(pre, in, pos, prei + <span class="number">1</span>, prei + find - ini, ini, find - <span class="number">1</span>, posi, posi + find - ini - <span class="number">1</span>);</span><br><span class="line">    set(pre, in, pos, prei + find - ini + <span class="number">1</span>, prej, find + <span class="number">1</span>, inj, posi + find - ini, posj - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目五-路灯放法"><a href="#题目五-路灯放法" class="headerlink" title="题目五 路灯放法"></a>题目五 路灯放法</h2><p>小Q正在给一条长度为n的道路设计路灯安置方案。<br>为了让问题更简单,小Q把道路视为n个方格,需要照亮的地方用’<code>.</code>‘表示，不需要照亮的障碍物格子用’<code>X</code>‘表示。小Q现在要在道路上设置一些路灯，对于安置在pos位置的路灯，这盏路灯可以照亮<code>pos - 1, pos, pos + 1</code>这三个位置。小Q希望能安置尽量少的路灯照亮所有’.’区域，希望你能帮他计算一下最少需要多少盏路灯。<br>输入描述:<br>输入的第一行包含一个正整数t(1&lt;= t&lt;1000)，表示测试用例数<br>接下来每两行一个测试数据，第一行一个正整数n(1 &lt;= n &lt;= 1000),表示道路的长度。第二行一个字符串s表示道路的构造,只包含’<code>.</code>‘和’<code>X</code>’。<br>输出描述:<br>对于每个测试用例,输出一个正整数表示最少需要多少盏路灯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minLight</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; str.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// .</span></span><br><span class="line">            ans++;</span><br><span class="line">            <span class="comment">// 来到当前位置，保证之前的灯，不会影响到当前位置</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> == str.length) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[i + <span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                    i += <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//下个位置是.在i+1放</span></span><br><span class="line">                    i += <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种解法，求连续.的个数除3后+1就是结果</p><h2 id="题目六-最大子数组和"><a href="#题目六-最大子数组和" class="headerlink" title="题目六  最大子数组和"></a>题目六  最大子数组和</h2><p>为了保证招聘信息的质量问题，公司为每个职位设计了打分系统，打分可以为正数，也可以为负数，正数表示用户认可帖子质量，负数表示用户不认可帖子质量.打分的分数根据评价用户的等级大小不定，比如可以为41分，10分，30分，-10分寺。假攻数组A记录了一条帖子所有打分记录，现在需要找出帖子曾经得到过最高的分数是多少，用于后续根据最高分数来确认需要对发帖用户做相应的惩罚或奖励．其中，最高分的定义为:用户所有打分记录中，连续打分数据之和的最大值即认为是帖子曾经获得的最高分。例如:帖子10001010近期的打分记录为<code>[1,1,-1,-10,11,4,-6,9,20,-10,-2]</code>,那么该条帖子曾经到达过的最高分数为<code>11+4+(-6)+9+20=38</code>。请实现一段代码，输入为帖子近期的打分记录，输出为当前帖子得到的最高分数。</p><blockquote><p>leetcode 53 <a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></p></blockquote><p>解</p><p>0-n的数组，假设a-b最大，a-b累加和一定大于0，0-a累加和一定小于0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        cur = Math.max(nums[i], cur + nums[i]);</span><br><span class="line">        max = Math.max(max, cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目七-子矩阵最大累加和"><a href="#题目七-子矩阵最大累加和" class="headerlink" title="题目七 子矩阵最大累加和"></a>题目七 子矩阵最大累加和</h2><p>给定一个整型矩阵，返回子矩阵的最大累计和。</p><p>解：</p><p>假设是一个3x3的矩阵，求第一行、第一行第二行、第一行第二行第三行、第二行、第二行第三行、第三行中最大的矩形。例如求第一行，使用题目6中的求法将结果求出，求第一行第二行，将2行加在一起求出结果，最后求出最大值即可。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目一-打印目录&quot;&gt;&lt;a href=&quot;#题目一-打印目录&quot; class=&quot;headerlink&quot; title=&quot;题目一 打印目录&quot;&gt;&lt;/a&gt;题目一 打印目录&lt;/h2&gt;&lt;p&gt;给你一个字符串类型的数组arr，譬如:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String[] arr = &amp;#123; &lt;span class=&quot;string&quot;&gt;&amp;quot;b\\cst&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;d\\&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;a\\d\\e&amp;quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;a\\b\\c”&amp;#125;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;你把这些路径中蕴含的目录结构给画出来，子目录直接列在父目录下面，并比父目录向右进两格，就像这样:&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  d&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    e&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;同一级的需要按字母顺序排列，不能乱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经典前缀树题目&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 有序打印&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; TreeMap&amp;lt;String, Node&amp;gt; nextMap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nextMap = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] folderPaths)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (folderPaths == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ||folderPaths.length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node header = generateFolderTree(folderPaths);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printProcess(header, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Node &lt;span class=&quot;title&quot;&gt;generateFolderTree&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] folderPaths)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node head = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (String foldPath : folderPaths) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String[] paths = foldPath.split(&lt;span class=&quot;string&quot;&gt;&amp;quot;\\\\&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node cur = head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (String path : paths) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!cur.nextMap.containsKey(path)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cur.nextMap.put(path, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node(path));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            cur = cur.nextMap.get(path);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printProcess&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Node node, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; level)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (level != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(get2nSpace(level) + node.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Node next : node.nextMap.values()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printProcess(next, level + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;get2nSpace&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String res = &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; n++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res += &lt;span class=&quot;string&quot;&gt;&amp;quot;  &amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;题目二-搜索二叉树转换双向链表&quot;&gt;&lt;a href=&quot;#题目二-搜索二叉树转换双向链表&quot; class=&quot;headerlink&quot; title=&quot;题目二 搜索二叉树转换双向链表&quot;&gt;&lt;/a&gt;题目二 搜索二叉树转换双向链表&lt;/h2&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>中级提升班5</title>
    <link href="http://yoursite.com/2023/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD5/"/>
    <id>http://yoursite.com/2023/01/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD5/</id>
    <published>2023-01-07T14:18:58.000Z</published>
    <updated>2023-01-08T12:55:55.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目一-达标字符串"><a href="#题目一-达标字符串" class="headerlink" title="题目一 达标字符串"></a>题目一 达标字符串</h2><p>字符串只由’0’和’1’两种字符构成，<br>当字符串长度为1时，所有可能的字符串为”0”、”1”;<br>当字符串长度为2时，所有可能的字符串为”00”、”01”、”10”、”11”;<br>当字符串长度为3时，所有可能的字符串为”000”、”001”、 “010”、 “011”、 “100”、”101”、”110”、 “111”<br>如果某一个字符串中，只要是出现’0’的位置，左边就靠着’1’，这样的字符串叫作达标字符串。<br>给定一一个正数N，返回所有长度为N的字符串中，达标字符串的数量。<br>比如，N=3， 返回3，因为只有”101”、”110”、 “111”达标。</p><p><strong>解</strong></p><p>n=i在长度为i有多少合法的字符串，就规定了在0位置上必须为1，求f(n-1)。</p><p>对于n=8，就是0位置为1,求剩下7位置的可能性，f(7),此时就有2中可能性</p><ol><li>第一位为1，求f(6)的数量 </li><li>第一位为0，那么下一位就必须填1，f(5)的数量</li></ol><p><code>f(i) = f(i-1)+f(i-2)</code>,此时把问题转化为了<strong>斐波那契数列</strong>问题。采用递归或动态规划的方式求解,下面是采用的线性代数中将斐波那契数列转换为矩阵相乘的求解方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//常数矩阵</span></span><br><span class="line">    <span class="keyword">int</span>[][] base = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] res = matrixPower(base, n - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 第n项 f(n) f(n-1) = |1,1| * base 矩阵的左侧相加就是结果</span></span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>] + res[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵相乘的求法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] matrixPower(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> p) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m.length][m[<span class="number">0</span>].length];</span><br><span class="line">    <span class="comment">// 矩阵位置1的含义 对角线为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">        res[i][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] tmp = m;</span><br><span class="line">    <span class="keyword">for</span> (; p != <span class="number">0</span>; p &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p &amp; <span class="number">1</span>) !=<span class="number">0</span>)&#123; <span class="comment">// 当前二进制位不为0 矩阵需要相乘</span></span><br><span class="line">            res = muliMatrix(res, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = muliMatrix(tmp, tmp); <span class="comment">// 1 2 4 8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵相乘 O(1)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] muliMatrix(<span class="keyword">int</span>[][] m1, <span class="keyword">int</span>[][] m2) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m1.length][m2[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;m1.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=m2.length;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;m2.length;k++)&#123;</span><br><span class="line">                res[i][j] += m1[i][k] * m2[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二-不能组成三角形"><a href="#题目二-不能组成三角形" class="headerlink" title="题目二 不能组成三角形"></a>题目二 不能组成三角形</h2><p>在迷迷糊糊的大草原上，小红捡到了n根木棍，第i根木棍的长度为i，小红现在很开心。想选出其中的三根木棍组成美丽的三角形。<br>但是小明想捉弄小红，想去掉一些木棍，使得小红任意选三根木棍都不能组成三角形。<br>请问小明最少去掉多少根木棍呢?给定N，返回至少去掉多少根?</p><p><strong>解</strong></p><p>不能组成三角形，将题目转化为求n以内的斐波那契数列数列的个数，就是最多个保留木棍的个数。两边之和大于第三边</p><p>代码如上一题。</p><h2 id="题目三-相邻是4的倍数"><a href="#题目三-相邻是4的倍数" class="headerlink" title="题目三 相邻是4的倍数"></a>题目三 相邻是4的倍数</h2><p>给定一个数组arr,如果通过调整可以做到arr中任意两个相邻的数字相乘是4的倍数,返回true;如果不能返回false</p><p><strong>解</strong></p><p>将数组中数分为2类奇数a个,偶数中只有一个2因子的b个，包含4因子的数c个，有以下几种情况</p><ol><li><p><code>b==0</code> “奇 四 奇 四 奇” …  这样摆节省空间</p><ol><li><code>a==1</code>, <code>c&gt;=1</code></li><li><code>a!=1</code>,<code>c&gt;=a-1</code></li></ol></li><li><p><code>b!=0</code> “2222224奇4奇4”</p><ol><li><code>a==1</code>, <code>c&gt;=1</code></li><li><code>a!=1</code> , <code>c&gt;=a</code></li></ol><p>c&gt;=a</p></li><li><p>b=1 c=0 a=0 不成立</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nearMultiple4</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> even2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> even4 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                even4++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                even2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            odd++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (even2 == <span class="number">1</span> &amp;&amp; even4 == <span class="number">0</span> &amp;&amp; odd == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> res;</span><br><span class="line">    <span class="keyword">if</span> (even2 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (odd == <span class="number">1</span>) &#123;</span><br><span class="line">            res = even4 &gt;= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = even4 &gt;= odd - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = even4 &gt;= odd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目四-整数字符串"><a href="#题目四-整数字符串" class="headerlink" title="题目四 整数字符串"></a>题目四 整数字符串</h2><p>给定一个字符串，如果该字符串符合人们日常书写一个整数的形式，返回int类型的这个数;如果不符合或者越界返回-1或者报错。</p><p><strong>解</strong></p><p>有以下几个条件</p><ol><li>数字之外只允许有”-“, </li><li>有”-“只允许出现在开头, 并且跟着数字字符</li><li>如果开头是0后序没有数字</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">    <span class="keyword">if</span> (!isValid(str)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;can not convert&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> neg = str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> minq = Integer.MIN_VALUE /<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> minr = Integer.MIN_VALUE %<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;<span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = neg ? <span class="number">1</span> : <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="comment">// str[i] = &#x27;0&#x27; cur -&gt; 0</span></span><br><span class="line">        <span class="comment">// str[i] = &#x27;1&#x27; cur -&gt; -1</span></span><br><span class="line">        <span class="comment">// str[i] = &#x27;4&#x27; cur -&gt; -4</span></span><br><span class="line">        cur = <span class="string">&#x27;0&#x27;</span> - str[i];</span><br><span class="line">        <span class="comment">//中途转化过程中，溢出的时候</span></span><br><span class="line">        <span class="keyword">if</span> ( ( res &lt; minq) || (res == minq &amp;&amp; cur &lt; minr)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException( <span class="string">&quot;can not convert&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        res = res * <span class="number">10</span> + cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// res是 负数</span></span><br><span class="line">    <span class="keyword">if</span> (!neg &amp;&amp; res == Integer.MIN_VALUE)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException( <span class="string">&quot;can not convert&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> neg ? res : -res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用负数承接转换的数字 -214783648 负数表示范围比正数大</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查某一个字符串str，是否符合日常书写标准public static boolean isValid( char[] str) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span> &amp;&amp; (str[<span class="number">0</span>] &lt; <span class="string">&#x27;0&#x27;</span> || str[<span class="number">0</span>] &gt; <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1) str[0] == &#x27;-&#x27; &amp;&amp; str.length == 1</span></span><br><span class="line">    <span class="comment">// 2) str[0] == &#x27;-&#x27; &amp;&amp; str.length != 1 &amp;&amp; str[1] == &#x27;0&#x27;)</span></span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (str.length == <span class="number">1</span> || str[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; str.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目五-最高的k个记录"><a href="#题目五-最高的k个记录" class="headerlink" title="题目五 最高的k个记录"></a>题目五 最高的k个记录</h2><p>设计并实现TopKRecord结构，可以不断地向其中加入字符串，并且可以根据字符串出现的情况随时打印加入次数最多的前k个字符串。具体为:</p><ol><li>k在TopKRecord实例生成时指定，并且不再变化(k是构造TopKRecord的参数)</li><li>含有add (String str)方法，即向TopKRecord中加入字符串。</li><li>含有printTopK()方法，即打印加入次数最多的前k个字符串，打印有哪些字符串和对应的次数即可，不要求严格按排名顺序打印。</li><li>如果在出现次数最征…..o字符串中，最后一名的字符串有多个，比如出现次数最多的前3个字符串具体排名为:<br>A 100次B 90次C 80次D 80次E80次，其他任何字符串出现次数都不超过80次<br>那么只需要打印3个，打印ABC、ABD、ABE都可以。也就是说可以随意抛弃最后一名，只要求打印k个</li></ol><p>要求:</p><ol><li>在任何时候，add 方法的时间复杂度不超过0(logk)2）在任何时候，printTopK方法的时间复杂度不超过0(k)。</li></ol><p>题目在 <strong>中级提升班3 字符串数组出现最大的前k个</strong>中已经写过，此处省略</p><h2 id="题目六-零食的装法"><a href="#题目六-零食的装法" class="headerlink" title="题目六 零食的装法"></a>题目六 零食的装法</h2><p>牛牛准备参加学校组织的春游，出发前牛牛准备往背包里装入一些零食，牛牛的背包容量为w。<br>牛牛家里一共有n袋零食，第i袋零食体积为v[i]。<br>牛牛想知道在总体积不超过背包容量的情况下，他一共有多少种零食放法(总体积为0也算一种放法)。<br><strong>解</strong></p><p>背包问题的变种，完全背包问题是容量为n正好可以装满的方法，该方法就是从容量为0到容量为n的方法都相加即使最终的答案。</p><blockquote><p>类似于leetcode 零钱兑换2问题 只不过是所有的可能性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snackPlacement</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123; <span class="comment">// 从下往上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= n; rest++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> zhang = <span class="number">0</span>; arr[index] * zhang &lt;= rest; zhang++) &#123;</span><br><span class="line">                ways += dp[ index + <span class="number">1</span>][ rest - arr[index] * zhang];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[index][rest] = ways;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n是大小，将dp表第一行加起来就是最终结果</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++ )&#123;</span><br><span class="line">        res += dp[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目七-找工作"><a href="#题目七-找工作" class="headerlink" title="题目七 找工作"></a>题目七 找工作</h2><p>为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> money; <span class="comment">// 该工作的报酬</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> hard; <span class="comment">//该工作的难度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> money,<span class="keyword">int</span> hard)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.money = money;</span><br><span class="line"><span class="keyword">this</span>.hard = hard;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定一个Job类型的数组jobarr，表示所有的工作。给定一个int类型的数组arr，表示所有小伙伴的能力。返回int类型的数组，表示每一个小伙伴按照牛牛的标准选工作后所能获得的报酬。</p><blockquote><p>leetcode 502 IPO</p></blockquote><p><strong>解</strong></p><p>首先对Job进行排序，先安装Job的难度由小到大排，如果难度一样按照报酬排。难度一样保留报酬最高的；去掉难度升高报酬减少的工作；保持难度递增，报酬一定递增的单调性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JobComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Job</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Job o1, Job o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.hard != o2.hard ? o1.hard - o2.hard : o2.money - o1.money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getMoneys(Job[] jobs, <span class="keyword">int</span>[] ability) &#123;</span><br><span class="line">    <span class="comment">// 难度由小到大排，如果难度一样按照报酬</span></span><br><span class="line">    Arrays.sort(jobs, <span class="keyword">new</span> JobComparator());</span><br><span class="line">    <span class="comment">// 难度为key的工作，最优钱数是多少，有序表</span></span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    map.put(jobs[<span class="number">0</span>].hard, jobs[<span class="number">0</span>].money);</span><br><span class="line">    Job pre = jobs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; jobs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (jobs[i].hard != pre.hard &amp;&amp; jobs[i].money &gt; pre.money) &#123;</span><br><span class="line">            pre = jobs[i];</span><br><span class="line">            map.put(pre.hard, pre.money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[ability.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ability.length; i++) &#123;</span><br><span class="line">        Integer key = map.floorKey(ability[i]);</span><br><span class="line">        ans[i] = key != <span class="keyword">null</span> ? map.get(key) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目一-达标字符串&quot;&gt;&lt;a href=&quot;#题目一-达标字符串&quot; class=&quot;headerlink&quot; title=&quot;题目一 达标字符串&quot;&gt;&lt;/a&gt;题目一 达标字符串&lt;/h2&gt;&lt;p&gt;字符串只由’0’和’1’两种字符构成，&lt;br&gt;当字符串长度为1时，所有可能的字符串为”0”、”1”;&lt;br&gt;当字符串长度为2时，所有可能的字符串为”00”、”01”、”10”、”11”;&lt;br&gt;当字符串长度为3时，所有可能的字符串为”000”、”001”、 “010”、 “011”、 “100”、”101”、”110”、 “111”&lt;br&gt;如果某一个字符串中，只要是出现’0’的位置，左边就靠着’1’，这样的字符串叫作达标字符串。&lt;br&gt;给定一一个正数N，返回所有长度为N的字符串中，达标字符串的数量。&lt;br&gt;比如，N=3， 返回3，因为只有”101”、”110”、 “111”达标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;n=i在长度为i有多少合法的字符串，就规定了在0位置上必须为1，求f(n-1)。&lt;/p&gt;
&lt;p&gt;对于n=8，就是0位置为1,求剩下7位置的可能性，f(7),此时就有2中可能性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一位为1，求f(6)的数量 &lt;/li&gt;
&lt;li&gt;第一位为0，那么下一位就必须填1，f(5)的数量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;f(i) = f(i-1)+f(i-2)&lt;/code&gt;,此时把问题转化为了&lt;strong&gt;斐波那契数列&lt;/strong&gt;问题。采用递归或动态规划的方式求解,下面是采用的线性代数中将斐波那契数列转换为矩阵相乘的求解方式。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;fi&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n &amp;lt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; || n == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//常数矩阵&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] base = &amp;#123;&amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;, &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] res = matrixPower(base, n - &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 第n项 f(n) f(n-1) = |1,1| * base 矩阵的左侧相加就是结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] + res[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 矩阵相乘的求法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] matrixPower(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] m, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; p) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] res = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[m.length][m[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 矩阵位置1的含义 对角线为1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; res.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res[i][i] = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] tmp = m;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (; p != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; p &amp;gt;&amp;gt;= &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ((p &amp;amp; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) !=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123; &lt;span class=&quot;comment&quot;&gt;// 当前二进制位不为0 矩阵需要相乘&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res = muliMatrix(res, tmp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tmp = muliMatrix(tmp, tmp); &lt;span class=&quot;comment&quot;&gt;// 1 2 4 8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//矩阵相乘 O(1)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] muliMatrix(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] m1, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] m2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[][] res = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[m1.length][m2[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;m1.length;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;=m2.length;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;k&amp;lt;m2.length;k++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                res[i][j] += m1[i][k] * m2[k][j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;题目二-不能组成三角形&quot;&gt;&lt;a href=&quot;#题目二-不能组成三角形&quot; class=&quot;headerlink&quot; title=&quot;题目二 不能组成三角形&quot;&gt;&lt;/a&gt;题目二 不能组成三角形&lt;/h2&gt;&lt;p&gt;在迷迷糊糊的大草原上，小红捡到了n根木棍，第i根木棍的长度为i，小红现在很开心。想选出其中的三根木棍组成美丽的三角形。&lt;br&gt;但是小明想捉弄小红，想去掉一些木棍，使得小红任意选三根木棍都不能组成三角形。&lt;br&gt;请问小明最少去掉多少根木棍呢?给定N，返回至少去掉多少根?&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>中级提升班4</title>
    <link href="http://yoursite.com/2023/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD4/"/>
    <id>http://yoursite.com/2023/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD4/</id>
    <published>2023-01-04T14:58:27.000Z</published>
    <updated>2023-01-07T14:19:42.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目一-猫狗队列"><a href="#题目一-猫狗队列" class="headerlink" title="题目一 猫狗队列"></a>题目一 猫狗队列</h2><p>实现一种狗猫队列的结构，要求如下:</p><ul><li>用户可以调用<code>add</code>方法将cat类或dog类的实例放入队列中;</li><li>用户可以调用<code>pollAll</code>方法，将队列中所有的实例按照进队列的先后顺序依次弹出; </li><li>用户可以调用<code>pollDog</code>方法，将队列中dog类的实例按照进队列的先后顺序依次弹出;</li><li>用户可以调用<code>pollCat</code>方法，将队列中cat类的实例按照进队列的先后顺序依次弹出;</li><li>用户可以调用<code>isEmpty</code>方法，检查队列中是否还有dog或cat 的实例;</li><li>用户可以调用<code>isDogEmpty</code>方法，检查队列中是否有dog类的实例;</li><li>用户可以调用<code>isCatEmpty</code>方法，检查队列中是否有cat类的实例。</li></ul><p>要求以上所有方法时间复杂度都是0(1)的</p><h2 id="题目二-最小栈"><a href="#题目二-最小栈" class="headerlink" title="题目二 最小栈"></a>题目二 最小栈</h2><p>实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。<br>要求: </p><ol><li><code>pop</code>、<code>push</code>、<code>getMin</code>操作的时间复杂度都是<code>O(1)</code> ;</li><li>设计的栈类型可以使用现成的栈结构</li></ol><blockquote><p>leetcode155  最小栈</p></blockquote><p>解</p><p>准备2个栈，一个数据栈，一个最小栈；入栈时数据栈直接入，最小栈查看栈顶元素是否比当前数小，小就继续压入最小的数，否则压入当前数。</p><h2 id="题目三-队列和栈"><a href="#题目三-队列和栈" class="headerlink" title="题目三 队列和栈"></a>题目三 队列和栈</h2><h3 id="如何仅用队列结构实现栈结构"><a href="#如何仅用队列结构实现栈结构" class="headerlink" title="如何仅用队列结构实现栈结构?"></a>如何仅用队列结构实现栈结构?</h3><blockquote><p>leetcode 225. 用队列实现栈</p></blockquote><p>使用1个队列</p><p>数据来时进入一个队列，当要返回数据时，将队列出队并入队，到只剩一个元素返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P0302Stack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">P0302Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何仅用栈结构实现队列结构"><a href="#如何仅用栈结构实现队列结构" class="headerlink" title="如何仅用栈结构实现队列结构?"></a>如何仅用栈结构实现队列结构?</h3><blockquote><p>leetcode 232. 用栈实现队列</p></blockquote><p>队列为先进先出，栈为先进后出，使用2个栈，所以一个进栈，一个出栈实现一个队列结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P0301Queue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">P0301Queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        outStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.isEmpty())&#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        convert();</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        convert();</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.empty() &amp;&amp; outStack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目四-动态规划的空间压缩技巧-最小路径和"><a href="#题目四-动态规划的空间压缩技巧-最小路径和" class="headerlink" title="题目四 动态规划的空间压缩技巧 最小路径和"></a>题目四 动态规划的空间压缩技巧 最小路径和</h2><p>给你一个二维数组matrix,其中每个数都是正数，要求从左上角走到右下角。每一步只能向右或者向下，沿途经过的数字要累加起来。最后请返回最小的路径和。</p><blockquote><p>leetcode 64 最小路径和</p></blockquote><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>最小的路径取左边和右边的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">return</span> process(grid, m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不能走</span></span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span> || n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(process(grid, m - <span class="number">1</span>, m), process(grid, m, n - <span class="number">1</span>)) + grid[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>每个位置只与左边和上边的元素有关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum2</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划空间压缩"><a href="#动态规划空间压缩" class="headerlink" title="动态规划空间压缩"></a>动态规划空间压缩</h3><p>对于第一行的数据只依赖于左边的数据</p><p>对于第二行的数据，依赖于它右边的数据和上边的数据，而最右边的数据只依赖于上边的数据。那么可以把二维dp表优化为一维dp表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum3</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + grid[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[j] = dp[j] + grid[i][j];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="压缩思路"><a href="#压缩思路" class="headerlink" title="压缩思路"></a>压缩思路</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c d e</span><br><span class="line">f g h <span class="selector-tag">i</span> j </span><br></pre></td></tr></table></figure><p>h依赖于b,c这么更新，如果一个值依赖于上一行左边的几个值， 用一维数组就需要从右向左更新，因为更新时数组中值还没有发生变化，还是上一行的值。</p><p>如果h依赖于b,c,g，左边的值，左上角的值，上边的值，对于f来说，a-&gt;f没有问题，此时再申请一个变量记住a的值，对于g来说就有了a,b,f的值了，同理h也是。</p><h2 id="题目五-装水的容器"><a href="#题目五-装水的容器" class="headerlink" title="题目五 装水的容器"></a>题目五 装水的容器</h2><p>给定一个数组arr,已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水<br>比如，<code>arr = &#123;3, 1, 2, 5，2, 4&#125;</code>，根据值画出的直方图就是容器形状，该容器可以装下5格水<br>再比如，<code>arr = &#123;4, 5, 1, 3, 2&#125;</code>，该容器可以装下2格水</p><p><strong>解</strong></p><p>容器可以装下几格水，从每个位置看左侧最大值和右侧最大值，较小的一个和当前位置的差值就是当前位置的最大值，对得到的每个位置求最大值就是可以装的几格水。</p><p>如果需要优化时间复杂度，采用双指针的办法，左指针从左边第二个位置开始，右指针从右边第二个开始，左侧最大值小先算左侧，右侧最大值小先算右侧</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10 8 12 5 2 4 11 3 7 </span><br><span class="line"></span><br><span class="line">max左侧为10 max右为7</span><br><span class="line">此时右侧最大值小 求解右侧位置的水 <span class="attribute">7-3</span>=4 右边左移</span><br><span class="line">此时左侧最大值小 求解左侧位置的水 <span class="attribute">10-8</span>=2 值不变 左边右移</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTheMaxOfWater</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> R = arr.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> rightMax = arr[arr.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftMax &lt;= rightMax)&#123;</span><br><span class="line">            water += Math.max(<span class="number">0</span>, leftMax - arr[L]);</span><br><span class="line">            leftMax = Math.max(leftMax, arr[L++]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            water += Math.max(<span class="number">0</span>, rightMax - arr[R]);</span><br><span class="line">            rightMax = Math.max(rightMax, arr[R--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> water;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目六-左右最值最大差"><a href="#题目六-左右最值最大差" class="headerlink" title="题目六 左右最值最大差"></a>题目六 左右最值最大差</h2><p>给定一个数组arr长度为N，你可以把任意长度大于0且小于N的前缀作为左部分，剩下的作为右部分。但是每种划分下都有左部分的最大值和右部分的最大值，请返回最大的，左部分最大值减去右部分最大值的绝对值。</p><p><strong>解</strong></p><p>贪心算法，O(n)先找到整体的max值，然后有2种情况</p><ol><li>max被划分到左部分, 右部分无论这么切，都会包含位置为N-1的数（小于这个位置的数不会统计，大于这个位置的数会降低结果）。<code>max-arr[N-1]</code></li><li>同理max被划分到右部分，左部分无论这么切，都会包含位置为0的数（小于这个位置的数不会统计，大于这个位置的数会降低结果）。<code>max-arr[0]</code></li></ol><p>最后得出的2个数求最大值既是结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftRightMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(Math.abs(max - arr[<span class="number">0</span>]), Math.abs(max - arr[arr.length - <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目七-旋转字符串"><a href="#题目七-旋转字符串" class="headerlink" title="题目七 旋转字符串"></a>题目七 旋转字符串</h2><p>如果一一个字符串为str，把字符串str前面任意的部分挪到后面形成的字符串叫作str的旋转词。比如str=” 12345”，str 的旋转有”12345”、”23451”、”34512”、”45123”和”51234”。 给定两个字符串a和b，请判断a和b是否互为旋转词。<br>比如:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span>=<span class="string">&quot;cdab&quot;</span>，b=<span class="string">&quot;abcd&quot;</span>，返回<span class="literal">true</span>。</span><br><span class="line"><span class="attr">a</span>=<span class="string">&quot;1ab2&quot;</span>，b=<span class="string">&quot;ab12&quot;</span>，返回<span class="literal">false</span>。 </span><br><span class="line"><span class="attr">a</span>=<span class="string">&quot;2ab1&quot;</span>，b=<span class="string">&quot;ab12&quot;</span>，返回<span class="literal">true</span>。</span><br></pre></td></tr></table></figure><p><strong>解</strong></p><p>有以下几个判断标准</p><ol><li>a和b的长度是否一样</li><li>a+a,判断b是否是其子串</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rotateString</span><span class="params">(String s, String goal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != goal.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String doubleS = s + s;</span><br><span class="line">    <span class="keyword">return</span> doubleS.contains(goal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目八-咖啡杯问题"><a href="#题目八-咖啡杯问题" class="headerlink" title="题目八 咖啡杯问题"></a>题目八 咖啡杯问题</h2><p>给定一个数组arr,已知其中所有的值都是非负的，一个数代表一台咖啡机运行时间，有n个人要喝咖啡，每个人只喝一杯，只有一台洗咖啡杯的机器，时间为a，一次一杯，咖啡杯不洗自然干净的时间为b,问n个人从喝咖啡开始，到咖啡杯洗干净需要多少时间。</p><p><strong>解</strong></p><h3 id="贪心-动态规划"><a href="#贪心-动态规划" class="headerlink" title="贪心+动态规划"></a>贪心+动态规划</h3><p>这个问题分为2个部分，首先计算出每个人喝完咖啡的时间，然后根据每个人的结束时间计算洗杯子的时间。</p><ol><li><p>每个人喝咖啡的时间计算，使用贪心算法，总是使用最先结束的，如果同一时间结束的有多个杯子，就使用运行时间最短的一个机器，算出每个人的结束时间。采用最小堆的方式（优先级队列）。</p></li><li><p>得到每个人的结束时间后，每个人是选择机器洗还是自然风干，使用递归的方式，假设洗咖啡杯的机器washline才有空，就从选择等机器和选择自然风干中选择用时最短的即可</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">shortestCoffeeCup</span><span class="params">(<span class="keyword">int</span>[] coffee, <span class="keyword">int</span> n, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最小堆 0位置放置结束时间， 1位置放置机器做咖啡的实际，2者相加最小的就是堆顶</span></span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (o1[<span class="number">0</span>] + o1[<span class="number">1</span>]) - (o2[<span class="number">0</span>] + o2[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coffee.length; i++) &#123;</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, coffee[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个人的终止时间</span></span><br><span class="line">    <span class="keyword">int</span>[] drinks = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] drink = queue.poll();</span><br><span class="line">        drink[<span class="number">0</span>] += drink[<span class="number">1</span>];</span><br><span class="line">        drinks[i] = drink[<span class="number">0</span>];</span><br><span class="line">        queue.add(drink);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归计算最小值</span></span><br><span class="line">    <span class="comment">// return process(drinks, a, b, 0, 0);</span></span><br><span class="line">    <span class="keyword">return</span> getMinTime(drinks, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a洗咖啡杯时间 b自动挥发的实际 washLine洗碗机空闲空闲的时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] drinks, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> index, <span class="keyword">int</span> washLine)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == drinks.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.max(washLine, drinks[index]) + a, drinks[index] + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放咖啡机洗</span></span><br><span class="line">    <span class="keyword">int</span> wash = Math.max(washLine, drinks[index]) + a;</span><br><span class="line">    <span class="comment">// 洗完剩下的咖啡杯最早结束时间</span></span><br><span class="line">    <span class="keyword">int</span> next1 = process(drinks, a, b, index + <span class="number">1</span>, wash);</span><br><span class="line">    <span class="keyword">int</span> p1 = Math.max(wash, next1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动挥发</span></span><br><span class="line">    <span class="keyword">int</span> dry = drinks[index] + b;</span><br><span class="line">    <span class="keyword">int</span> next2 = process(drinks, a, b, index + <span class="number">1</span>, washLine);</span><br><span class="line">    <span class="keyword">int</span> p2 = Math.max(dry, next2);</span><br><span class="line">    <span class="keyword">return</span> Math.min(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index 0 - n-1</span></span><br><span class="line"><span class="comment">// washLine drinks[0] + na drinks[1] +(n-1)a  最大值 或者 最后一个时间点 + na</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinTime</span><span class="params">(<span class="keyword">int</span>[] drinks, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = drinks.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][drinks[n - <span class="number">1</span>] + n * a];</span><br><span class="line">    <span class="comment">// basecase</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        <span class="comment">// i就是washLine</span></span><br><span class="line">        dp[n - <span class="number">1</span>][i] = Math.min(Math.max(i, drinks[n - <span class="number">1</span>]) + a, drinks[n - <span class="number">1</span>] + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = n - <span class="number">2</span>; row &gt;= <span class="number">0</span>; row--) &#123;</span><br><span class="line">        <span class="keyword">int</span> washLine = drinks[row] + (row + <span class="number">1</span>) * a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; washLine; col++) &#123;</span><br><span class="line">            <span class="keyword">int</span> wash = Math.max(col, drinks[row]) + a;</span><br><span class="line">            <span class="comment">// 2种取最优解</span></span><br><span class="line">            dp[row][col] = Math.min(Math.max(wash, dp[row + <span class="number">1</span>][wash]), Math.max(drinks[row] + b, dp[row + <span class="number">1</span>][col]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目一-猫狗队列&quot;&gt;&lt;a href=&quot;#题目一-猫狗队列&quot; class=&quot;headerlink&quot; title=&quot;题目一 猫狗队列&quot;&gt;&lt;/a&gt;题目一 猫狗队列&lt;/h2&gt;&lt;p&gt;实现一种狗猫队列的结构，要求如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户可以调用&lt;code&gt;add&lt;/code&gt;方法将cat类或dog类的实例放入队列中;&lt;/li&gt;
&lt;li&gt;用户可以调用&lt;code&gt;pollAll&lt;/code&gt;方法，将队列中所有的实例按照进队列的先后顺序依次弹出; &lt;/li&gt;
&lt;li&gt;用户可以调用&lt;code&gt;pollDog&lt;/code&gt;方法，将队列中dog类的实例按照进队列的先后顺序依次弹出;&lt;/li&gt;
&lt;li&gt;用户可以调用&lt;code&gt;pollCat&lt;/code&gt;方法，将队列中cat类的实例按照进队列的先后顺序依次弹出;&lt;/li&gt;
&lt;li&gt;用户可以调用&lt;code&gt;isEmpty&lt;/code&gt;方法，检查队列中是否还有dog或cat 的实例;&lt;/li&gt;
&lt;li&gt;用户可以调用&lt;code&gt;isDogEmpty&lt;/code&gt;方法，检查队列中是否有dog类的实例;&lt;/li&gt;
&lt;li&gt;用户可以调用&lt;code&gt;isCatEmpty&lt;/code&gt;方法，检查队列中是否有cat类的实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要求以上所有方法时间复杂度都是0(1)的&lt;/p&gt;
&lt;h2 id=&quot;题目二-最小栈&quot;&gt;&lt;a href=&quot;#题目二-最小栈&quot; class=&quot;headerlink&quot; title=&quot;题目二 最小栈&quot;&gt;&lt;/a&gt;题目二 最小栈&lt;/h2&gt;&lt;p&gt;实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。&lt;br&gt;要求: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;pop&lt;/code&gt;、&lt;code&gt;push&lt;/code&gt;、&lt;code&gt;getMin&lt;/code&gt;操作的时间复杂度都是&lt;code&gt;O(1)&lt;/code&gt; ;&lt;/li&gt;
&lt;li&gt;设计的栈类型可以使用现成的栈结构&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;leetcode155  最小栈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解&lt;/p&gt;
&lt;p&gt;准备2个栈，一个数据栈，一个最小栈；入栈时数据栈直接入，最小栈查看栈顶元素是否比当前数小，小就继续压入最小的数，否则压入当前数。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>中级提升班3</title>
    <link href="http://yoursite.com/2023/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD3/"/>
    <id>http://yoursite.com/2023/01/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD3/</id>
    <published>2023-01-02T10:46:44.000Z</published>
    <updated>2023-01-04T15:00:41.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目一-洗衣机问题"><a href="#题目一-洗衣机问题" class="headerlink" title="题目一 洗衣机问题"></a>题目一 洗衣机问题</h2><p>有n个打包机器从左到右一字排开，上方有一个 自动装置会抓取一批放物品到每个打包机上，放到每个机器上的这些物品数量有多有少，由于物品数量不相同，需要工人将每个机器上的物品进行移动从而到达物品数量相等才能打包。每个物品重量太大、每次只能搬一个物品进行移动，为了省力，只在相邻的机器上移动。请计算在搬动最小轮数的前提下，使每个机器上的物品数量相等。如果不能使每个机器上的物品相同,<br>返回-1。<br>例如[1, 0, 5]表示有3个机器，每个机器上分别有1、0、5个物品，经过这些轮后:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一轮:1  <span class="number"> 0 </span>&lt;-<span class="number"> 5 </span>=&gt;<span class="number"> 1 </span>1 4</span><br><span class="line">第二轮:1 &lt;-1 &lt;-<span class="number"> 4 </span>=&gt;<span class="number"> 2 </span>1 3</span><br><span class="line">第三轮:2  <span class="number"> 1 </span>&lt;-<span class="number"> 3 </span>=&gt;<span class="number"> 2 </span>2 2</span><br></pre></td></tr></table></figure><p>移动了3轮，每个机器上的物品相等，所以返回3<br>例如[2, 2, 3]表示有3个机器，每个机器上分别有2、2、3个物品，<br>这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回-1</p><blockquote><p>leetcode517  超级洗衣机</p></blockquote><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>衣服和机器必须正好均分<code>sum%n==0</code>才能移动，将机器以机器i分开，为此时有以下几种情况：</p><ol><li>i的左侧缺少A件，i的右侧缺少B件，对于i来说它至少需要移动<code>A+B</code>轮；</li><li>i的左侧多余A件，i的右侧多余B件，对于i来说至少需要移动<code>max(A,B)</code>；</li><li>i的左侧缺少A件，i的右侧多余B件，对于i来说至少需要移动<code>max(A,B)</code>，因为必须要把最大的移动完才可以</li></ol><p>将每个位置的移动情况都求出，其中最大的就是整体最少的移动次数。这是个瓶颈问题，只有解决最大位置才是整体解决的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minOps</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sum % size != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> avg = sum / size;</span><br><span class="line">    <span class="keyword">int</span> leftSum = <span class="number">0</span>; <span class="comment">// 左侧部分</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 负需要输入 正需要输出</span></span><br><span class="line">        <span class="keyword">int</span> leftRest = leftSum - i * avg;  <span class="comment">// 左侧部分 - 平均值</span></span><br><span class="line">        <span class="comment">// 负需要输入 正需要输出</span></span><br><span class="line">        <span class="comment">// 右侧部分 - 平均值</span></span><br><span class="line">        <span class="keyword">int</span> rightRest = (sum - leftSum - arr[i]) - (size - i - <span class="number">1</span>) * avg;</span><br><span class="line">        <span class="keyword">int</span> need = <span class="number">0</span>; <span class="comment">// i位置需要的移动次数</span></span><br><span class="line">        <span class="keyword">if</span> (leftRest &lt; <span class="number">0</span> &amp;&amp; rightRest &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            need = Math.abs(leftRest) + Math.abs(rightRest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            need = Math.max(Math.abs(leftRest), Math.abs(rightRest));</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, need);</span><br><span class="line">        leftSum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二-zigzag打印矩阵"><a href="#题目二-zigzag打印矩阵" class="headerlink" title="题目二 zigzag打印矩阵"></a>题目二 zigzag打印矩阵</h2><p>用zigzag的方式打印矩阵，比如如下的矩阵</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span></span><br><span class="line"><span class="attribute">4</span><span class="number">5</span><span class="number">6</span><span class="number">7</span></span><br><span class="line"><span class="attribute">8</span><span class="number">9</span><span class="number">10</span><span class="number">11</span></span><br></pre></td></tr></table></figure><p>打印顺序为:0 1 4 8 5 2 3 6 9 10 7 11</p><blockquote><p>leetcode 498 对角线遍历</p></blockquote><p><strong>解</strong></p><p>这类题目是有技巧的，首先看打印的原理，类似于2个点之间的数据打印，所以取a,b两点，a点的行动轨迹从左到右，到边界后向下，b点的行动轨迹从上到下，到边界后向右走。</p><p>a和b的行动轨迹确定后，打印ab之间的数据，从a-&gt;b的轨迹为a的点纵轴+1，横轴-1,从b-&gt;a的轨迹为横轴+1，纵轴-1。<strong>每找到新的ab点就交换ab的打印顺序数据。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findDiagonalOrder(<span class="keyword">int</span>[][] mat) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> aRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> aCol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bCol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> endR = mat.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endC = mat[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// true向上遍历</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (aRow != endR + <span class="number">1</span>) &#123;</span><br><span class="line">        print(mat, aRow, aCol, bRow, bCol, flag, list);</span><br><span class="line">        <span class="comment">// a 是先向左，再向下 分界点是endC 左上角</span></span><br><span class="line">        aRow = aCol == endC ? aRow + <span class="number">1</span> : aRow;</span><br><span class="line">        aCol = aCol == endC ? aCol : aCol + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// b 是先向下，再向左 分界点是endR 右上角</span></span><br><span class="line">        bCol = bRow == endR ? bCol + <span class="number">1</span> : bCol;</span><br><span class="line">        bRow = bRow == endR ? bRow : bRow + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = !flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[mat.length * mat[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        ret[i] = list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> aRow, <span class="keyword">int</span> aCol, <span class="keyword">int</span> bRow, <span class="keyword">int</span> bCol, <span class="keyword">boolean</span> flag, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">// 从 a向b移动</span></span><br><span class="line">        <span class="keyword">while</span> (aRow != bRow + <span class="number">1</span>) &#123;</span><br><span class="line">            list.add(m[aRow++][aCol--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从 b向a移动</span></span><br><span class="line">        <span class="keyword">while</span> (bCol != aCol + <span class="number">1</span>) &#123;</span><br><span class="line">            list.add(m[bRow--][bCol++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三-螺旋打印矩阵"><a href="#题目三-螺旋打印矩阵" class="headerlink" title="题目三 螺旋打印矩阵"></a>题目三 螺旋打印矩阵</h2><p>用螺旋的方式打印矩阵，比如如下的矩阵</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span></span><br><span class="line"><span class="attribute">4</span><span class="number">5</span><span class="number">6</span><span class="number">7</span></span><br><span class="line"><span class="attribute">8</span><span class="number">9</span><span class="number">10</span><span class="number">11</span></span><br></pre></td></tr></table></figure><p>打印顺序为:01237 11 10 98456</p><blockquote><p>leetcode 54 螺旋矩阵</p></blockquote><p><strong>解法</strong></p><p>螺旋打印，从整体上分析，就是一圈一圈的打印，所以获取每一圈的左上角和右下角，然后打印这个圈，然后2个点收缩，有以下三种情况</p><ol><li>点和点刚好构成一个圈，循环打印</li><li>点和点在横线，打印横线</li><li>点和点在竖线，竖着打印</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> tR = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tC = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dR = matrix.length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dC = matrix[<span class="number">0</span>].length -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tR &lt;= dR &amp;&amp; tC &lt;= dC)&#123;</span><br><span class="line">        printEdge(matrix, tR++, tC++, dR--, dC--, list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == c) &#123; <span class="comment">//一条横线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt;= d; i++) &#123;</span><br><span class="line">            list.add(m[a][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == d) &#123; <span class="comment">// 一条竖线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt;= c; i++) &#123;</span><br><span class="line">            list.add(m[i][b]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> curC = b;</span><br><span class="line">        <span class="keyword">int</span> curR = a;</span><br><span class="line">        <span class="keyword">while</span> (curC != d) &#123;</span><br><span class="line">            list.add(m[a][curC]);</span><br><span class="line">            curC++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curR != c) &#123;</span><br><span class="line">            list.add(m[curR][d]);</span><br><span class="line">            curR++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curC != b) &#123;</span><br><span class="line">            list.add(m[c][curC]);</span><br><span class="line">            curC--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curR != a) &#123;</span><br><span class="line">            list.add(m[curR][b]);</span><br><span class="line">            curR--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目四-旋转矩阵"><a href="#题目四-旋转矩阵" class="headerlink" title="题目四 旋转矩阵"></a>题目四 旋转矩阵</h2><p>给定一个正方形矩阵，只用有限几个变量，实现矩阵中每个位置的数顺时针转动90度，比如如下的矩阵</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span><span class="number">1</span><span class="number">2</span><span class="number">3</span></span><br><span class="line"><span class="attribute">4</span><span class="number">5</span><span class="number">6</span><span class="number">7</span></span><br><span class="line"><span class="attribute">8</span><span class="number">9</span><span class="number">10</span><span class="number">11</span></span><br><span class="line"><span class="attribute">12</span><span class="number">13</span> <span class="number">14</span> <span class="number">15</span></span><br></pre></td></tr></table></figure><p>矩阵调整为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">12</span><span class="number">8</span><span class="number">4</span><span class="number">0</span></span><br><span class="line"><span class="attribute">13</span><span class="number">9</span><span class="number">5</span><span class="number">1</span></span><br><span class="line"><span class="attribute">14</span><span class="number">10</span><span class="number">6</span><span class="number">2</span></span><br><span class="line"><span class="attribute">15</span><span class="number">11</span><span class="number">7</span><span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>leetcode 48 旋转图像</p></blockquote><p><strong>解</strong></p><p>从整体上分析，就是一圈一圈的转换，所以获取每一圈的左上角和右下角，然后转换这个圈，然后2个点收缩，在转换。</p><p>每一圈自己怎么转换?</p><p>坐上角点(a,b),右下角点(c,d)，每条边上的点的数量较少转换的轮数，一共有d-b+1轮转换，每轮转换4个点</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m<span class="selector-attr">[a]</span><span class="selector-attr">[b+i]</span></span><br><span class="line">m<span class="selector-attr">[a+i]</span><span class="selector-attr">[d]</span></span><br><span class="line">m<span class="selector-attr">[c]</span><span class="selector-attr">[d-i]</span></span><br><span class="line">m<span class="selector-attr">[c-i]</span><span class="selector-attr">[b]</span></span><br></pre></td></tr></table></figure><p>逆序直到一圈换完</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aRow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> aCol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bRow = matrix.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> bCol = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (aRow &lt;= bRow)&#123;</span><br><span class="line">        rotateEdge(matrix, aRow, aCol, bRow, bCol);</span><br><span class="line">        aRow++;</span><br><span class="line">        aCol++;</span><br><span class="line">        bRow--;</span><br><span class="line">        bCol--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateEdge</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> aRow, <span class="keyword">int</span> aCol, <span class="keyword">int</span> bRow, <span class="keyword">int</span> bCol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; bCol - aCol; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp =  m[aRow][aCol+i];</span><br><span class="line">        m[aRow][aCol+i] = m[bRow-i][aCol];</span><br><span class="line">        m[bRow-i][aCol] = m[bRow][bCol-i];</span><br><span class="line">        m[bRow][bCol-i] = m[aRow+i][bCol];</span><br><span class="line">        m[aRow+i][bCol] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目五-搜索二维矩阵"><a href="#题目五-搜索二维矩阵" class="headerlink" title="题目五 搜索二维矩阵"></a>题目五 搜索二维矩阵</h2><p>给定一个元素为非负整数的二维数组matrix,每行和每列都是从小到大有序的。再给定一个非负整数aim,请判断aim是否在matrix中。</p><blockquote><p>leetcode240 搜索二维矩阵 II</p></blockquote><p><strong>解</strong></p><p>从右上角开始找，这个值大于就向下找，小于就向左找，最多找O(M+N)的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从矩阵右上角找</span></span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (col &gt;= <span class="number">0</span> &amp;&amp; row &lt;= matrix.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[row][col] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &lt; target) &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型变化</p><p>一个矩阵，里面的数字不是0就是1，0永远在1的左边，求1最多的行。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000000111</span></span><br><span class="line"><span class="number">000011111</span></span><br><span class="line"><span class="number">000011111</span></span><br><span class="line"><span class="number">000000111</span></span><br></pre></td></tr></table></figure><p><strong>解</strong></p><p>从第一行开始，准备2个变量,list保存行数，ans保存最大值；获取到第一个1开始的坐标，查看该坐标下一行的该位置是否为1，并看坐标是否可以左移，能够左移，就更新list和ans，否则继续下一行。</p><h2 id="题目六-SM操作"><a href="#题目六-SM操作" class="headerlink" title="题目六 SM操作"></a>题目六 SM操作</h2><p>假设s和m初始化，s=”a”;m=s;<br>再定义两种操作，第一种操作:<br><code>m = s;</code><br><code>s= s+s;</code><br>第二种操作:<br><code>s = s+m;</code><br>求最小的操作步骤数，可以将s拼接到长度等于n</p><p><strong>解</strong></p><ol><li>如果是<strong>质数只调用操作2</strong>，因为如果调用了操作1，加入s为k个a，那没最后m也会为k个a，是以k为因子的数，必然不可能组成质数。<code>N-1</code>次</li><li>n不是质数，n由某些质数因子构成n=<code>a*b*c*d</code>,<code>a*b*c</code>构成了那么d就一定是通过操作构成的d-1次，a*b构成了那么c就需要通过c-1构成，最后a+b+c+d-4，质数因子的和-质数因子的个数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minOps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isPrim(n)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n不是质数</span></span><br><span class="line">    <span class="keyword">int</span>[] divSumAndCount = divSumAndCount(n);</span><br><span class="line">    <span class="keyword">return</span> divSumAndCount[<span class="number">0</span>] - divSumAndCount[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">6</span> != <span class="number">1</span> &amp;&amp; n % <span class="number">6</span> != <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span> || n % (i + <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] divSumAndCount(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            count++;</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sum, count&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目七-字符串数组出现最大的前k个"><a href="#题目七-字符串数组出现最大的前k个" class="headerlink" title="题目七 字符串数组出现最大的前k个"></a>题目七 字符串数组出现最大的前k个</h2><p>给定一个字符串类型的数组arr，求其中出现次数最多的前K个.</p><blockquote><p>leetcode347 前 K 个高频元素</p><p>leetcode692 前K个高频单词</p></blockquote><p>解</p><p>解法一： 先用map统计词频，然后使用大根堆排序，弹出k个就是结果</p><p>解法二：小根堆（最小的弹出），容量为k，保存目前为止出现次数最大的前2个，节省空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过建立词频表，放在大根堆，根据出现次数排列的大根堆</span></span><br><span class="line"><span class="keyword">public</span> String[] preKOfMaxTimes1(String[] arr,<span class="keyword">int</span> K)&#123;</span><br><span class="line">    HashMap&lt;String,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hashMap.containsKey(s))&#123;</span><br><span class="line">            hashMap.put(s,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap.put(s,hashMap.get(s) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据词出现的个数建立对应的大根堆</span></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;String,Integer&gt;&gt; priorityQueue</span><br><span class="line">            = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2.getValue() - o1.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//存入大根堆</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">        priorityQueue.add(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出前K个</span></span><br><span class="line">    String[] str = <span class="keyword">new</span> String[K];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; K;i++)&#123;</span><br><span class="line">        String key = priorityQueue.poll().getKey();</span><br><span class="line">        str[i] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以建立只具有K个容量的小根堆，这样存放词频表，能进入门槛的放入(多了就开始删门槛放入)</span></span><br><span class="line"><span class="keyword">public</span> String[] preKOfMaxTimes2(String[] arr,<span class="keyword">int</span> K)&#123;</span><br><span class="line">    HashMap&lt;String,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String s : arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hashMap.containsKey(s))&#123;</span><br><span class="line">            hashMap.put(s,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap.put(s,hashMap.get(s) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建立小根堆</span></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;String,Integer&gt;&gt; priorityQueue</span><br><span class="line">            = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; o1, Map.Entry&lt;String, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getValue() - o2.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(priorityQueue.size() &lt;= <span class="number">7</span>)&#123;</span><br><span class="line">            priorityQueue.add(entry);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (priorityQueue.size() &gt; K</span><br><span class="line">                &amp;&amp; priorityQueue.peek().getValue() &lt; entry.getValue())&#123; <span class="comment">//小根堆顶部词数小于后序添加的</span></span><br><span class="line">            priorityQueue.poll();</span><br><span class="line">            priorityQueue.add(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出前K个</span></span><br><span class="line">    String[] str = <span class="keyword">new</span> String[K];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; K;i++)&#123;</span><br><span class="line">        String key = priorityQueue.poll().getKey();</span><br><span class="line">        str[i] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难度提示 已经上堆的数据，<strong>再局部调整</strong>， 需要新增加一个数据结构</p><p>准备3个数据结构,实现排行榜</p><ol><li><p>词频表（key字符串，value频率）</p></li><li><p>堆[初始k长度] </p></li><li><p>堆位置map (key字符串，value堆位置)</p></li></ol><p><strong>实时显示前K个，需要自己创建堆结构</strong>（类似于排行榜）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆上放的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String str;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> times;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        str = s;</span><br><span class="line">        times = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TopKRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heapSize;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, Node&gt; strNodeMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; nodeIndexMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopKRecord</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        heap = <span class="keyword">new</span> Node[size];</span><br><span class="line">        heapSize = <span class="number">0</span>;</span><br><span class="line">        strNodeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        nodeIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Node curNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> preIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 是不是新节点</span></span><br><span class="line">        <span class="keyword">if</span> (!strNodeMap.containsKey(str)) &#123;</span><br><span class="line">            curNode = <span class="keyword">new</span> Node(str, <span class="number">1</span>);</span><br><span class="line">            strNodeMap.put(str, curNode);</span><br><span class="line">            nodeIndexMap.put(curNode, preIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curNode = strNodeMap.get(str);</span><br><span class="line">            curNode.times++;</span><br><span class="line">            preIndex = nodeIndexMap.get(curNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不在堆上</span></span><br><span class="line">        <span class="keyword">if</span> (preIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heapSize == heap.length) &#123; <span class="comment">//堆满了</span></span><br><span class="line">                <span class="keyword">if</span> (heap[<span class="number">0</span>].times &lt; curNode.times) &#123; <span class="comment">// 大于门槛</span></span><br><span class="line">                    nodeIndexMap.put(heap[<span class="number">0</span>], -<span class="number">1</span>);</span><br><span class="line">                    nodeIndexMap.put(curNode, <span class="number">0</span>);</span><br><span class="line">                    heap[<span class="number">0</span>] = curNode;</span><br><span class="line">                    <span class="comment">// 调整堆</span></span><br><span class="line">                    heapify(<span class="number">0</span>, heapSize);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 堆没满</span></span><br><span class="line">                nodeIndexMap.put(curNode, heapSize);</span><br><span class="line">                heap[heapSize] = curNode;</span><br><span class="line">                <span class="comment">// 新增元素</span></span><br><span class="line">                heapInsert(heapSize++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调整堆</span></span><br><span class="line">            heapify(<span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != heap.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Str:&quot;</span> + heap[i].str + <span class="string">&quot; Times:&quot;</span> + heap[i].times);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parent = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (heap[index].times &lt; heap[parent].times) &#123;</span><br><span class="line">                swap(parent, index);</span><br><span class="line">                index = parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        nodeIndexMap.put(heap[index1], index2);</span><br><span class="line">        nodeIndexMap.put(heap[index2], index1);</span><br><span class="line">        Node tmp = heap[index1];</span><br><span class="line">        heap[index1] = heap[index2];</span><br><span class="line">        heap[index2] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> smallest = index;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; heapSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heap[i].times &lt; heap[index].times) &#123;</span><br><span class="line">                smallest = l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 操作右节点</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; heap[r].times &lt; heap[smallest].times) &#123;</span><br><span class="line">                smallest = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最小值不是index,调整堆</span></span><br><span class="line">            <span class="keyword">if</span> (smallest != index) &#123;</span><br><span class="line">                swap(smallest, index);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index = smallest;</span><br><span class="line">            l = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            r = index * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目一-洗衣机问题&quot;&gt;&lt;a href=&quot;#题目一-洗衣机问题&quot; class=&quot;headerlink&quot; title=&quot;题目一 洗衣机问题&quot;&gt;&lt;/a&gt;题目一 洗衣机问题&lt;/h2&gt;&lt;p&gt;有n个打包机器从左到右一字排开，上方有一个 自动装置会抓取一批放物品到每个打包机上，放到每个机器上的这些物品数量有多有少，由于物品数量不相同，需要工人将每个机器上的物品进行移动从而到达物品数量相等才能打包。每个物品重量太大、每次只能搬一个物品进行移动，为了省力，只在相邻的机器上移动。请计算在搬动最小轮数的前提下，使每个机器上的物品数量相等。如果不能使每个机器上的物品相同,&lt;br&gt;返回-1。&lt;br&gt;例如[1, 0, 5]表示有3个机器，每个机器上分别有1、0、5个物品，经过这些轮后:&lt;/p&gt;
&lt;figure class=&quot;highlight tap&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;第一轮:1  &lt;span class=&quot;number&quot;&gt; 0 &lt;/span&gt;&amp;lt;-&lt;span class=&quot;number&quot;&gt; 5 &lt;/span&gt;=&amp;gt;&lt;span class=&quot;number&quot;&gt; 1 &lt;/span&gt;1 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二轮:1 &amp;lt;-1 &amp;lt;-&lt;span class=&quot;number&quot;&gt; 4 &lt;/span&gt;=&amp;gt;&lt;span class=&quot;number&quot;&gt; 2 &lt;/span&gt;1 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第三轮:2  &lt;span class=&quot;number&quot;&gt; 1 &lt;/span&gt;&amp;lt;-&lt;span class=&quot;number&quot;&gt; 3 &lt;/span&gt;=&amp;gt;&lt;span class=&quot;number&quot;&gt; 2 &lt;/span&gt;2 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;移动了3轮，每个机器上的物品相等，所以返回3&lt;br&gt;例如[2, 2, 3]表示有3个机器，每个机器上分别有2、2、3个物品，&lt;br&gt;这些物品不管怎么移动，都不能使三个机器上物品数量相等，返回-1&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;leetcode517  超级洗衣机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;贪心&quot;&gt;&lt;a href=&quot;#贪心&quot; class=&quot;headerlink&quot; title=&quot;贪心&quot;&gt;&lt;/a&gt;贪心&lt;/h3&gt;&lt;p&gt;衣服和机器必须正好均分&lt;code&gt;sum%n==0&lt;/code&gt;才能移动，将机器以机器i分开，为此时有以下几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;i的左侧缺少A件，i的右侧缺少B件，对于i来说它至少需要移动&lt;code&gt;A+B&lt;/code&gt;轮；&lt;/li&gt;
&lt;li&gt;i的左侧多余A件，i的右侧多余B件，对于i来说至少需要移动&lt;code&gt;max(A,B)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;i的左侧缺少A件，i的右侧多余B件，对于i来说至少需要移动&lt;code&gt;max(A,B)&lt;/code&gt;，因为必须要把最大的移动完才可以&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将每个位置的移动情况都求出，其中最大的就是整体最少的移动次数。这是个瓶颈问题，只有解决最大位置才是整体解决的情况。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;minOps&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arr == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || arr.length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; size = arr.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num : arr) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sum += num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sum % size != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; avg = sum / size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; leftSum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 左侧部分&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ans = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; size; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 负需要输入 正需要输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; leftRest = leftSum - i * avg;  &lt;span class=&quot;comment&quot;&gt;// 左侧部分 - 平均值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 负需要输入 正需要输出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 右侧部分 - 平均值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rightRest = (sum - leftSum - arr[i]) - (size - i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) * avg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; need = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// i位置需要的移动次数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (leftRest &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; rightRest &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            need = Math.abs(leftRest) + Math.abs(rightRest);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            need = Math.max(Math.abs(leftRest), Math.abs(rightRest));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ans = Math.max(ans, need);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        leftSum += arr[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>中级提升班2</title>
    <link href="http://yoursite.com/2023/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD2/"/>
    <id>http://yoursite.com/2023/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD2/</id>
    <published>2023-01-01T05:02:55.000Z</published>
    <updated>2023-01-02T10:47:36.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目一-差值为k的去重数字对"><a href="#题目一-差值为k的去重数字对" class="headerlink" title="题目一 差值为k的去重数字对"></a>题目一 差值为k的去重数字对</h2><p>给定一一个数组arr,，求差值为k的去重数字对。</p><p>给一个数组3,2,5,7,0,0 差值为2的有(0,2),(3,5),(5,7)</p><blockquote><p>(<code>leetcode532</code> 数组中的 k-diff 数对)</p></blockquote><p>解</p><p>使用hash表将数据放入，遍历hash表，找到当前数+k的数是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findPairs(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer num : set)&#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(num + k))&#123;</span><br><span class="line">            res.add(Arrays.asList(num, num + k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode532的解法还需要处理k=0的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPairs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">        map.put(num, map.get(num) != <span class="keyword">null</span> ? map.get(num) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer num : map.keySet())&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(num + k))&#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; map.get(num) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目二-magic操作"><a href="#题目二-magic操作" class="headerlink" title="题目二 magic操作"></a>题目二 magic操作</h2><p>给一个包含n个整数元素的集合a，一个包含m个整数元素的集合b。</p><p>定义magic操作为，从一个集合中取出一个元素，放到另一个集合里，且操作过后每个集合的平均值都大于操作前。</p><p>注意以下两点:</p><ol><li><p>不可以把一个集合的元素取空，这样就没有平均值了</p></li><li><p>值为x的元素从集合b取出放入集合a，但集合a中已经有值为x的元素，则a的平均值不变(因为集合元素不会重复)，b的平均值可能会改变( 因为x被取出了)</p></li></ol><p>问最多可以进行多少次magic操作?</p><p><strong>解</strong></p><p>2个集合的平均值的这几种情况</p><ol><li><p>平均值一样都为n，</p><ol><li><p><code>&lt;n</code>的数，a平均值会上升，b平均值会下降;</p></li><li><p><code>=n</code>的数，a平均值和b平均值不变；</p></li><li><p><code>&gt;n</code>的数，a平均值会下降，b平均值会上升；</p><p>总结相等是不能进行magic操作。</p></li></ol></li><li><p>平均值不一样分别为A，B ,A&lt;B</p><ol><li><p>从小集合a向大集合b放</p><ol><li><code>&lt;A</code>的，a平均值上升，b平均值下降；</li><li><code>=A</code>的，a平均值不变，b平均值下降；</li><li><code>&gt;A</code>的，a平均值下降；</li></ol><p>不能进行magic操作。</p></li><li><p>从小集合b向大集合a放</p><ol><li><code>&lt;B || &gt;A</code>的,两个平均值上升；</li><li><code>=B</code>, b的平均值不变；</li><li><code>&gt;B</code> ,b平均值下降；</li></ol><p>只能放置b集合中<code>&lt;B || &gt;A</code>的数</p></li></ol></li></ol><p>根据分析，只能从集合b中找到<code>&lt;B || &gt;A</code>的数放入到集合a中，并且是在集合a中不存在的数。</p><p>那么进行多少次magic操作，就要按照一定的顺序进行放置，只能找到b集合中复合条件的数，将其按从小到大排列，依次放入a集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr1无重复值，arr2无重复值，arr1和arr2肯定有数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxOps</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr1)&#123;</span><br><span class="line">        sum1 +=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> sum2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr2)&#123;</span><br><span class="line">        sum2 +=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> avg1 = avg(sum1, arr1.length);</span><br><span class="line">    <span class="keyword">double</span> avg2 = avg(sum2, arr2.length);</span><br><span class="line">    <span class="keyword">if</span> ( avg1==avg2 )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 平均值不想动</span></span><br><span class="line">    <span class="keyword">int</span>[] arrMore = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span>[] arrLess = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">double</span> sumMore =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> sumLess =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (avg1 &gt; avg2)&#123;</span><br><span class="line">        arrMore = arr1;</span><br><span class="line">        sumMore = sum1;</span><br><span class="line">        arrLess = arr2;</span><br><span class="line">        sumLess = sum2;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        arrMore = arr2;</span><br><span class="line">        sumMore = sum2;</span><br><span class="line">        arrLess = arr1;</span><br><span class="line">        sumLess = sum1;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(arrMore);</span><br><span class="line">    HashSet&lt;Integer&gt; setLess = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 判断是否存在的set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num:arrLess)&#123;</span><br><span class="line">        setLess.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录个数</span></span><br><span class="line">    <span class="keyword">int</span> moreSize = arrMore.length;</span><br><span class="line">    <span class="keyword">int</span> lessSize = arrLess.length;</span><br><span class="line">    <span class="keyword">int</span> ops = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrMore.length; i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> cur = (<span class="keyword">double</span>) arrMore[i];</span><br><span class="line">        <span class="keyword">if</span> (cur &lt; avg(sumMore, moreSize) &amp;&amp; cur &gt;avg(sumLess, lessSize) &amp;&amp; !setLess.contains(arrMore[i]))&#123;</span><br><span class="line">            sumMore -=cur;</span><br><span class="line">            moreSize --;</span><br><span class="line">            sumLess += cur;</span><br><span class="line">            lessSize ++;</span><br><span class="line">            setLess.add(arrMore[i]);</span><br><span class="line">            ops++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ops;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">avg</span><span class="params">(<span class="keyword">double</span> sum, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum / (<span class="keyword">double</span>) (size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三-字符串转化"><a href="#题目三-字符串转化" class="headerlink" title="题目三 字符串转化"></a>题目三 字符串转化</h2><p>将给定的数转换为字符串，原则如下: 1对应a,2对应b，…26对应z，例如12258可以转换为”abbeh”，”aveh”，”abyh”， “Ibeh” and “Iyh”， 个数为5，编写一个函数，给出可以转换的不同字符串的个数。</p><blockquote><p>（<code>leetcode91</code>解码方法）</p></blockquote><p>解法</p><p>这是一个依次获取结果的动态规划问题，有一下几种情况</p><ol><li><code>[i] == &#39;0&#39;</code>,这种情况没有办法进行转换 <code>dp[i] = 0</code></li><li><code>[i] == 1</code>, 这种情况有可能是2位数也有可能是2位数 <code>dp[i] = dp[i+1] + dp[i+2]</code></li><li><code>[i] == 2</code>,这种情况一定有<code>dp[i+1]</code>,有没有<code>dp[i+2]</code>需要判断<code>[i+1]&lt;=6</code></li><li><code>[i]</code>为其他值<code>dp[i] = dp[i+1]</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">decodeStr</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[n] = <span class="number">1</span>;</span><br><span class="line">    dp[n - <span class="number">1</span>] = s.charAt(n - <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            dp[i] = dp[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ((s.charAt(i) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s.charAt(i + <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span> &lt; <span class="number">27</span>) &#123;</span><br><span class="line">                dp[i] += dp[i + <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目四-合法的括号匹配序列"><a href="#题目四-合法的括号匹配序列" class="headerlink" title="题目四 合法的括号匹配序列"></a>题目四 合法的括号匹配序列</h2><p>一个合法的括号匹配序列有以下定义:</p><ol><li>空串<code>&quot;&quot;</code>是一个合法的括号匹配序列</li><li>如果<code>&quot;X&quot;</code>和<code>&quot;Y&quot;</code>都是合法的括号匹配序列, “XY”也是一个合法的括号匹配序列</li><li>如果”X”是一个合法的括号匹配序列，那么”(X)”也是一个合法的括号匹配序列</li><li>每个合法的括号序列都可以由以上规则生成。</li></ol><p>例如: <code>&quot;&quot;</code>, <code>&quot;()&quot;</code>,<code>&quot;() ()&quot;</code>, <code>&quot;((()))&quot;</code>都是合法的括号序列</p><p>对于一个合法的括号序列我们又有以下定义它的深度:</p><ol><li>空串””的深度是0</li><li>如果字符串”X”的深度是x,字符串”Y”的深度是y,那么字符串”XY”的深度为max(x,y) </li><li>如果”X” 的深度是x,那么字符串” (X) “的深度是x+1</li></ol><p>例如: “<code>() () ()</code>“的深度是1, “<code>((()))</code>“的深度是3。牛牛现在给你一个合法的括号序列,需要你计算出其深度。</p><blockquote><p><code>leetcode1614</code> 括号的最大嵌套深度</p></blockquote><p><strong>解</strong></p><p>定义一个变量count的，遍历字符串，遇到左括号count++,遇到右括号count–,count达到的最大值就是其最大深度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chr = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxCount =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (chr[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            maxCount = Math.max(maxCount, count);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (chr[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="要求得到最长的有效子串-动态规划"><a href="#要求得到最长的有效子串-动态规划" class="headerlink" title="要求得到最长的有效子串 动态规划"></a>要求得到<strong>最长的有效子串</strong> 动态规划</h3><p>题目与上一道类似，只是要求得到<strong>最长的有效子串</strong>动态规划</p><blockquote><p>leetcode32 最长有效括号</p></blockquote><p><strong>解法</strong></p><p>dp[i]表示子串必须以i位置结尾，最长的有效子串是多大</p><p>求整个字符串的有效括号，就求一每个位置i为结尾，求当前最长的有效长度，有以下情况：</p><ol><li><code>i=&#39;(&#39;</code>, <code>dp[i]=0</code>,因为以(结尾，必不可能是有效的</li><li><code>i=&#39;)&#39;</code>,这是需要获取<code>dp[i-1]</code>位置上最长有效距离，并且获取这一段前的字符记为P是否为(如果是<code>dp[i-1]+2</code>,并且获取<code>dp[P-1]</code>位置上的最长有效距离，因为中间断开了，前面可能还有一段距离，并且不需要继续向前获取，因为在dp[P-1]位置上已经向前获取过了。</li></ol><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(()</span><span class="comment">()</span>)<span class="comment">()</span><span class="comment">()</span></span><br><span class="line"><span class="number">0123456789</span></span><br><span class="line"><span class="number">002046080</span></span><br><span class="line">求最后一位时前面是<span class="comment">( 所有+2，并且+8 因为前面这一位已经把前面最大的计算过了 </span></span><br></pre></td></tr></table></figure><h2 id="题目五-对栈里面数据进行排序"><a href="#题目五-对栈里面数据进行排序" class="headerlink" title="题目五 对栈里面数据进行排序"></a>题目五 对栈里面数据进行排序</h2><p>请编写一个程序，对一个栈里的整型数据，按升序进行排序( 即排序前，栈里的数据是无序的，排序后最大元素位于栈顶)，要求最多只能使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。</p><p>解</p><p>使用另外的一个栈，在这个栈中让数据保持从小到大，栈顶为最小，从数据栈中弹出一个元素，如果比排序栈中栈顶元素小直接放入，否则排序栈一直弹出元素到数据栈中，知道可以把数据放入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;Integer&gt; <span class="title">sortStack</span><span class="params">(Stack&lt;Integer&gt; stack)</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; helpStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        Integer pop = stack.pop();</span><br><span class="line">        <span class="keyword">while</span> (!helpStack.isEmpty() &amp;&amp; pop &lt; helpStack.peek())&#123;</span><br><span class="line">            stack.push(helpStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        helpStack.push(pop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helpStack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目六-涂色的最少方案"><a href="#题目六-涂色的最少方案" class="headerlink" title="题目六 涂色的最少方案"></a>题目六 涂色的最少方案</h2><p>牛牛有一些排成一行的正方形。每个正方形已经被染成红色或者绿色。牛牛现在可以选择任意一个正方形然后用这两种颜色的任意一种进行染色,这个正方形的颜色将会被覆盖。牛牛的目标是在完成染色之后，<strong>每个红色R都比每个绿色G距离最左侧近</strong>。牛牛想知道他最少需要涂染几个正方形。<br>如样例所示: s = RGRGR<br>我们涂染之后变成RRRGG满足要求了，涂染的个数为2,没有比这个更好的涂染方案。</p><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>从左向右遍历数组，L范围[0，N]。 L左侧全变为R，L右侧全变为G</p><ol><li>L == 0 ，统计<code>[0，N-1]</code>上一共有多少个R全部染成G。</li><li>L == N，统计<code>[0，N-1]</code>上一共有多少个G全部染成R。</li><li>统计<code>arr[0,L]</code>有多少个G，全部染成R + 统计<code>arr[L+1,N-1]</code>有多少个G，全部染成R</li></ol><p>3个情况下变化最少的情况就是我们所需要的结果。</p><p>时间复杂度<code>O(n*n)</code></p><h3 id="解法二-预处理"><a href="#解法二-预处理" class="headerlink" title="解法二-预处理"></a>解法二-预处理</h3><p>在每次遍历时都需要统计多少个G，多少个R，这时我们可以引入两个辅助数组保存这个结果,arr1这个数组保存着 <code>0-i</code>范围上有几个R，arr2保存着<code>i-n-1</code>上有几个G。这样在遍历时直接去数组中获取答案即可，时间复杂度为<code>O(n)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RGRGR -&gt; RRRGG</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minPaint</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[chs.length];</span><br><span class="line">    right[chs.length - <span class="number">1</span>] = chs[chs.length - <span class="number">1</span>] == <span class="string">&#x27;R&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 辅助数组的计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = chs.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        right[i] = right[i + <span class="number">1</span>] + (chs[i] == <span class="string">&#x27;R&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始为 把数组全变为G的代价</span></span><br><span class="line">    <span class="keyword">int</span> res = right[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        left += chs[i] == <span class="string">&#x27;G&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 计算左侧几个G染成R</span></span><br><span class="line">        <span class="comment">// 左侧的变为R的个数 + 右侧变为G的个数</span></span><br><span class="line">        res = Math.min(res, left + right[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把数组全部变为R的代价 统计数组有几个G</span></span><br><span class="line">    res = Math.min(res, left + (chs[chs.length - <span class="number">1</span>] == <span class="string">&#x27;G&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目七-二叉树的最大权值"><a href="#题目七-二叉树的最大权值" class="headerlink" title="题目七 二叉树的最大权值"></a>题目七 二叉树的最大权值</h2><p>二叉树每个结点都有一-个int型权值，给定一棵二叉树，要求计算出从根结点到叶结点的所有路径中，权值和最大的值为多少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxPath</span><span class="params">(TreeNode head)</span> </span>&#123;</span><br><span class="line">    p(head, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">p</span><span class="params">(TreeNode x, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.left == <span class="keyword">null</span> &amp;&amp; x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        maxSum = Math.max(maxSum, pre + x.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p(x.left, pre+x.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">        p(x.right, pre+x.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目一-差值为k的去重数字对&quot;&gt;&lt;a href=&quot;#题目一-差值为k的去重数字对&quot; class=&quot;headerlink&quot; title=&quot;题目一 差值为k的去重数字对&quot;&gt;&lt;/a&gt;题目一 差值为k的去重数字对&lt;/h2&gt;&lt;p&gt;给定一一个数组arr,，求差值为k的去重数字对。&lt;/p&gt;
&lt;p&gt;给一个数组3,2,5,7,0,0 差值为2的有(0,2),(3,5),(5,7)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(&lt;code&gt;leetcode532&lt;/code&gt; 数组中的 k-diff 数对)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解&lt;/p&gt;
&lt;p&gt;使用hash表将数据放入，遍历hash表，找到当前数+k的数是否存在&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; findPairs(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HashSet&amp;lt;Integer&amp;gt; set = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num: nums)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        set.add(num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Integer num : set)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (set.contains(num + k))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res.add(Arrays.asList(num, num + k));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;leetcode532的解法还需要处理k=0的情况&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;findPairs&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] nums, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HashMap&amp;lt;Integer, Integer&amp;gt; map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num: nums)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        map.put(num, map.get(num) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ? map.get(num) + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; res = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Integer num : map.keySet())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (map.containsKey(num + k))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (k == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; map.get(num) == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            res ++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;题目二-magic操作&quot;&gt;&lt;a href=&quot;#题目二-magic操作&quot; class=&quot;headerlink&quot; title=&quot;题目二 magic操作&quot;&gt;&lt;/a&gt;题目二 magic操作&lt;/h2&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>中级提升班1</title>
    <link href="http://yoursite.com/2022/12/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD1/"/>
    <id>http://yoursite.com/2022/12/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD/%E4%B8%AD%E7%BA%A7%E6%8F%90%E5%8D%87%E7%8F%AD1/</id>
    <published>2022-12-31T07:11:22.000Z</published>
    <updated>2023-01-01T07:28:03.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目一-绳子覆盖最多点的数量"><a href="#题目一-绳子覆盖最多点的数量" class="headerlink" title="题目一 绳子覆盖最多点的数量"></a>题目一 绳子覆盖最多点的数量</h2><p>给定一个有序数组arr,代表数轴上从左到右有n个点<code>arr[0]、arr[1]... arr[n-1]</code>,给定一个正数T，代表一根长度为T的绳子，求绳子最多能覆盖其中的几个点。</p><h3 id="解法一-二分查找"><a href="#解法一-二分查找" class="headerlink" title="解法一-二分查找"></a>解法一-二分查找</h3><p>以每个点开始，向左延伸T的长度，看有多个点被覆盖。时间复杂度：遍历一遍<code>n</code>,找点二分<code>logn</code>，<code>O(nlogn)</code>。</p><p><strong>利用二分找小于等于arr[L]+k的最右侧的节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxCoverPoint</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || K &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">0</span>;L&lt;arr.length;L++)&#123;</span><br><span class="line">        <span class="keyword">int</span> R=binarySearch(arr,L,K);</span><br><span class="line">        max=Math.max(max,R-L+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L=i;</span><br><span class="line">    <span class="keyword">int</span> R=arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> target=arr[i]+K;</span><br><span class="line">    <span class="keyword">int</span> ans=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">        <span class="comment">//1:找中点</span></span><br><span class="line">        <span class="keyword">int</span> mid=L+((R-L)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;=target)&#123;</span><br><span class="line">            ans=mid;</span><br><span class="line">            L=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            R=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二-滑动窗口"><a href="#解法二-滑动窗口" class="headerlink" title="解法二-滑动窗口"></a>解法二-滑动窗口</h3><p>维持一个窗口，L和R位置都是不回退的，在一个点L不动，让R一直向右走不能大于绳子长度，然后让L向右走一格，看R能向右走多少。时间复杂度<code>O(n)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxCoverPoint2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//双指针 时间复杂度为O(N)</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || K &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;L&lt;arr.length;L++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(R&lt;arr.length&amp;&amp;arr[R]-arr[L]&lt;=K)&#123;</span><br><span class="line">            R++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//R指向的是匹配失败的位置</span></span><br><span class="line">        max=Math.max(max,R-L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这题是窗口问题中的经典题目，窗口模型的关键之处在于双指针不回退，每次尝试下一个开头的时候，都只需要从上一个失败的位置继续尝试即可，而不需要回退R指针。</strong></p><h2 id="题目二-买苹果的最小袋子数"><a href="#题目二-买苹果的最小袋子数" class="headerlink" title="题目二 买苹果的最小袋子数"></a>题目二 买苹果的最小袋子数</h2><p>小虎去附近的商店买苹果，奸诈的商贩使用了捆绑交易，只提供6个每袋和8个每袋的包装包装不可拆分。可是小虎现在只想购买恰好n个苹果，小虎想购买尽量少的袋数方便携带。如果不能购买恰好n个苹果，小虎将不会购买。输入一个整数n，表示小虎想购买的个苹果，返回最小使用多少袋子。如果无论如何都不能正好装下，返回-1。</p><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>先用暴力方法解决这个问题：用苹果数量除以8就知道了至多要用多少个8号袋，然后依次减少8号袋的数量，看剩下的苹果需要多少个6号袋…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minBags</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = n / <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = y; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> rest = n - i * <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (rest % <span class="number">6</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rest / <span class="number">6</span> + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6和8的最小公倍数是24，剩下的袋子大于24时就可以停止了，因为24这部分可以被8处理为什么要用6来处理。</p><p>6和8的最大公约数是2，所以如果数量不能被2整除就可以停止了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有可以装8个和6个袋子，给n个苹果，最小使用的袋子数</span></span><br><span class="line"><span class="comment">// 解</span></span><br><span class="line"><span class="comment">// 先用暴力方法解决这个问题：用苹果数量除以8就知道了至多要用多少个8号袋，</span></span><br><span class="line"><span class="comment">// 然后依次减少8号袋的数量，看剩下的苹果需要多少个6号袋…</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minBags</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bag6 = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> bag8 = n / <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> rest = n - <span class="number">8</span> * bag8;</span><br><span class="line">    <span class="keyword">while</span> (bag8 &gt;= <span class="number">0</span> &amp;&amp; rest &lt; <span class="number">24</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> restUse6 = minBagsBase6(rest);</span><br><span class="line">        <span class="keyword">if</span> (restUse6 != -<span class="number">1</span>)&#123;</span><br><span class="line">            bag6 = restUse6;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rest = n - <span class="number">8</span> * (--bag8);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bag6 == -<span class="number">1</span> ? -<span class="number">1</span> : bag6 + bag8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果剩余苹果rest可以被装6个苹果的袋子搞定，返回袋子数量</span></span><br><span class="line"><span class="comment">//不能搞定返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minBagsBase6</span><span class="params">(<span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rest % <span class="number">6</span> == <span class="number">0</span> ? (rest / <span class="number">6</span>) : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据结果反推，找规律"><a href="#根据结果反推，找规律" class="headerlink" title="根据结果反推，找规律"></a>根据结果反推，找规律</h3><p>N一定是2的倍数，否则两种袋子始终装不满，原因是6和8的最小公倍数是2。<br> N大于等于18时，从18开始，8个数字一组。<br> N小于18时，直接给出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minBag2</span><span class="params">(<span class="keyword">int</span> apple)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((apple &amp; <span class="number">1</span>) != <span class="number">0</span> )&#123; <span class="comment">// 如果是奇数，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (apple &lt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (apple == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (apple == <span class="number">6</span> || apple == <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (apple == <span class="number">12</span> || apple == <span class="number">14</span> || apple== <span class="number">16</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (apple-<span class="number">18</span>)/<span class="number">8</span> + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目三-吃草的获胜者"><a href="#题目三-吃草的获胜者" class="headerlink" title="题目三 吃草的获胜者"></a>题目三 吃草的获胜者</h2><p>2只动物先后进行吃草，每个人只能吃4的某次方的草，比如1,4,16…,给你草的数量N，问谁最先把艹吃完。</p><h3 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h3><p>先手从1份草开始尝试吃，一直到base*4 &gt;n，看能不能赢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n份青草放一堆，先手后手</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">winner1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 0  1  2  3   4</span></span><br><span class="line">    <span class="comment">// 后 先 后  先  先</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (n == <span class="number">0</span>) || (n == <span class="number">2</span>) ? <span class="string">&quot;后手&quot;</span> :<span class="string">&quot;先手&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n&gt;=5时</span></span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1</span>; <span class="comment">// 先手要吃的草</span></span><br><span class="line">    <span class="keyword">while</span> (base &lt;= n)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前一共n份草，先手吃掉的是base份，n-base是留给后手的草</span></span><br><span class="line">        <span class="comment">// 当前过程是先手，之后的过程就是后手</span></span><br><span class="line">        <span class="keyword">if</span> (winner1(n - base).equals(<span class="string">&quot;后手&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;先手&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (base &gt; n/<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        base *= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;后手&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据结果，找规律"><a href="#根据结果，找规律" class="headerlink" title="根据结果，找规律"></a>根据结果，找规律</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">后手,后手</span><br><span class="line">先手,先手</span><br><span class="line">后手,后手</span><br><span class="line">先手,先手</span><br><span class="line">先手,先手</span><br><span class="line">后手,后手</span><br><span class="line">先手,先手</span><br><span class="line">后手,后手</span><br><span class="line">先手,先手</span><br><span class="line">先手,先手</span><br><span class="line">后手,后手</span><br><span class="line">先手,先手</span><br><span class="line">后手,后手</span><br><span class="line">先手,先手</span><br><span class="line">先手,先手</span><br><span class="line">后手,后手</span><br><span class="line">先手,先手</span><br><span class="line">后手,后手</span><br><span class="line">先手,先手</span><br><span class="line">先手,先手</span><br></pre></td></tr></table></figure><p>从结果看，5次一循环，后手，先手，后手，先手，先手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">winner2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span> || n % <span class="number">5</span> == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;后手&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;先手&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目四-最大正方形"><a href="#题目四-最大正方形" class="headerlink" title="题目四 最大正方形"></a>题目四 最大正方形</h2><p>给定一个N*N的矩阵matrix，只有0和1两种值，返回边框全是1的最大正方形的边长长度。<br>例如:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01111</span><br><span class="line">01001</span><br><span class="line">01001</span><br><span class="line">01111</span><br><span class="line">01011</span><br></pre></td></tr></table></figure><p>其中边框全是1的最大正方形的大小为4*4，所以返回4。</p><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>一个<code>n*n</code>的矩阵，子矩阵的数量：以任意一点<code>n*n</code>为左上角，任意一点<code>n*n</code> 为右下角，做成的长方形（两个点重合，交换的可能性少），数量为 <code>n*n*n*n</code></p><p>一个<code>n*n</code>的矩阵，子正方形的数量：以任意一点<code>n*n</code>为左上角，另外一个点构成的边长会枚举1,2,3…n的数量，数量为 <code>n*n*n</code></p><p>遍历正方形的每个点，然后开始枚举边长从1…边界(右边先到边界还是左边先到边界)，然后判断这个正方形的边长都为一（这时又需要遍历每条边），找到最大的正方形即可。时间复杂度为<code>O(n*n*n*n)</code></p><h3 id="解法二-预处理"><a href="#解法二-预处理" class="headerlink" title="解法二-预处理"></a>解法二-预处理</h3><p>此时需要2个矩阵记录连续1的信息</p><p>right矩阵信息记录每个点包括自己的右侧有多个连续的1;</p><p>down矩阵信息记录每个点包括自己的下侧有多个连续的1;</p><p>这样在我们遍历矩阵计算连续正方形时就不必在遍历矩阵了。时间复杂度优化为<code>O(n*n*n*n)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取预处理数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setBorderMap</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span>[][] right, <span class="keyword">int</span>[][] down)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = m.length;</span><br><span class="line">    <span class="keyword">int</span> c = m[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (m[r - <span class="number">1</span>][c - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        right[r - <span class="number">1</span>][c - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        down[r - <span class="number">1</span>][c - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[i][c - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            right[i][c - <span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">            down[i][c - <span class="number">1</span>] = down[i + <span class="number">1</span>][c - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = c - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m[r - <span class="number">1</span>][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            right[r - <span class="number">1</span>][i] = right[r - <span class="number">1</span>][i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            down[r - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = r - <span class="number">2</span>; i != -<span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = c - <span class="number">2</span>; j != -<span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                right[i][j] = right[i][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                down[i][j] = down[i + <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxSize</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] right = <span class="keyword">new</span> <span class="keyword">int</span>[m.length][m[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span>[][] down = <span class="keyword">new</span> <span class="keyword">int</span>[m.length][m[<span class="number">0</span>].length];</span><br><span class="line">    setBorderMap(m, right, down); <span class="comment">// O(N^2); + </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始遍历每个边长</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> size = Math.min(m.length, m[<span class="number">0</span>].length); size != <span class="number">0</span>; size--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSizeOfBorder(size, right, down)) &#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSizeOfBorder</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span>[][] right, <span class="keyword">int</span>[][] down)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历每个位置，看是否有满足的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != right.length - size + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != right[<span class="number">0</span>].length - size + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right[i][j] &gt;= size &amp;&amp; down[i][j] &gt;= size</span><br><span class="line">                    &amp;&amp; right[i + size - <span class="number">1</span>][j] &gt;= size</span><br><span class="line">                    &amp;&amp; down[i][j + size - <span class="number">1</span>] &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目五-等概率返回函数"><a href="#题目五-等概率返回函数" class="headerlink" title="题目五 等概率返回函数"></a>题目五 等概率返回函数</h2><p>给定一个函数f，可以<code>1~5</code>的数字等概率返回一个。 请加工出<code>1~7</code>的数字等概率返回一个的函数g。<br>给定一个函数f，可以<code>a~b</code>的数字等概率返回一个。 请加工出c~d的数字等概率返回一个的函数g。<br>给定一个函数f，以p概率返回0，以1-p概率返回1。 请加工出等概率返回0和1的函数g.</p><p><strong>1解法</strong></p><p>等概率返回<code>1-5</code>的函数，先把它变成等概率返回<code>0-1</code>的函数，如果返回是1-2,返回0，如果是得到4-5返回1，如果是得到3重新获取值。</p><p>等概率获取1-7等于等概率获取0-6,0-6在二进制上是3位，那么我们可以把等概率返回0-1的函数调用3次，获取3位数，这3位数分别组成二进制位，这样就获取到了0-7的等概率数；如果是获取到7，就重新进行计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等概率返回 1-5</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.random() * <span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等概率返回0和1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">r01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        res = f1();</span><br><span class="line">    &#125; <span class="keyword">while</span> (res == <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> res &lt; <span class="number">3</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等概率返回1-7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 3个二进制位</span></span><br><span class="line">        res = (r01() &lt;&lt; <span class="number">2</span>) + (r01() &lt;&lt; <span class="number">1</span>) + r01();</span><br><span class="line">    &#125; <span class="keyword">while</span> (res == <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2解法</strong></p><p>函数f，可以<code>a~b</code>的数字等概率返回一个，把该函数转换为等概率返回<code>0~1</code>的函数，对<code>a~b</code>二分，低位部分返回0，高位部分返回1，多余的数字重新计算；然后将<code>c~d</code>转换为<code>0~d-c</code>，并判断其是几位二进制，然后获取<code>0~1</code>的函数几次，对于多余的部分重新计算，最后的结果加+c就是等概率返回<code>c~d</code>的函数。</p><p><strong>3解法</strong></p><p>以p概率返回0，以1-p概率返回1。那么用该函数计算2次，获取到00、11就重新获取，直到获取的10和01，这2个概率为<code>1*(1-p)</code>,获取到01返回0，获取到01返回1。</p><h2 id="题目六-节点为n的二叉树数量"><a href="#题目六-节点为n的二叉树数量" class="headerlink" title="题目六 节点为n的二叉树数量"></a>题目六 节点为n的二叉树数量</h2><p>给定一个非负整数n，代表二叉树的节点个数。返回能形成多少种不同的二叉树结构(同<code>leetcode 96</code>)</p><h3 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h3><p>N个节点，计算n个节点的函数为F(N)</p><ol><li><p>左树没有节点，右树N-1个节点，<code>F(N-1)</code></p></li><li><p>左树1个节点，右树N-2个节点，<code>F(N-2)</code></p></li><li><p>左树2个节点，右树N-3的节点，<code>F(2) * F(N-3)</code> </p></li><li><p>…</p></li></ol><p>得出结论左树i个节点，右树N-i-1个节点,<code>F(i) * F(N-i-1)</code> ，将所有结果相加就是最后的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> leftNum = <span class="number">0</span>; leftNum &lt;= n - <span class="number">1</span>; leftNum++) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftWays = process(leftNum);</span><br><span class="line">        <span class="keyword">int</span> rightWays = process(n - <span class="number">1</span> - leftNum);</span><br><span class="line">        res += leftWays * rightWays;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123; <span class="comment">// 节点数为i</span></span><br><span class="line">        <span class="comment">// 节点个数为i时 左侧节点 j-1,右侧节点 i-j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目七-完整的括号字符串"><a href="#题目七-完整的括号字符串" class="headerlink" title="题目七 完整的括号字符串"></a>题目七 完整的括号字符串</h2><p>一个完整的括号字符串定义规则如下:<br>①空字符串是完整的。<br>②如果s是完整的字符串，那么(s)也是完整的。<br>③如果s和t是完整的字符串，将它们连接起来形成的st也是完整的。<br>例如，<code>&quot;(() ())&quot;</code>，<code>&quot;&quot;</code>和<code>&quot;(()) () &quot;</code>是完整的括号字符串，<code>&quot;())(&quot;</code>，<code>&quot;()(&quot;</code>和<code>&quot;)&quot;</code>是不完整的括号字符串。<br>牛牛有一个括号字符串s,现在需要在其中任意位置尽量少地添加括号,将其转化为一个完整的括号字符串。请问牛牛至少需要添加多少个括号。</p><p>(同<code>leetcode921</code>)</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>一个完整字符串的判断方法：从左向右遍历字符串，定义变量count,遇到左括号++，遇到右括号–，满足以下条件就是一个完整字符串</p><ol><li><p>遍历中间没有<code>count&lt;0</code>;</p></li><li><p>结束后<code>count=0</code>；</p></li></ol><p>那么如何添加括号使其满足完整的括号字符串。定义一个新的变量ans=0,</p><ol><li>当出现count&lt;0时，说明缺少了左括号，ans++,并把count重新置为0；</li><li>遍历完的时候如果count&gt;0,就添加count个右括号</li></ol><p>参考</p><p>[绳子最大覆盖点数【窗口】][<a href="https://blog.csdn.net/ai15013602354/article/details/124161141]">https://blog.csdn.net/ai15013602354/article/details/124161141]</a></p><p>[小虎去买苹果][<a href="https://bbs.huaweicloud.com/blogs/250330]">https://bbs.huaweicloud.com/blogs/250330]</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目一-绳子覆盖最多点的数量&quot;&gt;&lt;a href=&quot;#题目一-绳子覆盖最多点的数量&quot; class=&quot;headerlink&quot; title=&quot;题目一 绳子覆盖最多点的数量&quot;&gt;&lt;/a&gt;题目一 绳子覆盖最多点的数量&lt;/h2&gt;&lt;p&gt;给定一个有序数组arr,代表数轴上从左到右有n个点&lt;code&gt;arr[0]、arr[1]... arr[n-1]&lt;/code&gt;,给定一个正数T，代表一根长度为T的绳子，求绳子最多能覆盖其中的几个点。&lt;/p&gt;
&lt;h3 id=&quot;解法一-二分查找&quot;&gt;&lt;a href=&quot;#解法一-二分查找&quot; class=&quot;headerlink&quot; title=&quot;解法一-二分查找&quot;&gt;&lt;/a&gt;解法一-二分查找&lt;/h3&gt;&lt;p&gt;以每个点开始，向左延伸T的长度，看有多个点被覆盖。时间复杂度：遍历一遍&lt;code&gt;n&lt;/code&gt;,找点二分&lt;code&gt;logn&lt;/code&gt;，&lt;code&gt;O(nlogn)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用二分找小于等于arr[L]+k的最右侧的节点&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 二分法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxCoverPoint&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; K)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arr == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || arr.length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || K &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; max=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;L&amp;lt;arr.length;L++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; R=binarySearch(arr,L,K);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        max=Math.max(max,R-L+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; max;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;binarySearch&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; K)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L=i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; R=arr.length-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; target=arr[i]+K;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; ans=-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(L&amp;lt;=R)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//1:找中点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; mid=L+((R-L)&amp;gt;&amp;gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(arr[mid]&amp;lt;=target)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans=mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            L=mid+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            R=mid-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;解法二-滑动窗口&quot;&gt;&lt;a href=&quot;#解法二-滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;解法二-滑动窗口&quot;&gt;&lt;/a&gt;解法二-滑动窗口&lt;/h3&gt;&lt;p&gt;维持一个窗口，L和R位置都是不回退的，在一个点L不动，让R一直向右走不能大于绳子长度，然后让L向右走一格，看R能向右走多少。时间复杂度&lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxCoverPoint2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[] arr, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; K)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//双指针 时间复杂度为O(N)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arr == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || arr.length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || K &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; max=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; L=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; R=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(;L&amp;lt;arr.length;L++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(R&amp;lt;arr.length&amp;amp;&amp;amp;arr[R]-arr[L]&amp;lt;=K)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            R++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//R指向的是匹配失败的位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        max=Math.max(max,R-L);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; max;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;这题是窗口问题中的经典题目，窗口模型的关键之处在于双指针不回退，每次尝试下一个开头的时候，都只需要从上一个失败的位置继续尝试即可，而不需要回退R指针。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>有序表</title>
    <link href="http://yoursite.com/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/"/>
    <id>http://yoursite.com/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/</id>
    <published>2022-12-25T14:39:07.000Z</published>
    <updated>2022-12-31T07:41:19.630Z</updated>
    
    <content type="html"><![CDATA[<p>有序表是一种查找时间复杂度为<code>O(logn)</code>的算法，实现有序表的情况有红黑树、AVL树、SB树、跳表。</p><p>前3个都属于平衡搜索二叉树系列BST</p><p>如果我们有一个搜索二叉树，如何能让他的增删改查就尽量快一些。一般默认搜索二叉树没有重复节点，因为我们可以通过增数据项存重述节点的信息。就是一个节点的信息多一些，也不重要。在搜索二叉树中进行操作增删改查的操作，但是因为不平衡，所以我们是<strong>不能保证时间复杂度</strong>。一旦不平衡，我们的时间复杂度可能就是<code>O(N)</code>。所以我们要保证平衡性。</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>AVL树：是最最严格的平衡树，它每一个节点，左右子树<strong>高度差不超过一</strong><br>为了满足这个操作，需要引入两个操作：左旋+右旋。旋转表示的是头结点往哪边倒。</p><p><img src="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="在这里插入图片描述"></p><p>AVL树实现的是怎么用左旋和右旋的操作；红黑树也是实现左旋和右旋，并且有自己关于平衡的定义；SB树同样也有自己平衡的操作。</p><h3 id="AVL树是怎么发现自己不平衡的？"><a href="#AVL树是怎么发现自己不平衡的？" class="headerlink" title="AVL树是怎么发现自己不平衡的？"></a>AVL树是怎么发现自己不平衡的？</h3><p>AVL数的增删改查与搜索二叉树相同，只是在增加节点后，<strong>会从当前增加的节点开始向上查找是否有平衡性</strong>；对于删除来说，是从替换节点（一个节点删除必然有节点替换这个节点）开始查找是否有平衡性。</p><p><img src="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/AVL%E6%A3%80%E6%9F%A5%E4%B8%8D%E5%B9%B3%E8%A1%A1.png" alt="image-20221226213740304"></p><p>对于插入节点1来说，就从插入节点1开始向上查看每个节点是否平衡；对于删除节点5来说，会从它的替换节点6的上一个节点7开始查看每个节点是否不平衡</p><h3 id="平衡性被破坏的情况"><a href="#平衡性被破坏的情况" class="headerlink" title="平衡性被破坏的情况"></a>平衡性被破坏的情况</h3><p> AVL树有<strong>4 种类别进行固定化程序的操作</strong>。</p><h4 id="LL右单旋"><a href="#LL右单旋" class="headerlink" title="LL右单旋"></a>LL右单旋</h4><p>LL的意思是向左子树（L）的左孩子（L）中插入新节点后导致不平衡，这种情况下需要右旋操作，而不是说LL的意思是右旋，后面的也是一样。我们需要对节点y进行平衡的维护。</p><p><img src="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/AVL%E6%A0%91LL%E5%8F%B3%E5%8D%95%E6%97%8B.png" alt="img"></p><h4 id="RR左单旋"><a href="#RR左单旋" class="headerlink" title="RR左单旋"></a>RR左单旋</h4><p>我们需要对节点y进行平衡的维护。</p><p><img src="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/AVL%E6%A0%91RR%E5%B7%A6%E5%8D%95%E6%97%8B.png" alt></p><h4 id="LR先左旋后右旋"><a href="#LR先左旋后右旋" class="headerlink" title="LR先左旋后右旋"></a>LR先左旋后右旋</h4><p>节点插入左子树（L）的右子树（R）中</p><p><img src="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/AVL%E6%A0%91LR%E5%85%88%E5%B7%A6%E6%97%8B%E5%90%8E%E5%8F%B3%E9%80%89.png" alt="在这里插入图片描述"></p><p><strong>第三个图中x和z反了，失误</strong></p><h4 id="RL先右旋后左旋"><a href="#RL先右旋后左旋" class="headerlink" title="RL先右旋后左旋"></a>RL先右旋后左旋</h4><p><img src="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/AVL%E6%A0%91RL%E5%85%88%E5%8F%B3%E6%97%8B%E5%90%8E%E5%B7%A6%E6%97%8B.png" alt="在这里插入图片描述"></p><p><strong>第二个图中y的左孩子为T1，第三个图中x和z反了，孩子也错了，应该是从左至右T1，T2，T3，T4，失误。。。</strong></p><p>（红黑树和SB树）与AVL树的区别只在于和AVL的节点平衡性判定标准不一样，别的都一样。处理平衡的方式也是左右旋。</p><p>AVL数维持的是高度信息，红黑树维持的是自己关于平衡的信息，SB树维持的是有多少个节点的信息。平衡树在更新时保证把信息更新对。</p><h2 id="SB树"><a href="#SB树" class="headerlink" title="SB树"></a>SB树</h2><h3 id="平衡标准"><a href="#平衡标准" class="headerlink" title="平衡标准"></a>平衡标准</h3><p>每棵子树的节点个数，不小于其兄弟的子树的节点个数<br>既每棵叔叔树的节点个数，不小于其任何侄子树的节点个数</p><img src="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/SB树平衡条件.png" alt="image-20221226221607909" style="zoom:80%;"><p><code>[B] &gt;= max&#123;[F],[G]&#125;</code>, <code>[C]&gt;=max&#123;[D],[E]&#125;</code></p><p>Size-Balance树也是有四种不平衡情况：<br>LL，LR，RL，RR</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="平衡标准-1"><a href="#平衡标准-1" class="headerlink" title="平衡标准"></a>平衡标准</h3><ol><li>每个节点都是红色，或黑色。</li><li>根节点是黑色。</li><li>每个叶子节点(最底层的空区域，没有数据)是黑色。</li><li>如果一个节点是红色，它儿子节点都是黑色（红节点不能相邻）。</li><li>对每个节点，从该节点到子孙节点的所有路径上包含相同数目的黑节点。</li></ol><p>从头到底的路径最长的路径是红黑节点交替的路径，从头到底的路径最短的路径是只有黑节点，而到达底部黑色节点相同，那么这2条路径的差距就是2倍。红黑树要表达的是路径关系。</p><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><ol><li>跳表，又叫做跳跃表、跳跃列表，在有序链表的基础上增加了“跳跃”的功能</li><li>跳表在原来的有序链表上加上了多级索引，通过索引来快速查找；可以支持快速的删除、插入和查找操作。</li><li>跳表实际上是一种增加了<strong>前向指针</strong>的链表，是一种随机化的数据结构</li><li>Redis中 的 <code>SortedSet</code>、<code>LevelDB</code> 中的 <code>MemTable</code> 都用到了跳表</li><li>对比平衡树, 跳表的实现和维护会更加简单, 跳表的搜索、删除、添加的平均时间复杂度是 <code>O(logn)</code></li></ol><p><img src="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/%E8%B7%B3%E8%A1%A8.png" alt="在这里插入图片描述"></p><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><ol><li>从顶层链表的首元素开始，从左往右搜索，直至找到一个大于或等于目标的元素，或者到达当前层链表的尾部</li><li>如果该元素等于目标元素，则表明该元素已被找到</li><li>如果该元素大于目标元素或已到达链表的尾部，则退回到当前层的前一个元素，然后转入下一层进行搜索</li></ol><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><img src="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/%E8%B7%B3%E8%A1%A8%E6%8F%92%E5%85%A5.png" alt="在这里插入图片描述"></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>在跳表中删除某个结点时，如果这个结点在索引中也出现了，我们<strong>除了要删除原始链表中的结点，还要删除索引中的</strong>。因为单链表中的删除操作需要拿到删除结点的前驱结点，然后再通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点（双向链表除外）。因此跳表的删除操作时间复杂度即为O(logn)。</p><h4 id="索引动态更新"><a href="#索引动态更新" class="headerlink" title="索引动态更新"></a>索引动态更新</h4><p>当我们不断地往跳表中插入数据时，我们如果不更新索引，就有可能出现某2个索引节点之间的数据非常多的情况，在极端情况下，跳表还会退化成单链表</p><p><img src="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/%E8%B7%B3%E8%A1%A8%E7%B4%A2%E5%BC%95.png" alt="在这里插入图片描述"></p><p>跳表是通过<strong>随机函数</strong>来维护“平衡性”。</p><p>当我们在跳表中插入数据的时候，我们通过选择同时将这个数据<strong>插入到部分索引层中</strong>，如何选择索引层，可以通过一个随机函数来决定这个节点插入到哪几级索引中，比如随机生成了k，那么就将这个索引加入到，第一级到第k级索引中。</p><p><img src="/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/%E8%B7%B3%E8%A1%A8%E7%B4%A2%E5%BC%95%E5%B1%82.png" alt="在这里插入图片描述"></p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li>跳表由很多层结构组成，level是通过一定的概率随机产生的；</li><li>每一层都是一个有序的链表，默认是升序 ；</li><li>最底层(Level 1)的链表包含所有元素；</li><li>如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现；</li><li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。</li></ol><p>参考</p><p>[详细图文——AVL树][<a href="https://blog.csdn.net/qq_25343557/article/details/89110319]">https://blog.csdn.net/qq_25343557/article/details/89110319]</a></p><p>[跳表（Skip List）][<a href="https://blog.csdn.net/weixin_45480785/article/details/116293416]">https://blog.csdn.net/weixin_45480785/article/details/116293416]</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有序表是一种查找时间复杂度为&lt;code&gt;O(logn)&lt;/code&gt;的算法，实现有序表的情况有红黑树、AVL树、SB树、跳表。&lt;/p&gt;
&lt;p&gt;前3个都属于平衡搜索二叉树系列BST&lt;/p&gt;
&lt;p&gt;如果我们有一个搜索二叉树，如何能让他的增删改查就尽量快一些。一般默认搜索二叉树没有重复节点，因为我们可以通过增数据项存重述节点的信息。就是一个节点的信息多一些，也不重要。在搜索二叉树中进行操作增删改查的操作，但是因为不平衡，所以我们是&lt;strong&gt;不能保证时间复杂度&lt;/strong&gt;。一旦不平衡，我们的时间复杂度可能就是&lt;code&gt;O(N)&lt;/code&gt;。所以我们要保证平衡性。&lt;/p&gt;
&lt;h2 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h2&gt;&lt;p&gt;AVL树：是最最严格的平衡树，它每一个节点，左右子树&lt;strong&gt;高度差不超过一&lt;/strong&gt;&lt;br&gt;为了满足这个操作，需要引入两个操作：左旋+右旋。旋转表示的是头结点往哪边倒。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;AVL树实现的是怎么用左旋和右旋的操作；红黑树也是实现左旋和右旋，并且有自己关于平衡的定义；SB树同样也有自己平衡的操作。&lt;/p&gt;
&lt;h3 id=&quot;AVL树是怎么发现自己不平衡的？&quot;&gt;&lt;a href=&quot;#AVL树是怎么发现自己不平衡的？&quot; class=&quot;headerlink&quot; title=&quot;AVL树是怎么发现自己不平衡的？&quot;&gt;&lt;/a&gt;AVL树是怎么发现自己不平衡的？&lt;/h3&gt;&lt;p&gt;AVL数的增删改查与搜索二叉树相同，只是在增加节点后，&lt;strong&gt;会从当前增加的节点开始向上查找是否有平衡性&lt;/strong&gt;；对于删除来说，是从替换节点（一个节点删除必然有节点替换这个节点）开始查找是否有平衡性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9C%89%E5%BA%8F%E8%A1%A8/AVL%E6%A3%80%E6%9F%A5%E4%B8%8D%E5%B9%B3%E8%A1%A1.png&quot; alt=&quot;image-20221226213740304&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>暴力递归到动态规划</title>
    <link href="http://yoursite.com/2022/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2022/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-12-24T10:49:58.000Z</published>
    <updated>2022-12-31T07:40:14.481Z</updated>
    
    <content type="html"><![CDATA[<p>递归 -&gt; 记忆化搜索 (dp)-&gt; 严格表结构（dp）</p><p>某些问题上 记忆化搜索和严格表结构时间复杂度相同</p><h2 id="机器人走路问题"><a href="#机器人走路问题" class="headerlink" title="机器人走路问题"></a>机器人走路问题</h2><p>有N个格子，机器人初始在的位置S，目标位置是E，机器人可以向左或向右行走，每次走一步，可以走的步数为K步，问机器人有几种走法</p><h3 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">walkWays</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> E, <span class="keyword">int</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f1(N, E, K, S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> N    固定参数，一共有N个位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> E    固定参数，目标位置E</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rest 还剩下几步要走</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cur  当前所在位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法有多少种走法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> E, <span class="keyword">int</span> rest, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// basecase 已经无法行走了, 看当前位置是不是目标位置</span></span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cur == E ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经在最左，不能向左走了</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1(N, E, rest - <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经在最右不能，向右走了</span></span><br><span class="line">    <span class="keyword">if</span> (cur == N) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1(N, E, rest - <span class="number">1</span>, N - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向左走，向右走</span></span><br><span class="line">    <span class="keyword">return</span> f1(N, E, rest - <span class="number">1</span>, cur - <span class="number">1</span>) + f1(N, E, rest, cur + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有可变参数是影响当前方法结果的，当可变参数rest和cur定了后结果就确定了，</p><p>分析递归</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">N=<span class="number">5</span>,E=<span class="number">4</span>,K=<span class="number">4</span>,S=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">第一步</span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">4</span>,<span class="number">2</span>)</span></span> 走 f(<span class="number">3</span>,<span class="number">1</span>) f(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">第二步</span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">1</span>)</span></span> 走 f(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span> 走 f(<span class="number">2</span>,<span class="number">2</span>) f(<span class="number">2</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>可以看到在计算时，<code>f(2,2)</code>,这个结果被多次计算，如果将这个计算结果保存到一个表结构中，后序遇到时直接取出，就可以避免重复计算，利用空间换时间，这就记忆化搜索</p><h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><p>记忆化搜索，使用一个表结构保存每次计算结果的值，这个表结构与可变参数的范围有关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记忆化搜索</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">walkWays2</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> E, <span class="keyword">int</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表的大小和可变参数的大小有关</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= N; j++) &#123;</span><br><span class="line">            dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2(N, E, K, S, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> N    固定参数，一共有N个位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> E    固定参数，目标位置E</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rest 还剩下几步要走</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cur  当前所在位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dp   记忆表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法有多少种走法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> E, <span class="keyword">int</span> rest, <span class="keyword">int</span> cur, <span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dp[rest][cur] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[rest][cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// basecase 已经无法行走了, 看当前位置是不是目标位置</span></span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">        dp[rest][cur] = cur == E ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> dp[rest][cur];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经在最左，不能向左走了</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">        dp[rest][cur] = f2(N, E, rest - <span class="number">1</span>, <span class="number">2</span>, dp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == N) &#123; <span class="comment">// 已经在最右不能，向右走了</span></span><br><span class="line">        dp[rest][cur] = f2(N, E, rest - <span class="number">1</span>, N - <span class="number">1</span>, dp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 向左走，向右走</span></span><br><span class="line">        dp[rest][cur] = f2(N, E, rest - <span class="number">1</span>, cur - <span class="number">1</span>, dp) + f2(N, E, rest, cur + <span class="number">1</span>, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[rest][cur];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用暴力递归的方式时间复杂度为<code>O(2^k)</code>是指数级别的，使用记忆化搜索是<code>O(NK)</code></p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>从dp表开始看·</p><p><code>basecase</code>为rest=0 那么可以看出第一排为<code>0,0,0,1,0</code></p><ol><li><code>cur == 1</code> 下面的每一排都依赖于上面 <code>[rest-1]][cur + 1]</code>位置的值，右上角的值</li><li><code>cur == N</code> 下面的每一排都依赖于上面 <code>[rest-1]][cur - 1]</code>位置的值，左上角的值</li><li>下面的每一排都依赖于上面 <code>[rest-1]][cur + 1]</code>+ <code>[rest-1]][cur - 1]</code>位置的值，左上角的值+右上角的值</li></ol><p>下面的每一排都依赖于上面 [rest-1]</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>0</td><td>x</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>x</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>2</td><td>x</td><td>0</td><td>1</td><td>0</td><td>2</td><td>0</td></tr><tr><td>3</td><td>x</td><td>1</td><td>0</td><td>3</td><td>0</td><td>2</td></tr><tr><td>4</td><td>x</td><td>0</td><td>4</td><td>0</td><td>5</td><td>0</td></tr></tbody></table><p><strong>严格表结构的动态规划</strong>，动态规划是注意在于位置依赖的顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">walkWays3</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> E, <span class="keyword">int</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表的大小和可变参数的大小有关</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j == N)&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][N - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[K][E];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由结果来看每一步的结果都只与上一步结果有关，由此可以进行空间压缩，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">walkWays4</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> E, <span class="keyword">int</span> S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    dp[S] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftUp = dp[<span class="number">1</span>]; <span class="comment">// 左上角的值，需要临时变量来保存左上角的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dp[j];</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[j] = dp[j + <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j == N)&#123;</span><br><span class="line">                dp[j] = leftUp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = leftUp +dp[j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            leftUp = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[E];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="记忆化搜索变为-严格意义上的动态规划"><a href="#记忆化搜索变为-严格意义上的动态规划" class="headerlink" title="记忆化搜索变为 严格意义上的动态规划"></a>记忆化搜索变为 严格意义上的动态规划</h2><ol><li>分析可变参数的变化范围<ul><li>单可变参数的维度，维度保证是一维</li><li>可变参数的个数，参数个数尽量少</li></ul></li><li>标出计算的终止位置</li><li>标出basecase</li><li>看要求的位置是如何依赖其他位置的</li><li>确定表计算的顺序，从哪些格子计算到哪些格子</li></ol><h2 id="马到底最终位置的方法数"><a href="#马到底最终位置的方法数" class="headerlink" title="马到底最终位置的方法数"></a>马到底最终位置的方法数</h2><p>有个棋盘（10x9），马的位置在（0,0），经过k步马最终的坐标(a，b)，问方法数一共是多少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWays</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(x, y, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从（x,y）位置出发，去往(0,0)位置，必须跳step步的解法有多少种</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x    横坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> y    纵坐标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> step 步数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 方法有多少种</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">8</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// basecase</span></span><br><span class="line">    <span class="keyword">if</span> (step == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 马 的跳法</span></span><br><span class="line">    <span class="keyword">return</span> process(x - <span class="number">1</span>, y + <span class="number">2</span>, step - <span class="number">1</span>)</span><br><span class="line">            + process(x + <span class="number">1</span>, y + <span class="number">2</span>, step - <span class="number">1</span>)</span><br><span class="line">            + process(x + <span class="number">2</span>, y + <span class="number">1</span>, step - <span class="number">1</span>)</span><br><span class="line">            + process(x - <span class="number">2</span>, y + <span class="number">1</span>, step - <span class="number">1</span>)</span><br><span class="line">            + process(x - <span class="number">1</span>, y - <span class="number">2</span>, step - <span class="number">1</span>)</span><br><span class="line">            + process(x + <span class="number">1</span>, y - <span class="number">2</span>, step - <span class="number">1</span>)</span><br><span class="line">            + process(x - <span class="number">2</span>, y - <span class="number">1</span>, step - <span class="number">1</span>)</span><br><span class="line">            + process(x + <span class="number">2</span>, y - <span class="number">1</span>, step - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数有3个，准备3维的dp表,类似于立方体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dpWays</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">8</span> || y &lt; <span class="number">0</span> || y &gt; <span class="number">9</span> || step &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">10</span>][step + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 只有这个位置是1</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">1</span>; h &lt;= step; h++) &#123; <span class="comment">// 从第1层开始</span></span><br><span class="line">        <span class="comment">// 穷举x,y</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">9</span>; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">10</span>; c++) &#123;</span><br><span class="line">                dp[r][c][h] += getValue(dp, r - <span class="number">1</span>, c + <span class="number">2</span>, h - <span class="number">1</span>);</span><br><span class="line">                dp[r][c][h] += getValue(dp, r - <span class="number">1</span>, c - <span class="number">2</span>, h - <span class="number">1</span>);</span><br><span class="line">                dp[r][c][h] += getValue(dp, r + <span class="number">1</span>, c + <span class="number">2</span>, h - <span class="number">1</span>);</span><br><span class="line">                dp[r][c][h] += getValue(dp, r + <span class="number">1</span>, c - <span class="number">2</span>, h - <span class="number">1</span>);</span><br><span class="line">                dp[r][c][h] += getValue(dp, r - <span class="number">2</span>, c + <span class="number">1</span>, h - <span class="number">1</span>);</span><br><span class="line">                dp[r][c][h] += getValue(dp, r - <span class="number">2</span>, c - <span class="number">1</span>, h - <span class="number">1</span>);</span><br><span class="line">                dp[r][c][h] += getValue(dp, r + <span class="number">2</span>, c + <span class="number">1</span>, h - <span class="number">1</span>);</span><br><span class="line">                dp[r][c][h] += getValue(dp, r + <span class="number">2</span>, c - <span class="number">1</span>, h - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x][y][step];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止越界</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span>[][][] dp, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt; <span class="number">8</span> || col &lt; <span class="number">0</span> || col &gt; <span class="number">9</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row][col][step];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="凑硬币问题"><a href="#凑硬币问题" class="headerlink" title="凑硬币问题"></a>凑硬币问题</h2><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>从第一种硬币开始试，第一种1张、2张… 不能超过最大金额</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr里都是正数，没有重复值，每一个值代表一 种货币，每一种都可以用无限张</span></span><br><span class="line"><span class="comment">// 最终要找零钱数是aim,</span></span><br><span class="line"><span class="comment">// 找零方法数返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">way1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> process(arr, <span class="number">0</span>, aim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以自由使用arr[index...]所有的面值</span></span><br><span class="line"><span class="comment">// 需要搞定的钱数是rest</span></span><br><span class="line"><span class="comment">// 返回找零的方法数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// arr[index] 0张 1张... 不要超过rest的钱数</span></span><br><span class="line">    <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> zhang = <span class="number">0</span>; arr[index] * zhang &lt;= rest; zhang++) &#123;</span><br><span class="line">        ways += process(arr, index + <span class="number">1</span>, rest - arr[index] * zhang);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换为动态规划</p><p>查看<code>basecase</code>， rest == 0的位置是1其余位置为0</p><p>看其余位置的依赖关系，假设硬币为1,2,3</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0</span> <span class="number">1</span><span class="number">2</span><span class="number">3</span></span><br><span class="line"><span class="attribute">0</span></span><br><span class="line"><span class="attribute">1</span>?</span><br><span class="line"><span class="attribute">2</span>需要需要</span><br><span class="line"><span class="attribute">3</span> <span class="number">1</span><span class="number">0</span><span class="number">0</span><span class="number">0</span></span><br></pre></td></tr></table></figure><p>对于?位置，当数量为0时ways+=rest，张数等于1的时候需要<code>rest - arr[index] * zhang</code>列的位置。是一个累加的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">    dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123; <span class="comment">// 从下往上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ways = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> zhang = <span class="number">0</span>; arr[index] * zhang &lt;= rest; zhang++) &#123;</span><br><span class="line">                ways += dp[ index + <span class="number">1</span>][ rest - arr[index] * zhang];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[index][rest] = ways;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于中间的枚举每张钞票行为，真的有必要吗？从数学上看</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... x y</span><br><span class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c d</span><br></pre></td></tr></table></figure><p>对于y来说需要 a+b+c+d, 对于x来说需要a+b+c ,对于每一行，你前的某个值已经计算过这些了,所有对于y来说只需要x+d就可以了。所以结果为：<code>dp[index][rest] = dp[index + 1][rest];</code>同时如果结果不出界的话<code>rest - arr[index] &gt;= 0</code>是<code>dp[index][rest] += dp[index][rest - arr[index]];</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">    dp[N][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = N - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123; <span class="comment">// 从下往上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rest = <span class="number">0</span>; rest &lt;= aim; rest++) &#123;</span><br><span class="line">            dp[index][rest] = dp[index + <span class="number">1</span>][rest];</span><br><span class="line">            <span class="keyword">if</span> (rest - arr[index] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                dp[index][rest] += dp[index][rest - arr[index]]; <span class="comment">// 之前的值已经被rest - arr[index]计算过了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;递归 -&amp;gt; 记忆化搜索 (dp)-&amp;gt; 严格表结构（dp）&lt;/p&gt;
&lt;p&gt;某些问题上 记忆化搜索和严格表结构时间复杂度相同&lt;/p&gt;
&lt;h2 id=&quot;机器人走路问题&quot;&gt;&lt;a href=&quot;#机器人走路问题&quot; class=&quot;headerlink&quot; title=&quot;机器人走路问题&quot;&gt;&lt;/a&gt;机器人走路问题&lt;/h2&gt;&lt;p&gt;有N个格子，机器人初始在的位置S，目标位置是E，机器人可以向左或向右行走，每次走一步，可以走的步数为K步，问机器人有几种走法&lt;/p&gt;
&lt;h3 id=&quot;暴力递归&quot;&gt;&lt;a href=&quot;#暴力递归&quot; class=&quot;headerlink&quot; title=&quot;暴力递归&quot;&gt;&lt;/a&gt;暴力递归&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 暴力递归&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;walkWays&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; N, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; E, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; S, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; K)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f1(N, E, K, S);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 递归方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; N    固定参数，一共有N个位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; E    固定参数，目标位置E&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; rest 还剩下几步要走&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; cur  当前所在位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; 方法有多少种走法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; N, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; E, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rest, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; cur)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// basecase 已经无法行走了, 看当前位置是不是目标位置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rest == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; cur == E ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 已经在最左，不能向左走了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cur == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f1(N, E, rest - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 已经在最右不能，向右走了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (cur == N) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f1(N, E, rest - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, N - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 向左走，向右走&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f1(N, E, rest - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, cur - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) + f1(N, E, rest, cur + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;只有可变参数是影响当前方法结果的，当可变参数rest和cur定了后结果就确定了，&lt;/p&gt;
&lt;p&gt;分析递归&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;N=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,E=&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,K=&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,S=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一步&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; 走 f(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) f(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二步&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; 走 f(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; 走 f(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) f(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以看到在计算时，&lt;code&gt;f(2,2)&lt;/code&gt;,这个结果被多次计算，如果将这个计算结果保存到一个表结构中，后序遇到时直接取出，就可以避免重复计算，利用空间换时间，这就记忆化搜索&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://yoursite.com/2022/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2022/12/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2022-12-23T12:32:41.000Z</published>
    <updated>2022-12-31T07:41:12.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="比较两个数中较大的数"><a href="#比较两个数中较大的数" class="headerlink" title="比较两个数中较大的数"></a>比较两个数中较大的数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetMax</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    保证参数n 不是n就是1 1-&gt;0 0-&gt;1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">flip</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n ^ <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    n是非负数返回1， n是负数返回0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sign</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flip((n &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不考虑溢出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a - b; <span class="comment">//可能会溢出</span></span><br><span class="line">        <span class="keyword">int</span> scA = sign(c); <span class="comment">// a-b为非负 scA为1，否则是0</span></span><br><span class="line">        <span class="keyword">int</span> scB = sign(scA);</span><br><span class="line">        <span class="comment">// scA为0 scb必为1；scA为0，scb为0</span></span><br><span class="line">        <span class="keyword">return</span> a * scA + b * scB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑溢出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a - b; <span class="comment">//可能会溢出</span></span><br><span class="line">        <span class="keyword">int</span> sa = sign(a);</span><br><span class="line">        <span class="keyword">int</span> sb = sign(b);</span><br><span class="line">        <span class="keyword">int</span> sc = sign(c);</span><br><span class="line">        <span class="keyword">int</span> diffSab = sa ^ sb; <span class="comment">//a和b符号不一样为1，一样为0</span></span><br><span class="line">        <span class="keyword">int</span> sameSab = flip(diffSab);  <span class="comment">//a和b符号一样为1，不 一样为0</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            返回a</span></span><br><span class="line"><span class="comment">                a和b符号相同 a-b &gt;=0</span></span><br><span class="line"><span class="comment">                a和b符号不相同 a &gt; 0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> returnA = diffSab * sa + sameSab * sc;</span><br><span class="line">        <span class="keyword">int</span> returnB = flip(returnA);</span><br><span class="line">        <span class="keyword">return</span> a * returnA + b * returnB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断一个32位正数是不是2的幂、四的幂"><a href="#判断一个32位正数是不是2的幂、四的幂" class="headerlink" title="判断一个32位正数是不是2的幂、四的幂"></a>判断一个32位正数是不是2的幂、四的幂</h2><p>对2的幂来说，2进制上只有1位是1</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2</span>的<span class="number">0</span>次方<span class="number">0</span>... <span class="number">01</span></span><br><span class="line"><span class="attribute">2</span>的<span class="number">1</span>次方<span class="number">0</span>... <span class="number">10</span></span><br><span class="line"><span class="attribute">2</span>的<span class="number">2</span>次方<span class="number">0</span>... <span class="number">100</span></span><br></pre></td></tr></table></figure><p>X只有一个1， X-1 会把唯一的1打撒</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2</span>的<span class="number">0</span>次方-<span class="number">1</span> <span class="number">0</span>... <span class="number">00</span></span><br><span class="line"><span class="attribute">2</span>的<span class="number">1</span>次方-<span class="number">1</span> <span class="number">0</span>... <span class="number">01</span></span><br><span class="line"><span class="attribute">2</span>的<span class="number">2</span>次方-<span class="number">1</span><span class="number">0</span>... <span class="number">011</span></span><br></pre></td></tr></table></figure><p>判断一个数是不是2的幂通过 X&amp;(X-1)==0</p><p>对4的幂来说，它的1在奇数位上</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">4</span>的<span class="number">0</span>次方<span class="number">0</span>... <span class="number">01</span></span><br><span class="line"><span class="attribute">4</span>的<span class="number">1</span>次方<span class="number">0</span>... <span class="number">100</span></span><br><span class="line"><span class="attribute">4</span>的<span class="number">2</span>次方<span class="number">0</span>... <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>判断一个数是不是4的幂，先判断它是不是2的幂，然后 X &amp; 010101…01 不等于0</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// X只有一个1， X-1 会把唯一的1打撒 X&amp;(X-1)==0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// X只有一个1， X-1 会把唯一的1打撒 X&amp;(X-1)==0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (n &amp; <span class="number">0x55555555</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给定两个有符号32位整数a和b-不能使用算术运算符，分别实现a和b的加、减、乘、除运算"><a href="#给定两个有符号32位整数a和b-不能使用算术运算符，分别实现a和b的加、减、乘、除运算" class="headerlink" title="给定两个有符号32位整数a和b,不能使用算术运算符，分别实现a和b的加、减、乘、除运算"></a>给定两个有符号32位整数a和b,不能使用算术运算符，分别实现a和b的加、减、乘、除运算</h2><p>如果给定a、b执行加减乘除的运算结果就会导致数据的溢出，那么你实现的函数不必对此负责,除此之外请保证计算过程不发生溢出</p><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><p>先进行异或运算，异或是<strong>无进位相加</strong>，再进行与运算，与运算是<strong>进位信息</strong>，将它左移一位，得到2个数，将这2个数相加，也是是重复以上操作，直到得到<strong>进位信息的全是0</strong>，<strong>无进位相加</strong>就是最后结果。</p><h3 id="相减"><a href="#相减" class="headerlink" title="相减"></a>相减</h3><p>a-b = a+(-b) , -b这么求？相反数 就是取反加1</p><h3 id="相乘"><a href="#相乘" class="headerlink" title="相乘"></a>相乘</h3><p>二进制乘法与十进制乘法相同</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">   100</span></span><br><span class="line"><span class="code">   101</span></span><br><span class="line"><span class="code">  ----</span></span><br><span class="line"><span class="code">   100  // 1与上面与</span></span><br><span class="line"><span class="code">  000</span></span><br><span class="line"><span class="section"> 100// 1与上面与</span></span><br><span class="line"><span class="section">-------</span></span><br><span class="line"><span class="code"> 10100</span></span><br></pre></td></tr></table></figure><h3 id="相除"><a href="#相除" class="headerlink" title="相除"></a>相除</h3><p>a/b，就是讲b向左移动刚好被a最大相减的位置上</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">10100 / 100</span><br><span class="line">把100 左移2位 记为100</span><br><span class="line"><span class="code">  10100</span></span><br><span class="line"><span class="section">- 10000</span></span><br><span class="line"><span class="section">-------</span></span><br><span class="line"><span class="code">  00100</span></span><br><span class="line"><span class="bullet">-   </span>100不左移 记为1</span><br><span class="line"></span><br><span class="line">最终结果为 100 + 1 = 101</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a+b保证不溢出</span></span><br><span class="line"><span class="comment">// leetcode 371 两数相加无+-</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = a;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        sum = a ^ b;    <span class="comment">// 无进位加</span></span><br><span class="line">        b = (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// 进位信息</span></span><br><span class="line">        a = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相减 a-b = a + (-b)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(a, negNum(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相反数 就是取反加1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">negNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(~n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相乘</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123; <span class="comment">// 从最后一位开始计算</span></span><br><span class="line">            res = add(res, a);</span><br><span class="line">        &#125;</span><br><span class="line">        a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        b &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = isNeg(a) ? negNum(a) : a;</span><br><span class="line">    <span class="keyword">int</span> y = isNeg(b) ? negNum(b) : b;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt; -<span class="number">1</span>; i = minus(i, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 已经到最大相除的位置 y相左移可能会溢出</span></span><br><span class="line">        <span class="keyword">if</span> ((x &gt;&gt; i) &gt;= y) &#123;</span><br><span class="line">            res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            x = minus(x, y &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isNeg(a) ^ isNeg(b) ? negNum(res) : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (a == Integer.MIN_VALUE &amp;&amp; b == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == Integer.MIN_VALUE) &#123; <span class="comment">// a和b不都是最小值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == Integer.MIN_VALUE &amp;&amp; b &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = div(add(a, <span class="number">1</span>), b);</span><br><span class="line">        <span class="keyword">return</span> add(res, div(minus(a, multi(res, b)), b));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> div(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNeg</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;比较两个数中较大的数&quot;&gt;&lt;a href=&quot;#比较两个数中较大的数&quot; class=&quot;headerlink&quot; title=&quot;比较两个数中较大的数&quot;&gt;&lt;/a&gt;比较两个数中较大的数&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GetMax&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    保证参数n 不是n就是1 1-&amp;gt;0 0-&amp;gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;flip&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; n ^ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    n是非负数返回1， n是负数返回0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sign&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; flip((n &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;) &amp;amp; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 不考虑溢出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getMax1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c = a - b; &lt;span class=&quot;comment&quot;&gt;//可能会溢出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; scA = sign(c); &lt;span class=&quot;comment&quot;&gt;// a-b为非负 scA为1，否则是0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; scB = sign(scA);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// scA为0 scb必为1；scA为0，scb为0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a * scA + b * scB;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 考虑溢出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getMax2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; c = a - b; &lt;span class=&quot;comment&quot;&gt;//可能会溢出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sa = sign(a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sb = sign(b);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sc = sign(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; diffSab = sa ^ sb; &lt;span class=&quot;comment&quot;&gt;//a和b符号不一样为1，一样为0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sameSab = flip(diffSab);  &lt;span class=&quot;comment&quot;&gt;//a和b符号一样为1，不 一样为0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;            返回a&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                a和b符号相同 a-b &amp;gt;=0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;                a和b符号不相同 a &amp;gt; 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;         */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; returnA = diffSab * sa + sameSab * sc;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; returnB = flip(returnA);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a * returnA + b * returnB;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;判断一个32位正数是不是2的幂、四的幂&quot;&gt;&lt;a href=&quot;#判断一个32位正数是不是2的幂、四的幂&quot; class=&quot;headerlink&quot; title=&quot;判断一个32位正数是不是2的幂、四的幂&quot;&gt;&lt;/a&gt;判断一个32位正数是不是2的幂、四的幂&lt;/h2&gt;&lt;p&gt;对2的幂来说，2进制上只有1位是1&lt;/p&gt;
&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;2&lt;/span&gt;的&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;次方	&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;... &lt;span class=&quot;number&quot;&gt;01&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;2&lt;/span&gt;的&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;次方	&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;... &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;2&lt;/span&gt;的&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;次方	&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;... &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;X只有一个1， X-1 会把唯一的1打撒&lt;/p&gt;
&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;2&lt;/span&gt;的&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;次方-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;	 	&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;... &lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;2&lt;/span&gt;的&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;次方-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;	 	&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;... &lt;span class=&quot;number&quot;&gt;01&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;2&lt;/span&gt;的&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;次方-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;		&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;... &lt;span class=&quot;number&quot;&gt;011&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;判断一个数是不是2的幂通过 X&amp;amp;(X-1)==0&lt;/p&gt;
&lt;p&gt;对4的幂来说，它的1在奇数位上&lt;/p&gt;
&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;4&lt;/span&gt;的&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;次方	&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;... &lt;span class=&quot;number&quot;&gt;01&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;4&lt;/span&gt;的&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;次方	&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;... &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;4&lt;/span&gt;的&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;次方	&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;... &lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>大数据题目解法</title>
    <link href="http://yoursite.com/2022/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95/"/>
    <id>http://yoursite.com/2022/12/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%B3%95/</id>
    <published>2022-12-21T13:45:24.000Z</published>
    <updated>2022-12-31T07:40:36.470Z</updated>
    
    <content type="html"><![CDATA[<p>资源限制类题目</p><h2 id="哈希函数可以把数据按照种类均匀分流"><a href="#哈希函数可以把数据按照种类均匀分流" class="headerlink" title="哈希函数可以把数据按照种类均匀分流"></a>哈希函数可以把数据按照种类均匀分流</h2><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">一个大文件 无符号整数 (</span><span class="number">2</span><span class="keyword">^32</span><span class="keyword">^-1</span><span class="xml"> 就是 </span><span class="number">0</span><span class="xml">- </span><span class="number">42</span><span class="xml">亿范围）有</span><span class="number">40</span><span class="xml">亿个数，</span><span class="number">1</span><span class="xml">g内存求出现次数最多的数是哪一个？</span></span><br></pre></td></tr></table></figure><p>如果使用hash表来做 <code>key - value</code> ,key是(4B),value是int(4B), 一个数就要8B，如果40亿个数都不一样，就需要 320亿B（32G）。</p><p>对数据a 先使用 <code>hash函数</code>得到数 b，然后  <code>% 100</code>得到 0-99范围的数，相同的数据进同一个文件，不同的数种类上进不同文件。对每一个小文件使用hash表，然后求出这100个数的最大值。不怕同一种数太多，怕不同种的数太多，内存不够。</p><h2 id="布隆过滤器用于集合的建立与查询，并可以节省大量空间"><a href="#布隆过滤器用于集合的建立与查询，并可以节省大量空间" class="headerlink" title="布隆过滤器用于集合的建立与查询，并可以节省大量空间"></a>布隆过滤器用于集合的建立与查询，并可以节省大量空间</h2><p>解决黑名单过滤、对100亿url(64Byte)进行黑名单过滤过滤，如果使用hashset,需要640G内存。</p><p>爬虫去重，多个线程爬url, 如果已经爬过，就不要再爬，爬虫之间不要爬同一个。</p><p><strong>集合有添加、有查询，没有查询、极大程度减少内存使用，允许有一定程度失误率。</strong>如果一个数据不在布隆过滤器中，可能会误报，但一个数据在布隆过滤器中，一定不会误报。</p><h2 id="一致性哈希解决数据服务-器的负载管理问题"><a href="#一致性哈希解决数据服务-器的负载管理问题" class="headerlink" title="一致性哈希解决数据服务 器的负载管理问题"></a>一致性哈希解决数据服务 器的负载管理问题</h2><p>数据服务器怎么组织， 数据种类均匀分配。有3台服务器、一个数据同算hash然后取模方法，觉定这个数据在哪个服务器存储。hash key怎么选择，让高、中、低频的数据均匀分配的key，身份证之类。上面的算法好像可以把图片均衡地分配到不同的服务器,但<strong>增加和减少服务器时，如果要重新算hash会造成数据迁移</strong>。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>决分布式缓存的问题。 在移除或者添加一个服务器时，能够<strong>尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系</strong>。一致性哈希解决了简单哈希算法在分布式哈希表中存在的动态伸缩等问题 。</p><p>一致性hash算法会建立一个有2^32个槽点(0 - 2^32-1^)的hash环，假设现在有A、B、C三台服务器，以A为例，会进行hash(A)%2^32^，得到一个0 - 2^32-1^之间的数，然后映射到hash环上</p><p>接下来，我们以m1为例，我们照样算出hash(m1)%2^32^的值，然后映射到hash环上，然后以该点出发，<strong>顺时针遇到的第一个服务器，即为数据即将存储的服务器。</strong></p><p>如果这个时候在A - C之间插入了服务器D，请求获取getKey(m1)时，顺时针获得的服务器是D，从D上获取数据理所当然会失败，因为数据存在A上缓存。这样看缓存好像还是失效了。</p><p>虽然增加了节点D后，m1的缓存失效了，但是，分布在 A-B，B-C 以及 D-A上面的数据仍然有效，<strong>失效的只是C-D段的数据</strong>(数据存在A节点，但是顺时针获取的服务器是D)。这样就保证了缓存数据<strong>不会像hash算法那样大面积失效</strong>，同样起到减轻数据库压力的效果。</p><p><strong>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</strong></p><h4 id="hash偏斜"><a href="#hash偏斜" class="headerlink" title="hash偏斜"></a>hash偏斜</h4><p>A、B、C服务节点，如果接近于将hash环平均分配那固然理想，但是如果他们hash值十分相近,就会导致某一段直接会被大量分配，给某一节点大量分配，如果这时这个节点被删除，会有大量请求涌向相邻的节点，给这个节点带来巨大压力，这部分缓存也就失效了，导致了缓存雪崩。</p><p>如何保证节点的负载均衡？如何保证在添加节点后的负载均衡？</p><h4 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h4><p>如果我们的节点足够多，就应该可以防止服务器节点分布不均的问题了。</p><p>以A节点为例，虚拟构造出(A0,A1,A2….AN)，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为<strong>虚拟节点</strong>。<strong>只要是落在这些虚拟节点上的数据，都存入A节点</strong>。读取时也相同，顺时针获取的是A0虚拟节点，就到A节点上获取数据，这样就能解决数据分布不均的问题。</p><p>虚拟节点读写大概流程为:  数据读写 -&gt; 虚拟节点 -&gt; 真实节点 -&gt; 读写</p><h2 id="利用并查集结构做岛问题的并行计算"><a href="#利用并查集结构做岛问题的并行计算" class="headerlink" title="利用并查集结构做岛问题的并行计算"></a>利用并查集结构做岛问题的并行计算</h2><p>参考并查集一节</p><h2 id="位图解决某一范围上数字的出现情况，并可以节省大量空间"><a href="#位图解决某一范围上数字的出现情况，并可以节省大量空间" class="headerlink" title="位图解决某一范围上数字的出现情况，并可以节省大量空间"></a>位图解决某一范围上数字的出现情况，并可以节省大量空间</h2><p><strong>问题</strong></p><p>32位无符号整数的范围是0~4,294,967 ,295,现在有一个正好包含40亿个无符号 整数的文件，所以在整个范围中必然存在没出现过的数。可以使用最多1GB的内存，怎么找到所有未出现过的数?<br>[进阶]<br>内存限制为4KB,但是只用找到一个没出现过的数即可</p><p><strong>解</strong></p><p>准备一个2的32次方的Byte类型的数组要多少空间？ 2^32^/ 8 字节 越500M，这个Byte位置的0代表没出现过，1代表出现过</p><p><strong>进价解法</strong></p><p>准备4KB的int类型的数组，1个int类型是4字节，4KB/4=1024份，把整个范围 2^32^分为1024份，这个一定可以整除，一份是4194304</p><p>整个数组中0位置代表 0 - 4194304出现了多少次，统计完后，有的位置数量会多，一旦某个位置的词频数没有到达4194304，就说明这个范围上缺少数字，在这个范围上再一直分下去，一定可以定位到这个数字</p><p>同理如果只有3个位置，那么就对范围一直二分，最后一定可以定位到缺少的数</p><h2 id="利用分段统计思想、并进一步节省大量空间"><a href="#利用分段统计思想、并进一步节省大量空间" class="headerlink" title="利用分段统计思想、并进一步节省大量空间"></a>利用分段统计思想、并进一步节省大量空间</h2><h2 id="利用堆、外排序来做多个处理单元的结果合并"><a href="#利用堆、外排序来做多个处理单元的结果合并" class="headerlink" title="利用堆、外排序来做多个处理单元的结果合并"></a>利用堆、外排序来做多个处理单元的结果合并</h2><h2 id="大数据题目"><a href="#大数据题目" class="headerlink" title="大数据题目"></a>大数据题目</h2><h3 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有一个包含<span class="number">100</span>亿个<span class="built_in">URL</span>的大文件，假设每个<span class="built_in">URL</span>占用<span class="number">64</span><span class="variable">B</span><span class="operator">,</span>请找出其中所有重复的<span class="built_in">URL</span></span><br><span class="line"><span class="punctuation">[</span>补充<span class="punctuation">]</span></span><br><span class="line">某搜索公司一天的用户搜索词汇是海量的<span class="punctuation">(</span>百亿数据量<span class="punctuation">)</span><span class="operator">,</span>请设计<span class="operator">-</span> <span class="operator">-</span>种求出每天热门<span class="variable">Top100</span></span><br><span class="line">词汇的可行办法</span><br></pre></td></tr></table></figure><p>解法1：使用布隆过滤器判断url存不存在（可能会有误判）</p><p>解法2：hash计算每个url, hash函数特性使相同的url会进同一个文件,每个文件分开统计</p><p>top求法，先使用hash分流的方法，分为多个小文件，对多个小文件求Top100,最后对这些小文件的Top100再求Top100(这时就需要使用堆排序)，推排序：先把这些小文件的最大值建立一个堆中，弹出最大的url， 然后找到弹出url所在文件中出现第二多的url放入堆中，再弹出一个，直到弹出100个为止。</p><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">32</span>位无符号整数的范围是<span class="number">0</span>~<span class="number">4294967295</span>,现在有<span class="number">40</span>亿个无符号整数,可以使用最多<span class="number">1</span>GB的</span><br><span class="line">内存，找出所有出现了两次的数。</span><br><span class="line"><span class="string">[补充]</span></span><br><span class="line">可以使用最多<span class="number">10</span>MB的内存，怎么找到这<span class="number">40</span>亿个整数的中位数?</span><br></pre></td></tr></table></figure><p>解法：使用位图，用2位bit位来表示一个数出现的情况 00-没出现，01-出现一次，10，出现2次，11-出现3次及以上，这样内存消耗正好是1GB</p><p>补充的解法：以4kb的内存为例，准备4KB的int类型的数组，1个int类型是4字节，4KB/4=1024份，把整个范围 2^32^分为1024份，这个一定可以整除，一份是4194304，整个数组中0位置代表 0 - 4194304出现了多少次；看第20亿位的数落在那个范围内，对这个范围在次进行以上步骤等分为1024份，直到求出中位数。</p><h3 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有一个<span class="number">10</span>G文件，里面是<span class="built_in">int</span>类型的无序数，将这个文件内的数进行排序，最多可使用<span class="number">5</span>g内存</span><br></pre></td></tr></table></figure><p>使用一个小根堆，这个堆里面存储（数据，数量）占用8字节，堆其他开销算8字节，一共16字节，5G/16字节=2的28次方，这个堆可以存放2的28次方的数据，那么可以把整个范围 2^32^分为2的4次方，每份单独组织小根堆的状况（份和份之间一定是按照顺序来的），然后按照排序后的顺序和数量输出到新文件中，依次计算每份并写入到文件</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;资源限制类题目&lt;/p&gt;
&lt;h2 id=&quot;哈希函数可以把数据按照种类均匀分流&quot;&gt;&lt;a href=&quot;#哈希函数可以把数据按照种类均匀分流&quot; class=&quot;headerlink&quot; title=&quot;哈希函数可以把数据按照种类均匀分流&quot;&gt;&lt;/a&gt;哈希函数可以把数据按照种类均匀分流&lt;/h2&gt;&lt;figure class=&quot;highlight parser3&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;一个大文件 无符号整数 (&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;^32&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;^-1&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt; 就是 &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;亿范围）有&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;亿个数，&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;g内存求出现次数最多的数是哪一个？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果使用hash表来做 &lt;code&gt;key - value&lt;/code&gt; ,key是(4B),value是int(4B), 一个数就要8B，如果40亿个数都不一样，就需要 320亿B（32G）。&lt;/p&gt;
&lt;p&gt;对数据a 先使用 &lt;code&gt;hash函数&lt;/code&gt;得到数 b，然后  &lt;code&gt;% 100&lt;/code&gt;得到 0-99范围的数，相同的数据进同一个文件，不同的数种类上进不同文件。对每一个小文件使用hash表，然后求出这100个数的最大值。不怕同一种数太多，怕不同种的数太多，内存不够。&lt;/p&gt;
&lt;h2 id=&quot;布隆过滤器用于集合的建立与查询，并可以节省大量空间&quot;&gt;&lt;a href=&quot;#布隆过滤器用于集合的建立与查询，并可以节省大量空间&quot; class=&quot;headerlink&quot; title=&quot;布隆过滤器用于集合的建立与查询，并可以节省大量空间&quot;&gt;&lt;/a&gt;布隆过滤器用于集合的建立与查询，并可以节省大量空间&lt;/h2&gt;&lt;p&gt;解决黑名单过滤、对100亿url(64Byte)进行黑名单过滤过滤，如果使用hashset,需要640G内存。&lt;/p&gt;
&lt;p&gt;爬虫去重，多个线程爬url, 如果已经爬过，就不要再爬，爬虫之间不要爬同一个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集合有添加、有查询，没有查询、极大程度减少内存使用，允许有一定程度失误率。&lt;/strong&gt;如果一个数据不在布隆过滤器中，可能会误报，但一个数据在布隆过滤器中，一定不会误报。&lt;/p&gt;
&lt;h2 id=&quot;一致性哈希解决数据服务-器的负载管理问题&quot;&gt;&lt;a href=&quot;#一致性哈希解决数据服务-器的负载管理问题&quot; class=&quot;headerlink&quot; title=&quot;一致性哈希解决数据服务 器的负载管理问题&quot;&gt;&lt;/a&gt;一致性哈希解决数据服务 器的负载管理问题&lt;/h2&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>树形DP</title>
    <link href="http://yoursite.com/2022/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91Morris/"/>
    <id>http://yoursite.com/2022/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91Morris/</id>
    <published>2022-12-18T15:23:21.000Z</published>
    <updated>2022-12-31T07:40:50.643Z</updated>
    
    <content type="html"><![CDATA[<p>前提：如果题目求解目标是S规则，则求解流程可以定成以每一个节点为头节点的子树在S规则下的每一个答案，并且最终答案一定在其中。</p><h2 id="二叉树节点间的最大距离问题"><a href="#二叉树节点间的最大距离问题" class="headerlink" title="二叉树节点间的最大距离问题"></a>二叉树节点间的最大距离问题</h2><p>从二叉树的节点a出发，可以向上或者向下走，但沿途的节点<strong>只能经过一次</strong>，到达节点b时路径上的节点个数叫作a到b的距离，那么二叉树任何两个节点之间都有距离，求整棵树上的最大距离。</p><p>分析：</p><ol><li>当前节点X不参与的情况：当前最大距离可能来着<strong>左树的最大距离，右数的最大距离</strong>。</li><li>当前节点参与的情况下：左树最远节点，到右树最远节点。左树高 + 1（自己）+ 右树高。</li><li>三个值求最大值就为整棵树上的最大距离。对于每个节点需要2个信息：<strong>最大距离和树的高度</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Morris</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> maxDistance; <span class="comment">// 最大距离</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> height;      <span class="comment">// 高度</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> dis, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">            maxDistance = dis;</span><br><span class="line">            height = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归函数 返回以x为头的整棵树 的 信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Info leftInfo = process(x.left);</span><br><span class="line">        Info rightInfo = process(x.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> p1 = leftInfo.maxDistance;</span><br><span class="line">        <span class="keyword">int</span> p2 = rightInfo.maxDistance;</span><br><span class="line">        <span class="keyword">int</span> p3 = leftInfo.height + <span class="number">1</span> + rightInfo.height;</span><br><span class="line">        <span class="keyword">int</span> maxDistance = Math.max(p1, Math.max(p2, p3));               <span class="comment">// 最大距离</span></span><br><span class="line">        <span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>;   <span class="comment">//树的最大高度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(maxDistance, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> process(head).maxDistance - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node head1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        head1.left = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        head1.right = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        head1.left.left = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        head1.left.right = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        head1.right.left = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        head1.right.right = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        head1.left.left.left = <span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        head1.right.left.right = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        <span class="comment">//返回以head1为头节点的树的最大距离</span></span><br><span class="line">        System.out.println(maxDistance(head1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树形DP套路"><a href="#树形DP套路" class="headerlink" title="树形DP套路"></a>树形DP套路</h2><ol><li>以某个节点X为头节点的子树中，分析答案有哪些可能性，并且这种分析是<strong>以X的左子树、X的右子树和X整棵树</strong>的角度来考虑可能性。</li><li>根据第一步的可能性分析，列出所有需要的信息。</li><li>合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构</li><li>设计递归函数，递归函数是处理以X为头节点的情况下的答案。<br>包括设计递归的basecase，默认直接得到左树和右树的所有信息，以及把可能性做整合，并且要返回第三步的信息结构这四个小步骤</li></ol><h2 id="派对的最大快乐值"><a href="#派对的最大快乐值" class="headerlink" title="派对的最大快乐值"></a>派对的最大快乐值</h2><p><strong>问题</strong></p><p>公司的每个员工都符合Employee类的描述。整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。树的头节点是公司唯一的老板。除老板之外的每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工(subordinates列表为空)，除基层员工外，每个员工都有一个或多个直接下级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> happy; <span class="comment">//这名员工可以带来的快乐值</span></span><br><span class="line">List&lt;Employee&gt; subordinates; <span class="comment">//这名员工有哪些直接下级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个公司现在要办party，你可以决定哪些员工来，哪些员工不来。但是要遵循如下规则。</p><ol><li>如果某个员工来了，那么这个员工的所有直接下级都不能来</li><li>派对的整体快乐值是所有到场员工快乐值的累加</li><li>你的目标是让派对的整体快乐值尽量大</li><li>给定一棵多叉树的头节点boss，请返回派对的最大快乐值。</li></ol><p><strong>解题</strong></p><p>解题思路：当一棵树头节点为x时，如图所示，可分为两种情况：<br>①当x参与：则maxHappy = x(乐) + a树不来的快乐值 + b树b不来的快乐值<br>②当x不参与：则maxHappy = 0 + max(a树a来的快乐值, a树a不来的快乐值) + max(b树b来的快乐值, b树b不来的快乐值)</p><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartyMaxHappy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> happy; <span class="comment">//这名员工可以带来的快乐值</span></span><br><span class="line">        List&lt;Employee&gt; subordinates; <span class="comment">//这名员工有哪些直接下级</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> comeMax;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> notComeMax;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> comeMax, <span class="keyword">int</span> notComeMax)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.comeMax = comeMax;</span><br><span class="line">            <span class="keyword">this</span>.notComeMax = notComeMax;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxHappy</span><span class="params">(Employee boss)</span> </span>&#123;</span><br><span class="line">        Info headInfo = process(boss);</span><br><span class="line">        <span class="keyword">return</span> Math.max(headInfo.comeMax, headInfo.notComeMax);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Info <span class="title">process</span><span class="params">(Employee e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.subordinates.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Info(e.happy, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> eCome = e.happy;</span><br><span class="line">        <span class="keyword">int</span> eNotCome = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : e.subordinates)&#123;</span><br><span class="line">            Info nextInfo = process(employee);</span><br><span class="line">            eCome += nextInfo.notComeMax;</span><br><span class="line">            eNotCome += Math.max(nextInfo.comeMax, nextInfo.notComeMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Info(eCome, eNotCome);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="morris遍历"><a href="#morris遍历" class="headerlink" title="morris遍历"></a>morris遍历</h2><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><code>morris</code>是二叉树遍历算法的进阶算法，<code>morris</code>遍历可以将<strong>非递归遍历中的空间复杂度O(n)降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法</strong>。</p><p>假设来到当前节点cur,开始时cur来到头节点位置</p><ol><li>如果cur没有左孩子，cur向右移动<code>(cur = cur.right)</code></li><li>如果cur有左孩子，找到左子树上最右的节点<code>mostRight</code>:<ol><li>如果<code>mostRight</code>的右指针指向空，让其指向cur,<br>然后cur向左移动<code>(cur = cur.left)</code></li><li>如果<code>mostRight</code>的右指针指向cur，让其指向null,<br>然后cur向右移动<code>(cur = cur.right)</code></li></ol></li></ol><p>3) cur为空时遍历停止</p><img src="/2022/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B7%A6%E7%A8%8B%E4%BA%91/%E5%9F%BA%E7%A1%80/%E4%BA%8C%E5%8F%89%E6%A0%91Morris/树的遍历.png" alt="image-20221221200750059" style="zoom: 67%;"><p>遍历结果为 1(左树最右为5)， 2（左树最右为2）， 4 （当来到4的时候左子树为空，向右移动）2, 5, 1, 3, 6, 3, 7</p><p>一些位置走了2遍，通过判断左树上最右节点的右指针是否指向自己，来判断是否已经遍历过自己。</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mirrors</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到左子树最右节点， 并且这个节点的右指针不指向自己</span></span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首次遍历</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//mostRight.right == cur</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每个节点虽然遍历了2编，但是所遍历的节点它们并不重复，固时间复杂度为<code>O(n)</code></p><h3 id="先中后序遍历"><a href="#先中后序遍历" class="headerlink" title="先中后序遍历"></a>先中后序遍历</h3><ol><li><p>mirrors遍历的先序遍历，出现一次的直接打印，出现两次的只打印第一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mirrorsPre</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到左子树最右节点， 并且这个节点的右指针不指向自己</span></span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首次遍历</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 出现2次的</span></span><br><span class="line">                System.out.println(cur.value);</span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//mostRight.right == cur</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 出现一次的</span></span><br><span class="line">            System.out.println(cur.value);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>中序遍历：出现一次的直接打印，出现两次的只打印第二次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mirrorsIn</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到左子树最右节点， 并且这个节点的右指针不指向自己</span></span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首次遍历</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 出现2次的</span></span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//mostRight.right == cur</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cur.value);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后序遍历：只判断节点是不是第二次出现，若是逆序打印左树的右边界，整个过程之后，打印整颗子树的右边界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mirrorsPost</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到左子树最右节点， 并且这个节点的右指针不指向自己</span></span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首次遍历</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 出现2次的</span></span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//mostRight.right == cur</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">                printEdge(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printEdge(cur.left);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">    Node tail = reverseEdge(x);</span><br><span class="line">    Node cur = tail;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(cur.value);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseEdge(tail);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于链表反转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">reverseEdge</span><span class="params">(Node from)</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    Node next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (from != <span class="keyword">null</span>)&#123;</span><br><span class="line">        next = from.right;</span><br><span class="line">        from.right = pre;</span><br><span class="line">        pre = from;</span><br><span class="line">        from = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="判断一颗树是不是搜索二叉树"><a href="#判断一颗树是不是搜索二叉树" class="headerlink" title="判断一颗树是不是搜索二叉树"></a>判断一颗树是不是搜索二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    Node mostRight = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> preValue = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到左子树最右节点， 并且这个节点的右指针不指向自己</span></span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="keyword">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首次遍历</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 出现2次的</span></span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//mostRight.right == cur</span></span><br><span class="line">                mostRight.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否是递增</span></span><br><span class="line">        <span class="keyword">if</span> (cur.value &lt;= preValue) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preValue = cur.value;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;前提：如果题目求解目标是S规则，则求解流程可以定成以每一个节点为头节点的子树在S规则下的每一个答案，并且最终答案一定在其中。&lt;/p&gt;
&lt;h2 id=&quot;二叉树节点间的最大距离问题&quot;&gt;&lt;a href=&quot;#二叉树节点间的最大距离问题&quot; class=&quot;headerlink&quot; title=&quot;二叉树节点间的最大距离问题&quot;&gt;&lt;/a&gt;二叉树节点间的最大距离问题&lt;/h2&gt;&lt;p&gt;从二叉树的节点a出发，可以向上或者向下走，但沿途的节点&lt;strong&gt;只能经过一次&lt;/strong&gt;，到达节点b时路径上的节点个数叫作a到b的距离，那么二叉树任何两个节点之间都有距离，求整棵树上的最大距离。&lt;/p&gt;
&lt;p&gt;分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前节点X不参与的情况：当前最大距离可能来着&lt;strong&gt;左树的最大距离，右数的最大距离&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当前节点参与的情况下：左树最远节点，到右树最远节点。左树高 + 1（自己）+ 右树高。&lt;/li&gt;
&lt;li&gt;三个值求最大值就为整棵树上的最大距离。对于每个节点需要2个信息：&lt;strong&gt;最大距离和树的高度&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Morris&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 二叉树节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Node left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Node right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; data)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value = data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 返回信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Info&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxDistance; &lt;span class=&quot;comment&quot;&gt;// 最大距离&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; height;      &lt;span class=&quot;comment&quot;&gt;// 高度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Info&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; dis, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; h)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            maxDistance = dis;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            height = h;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 递归函数 返回以x为头的整棵树 的 信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Info &lt;span class=&quot;title&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Node x)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (x == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Info(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Info leftInfo = process(x.left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Info rightInfo = process(x.right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; p1 = leftInfo.maxDistance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; p2 = rightInfo.maxDistance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; p3 = leftInfo.height + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + rightInfo.height;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxDistance = Math.max(p1, Math.max(p2, p3));               &lt;span class=&quot;comment&quot;&gt;// 最大距离&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; height = Math.max(leftInfo.height, rightInfo.height) + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;   &lt;span class=&quot;comment&quot;&gt;//树的最大高度&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Info(maxDistance, height);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;maxDistance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Node head)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; process(head).maxDistance - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node head1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head1.left = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head1.right = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head1.left.left = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head1.left.right = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head1.right.left = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head1.right.right = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head1.left.left.left = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head1.right.left.right = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Node(&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//返回以head1为头节点的树的最大距离&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(maxDistance(head1));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;树形DP套路&quot;&gt;&lt;a href=&quot;#树形DP套路&quot; class=&quot;headerlink&quot; title=&quot;树形DP套路&quot;&gt;&lt;/a&gt;树形DP套路&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;以某个节点X为头节点的子树中，分析答案有哪些可能性，并且这种分析是&lt;strong&gt;以X的左子树、X的右子树和X整棵树&lt;/strong&gt;的角度来考虑可能性。&lt;/li&gt;
&lt;li&gt;根据第一步的可能性分析，列出所有需要的信息。&lt;/li&gt;
&lt;li&gt;合并第二步的信息，对左树和右树提出同样的要求，并写出信息结构&lt;/li&gt;
&lt;li&gt;设计递归函数，递归函数是处理以X为头节点的情况下的答案。&lt;br&gt;包括设计递归的basecase，默认直接得到左树和右树的所有信息，以及把可能性做整合，并且要返回第三步的信息结构这四个小步骤&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;派对的最大快乐值&quot;&gt;&lt;a href=&quot;#派对的最大快乐值&quot; class=&quot;headerlink&quot; title=&quot;派对的最大快乐值&quot;&gt;&lt;/a&gt;派对的最大快乐值&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="左程云" scheme="http://yoursite.com/tags/%E5%B7%A6%E7%A8%8B%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring 事务</title>
    <link href="http://yoursite.com/2022/12/11/%E6%A1%86%E6%9E%B6/Spring/Spring%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2022/12/11/%E6%A1%86%E6%9E%B6/Spring/Spring%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-12-11T15:17:48.000Z</published>
    <updated>2022-12-25T07:13:43.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务：是数据库操作的最小单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行，要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）。</p><h3 id="事务是四大特性"><a href="#事务是四大特性" class="headerlink" title="事务是四大特性"></a>事务是四大特性</h3><ol><li><strong>原子性（Atomicity）</strong>:事务中所有操作是不可再分割的原子单元。事务中所有操作要么全部执行成功，要么全部执行失败。</li><li><strong>一致性（Consistency）</strong>:事务执行后，数据库状态与其他业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的连个账号余额之和应该是不变的。</li><li><strong>隔离性（lsolation）</strong>:隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。</li><li><strong>持久性（Durability）</strong>:一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。</li></ol><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>数据库事务的隔离级别有4种，由低到高分别为<code>Read uncommitted</code> 、<code>Read committed</code> 、<code>Repeatable read</code> 、<code>Serializable</code>。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读、事务丢失。</p><h4 id="并发操作中出现的问题"><a href="#并发操作中出现的问题" class="headerlink" title="并发操作中出现的问题"></a>并发操作中出现的问题</h4><ul><li><p><strong>脏读:(读取了未提交的新事物，然后被回滚了)</strong><br>事务A读取了事务B中尚未提交的数据。如果事务B回滚，则A读取使用了错误的数据。</p></li><li><p><strong>不可重复读:(读取了提交的新事务，指更新操作)</strong><br>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p></li><li><p><strong>幻读:(也是读取了提交的新事务，指增删操作)</strong><br>在事务A多次读取构成中，事务B对数据进行了新增操作，导致事务A多次读取的数据不一致。</p></li><li><p><strong>第一类事物丢失:(称为回滚丢失)</strong></p><p>对于第一类事物丢失，就是比如A和B同时在执行一个数据，然后B事物已经提交了，然后A事物回滚了，这样B事物的操作就因A事物回滚而丢失了。</p></li><li><p><strong>第二类事物丢失:(提交覆盖丢失)</strong><br>对于第二类事物丢失，也称为覆盖丢失，就是A和B一起执行一个数据，两个同时取到一个数据，然后B事物首先提交，但是A事物加下来又提交，这样就覆盖了B事物.</p></li></ul><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul><li><code>Read uncommitted</code><br>读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。会产生脏读。</li><li><code>Read committed</code><br>读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。会产生不可重复读。</li><li><code>Repeatable read</code><br>重复读，就是在开始读取数据（事务开启)时，不再允许修改操作。可能会产生幻读。</li><li><code>Serializable</code><br>Serializable是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</li></ul><h2 id="Spring事务使用"><a href="#Spring事务使用" class="headerlink" title="Spring事务使用"></a>Spring事务使用</h2><p>基础配置,模拟一个转账业务</p><ol><li><p>定义数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BasicDataSource dataSource = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">    dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/ssm?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&quot;</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">jdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义数据库操作dao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(String fromName, Integer money)</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update account set money = money-? where name=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, money, fromName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">in</span><span class="params">(String toName, Integer money)</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;update account set money = money+? where name=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, money, toName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">accountDao.out(fromName, money);</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Sql Error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">accountDao.in(toName, money);</span><br></pre></td></tr></table></figure></li></ol><h3 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h3><p>添加事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务管理器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务管理器模板</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionTemplate <span class="title">transactionTemplate</span><span class="params">(TransactionManager transactionManager)</span></span>&#123;</span><br><span class="line">    TransactionTemplate transactionTemplate = <span class="keyword">new</span> TransactionTemplate();</span><br><span class="line">    transactionTemplate.setTransactionManager((DataSourceTransactionManager) transactionManager);</span><br><span class="line">    <span class="keyword">return</span> transactionTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用编程式事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String fromName, String toName, Integer money)</span> </span>&#123;</span><br><span class="line">    transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">        accountDao.out(fromName, money);</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Sql Error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        accountDao.in(toName, money);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码块中的内容有一处失败，整体失败。</p><h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><p>声明式事务不需要事务模板</p><p>配置类开启注解事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.lq.spring&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事务管理器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String fromName, String toName, Integer money)</span> </span>&#123;</span><br><span class="line">    accountDao.out(fromName, money);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Sql Error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    accountDao.in(toName, money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传播特性"><a href="#传播特性" class="headerlink" title="传播特性"></a>传播特性</h2><h3 id="物理事务和逻辑事务"><a href="#物理事务和逻辑事务" class="headerlink" title="物理事务和逻辑事务"></a>物理事务和逻辑事务</h3><p>物理事务：所谓物理事务指的就是<strong>Connection开启的事务</strong>。</p><p>逻辑事务：在一个复杂的业务系统中，可能会调用多个service，每个service都有自己的事务(标注了<code>@Transactional</code>)，此时我们需要根据事务传播方式(Propagation)来决定当前事务的行为(比如要挂起创建新事物，还是加入当前事务)。我们可以认为每个注解了<code>@Transactional</code>的方法都是一个逻辑事务，这些逻辑事务被Spring事务管理，Spring会根据事务传播方式来决定是否开启新事务</p><h3 id="7个传播特性"><a href="#7个传播特性" class="headerlink" title="7个传播特性"></a>7个传播特性</h3><p>当一个事务方法被另外一个事务方法调用时，这个事务方法应该如何执行。</p><p>Spring的7种事务隔离级别</p><table><thead><tr><th>事务</th><th>描述</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>默认事务类型，如果没有，就新建一个事务;如果有，就加入当前事务。适合绝大多数情况。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>如果没有，就新建一个事务;如果有，就将当前事务挂起。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果没有，就新建一个事务;如果有，就在当前事务中嵌套其他事务（子事务回滚不影响父事务，但父事务回滚子事务需要回滚）。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>如果没有，就以非事务方式执行;如果有，就使用当前事务。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>如果没有，就以非事务方式执行;如果有，就将当前事务挂起即无论如何不支持事务。</td></tr><tr><td>PROPAGATION_NEVER</td><td>如果没有，就以非事务方式执行;如果有，就抛出异常。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>如果没有，就抛出异常;如果有，就使用当前事务。</td></tr></tbody></table><ul><li>不需要事务：<code>PROPAGATION_NEVER</code>，<code>PROPAGATION_NOT_SUPPORTED</code></li><li>可有可无的：<code>PROPAGATION_SUPPORTS</code></li><li>必须要要有事务的：<code>PROPAGATION_REQUIRES_NEW</code>（总是新建），<code>PROPAGATION_REQUIRED</code>（可新建，可加入），<code>PROPAGATION_NESTED</code>（嵌套事务），<code>PROPAGATION_MANDATORY</code>（抛出异常）</li></ul><h2 id="EnableTransactionManagement注解"><a href="#EnableTransactionManagement注解" class="headerlink" title="@EnableTransactionManagement注解"></a>@EnableTransactionManagement注解</h2><p>该注解导入了类<code>TransactionManagementConfigurationSelector</code>,该类实现了<code>ImportSelector</code>，.最终会执行<code>selectImports</code>为容器注入bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(adviceMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> PROXY:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;AutoProxyRegistrar.class.getName(), ProxyTransactionManagementConfiguration.class.getName()&#125;;</span><br><span class="line">    <span class="keyword">case</span> ASPECTJ:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="keyword">this</span>.determineTransactionAspectClass()&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会注入<code>AutoProxyRegistrar</code>和<code>ProxyTransactionManagementConfiguration</code></p><h3 id="AutoProxyRegistrar"><a href="#AutoProxyRegistrar" class="headerlink" title="AutoProxyRegistrar"></a>AutoProxyRegistrar</h3><p><code>AutoProxyRegistrar</code>实现了<code>ImportBeanDefinitionRegistrar</code>，回向容器注入需要的<code>BeanDefiniton</code>，最终调用了<code>AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)</code>,如果容器中没有名称为<code>org.springframework.aop.config.internalAutoProxyCreator</code>的<code>BeanDefinition</code>那么会注入<code>InfrastructureAdvisorAutoProxyCreator</code></p><p>这里的<code>InfrastructureAdvisorAutoProxyCreator</code>是是<code>AbstractAutoProxyCreator</code>的子类，实现了<code>SmartInstantiationAwareBeanPostProcessor</code>会在<code>getEarlyBeanReference</code>提前暴露代理对象或者在bean完成实例化初始化后调用<code>postProcessAfterInitialization</code>对原始的bean进行aop增强。也就是说这里会注入一个基于动态代理实现Aop增强的一个bean后置处理器</p><h3 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a>ProxyTransactionManagementConfiguration</h3><p>类图：</p><img src="/2022/12/11/%E6%A1%86%E6%9E%B6/Spring/Spring%E4%BA%8B%E5%8A%A1/ProxyTransactionManagementConfiguration类图.png" alt="image-20221218194357113" style="zoom:80%;"><ol><li><p>注入<code>TransactionalEventListenerFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = TransactionManagementConfigUtils.TRANSACTIONAL_EVENT_LISTENER_FACTORY_BEAN_NAME)</span></span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TransactionalEventListenerFactory <span class="title">transactionalEventListenerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> TransactionalEventListenerFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步是在其父类<code>AbstractTransactionManagementConfiguration</code>中完成的</p><p><code>TransactionalEventListenerFactory</code>在事务的多播器中会把标注<code>TransactionalEventListener</code>的方法包装成一个<code>ApplicationListener</code>来响应对应的事件。</p></li><li><p>注入<code>TransactionInterceptor</code></p><p><code>TransactionInterceptor</code>实现了<code>MethodInterceptor</code>,是一个<code>Advise</code>一个基于方法拦截器的通知，在其中实现了事务的增强逻辑。在<code>Spring AOP</code>中我们分析过最后的aop代理对象执行方法的时候会调用到方法拦截器的<code>invoke</code>方法，<code>TransactionInterceptor</code>便是在其中实现了事务的增强。</p></li><li><p>注入<code>BeanFactoryTransactionAttributeSourceAdvisor</code></p><p><code>BeanFactoryTransactionAttributeSourceAdvisor</code>是一个<code>PointcutAdvisor</code>,是一个<code>Advisor</code>，它使用<code>Pointcut</code>来判断当前对象的方法是否需要增强，使用<code>Advice</code>对方法进行增强。</p></li><li><p>注入<code>TransactionAttributeSource</code></p><p>这里注入的是<code>AnnotationTransactionAttributeSource</code>，主要负责从类上，方法上，获取<code>@Transactional</code>注解信息,比如抛出什么异常回滚，事务超时时间等。</p></li></ol><p>我们基本上清楚了Spring 事务是如何实现的了，首先是通过<code>BeanPostProcessor</code>与<code>Spring IOC</code>容器结合在一起，在bean实例化初始化后调用后置处理器（如果出现循环依赖那么调用的是提前暴露对象的<code>getEarlyBeanReference</code>）对bean进行<code>Aop</code>增强，在<code>AbstractAutoProxyCreator</code>的<code>wrapIfNecessary</code>方法中，会获取全部的<code>Advisor</code>,便会拿到注入的<code>BeanFactoryTransactionAttributeSourceAdvisor</code>,然后使用<code>Pointcut</code>进行过滤，然后通过<code>ProxyFactory</code>选择使用JDK动态代理，还是cglib动态代理。后续调用代理对象的方法会调用到，<code>TransactionInterceptor</code>中的<code>invoke</code>实现了事务增强的逻辑。接下来我们详细看看细节部分</p><h2 id="Spring事务源码分析"><a href="#Spring事务源码分析" class="headerlink" title="Spring事务源码分析"></a>Spring事务源码分析</h2><h3 id="BeanFactoryTransactionAttributeSourceAdvisor"><a href="#BeanFactoryTransactionAttributeSourceAdvisor" class="headerlink" title="BeanFactoryTransactionAttributeSourceAdvisor"></a>BeanFactoryTransactionAttributeSourceAdvisor</h3><p>实现了<code>PointcutAdvisor</code>接口，我们看下它的<code>Pointcut</code>到底是什么，它的<code>Advice</code>又是什么。</p><h4 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> TransactionAttributeSource transactionAttributeSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionAttributeSourcePointcut pointcut = <span class="keyword">new</span> TransactionAttributeSourcePointcut() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> TransactionAttributeSource <span class="title">getTransactionAttributeSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> transactionAttributeSource;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个类维护了一个<code>TransactionAttributeSourcePointcut</code>类型的<code>pointcut</code></p><img src="/2022/12/11/%E6%A1%86%E6%9E%B6/Spring/Spring%E4%BA%8B%E5%8A%A1/TransactionAttributeSourcePointcut类图.png" alt="image-20221218201157611" style="zoom:80%;"><p>它实现了<code>StaticMethodMatcherPointcut</code>,它是一个静态方法匹配的Pointcut，这里的静态意思是<strong>不会因为入参的参数不同而改变过滤结果</strong>。我们看下具体的实现逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">   TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">   <span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>getTransactionAttributeSource</code>返回的是<code>AnnotationTransactionAttributeSource</code>实例，这里的逻辑是只要有<code>TransactionAttributeSource</code>并且可以拿到事务定义信息，那么就视为匹配，后面就会对方法进行增强。</p><h4 id="AnnotationTransactionAttributeSource是如何获取事务定义信息的"><a href="#AnnotationTransactionAttributeSource是如何获取事务定义信息的" class="headerlink" title="AnnotationTransactionAttributeSource是如何获取事务定义信息的"></a>AnnotationTransactionAttributeSource是如何获取事务定义信息的</h4><p><code>getTransactionAttribute</code>由其父类<code>AbstractFallbackTransactionAttributeSource</code>实现，其使用一个<code>ConcurrentHashMap</code>缓存方法和其对应的事务信息，如果缓存中没有那么会调用<code>computeTransactionAttribute</code>方法进行获取。<code>computeTransactionAttribute</code>方法会优先获取方法上面的事务注解信息，然后获取类类上面的注解信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First, see if we have a cached value.</span></span><br><span class="line">   Object cacheKey = getCacheKey(method, targetClass);</span><br><span class="line">   TransactionAttribute cached = <span class="keyword">this</span>.attributeCache.get(cacheKey);</span><br><span class="line">   <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Value will either be canonical value indicating there is no transaction attribute,</span></span><br><span class="line">      <span class="comment">// or an actual transaction attribute.</span></span><br><span class="line">      <span class="keyword">if</span> (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> cached;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We need to work it out.</span></span><br><span class="line">      TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</span><br><span class="line">      <span class="comment">// Put it in the cache.</span></span><br><span class="line">      <span class="keyword">if</span> (txAttr == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);</span><br><span class="line">         <span class="keyword">if</span> (txAttr <span class="keyword">instanceof</span> DefaultTransactionAttribute) &#123;</span><br><span class="line">            ((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">         <span class="keyword">this</span>.attributeCache.put(cacheKey, txAttr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> txAttr;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>computeTransactionAttribute</code>的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">    <span class="comment">// 是否只允许public方法，一般为true, 如果只允许public方法且当前方法不是public</span></span><br><span class="line">   <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The method may be on an interface, but we need attributes from the target class.</span></span><br><span class="line">   <span class="comment">// If the target class is null, the method will be unchanged.</span></span><br><span class="line">   <span class="comment">// 如果是CGLIB代理后的类，会一直找父类知道找到用户定义的类中的方法，并且是原始方法</span></span><br><span class="line">   Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First try is the method in the target class.</span></span><br><span class="line">   TransactionAttribute txAttr = findTransactionAttribute(specificMethod);</span><br><span class="line">   <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> txAttr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Second try is the transaction attribute on the target class.</span></span><br><span class="line">    <span class="comment">// 先从方法上面获取注解，其次拿类上面的</span></span><br><span class="line">   txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line">   <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">      <span class="keyword">return</span> txAttr;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">      <span class="comment">// Fallback is to look at the original method.</span></span><br><span class="line">      txAttr = findTransactionAttribute(method);</span><br><span class="line">      <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> txAttr;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Last fallback is the class of the original method.</span></span><br><span class="line">      txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line">      <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">         <span class="keyword">return</span> txAttr;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到事务注解只能标注在public方法上面，如果是像mybatis这种生成接口动态代理类那么会拿到接口上面的注解信息。</p><p>获取注解信息<code>findTransactionAttribute</code>调用了子类的<code>AnnotationTransactionAttributeSource#determineTransactionAttribute</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">determineTransactionAttribute</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (TransactionAnnotationParser parser : <span class="keyword">this</span>.annotationParsers) &#123;</span><br><span class="line">      TransactionAttribute attr = parser.parseTransactionAnnotation(element);</span><br><span class="line">      <span class="keyword">if</span> (attr != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> attr;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到一个新的类<code>TransactionAnnotationParser</code>,这是Spring根据<code>AnnotatedElement</code>获取注解的接口，可以扩展此接口实现自己的事务注解，并定制事务定义信息。这些事务注解解析器在构造方法中进行了定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationTransactionAttributeSource</span><span class="params">(<span class="keyword">boolean</span> publicMethodsOnly)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.publicMethodsOnly = publicMethodsOnly;</span><br><span class="line">   <span class="keyword">if</span> (jta12Present || ejb3Present) &#123;</span><br><span class="line">      <span class="keyword">this</span>.annotationParsers = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="comment">// spring的事务注解解析</span></span><br><span class="line">      <span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> SpringTransactionAnnotationParser());</span><br><span class="line">      <span class="keyword">if</span> (jta12Present) &#123;</span><br><span class="line">         <span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> JtaTransactionAnnotationParser());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ejb3Present) &#123;</span><br><span class="line">         <span class="keyword">this</span>.annotationParsers.add(<span class="keyword">new</span> Ejb3TransactionAnnotationParser());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.annotationParsers = Collections.singleton(<span class="keyword">new</span> SpringTransactionAnnotationParser());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Spring内置了<code>JTA</code>,<code>ejb</code>的事务注解处理器，但是使用的是<code>LinkedHashSet</code>，<code>SpringTransactionAnnotationParser</code>会放在最前面，解析Spring的<code>@Transactional</code>注解，这也是我们最常用的事务注解，<code>SpringTransactionAnnotationParser</code>会拿到事务注解信息，然后把注解的属性内容包装成 <code>RuleBasedTransactionAttribute</code></p><p><img src="/2022/12/11/%E6%A1%86%E6%9E%B6/Spring/Spring%E4%BA%8B%E5%8A%A1/RuleBasedTransactionAttribute%E7%B1%BB%E5%9B%BE.png" alt="image-20221218204708731"></p><p><code>RuleBasedTransactionAttribute</code>对<code>rollbackOn</code>进行了扩展，配合<code>SpringTransactionAnnotationParser</code>会解析事务注解中的<code>rollbackFor</code>,<code>rollbackForClassName</code>,<code>noRollbackFor</code>,<code>noRollbackForClassName</code>属性来判断异常抛出时是否需要回滚事务。如果这个属性没有值的话，会调用父类的<code>rollbackOn</code>,最终只会在<code>RuntimeException</code> 和 <code>Error</code>上面回滚。</p><h4 id="BeanFactoryTransactionAttributeSourceAdvisor是如何获取到Advice的"><a href="#BeanFactoryTransactionAttributeSourceAdvisor是如何获取到Advice的" class="headerlink" title="BeanFactoryTransactionAttributeSourceAdvisor是如何获取到Advice的"></a>BeanFactoryTransactionAttributeSourceAdvisor是如何获取到<code>Advice</code>的</h4><p>它实现了<code>BeanFactoryAware</code>,使用<code>advice</code>持有当前通知的引用，如果没有那么从容器中根据名称拿。在<code>ProxyTransactionManagementConfiguration</code>中直接设置<code>advice</code>为容器中的<code>TransactionInterceptor</code>,也就是说事务的增强逻辑定义在<code>TransactionInterceptor</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractBeanFactoryPointcutAdvisor</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">   resetAdviceMonitor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TransactionInterceptor"><a href="#TransactionInterceptor" class="headerlink" title="TransactionInterceptor"></a>TransactionInterceptor</h3><p><code>TransactionInterceptor</code>是事务拦截器，其invoke方法会在代理对象被代理方法执行的时候被回调到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line">   <span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line">   <span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">    <span class="comment">// 获取class 如果被CGLIB代理过会获取父类</span></span><br><span class="line">   Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span></span><br><span class="line">    <span class="comment">// 方法引用，业务逻辑代码</span></span><br><span class="line">   <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<strong><code>invokeWithinTransaction</code></strong>是spring事务原理的关键，此方法在其父类<code>TransactionAspectSupport</code>实现</p><h4 id="利用TransactionAttributeSource获取方法或者类上的事务注解信息"><a href="#利用TransactionAttributeSource获取方法或者类上的事务注解信息" class="headerlink" title="利用TransactionAttributeSource获取方法或者类上的事务注解信息"></a>利用TransactionAttributeSource获取方法或者类上的事务注解信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//invokeWithinTransaction</span></span><br><span class="line">TransactionAttributeSource tas = getTransactionAttributeSource();</span><br></pre></td></tr></table></figure><p>事务注解决定了事务增强的代码执行逻辑，这里使用的<code>TransactionAttributeSource</code>通常是是上文中我们提到的<code>AnnotationTransactionAttributeSource</code>，上文中我们直到，其内部存在map缓存，如果缓存没有那么调用<code>TransactionAnnotationParser</code>链式的进行解析，自然就调用到了<code>SpringTransactionAnnotationParser</code>,<code>SpringTransactionAnnotationParser</code>反射获取注解信息包装成<code>TransactionAttribute</code>对象</p><h4 id="获取事务管理器PlatformTransactionManager"><a href="#获取事务管理器PlatformTransactionManager" class="headerlink" title="获取事务管理器PlatformTransactionManager"></a>获取事务管理器PlatformTransactionManager</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//invokeWithinTransaction</span></span><br><span class="line"><span class="keyword">final</span> TransactionManager tm = determineTransactionManager(txAttr);</span><br></pre></td></tr></table></figure><p><code>PlatformTransactionManager</code>是spring抽象出的事务管理器接口，主要包含下面三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的传播行为返回当前活动的事务或创建新事务</span></span><br><span class="line">   <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据事务状态提交事务</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据事务状态回滚事务</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>determineTransactionManager</code>方法决定使用什么事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invokeWithinTransaction</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionManager <span class="title">determineTransactionManager</span><span class="params">(<span class="meta">@Nullable</span> TransactionAttribute txAttr)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Do not attempt to lookup tx manager if no tx attributes are set</span></span><br><span class="line">    <span class="comment">// 没有事务定义信息，或没有beanFactory返回TransactionManager属性的值</span></span><br><span class="line">   <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || <span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> getTransactionManager();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这一步获取事务注解上value的值，如果存在内容根据名称从beanFactory中获取合适的事务管理</span></span><br><span class="line">   String qualifier = txAttr.getQualifier();</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">      <span class="keyword">return</span> determineQualifiedTransactionManager(<span class="keyword">this</span>.beanFactory, qualifier);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.transactionManagerBeanName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> determineQualifiedTransactionManager(<span class="keyword">this</span>.beanFactory, <span class="keyword">this</span>.transactionManagerBeanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 一般不存在 走这里</span></span><br><span class="line">       <span class="comment">// 获取默认的事务管理器</span></span><br><span class="line">      TransactionManager defaultTransactionManager = getTransactionManager();</span><br><span class="line">      <span class="keyword">if</span> (defaultTransactionManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">         defaultTransactionManager = <span class="keyword">this</span>.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY);</span><br><span class="line">         <span class="keyword">if</span> (defaultTransactionManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//从beanFactory中获取合适的事务管理</span></span><br><span class="line">            defaultTransactionManager = <span class="keyword">this</span>.beanFactory.getBean(TransactionManager.class);</span><br><span class="line">            <span class="keyword">this</span>.transactionManagerCache.putIfAbsent(</span><br><span class="line">                  DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> defaultTransactionManager;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到Spring是支持<code>@Transactional</code>注解value指定特定的事务管理器，但是我们实际使用中通常是没有指定的，这里就会去bean工程中获取<code>PlatformTransactionManager</code>类型的bean，存在多个就会抛出异常了。这里拿到的一般是<code>DataSourceTransactionManager</code></p><h4 id="根据事务传播级别来决定是否由必要创建事务createTransactionIfNecessary"><a href="#根据事务传播级别来决定是否由必要创建事务createTransactionIfNecessary" class="headerlink" title="根据事务传播级别来决定是否由必要创建事务createTransactionIfNecessary"></a>根据事务传播级别来决定是否由必要创建事务createTransactionIfNecessary</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invokeWithinTransaction</span></span><br><span class="line">TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br></pre></td></tr></table></figure><p>首先调用<code>getTransaction</code>方法获取一个事务，然后调用<code>prepareTransactionInfo</code>封装事务的处理配置信息并绑定到当前线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="meta">@Nullable</span> TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">         status = tm.getTransaction(txAttr);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// log</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>getTransaction</code>在<code>AbstractPlatformTransactionManager</code>中是一个<code>final</code>的模板方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getTransaction</span></span><br><span class="line"><span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">   <span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 找到现有事务-&gt;检查传播行为以了解如何行为。</span></span><br><span class="line">   <span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check definition settings for new transaction.</span></span><br><span class="line"><span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">&quot;Invalid transaction timeout&quot;</span>, def.getTimeout());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line"><span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">         <span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">      def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">      def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">   SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">   <span class="comment">// log</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">      resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">   <span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">      <span class="comment">// log </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">   <span class="keyword">return</span> prepareTransactionStatus(def, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不存在事务"><a href="#不存在事务" class="headerlink" title="不存在事务"></a>不存在事务</h5><ol><li><p>首先要求超时时长不能小于-1.-1表示的使用底层事务系统的默认超时，如果不支持超时，则使用无</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">&quot;Invalid transaction timeout&quot;</span>, def.getTimeout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后如果的传播级别是<code>MANDATORY</code>支持当前事务，如果不存在则抛出异常,也就是说<code>MANDATORY</code>要求外层调用方法是在一个具备事务的情况下进行的调用.</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">         <span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果隔离级别是<code>Required(支持当前事务，如果当前不存在事务那么创建一个新事务)</code>,<code>RequireNew（创建一个新事务，如果存在事务则暂停当前事务）</code>,<code>Nested（如果当前事务存在，则在嵌套事务中执行）</code>那么会执行下面的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">      def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">      def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">    <span class="comment">// 挂起当前事务，让事务和线程解绑</span></span><br><span class="line">   SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">   <span class="comment">// log</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 开启一个事务</span></span><br><span class="line">      <span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">       <span class="comment">// 出现异常恢复被挂起的事务</span></span><br><span class="line">      resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">startTransaction</span><span class="params">(TransactionDefinition definition, Object transaction,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">boolean</span> debugEnabled, <span class="meta">@Nullable</span> SuspendedResourcesHolder suspendedResources)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">    DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">        definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">   <span class="comment">// 开启具体事务</span></span><br><span class="line">    doBegin(transaction, definition);</span><br><span class="line">    <span class="comment">// 设置当前事务的一些属性记录在ThreadLocal中</span></span><br><span class="line">    prepareSynchronization(status, definition);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是挂起当前事务，由于当前不存在事务，其实是把当前存在<code>TransactionSynchronization</code>事务同步回调的接口信息保存在<code>SuspendedResourcesHolder</code>中。在<code>DataSourceTransactionManager</code>中<code>doBegin</code>方法会获取对应的Connection,然后根据事务定义对Connection进行设置，比如如果是只读事务那么会执行<code>SET TRANSACTION READ ONLY</code>设置事务只读，设置超时时长，关闭自动提交等,并且把创建的事务信息绑定到<code>resources ThreadLocal</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareSynchronization</span><span class="params">(DefaultTransactionStatus status, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (status.isNewSynchronization()) &#123;</span><br><span class="line">      TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());</span><br><span class="line">      TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(</span><br><span class="line">            definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?</span><br><span class="line">                  definition.getIsolationLevel() : <span class="keyword">null</span>);</span><br><span class="line">      TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());</span><br><span class="line">      TransactionSynchronizationManager.setCurrentTransactionName(definition.getName());</span><br><span class="line">      TransactionSynchronizationManager.initSynchronization();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSynchronization</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isSynchronizationActive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Cannot activate transaction synchronization - already active&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    logger.trace(<span class="string">&quot;Initializing transaction synchronization&quot;</span>);</span><br><span class="line">    synchronizations.set(<span class="keyword">new</span> LinkedHashSet&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>prepareSynchronization</code>负责把事务相关信息设置到ThreadLocal中，并且初始化<code>TransactionSynchronization</code>的<code>LinkedHashSet</code>，这样我们我们通过<code>TransactionSynchronizationManager</code>加入一些回调方法的时候不会抛NPE，之所以使用<code>LinkedHashSet</code>是<code>TransactionSynchronizationManager</code>支持<code>Ordered接口</code>,<code>@Order注解</code>进行排序</p></li><li><p>如果是<code>SUPPORTS(支持当前事务,如果不存在，则以非事务方式执行)</code>,<code>NOT_SUPPORTED(不支持当前事务；始终以非事务方式执行)</code>,<code>NEVER(不支持当前事务，如果当前事务存在，则抛出异常)</code>那么不会开启事务，但是支持事务同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">   <span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">      <span class="comment">// log </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">   <span class="keyword">return</span> prepareTransactionStatus(def, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="存在事务的情况"><a href="#存在事务的情况" class="headerlink" title="存在事务的情况"></a>存在事务的情况</h5><ol><li><p>是如何判断是否存在事务的首先<code>doGetTransaction</code>方法会获取<code>resources ThreadLocal</code>中的事务信息，这个事务信息是在<code>doBegin</code>方法中绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doGetTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionManager.DataSourceTransactionObject txObject = <span class="keyword">new</span> DataSourceTransactionManager.DataSourceTransactionObject();</span><br><span class="line">    txObject.setSavepointAllowed(<span class="keyword">this</span>.isNestedTransactionAllowed());</span><br><span class="line">    <span class="comment">// 从threadLocal中获取事务资源</span></span><br><span class="line">    ConnectionHolder conHolder = (ConnectionHolder)TransactionSynchronizationManager.getResource(<span class="keyword">this</span>.obtainDataSource());</span><br><span class="line">    txObject.setConnectionHolder(conHolder, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> txObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用<code>isExistingTransaction</code>来判断是否存在事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExistingTransaction</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionManager.DataSourceTransactionObject txObject = (DataSourceTransactionManager.DataSourceTransactionObject)transaction;</span><br><span class="line">    <span class="keyword">return</span> txObject.hasConnectionHolder() &amp;&amp; txObject.getConnectionHolder().isTransactionActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样<code>doBegin</code>方法会设置<code>transactionActive</code>为true。<br>最后如果存在事务那么会执行下面的<code>handleExistingTransaction</code>来根据事务传播级别来创建事务</p></li><li><p>首先如果传播级别是<code>NEVER(不支持当前事务，如果当前事务存在，则抛出异常)</code>当前存在事务，那么抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">         <span class="string">&quot;Existing transaction found for transaction marked with propagation &#x27;never&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果传播级别是<code>NOT_SUPPORTED(不支持当前事务；始终以非事务方式执行)</code>那么不会开启事务，但是支持事务同步，并且会挂起当前事务，其中<code>prepareTransactionStatus</code>会初始化事务同步set,并且把当前事务的信息包装到<code>DefaultTransactionStatus</code>并返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">   <span class="comment">// log</span></span><br><span class="line">   Object suspendedResources = suspend(transaction);</span><br><span class="line">   <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">   <span class="comment">// 会初始化事务同步的set集合</span></span><br><span class="line">   <span class="keyword">return</span> prepareTransactionStatus(</span><br><span class="line">         definition, <span class="keyword">null</span>, <span class="keyword">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果传播级别是<code>RequireNew（创建一个新事务，如果存在事务则暂停当前事务）</code>会挂起当前事务，从<code>ThreadLocal</code>中解绑，然后开启新事务，并初始化<code>TransactionSynchronization</code>的set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">   <span class="comment">// log</span></span><br><span class="line">   <span class="comment">// 挂起事务</span></span><br><span class="line">   SuspendedResourcesHolder suspendedResources = suspend(transaction);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 开启事务</span></span><br><span class="line">      <span class="keyword">return</span> startTransaction(definition, transaction, debugEnabled, suspendedResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (RuntimeException | Error beginEx) &#123;</span><br><span class="line">      <span class="comment">// 将之前的事务恢复到ThreadLocal</span></span><br><span class="line">      resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">      <span class="keyword">throw</span> beginEx;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果传播级别是<code>Nested（如果当前事务存在，则在嵌套事务中执行）</code>,首先会判断是否允许嵌套事务，如果不允许那么抛出异常，通常<code>DataSourceTransactionManager</code>使用<code>savepoint</code>来实现嵌套事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">   <span class="comment">// 判断是否允许嵌套事务</span></span><br><span class="line">   <span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">      <span class="comment">// 抛出异常</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// ..log</span></span><br><span class="line">   <span class="comment">// 使用savepoint来执行嵌套事务</span></span><br><span class="line">   <span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">      <span class="comment">// Create savepoint within existing Spring-managed transaction,</span></span><br><span class="line">      <span class="comment">// through the SavepointManager API implemented by TransactionStatus.</span></span><br><span class="line">      <span class="comment">// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span></span><br><span class="line">      DefaultTransactionStatus status =</span><br><span class="line">            prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, <span class="keyword">false</span>, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 创建保存点</span></span><br><span class="line">      status.createAndHoldSavepoint();</span><br><span class="line">      <span class="keyword">return</span> status;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 这里是JTA使用XA实现分布式事务的逻辑</span></span><br><span class="line">      <span class="comment">// Nested transaction through nested begin and commit/rollback calls.</span></span><br><span class="line">      <span class="comment">// Usually only for JTA: Spring synchronization might get activated here</span></span><br><span class="line">      <span class="comment">// in case of a pre-existing JTA transaction.</span></span><br><span class="line">      <span class="keyword">return</span> startTransaction(definition, transaction, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>Connection#setSavepoint</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JdbcTransactionObjectSupport</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">createSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    ConnectionHolder conHolder = <span class="keyword">this</span>.getConnectionHolderForSavepoint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!conHolder.supportsSavepoints()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NestedTransactionNotSupportedException(<span class="string">&quot;Cannot create a nested transaction because savepoints are not supported by your JDBC driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (conHolder.isRollbackOnly()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CannotCreateTransactionException(<span class="string">&quot;Cannot create savepoint for transaction which is already marked as rollback-only&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> conHolder.createSavepoint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CannotCreateTransactionException(<span class="string">&quot;Could not create JDBC savepoint&quot;</span>, var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConnectionHolder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Savepoint <span class="title">createSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ++<span class="keyword">this</span>.savepointCounter;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getConnection().setSavepoint(<span class="string">&quot;SAVEPOINT_&quot;</span> + <span class="keyword">this</span>.savepointCounter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后如果是<code>Required(支持当前事务，如果当前不存在事务那么创建一个新事务) SUPPORTS(支持当前事务；如果不存在，则以非事务方式执行) MANDATORY（支持当前事务；如果当前不存在事务，则抛出异常）</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line"><span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>都不会产生新的事务。</p></li></ol><h4 id="prepareTransactionInfo包装事务信息并绑定到ThreadLocal"><a href="#prepareTransactionInfo包装事务信息并绑定到ThreadLocal" class="headerlink" title="prepareTransactionInfo包装事务信息并绑定到ThreadLocal"></a>prepareTransactionInfo包装事务信息并绑定到ThreadLocal</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createTransactionIfNecessary</span></span><br><span class="line"><span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">prepareTransactionInfo</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> TransactionAttribute txAttr, String joinpointIdentification,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="meta">@Nullable</span> TransactionStatus status)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装成TransactionInfo</span></span><br><span class="line">    TransactionInfo txInfo = <span class="keyword">new</span> TransactionInfo(tm, txAttr, joinpointIdentification);</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We need a transaction for this method...</span></span><br><span class="line">        <span class="comment">// log</span></span><br><span class="line">        <span class="comment">// The transaction manager will flag an error if an incompatible tx already exists.</span></span><br><span class="line">        txInfo.newTransactionStatus(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The TransactionInfo.hasTransaction() method will return false. We created it only</span></span><br><span class="line">        <span class="comment">// to preserve the integrity of the ThreadLocal stack maintained in this class.</span></span><br><span class="line">        <span class="comment">// log</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We always bind the TransactionInfo to the thread, even if we didn&#x27;t create</span></span><br><span class="line">    <span class="comment">// a new transaction here. This guarantees that the TransactionInfo stack</span></span><br><span class="line">    <span class="comment">// will be managed correctly even if no transaction was created by this aspect.</span></span><br><span class="line">    <span class="comment">// 绑定当前事务信息到ThreadLocal, 并记录之前的事务信息</span></span><br><span class="line">    txInfo.bindToThread();</span><br><span class="line">    <span class="keyword">return</span> txInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindToThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Expose current TransactionStatus, preserving any existing TransactionStatus</span></span><br><span class="line">    <span class="comment">// for restoration after this transaction is complete.</span></span><br><span class="line">    <span class="keyword">this</span>.oldTransactionInfo = transactionInfoHolder.get();</span><br><span class="line">    transactionInfoHolder.set(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会使用<code>oldTransactionInfo</code>记录之前的事务信息，并且绑定当前事务信息到<code>ThreadLocal</code>上，这样A事务方法调用B事务方法的时，能像栈一样先进后出。在<code>invokeWithinTransaction</code>调用完业务方法后，会调用<code>cleanupTransactionInfo</code>把<code>oldTransactionInfo</code>重写设置到<code>ThreadLocal</code>中，这意味着B方法执行结束，回到了A方法的调用栈中。</p><h4 id="回调业务逻辑InvocationCallback-proceedWithInvocation"><a href="#回调业务逻辑InvocationCallback-proceedWithInvocation" class="headerlink" title="回调业务逻辑InvocationCallback#proceedWithInvocation"></a>回调业务逻辑<code>InvocationCallback#proceedWithInvocation</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invokeWithinTransaction</span></span><br><span class="line">retVal = invocation.proceedWithInvocation();</span><br></pre></td></tr></table></figure><p>其实调用的是<code>MethodInvocation#proceed</code>,如果当前对象存在多层代理，比如先事务代理，再基于<code>@AspectJ</code>注解的方法调用时长统计，那么后面代理增强也会执行，具体逻辑在<code>ReflectiveMethodInvocation#proceed</code>方法中，如果还存在其他的拦截器链那么会继续执行拦截器中的逻辑，否则直接执行我们自己的业务逻辑代码。</p><h4 id="completeTransactionAfterThrowing-业务逻辑出现异常时的处理"><a href="#completeTransactionAfterThrowing-业务逻辑出现异常时的处理" class="headerlink" title="completeTransactionAfterThrowing 业务逻辑出现异常时的处理"></a>completeTransactionAfterThrowing 业务逻辑出现异常时的处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invokeWithinTransaction</span></span><br><span class="line">completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(<span class="meta">@Nullable</span> TransactionInfo txInfo, Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// log</span></span><br><span class="line">        <span class="comment">// 如果当前抛出的异常需要回滚</span></span><br><span class="line">        <span class="keyword">if</span> (txInfo.transactionAttribute != <span class="keyword">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用事务管理器的回滚方法</span></span><br><span class="line">                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向外抛出异常</span></span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">                <span class="comment">// log</span></span><br><span class="line">                ex2.initApplicationException(ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">                <span class="comment">// log </span></span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We don&#x27;t roll back on this exception.</span></span><br><span class="line">            <span class="comment">// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span></span><br><span class="line">            <span class="comment">// 当前异常不需要回滚</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, ex);</span><br><span class="line">                ex2.initApplicationException(ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException | Error ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>rollbackOn</code>取决于事务注解上面标注的在什么异常上回滚，在什么异常上不回滚，默认是在<code>RuntimeException</code>和<code>Error</code>上面才会回滚。</p><p>事务是如何回滚的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">            <span class="string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">   processRollback(defStatus, <span class="keyword">false</span>);<span class="comment">// 执行回滚策略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回滚策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="keyword">boolean</span> unexpected)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">boolean</span> unexpectedRollback = unexpected;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 回调事务同步的beforeCompletion方法</span></span><br><span class="line">         triggerBeforeCompletion(status);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果有保存点，一般是嵌套事务，回滚到保存点</span></span><br><span class="line">         <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">            <span class="comment">// log</span></span><br><span class="line">            status.rollbackToHeldSavepoint();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 如果是一个独立的事务like回滚</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">            <span class="comment">// log</span></span><br><span class="line">            doRollback(status);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Participating in larger transaction</span></span><br><span class="line">             <span class="comment">// 不是独立事务</span></span><br><span class="line">            <span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line">               <span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line">                  <span class="comment">// log</span></span><br><span class="line">                  doSetRollbackOnly(status);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// log</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// log</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Unexpected rollback only matters here if we&#x27;re asked to fail early</span></span><br><span class="line">            <span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">               unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">         triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Raise UnexpectedRollbackException if we had a global rollback-only marker</span></span><br><span class="line">      <span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line">               <span class="string">&quot;Transaction rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      cleanupAfterCompletion(status);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行回滚<code>DataSourceTransactionManager</code>是调用的<code>Connection#rollback</code>方法，这里首先会获取<code>ThreadLocal</code>中的<code>TransactionSynchronization</code>并且按照<code>@Order</code>和<code>Ordered</code>排序然后依次调用<code>beforeCompletion</code>,如果具备回滚点，那么直接回滚到保存点，如果是一个新事务，那么直接回滚，如果不是一个独立的事务，只是标记需要回滚，执行完这些后，还会回调<code>triggerAfterCompletion</code>,然后调用<code>TransactionSynchronization#afterCompletion</code>方法，然后调用<code>cleanupAfterCompletion</code>清理资源，并且恢复被挂起的线程。</p><h4 id="commitTransactionAfterReturning提交事务"><a href="#commitTransactionAfterReturning提交事务" class="headerlink" title="commitTransactionAfterReturning提交事务"></a>commitTransactionAfterReturning提交事务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invokeWithinTransaction</span></span><br><span class="line">commitTransactionAfterReturning(txInfo);</span><br></pre></td></tr></table></figure><p>具体逻辑在<code>processCommit</code>中进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// processCommit</span></span><br><span class="line"><span class="comment">// 钩子方法</span></span><br><span class="line">prepareForCommit(status);</span><br><span class="line"><span class="comment">// 回调事务同步器</span></span><br><span class="line">triggerBeforeCommit(status);</span><br><span class="line">triggerBeforeCompletion(status);</span><br><span class="line">beforeCompletionInvoked = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存在保存点，释放资源</span></span><br><span class="line"><span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">   <span class="comment">// log</span></span><br><span class="line">   unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">   status.releaseHeldSavepoint();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 独立事务直接提交</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">   <span class="comment">// log</span></span><br><span class="line">   unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">   doCommit(status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">   unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Throw UnexpectedRollbackException if we have a global rollback-only</span></span><br><span class="line"><span class="comment">// marker but still didn&#x27;t get a corresponding exception from commit.</span></span><br><span class="line"><span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line">         <span class="string">&quot;Transaction silently rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DataSourceTransactionManager</code>提交事务是执行的是<code>Connection#commit</code></p><p>同样完成只会还会调用<code>triggerAfterCommit</code>,<code>triggerAfterCompletion</code>并清理ThreadLocal中的内容，并且恢复被挂起的事务。</p><h3 id="事务同步回调接口TransactionSynchronization"><a href="#事务同步回调接口TransactionSynchronization" class="headerlink" title="事务同步回调接口TransactionSynchronization"></a>事务同步回调接口TransactionSynchronization</h3><img src="/2022/12/11/%E6%A1%86%E6%9E%B6/Spring/Spring%E4%BA%8B%E5%8A%A1/TransactionSynchronization.png" alt="image-20220828192354727" style="zoom:80%;"><p>其中<code>beforeCommit</code>,<code>beforeCompletion</code>,<code>aterCommit</code>，<code>afterCompletion</code>，只有当前事务是一个独立事务的时候才会回调，而且如果提交或者回滚的时候出现异常，<code>beforeCompletion</code>,<code>afterCompletion</code>也会被调用，我们可以通过<code>TransactionSynchronizationManager#registerSynchronization</code>注册回调的逻辑。</p><img src="/2022/12/11/%E6%A1%86%E6%9E%B6/Spring/Spring%E4%BA%8B%E5%8A%A1/registerSynchronization注册回调逻辑.png" alt="image-20220828193252799" style="zoom:80%;"><p>那么什么时候事务被视作时一个独立事务昵</p><ul><li>如果外部不存在一个事务，并且传播级别是<code>REQUIRED,REQUIRES_NEW,NESTED</code></li><li>如果外部存在一个事务，且传播级别为<code>REQUIRES_NEW</code></li><li>如果外部存在一个事务，且传播级别为嵌套事务，但是此时不是通过保存点来实现嵌套事务</li></ul><h2 id="事务失效的场景"><a href="#事务失效的场景" class="headerlink" title="事务失效的场景"></a>事务失效的场景</h2><ol><li><p><strong>方法内的自调用:</strong> Spring事务是<strong>基于AOP的</strong>， 只要使用代理对象调用某个方法时，Spring事务才能生效, 而在一个方法中调用使用<code>this.xx()</code>调用方法时，this并<strong>不是代理目对象</strong>，所以会导致事务失效。导致的方法上的注解<code>@Transcational</code>失效。</p><ul><li>解放办法1:把调用方法拆分到另外-个Bean中</li><li>解决办法2:自己注入自己</li><li>解决办法3: <code>AopContext.currentProxy()</code> + <code>@EnableAspectUAutoProxy(exposeProxy=true)</code></li></ul></li><li><p><strong>方法是<code>private</code>的</strong>: Spring事务 <a href="https://so.csdn.net/so/search?q=spring事务&spm=1001.2101.3001.7020">spring事务</a>的实现<code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是public，则<code>TransactionAttribute</code>返回null，即不支持事务。</p></li><li><p><strong>方法是final的</strong>:原因和private是一样的，因为spring事务底层实现使用了代理，aop，通过jdk的动态代理或者cglib，生成了代理类，在代理类中实现了事务功能，如果方法被final修饰，无法重写该方法，也就无法添加事务的功能了</p></li><li><p><strong>多个的线程调用方法</strong>:当<code>Mybatis</code>或<code>JdbcTemplate</code>执行SQL时， 会从<code>ThreadLocal</code>中去获取数据库连接对象, 如果开启事务的线程和执行SQL的线程是同一个,那么就能<br>拿到数据库连接对象，如果<strong>不是同一个线程</strong>,那就拿到不到数据库连接对象，这样，Mybatis或<code>ldbcTemplate</code>就会自 己去新建一个数据库连接用来执行SQL, 此数据库连<br>接的<code>autocommit</code>为true,那么执行完SQL就会提交,后续再抛异常也就不能再回滚之前已经提交了的SQL了。</p></li><li><p><strong>没加@Configuration注解:</strong>如果用<code>SpringBoot</code>基本没有这个问题， 但是如果用的Spring, 那么可能会有这个问题,这个问题的原因其实也是由于<code>Mybatis</code>或<code>JdbcTemplate</code>会从<code>ThreadLocal</code>中去获取数据库连接,但是<code>ThreadLocal</code>中存储的是一 个MAP, MAP的key为<code>DataSource</code>对象， value为连接对象， 而如果我们没有在<code>AppConfig</code>上添加<code>@Configuration</code>注解的话, 会导致MAP中存的<code>DataSource</code>对象和<code>Mybatis</code>和<code>JdbcTemplate</code>中的<code>DataSource</code>对象不相等， 从而也拿不到数据库连接，导致自己去创建数据库连接了。</p></li><li><p><strong>异常被吃掉</strong>:如果Spring事务没有捕获到异常，那么也就不会回滚了,默认情况下Spring会捕获<code>RuntimeException</code>和<code>Error</code>。</p></li><li><p><strong>类没有被Spring管理</strong></p></li><li><p><strong>数据库不支持事务</strong></p></li></ol><p>参考</p><p><a href="https://www.cnblogs.com/cuzzz/p/16633523.html">https://www.cnblogs.com/cuzzz/p/16633523.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是事务&quot;&gt;&lt;a href=&quot;#什么是事务&quot; class=&quot;headerlink&quot; title=&quot;什么是事务&quot;&gt;&lt;/a&gt;什么是事务&lt;/h2&gt;&lt;p&gt;事务：是数据库操作的最小单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起向系统提交，要么都执行，要么都不执行；事务是一组不可再分割的操作集合（工作逻辑单元）。&lt;/p&gt;
&lt;h3 id=&quot;事务是四大特性&quot;&gt;&lt;a href=&quot;#事务是四大特性&quot; class=&quot;headerlink&quot; title=&quot;事务是四大特性&quot;&gt;&lt;/a&gt;事务是四大特性&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;原子性（Atomicity）&lt;/strong&gt;:事务中所有操作是不可再分割的原子单元。事务中所有操作要么全部执行成功，要么全部执行失败。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性（Consistency）&lt;/strong&gt;:事务执行后，数据库状态与其他业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的连个账号余额之和应该是不变的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性（lsolation）&lt;/strong&gt;:隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久性（Durability）&lt;/strong&gt;:一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中，即使提交事务后，数据库马上崩溃，在数据库重启时，也必须能保证通过某种机制恢复数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;事务的隔离级别&quot;&gt;&lt;a href=&quot;#事务的隔离级别&quot; class=&quot;headerlink&quot; title=&quot;事务的隔离级别&quot;&gt;&lt;/a&gt;事务的隔离级别&lt;/h3&gt;&lt;p&gt;数据库事务的隔离级别有4种，由低到高分别为&lt;code&gt;Read uncommitted&lt;/code&gt; 、&lt;code&gt;Read committed&lt;/code&gt; 、&lt;code&gt;Repeatable read&lt;/code&gt; 、&lt;code&gt;Serializable&lt;/code&gt;。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读、事务丢失。&lt;/p&gt;
&lt;h4 id=&quot;并发操作中出现的问题&quot;&gt;&lt;a href=&quot;#并发操作中出现的问题&quot; class=&quot;headerlink&quot; title=&quot;并发操作中出现的问题&quot;&gt;&lt;/a&gt;并发操作中出现的问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;脏读:(读取了未提交的新事物，然后被回滚了)&lt;/strong&gt;&lt;br&gt;事务A读取了事务B中尚未提交的数据。如果事务B回滚，则A读取使用了错误的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不可重复读:(读取了提交的新事务，指更新操作)&lt;/strong&gt;&lt;br&gt;不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;幻读:(也是读取了提交的新事务，指增删操作)&lt;/strong&gt;&lt;br&gt;在事务A多次读取构成中，事务B对数据进行了新增操作，导致事务A多次读取的数据不一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;第一类事物丢失:(称为回滚丢失)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于第一类事物丢失，就是比如A和B同时在执行一个数据，然后B事物已经提交了，然后A事物回滚了，这样B事物的操作就因A事物回滚而丢失了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;第二类事物丢失:(提交覆盖丢失)&lt;/strong&gt;&lt;br&gt;对于第二类事物丢失，也称为覆盖丢失，就是A和B一起执行一个数据，两个同时取到一个数据，然后B事物首先提交，但是A事物加下来又提交，这样就覆盖了B事物.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;隔离级别&quot;&gt;&lt;a href=&quot;#隔离级别&quot; class=&quot;headerlink&quot; title=&quot;隔离级别&quot;&gt;&lt;/a&gt;隔离级别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Read uncommitted&lt;/code&gt;&lt;br&gt;读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。会产生脏读。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Read committed&lt;/code&gt;&lt;br&gt;读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。会产生不可重复读。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Repeatable read&lt;/code&gt;&lt;br&gt;重复读，就是在开始读取数据（事务开启)时，不再允许修改操作。可能会产生幻读。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;br&gt;Serializable是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP</title>
    <link href="http://yoursite.com/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/"/>
    <id>http://yoursite.com/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/</id>
    <published>2022-12-04T09:31:08.000Z</published>
    <updated>2022-12-11T15:17:11.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h2><p>AOP为<code>Aspect Oriented Programming</code>的缩写，意为：<strong>面向切面编程</strong>，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。 是一种新的模块化机制，用来描述分散在对象，类，或函数中的横切关注点，分离关注点使解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑代码中不在含义针对特定领域的代码调用，业务逻辑同特定领域问题的关系通过切面封装，维护，这样原本分散在整个应用程序中的变动可以很好地管理起来。</p><p>用人话说就是，通过切面完成特定逻辑（事务，入参出参日志等） 可以和业务逻辑（CRUD）抽离开，便于维护</p><ul><li><strong>Advice 通知</strong>：定义在连接点做什么，为切面增强提供植入接口。描述Spring AOP围绕方法调而注入的切面行为</li><li><strong>Pointcut切入点</strong>：切点决定Advice通知应该作用在哪个连接点，也就是通过<code>Poincut</code>来定义需要增强的方法集合，这些集合可以按照一定规则来完成，这种情况下，<code>Pointcut</code>意味着标识方法（比如事务切面定义了事务注解方法上生效）切入点是一些列织入逻辑代码的连接点集合</li><li><strong>Advisor通知器</strong>：整合Advice 和 Pointcut，定义应该在哪个关注点使用什么通知进行增强。</li></ul><h2 id="AOP重要接口和编程体验"><a href="#AOP重要接口和编程体验" class="headerlink" title="AOP重要接口和编程体验"></a>AOP重要接口和编程体验</h2><p>我们先抛弃Spring框架，利用<code>Spring AOP</code>中存在的工具实现AOP增强。</p><h3 id="基于Advice"><a href="#基于Advice" class="headerlink" title="基于Advice"></a>基于Advice</h3><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/Advice.png" alt="image-20220824154409542"></p><p><code>Advice</code>接口的实现有<code>AfterAdvice后置通知</code>，<code>Beforeadvice前置通知</code>，<code>MethodInterceptor方法拦截器</code>可以看做是环绕通知。</p><ol><li><p>服务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义advice 环绕通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my advice before&quot;</span>);</span><br><span class="line">        <span class="comment">// 方法执行</span></span><br><span class="line">        Object res = invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;my advice after&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代理工程</span></span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        AopService aopService = <span class="keyword">new</span> AopService();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置需要代理的对象</span></span><br><span class="line">        proxyFactory.setTarget(aopService);</span><br><span class="line">        proxyFactory.addAdvice(<span class="keyword">new</span> MyAdvice());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成代理对象</span></span><br><span class="line">        AopService proxy = (AopService)proxyFactory.getProxy();</span><br><span class="line">        proxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">my advice before</span></span><br><span class="line"><span class="comment">service doSomething</span></span><br><span class="line"><span class="comment">my advice after</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="基于Advisor"><a href="#基于Advisor" class="headerlink" title="基于Advisor"></a>基于Advisor</h3><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/Advisor.png" alt="image-20220824162331408"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代理工程</span></span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        AopService aopService = <span class="keyword">new</span> AopService();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// advisor</span></span><br><span class="line">        DefaultPointcutAdvisor advisor = <span class="keyword">new</span> DefaultPointcutAdvisor();</span><br><span class="line">        <span class="comment">// 根据名称匹配方法的pointcut</span></span><br><span class="line">        NameMatchMethodPointcut pointcut = <span class="keyword">new</span> NameMatchMethodPointcut();</span><br><span class="line">        <span class="comment">// 指定只有doSomething才增强</span></span><br><span class="line">        pointcut.setMappedName(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">        advisor.setPointcut(pointcut);</span><br><span class="line">        advisor.setAdvice(<span class="keyword">new</span> MyAdvice());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置需要代理的对象</span></span><br><span class="line">        proxyFactory.setTarget(aopService);</span><br><span class="line">        proxyFactory.addAdvice(<span class="keyword">new</span> MyAdvice());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成代理对象</span></span><br><span class="line">        AopService proxy = (AopService)proxyFactory.getProxy();</span><br><span class="line">        proxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有名称匹配的方法才生效。</p><p><code>Advisor</code>接口具备方法<code>Advice getAdvice()</code>来获取通知。<code>PointcutAdvisor</code>实现了<code>Advisor</code>并且新增方法<code>Pointcut getPointcut()</code>来获取切入点的定义。<code>Pointcut</code>接口定义了两个方法<code>ClassFilter getClassFilter()</code>,<code>MethodMatcher getMethodMatcher()</code>分别是对类和方法的筛选，来决定Advise是不是应该作用于当前类。</p><h2 id="ProxyFactory-和-ProxyFactoryBean"><a href="#ProxyFactory-和-ProxyFactoryBean" class="headerlink" title="ProxyFactory 和 ProxyFactoryBean"></a>ProxyFactory 和 ProxyFactoryBean</h2><h3 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h3><p>类图</p><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/ProxyFactory%E7%B1%BB%E5%9B%BE.png" alt="image-20221204222328470"></p><p><code>TargetSource</code> 用于获取 AOP 调用的当前“目标”</p><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/TargetSource%E7%B1%BB%E5%9B%BE.png" alt="image-20221204222936584"></p><p><code>getTargetClass</code>可以获取被代理对象的类型，<code>getTarget</code>可以获取被代理对象，<code>HotSwappableTargetSource</code>中的swap方法可以替换掉代理对象，<code>Spring Aop</code>常用的是<code>SingletonTargetSource</code>它持有了原始的被代理对象。</p><h3 id="ProxyFactory是如何创建代理对象的"><a href="#ProxyFactory是如何创建代理对象的" class="headerlink" title="ProxyFactory是如何创建代理对象的"></a>ProxyFactory是如何创建代理对象的</h3><p>在<code>ProxyFactory</code>类中有个<code>getProxy()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createAopProxy()</code>方法通过<code>getAopProxyFactory()</code>来创建代理对象，一般默认是<code>AopProxyFactory</code>的实现类<code>DefaultAopProxyFactory</code>。</p><h4 id="DefaultAopProxyFactory-createAopProxy"><a href="#DefaultAopProxyFactory-createAopProxy" class="headerlink" title="DefaultAopProxyFactory # createAopProxy"></a>DefaultAopProxyFactory # createAopProxy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">   <span class="comment">// Spring支持优化 设置了代理目标类 用户没有指定代理的接口</span></span><br><span class="line">   <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">      Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">      <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">               <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 代理目标类是一个接口 或者说已经被JDK动态代理了</span></span><br><span class="line">      <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">         <span class="comment">// 使用JDK动态代理</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 使用cglib动态代理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 使用JDK动态代理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里生成的<code>AopProxy</code> 才是负责生成代理对象的，其中spring内置了两种策略——<strong>JDK动态代理</strong>和<strong>CGLIB动态代理</strong>。</p><p>只有设置了需要代理目标类，或者说没有指定代理的接口，且代理目标类不是接口，不是已经被JDK动态代理后的类，那么才会使用CGLIB进行动态代理。</p><h4 id="AopProxy"><a href="#AopProxy" class="headerlink" title="AopProxy"></a>AopProxy</h4><p><code>AopPorxy</code>有2个实现类<code>CglibAopProxy</code>和<code>JdkDynamicAopProxy</code></p><h5 id="JdkDynamicAopProxy"><a href="#JdkDynamicAopProxy" class="headerlink" title="JdkDynamicAopProxy"></a><code>JdkDynamicAopProxy</code></h5><p><code>JdkDynamicAopProxy</code>还实现了<code>InvocationHandler</code></p><ul><li><p>生成代理对象<code>getProxy()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Creating JDK dynamic proxy: &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">   findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">   <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>); <span class="comment">//this只自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>invoke()</code><br>首先是对<code>equals</code>,<code>hashCode</code>的处理，目标对象声明了让目标对象执行，反之调用<code>JdkDynamicAopProxy</code>对应的方法，其次是如果配置中设置了暴露代理对象，那么将其放入到<code>AopContext</code>中的<code>ThreadLocal</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">   <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">   oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">   setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后获取当前对象的拦截器链，如果拦截器链为空 那么直接反射调用目标对象的方法。如果存在拦截器链那么new 一个<code>ReflectiveMethodInvocation</code>利用反射依次执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">target = targetSource.getTarget();</span><br><span class="line">Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether we have any advice. If we don&#x27;t, we can fallback on direct</span></span><br><span class="line"><span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">   <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">   <span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">   <span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">   Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">   retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">   MethodInvocation invocation =</span><br><span class="line">         <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">   <span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">   retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring只支持方法拦截器<code>MethodInterceptor</code>进行代理增强，对于Advise都会适配成<code>MethodInterceptor</code>,Spring采用适配器模式，具体的适配器如下</p><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/AdvisorAdapter%E7%B1%BB%E5%9B%BE.png" alt="image-20220824172451573"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//支持什么Advise被适配</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适配</span></span><br><span class="line">    <span class="function">MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring遍历每一个Advise责任链模式依次找到<code>AdvisorAdapter</code>然后调用适配方法得到一个<code>MethodInterceptor</code>，下面是适配成的<code>MethodInterceptor</code>。</p><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/MethodInterceptor.png" alt="image-20220824172904504"></p></li></ul><h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h5><p>设置<code>CallBack</code></p><p>首先<code>new</code> 一个<code>Enhancer</code>设置父类为被代理对象的类型，这里会将<code>Aop</code>的逻辑转变为一个<code>DynamicAdvisedInterceptor</code>，equals和hashCode方法也有对应的<code>callBack</code></p><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/Callback.png" alt="image-20220824174533939"></p><p>注意这里的<code>MethodInterceptor</code>是<code>org.springframework.cglib.proxy.MethodInterceptor</code>,其中的intercept 方法的逻辑和JDK动态代理的invoke类似，都是链式调用。</p><h3 id="ProxyFactoryBean"><a href="#ProxyFactoryBean" class="headerlink" title="ProxyFactoryBean"></a>ProxyFactoryBean</h3><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/ProxyFactoryBean%E7%B1%BB%E5%9B%BE.png" alt="image-20220824175124978"></p><p><code>ProxyFactoryBean</code>创建代理对象的逻辑和<code>ProxyFactory</code>类似，但是<code>ProxyFactoryBean</code>是一个<code>FactoryBean</code>，我们可以利用这一点在bean初始化的时候生成一个代理对象</p><p>使用<code>ProxyFactoryBean</code>或其他IOC类来创建AOP代理的最重要好处之一是，这意味着<strong>advice和切入点也可以由IoC管理</strong>。<code>ProxyFactoryBean</code>的<code>getObject()</code>将创建一个<strong>包装目标对象的AOP代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 初始化advisor链条</span></span><br><span class="line">   initializeAdvisorChain();</span><br><span class="line">   <span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line">      <span class="keyword">return</span> getSingletonInstance();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newPrototypeInstance();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getSingletonInstance()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title">getSingletonInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.singletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 没有创建过单例对象 进行创建</span></span><br><span class="line">      <span class="keyword">this</span>.targetSource = freshTargetSource();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == <span class="number">0</span> &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class="line">         <span class="comment">// Rely on AOP infrastructure to tell us what interfaces to proxy.</span></span><br><span class="line">         Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">         <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="string">&quot;Cannot determine target class for proxy&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class="keyword">this</span>.proxyClassLoader));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Initialize the shared singleton instance.</span></span><br><span class="line">      <span class="keyword">super</span>.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">      <span class="comment">// 最终还是通过AopProxyFactory创建AopProxy生成代理对象</span></span><br><span class="line">      <span class="keyword">this</span>.singletonInstance = getProxy(createAopProxy());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-AOP-和IOC是如何结合起来的"><a href="#Spring-AOP-和IOC是如何结合起来的" class="headerlink" title="Spring AOP 和IOC是如何结合起来的"></a>Spring AOP 和IOC是如何结合起来的</h2><p>我们在使用<code>Spring AOP</code>的时候会在启动类上加一个<code>@EnableAspectJAutoProxy</code>注解，这个注解<code>@Import(AspectJAutoProxyRegistrar.class)</code>导入了<code>AspectJAutoProxyRegistrar</code>,这个类实现了<code>ImportBeanDefinitionRegistrar</code>,Spring容器会调用其<code>registerBeanDefinitions</code>方法为我们注入<code>BeanDefinition</code>,后续会实例化一个<code>AnnotationAwareAspectJAutoProxyCreator</code>类型的bean，它是Spring IOC和AOP结合的关键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Register, escalate, and configure the AspectJ auto proxy creator based on the value</span></span><br><span class="line"><span class="comment">    * of the @&#123;<span class="doctag">@link</span> EnableAspectJAutoProxy#proxyTargetClass()&#125; attribute on the importing</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">         AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注册AnnotationAutoProxyCreator</span></span><br><span class="line">      AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">      AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">            AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);</span><br><span class="line">      <span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;proxyTargetClass&quot;</span>)) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">&quot;exposeProxy&quot;</span>)) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AnnotationAwareAspectJAutoProxyCreator类结构图"><a href="#AnnotationAwareAspectJAutoProxyCreator类结构图" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator类结构图"></a><code>AnnotationAwareAspectJAutoProxyCreator</code>类结构图</h3><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/AnnotationAwareAspectJAutoProxyCreator%E7%B1%BB%E5%9B%BE.png" alt="image-20220824180746690"></p><p>这其中最为关键的必然是<code>AnnotationAwareAspectJAutoProxyCreator</code>，它是一个<code>BeanPostProcessor</code>,从而在Spring 回调<code>postProcessAfterInitialization</code>对bean进行代理的增强,并且它实现了<code>SmartInstantiationAwareBeanPostProcessor</code> Spring容器创建bean的时候如果出现了循环依赖那么会调用到<code>getEarlyBeanReference</code>,在这个方法里面同样也会进行<code>aop</code>的增强</p><ul><li><p><code>AbstractAutoProxyCreator</code> 实现了<code>SmartInstantiationAwareBeanPostProcessor</code>是一个bean后置处理器，使用 AOP 代理包装每个符合条件的 bean，在调用 bean 本身之前<strong>委托给指定的拦截器</strong>，AOP代理发生的地方。</p></li><li><p><code>AbstractAdvisorAutoProxyCreator</code></p><p>为了每一个Bean找到合适的<code>Advisor</code>并且进行，如果<code>Advisor</code>标注了<code>@Order</code>或者说实现了<code>Ordered</code>接口那么会进行排序。</p></li><li><p><code>AspectJAwareAdvisorAutoProxyCreator</code></p><p><code>AbstractAdvisorAutoProxyCreator</code>子类，对一个切面中的多个Advisor进行优先级排序</p></li><li><p><code>AnnotationAwareAspectJAutoProxyCreator</code></p><p><code>AspectJAwareAdvisorAutoProxyCreator</code>的子类，会将容器中标注了<code>@AspectJ</code>注解的类解析成<code>Advisor</code>(整合<code>Advice</code> 和 <code>Pointcut</code>，定义应该使用哪个通知器并在哪个关注点使用它)</p></li></ul><h3 id="AbstractAutoProxyCreator的Aop增强"><a href="#AbstractAutoProxyCreator的Aop增强" class="headerlink" title="AbstractAutoProxyCreator的Aop增强"></a><code>AbstractAutoProxyCreator</code>的Aop增强</h3><h4 id="getEarlyBeanReference"><a href="#getEarlyBeanReference" class="headerlink" title="getEarlyBeanReference"></a>getEarlyBeanReference</h4><p>在Spring进行bean的实例化后， 在bean创建完成后会向三级缓存提添加单例工厂，而此时三级缓存的出现特意为了解决有AOP代理时循环依赖问题的，<code>getEarlyBeanReference</code>会对bean使用<code>SmartInstantiationAwareBeanPostProcessor</code>的实现类进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="comment">// addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AbstractAutoProxyCreator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">   Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">   <span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);<span class="comment">// 在map里面放入key和原始对象</span></span><br><span class="line">   <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<span class="comment">//进行aop代理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在bean实例化、填充属性后，初始bean时会调用<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>的方法，而对此时的AOP来说就进行了重要的一环<code>wrapIfNecessary</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">         <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于有AOP的对象，会在实例化后，就直接创建出代理对象并返回，<strong>但是这时，代理对象是没有初始化过的，是不可用的，所以Spring在创建代理时，持有了目标对象bean的引用</strong></p><h4 id="wrapIfNecessary"><a href="#wrapIfNecessary" class="headerlink" title="wrapIfNecessary"></a>wrapIfNecessary</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 如果已经代理过就不代理</span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果是基础组件类似于Advise、Pointcut、Advisor、AopInfrastructureBean对象也不代理</span></span><br><span class="line">   <span class="comment">// 应该跳过的也不代理</span></span><br><span class="line">   <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">   <span class="comment">// 找到当前bean对象合适的Advise和Advisor</span></span><br><span class="line">   Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">      <span class="comment">// 创建代理</span></span><br><span class="line">      Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">      <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">      <span class="keyword">return</span> proxy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>shouldSkip</code>被<code>AspectJAwareAdvisorAutoProxyCreator</code>重写，如果<code>Advisor</code>是<code>AspectJPointcutAdvisor</code>并且切面名称和bean名称相同那么会跳过，这应该是我们标注<code>@Aspect</code>的时候需要保证这个类会被Spring加入到容器，所有需要加<code>@Componet</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br></pre></td></tr></table></figure><h5 id="找到所有合适的advice-和advisor"><a href="#找到所有合适的advice-和advisor" class="headerlink" title="找到所有合适的advice 和advisor"></a>找到所有合适的advice 和advisor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 找到所有的advisor</span></span><br><span class="line">   List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">   <span class="comment">// 找到适用于当前bean的advisor</span></span><br><span class="line">   List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">   <span class="comment">// 子类扩展</span></span><br><span class="line">   extendAdvisors(eligibleAdvisors);</span><br><span class="line">   <span class="comment">// 排序</span></span><br><span class="line">   <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">      eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>findCandidateAdvisors</code>方法会找到容器中所以的<code>Advisor</code>类型的bean，<code>AnnotationAwareAspectJAutoProxyCreator</code>进行了重写，它还会把所以标注了<code>@Aspect</code>注解的bean中的增强逻辑封装成<code>Advisor</code></li><li><code>findAdvisorsThatCanApply</code>这个方法内部逻辑基本上就是调用<code>PointcutAdvisor</code>获取类过滤器，方法匹配器进行匹配。</li><li><code>sortAdvisors</code> 这里默认是通过@Order注解，或者Ordered接口进行排序，但是<code>AspectJAwareAdvisorAutoProxyCreator</code>进行了重写，因为它需要对同一个标注@Aspect切面里面的前置后置等进行排序</li></ul><h5 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="meta">@Nullable</span> Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">      AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">   proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//这里的ProxyTargetClass 来自上面的copyFrom 取决于EnableAspectJAutoProxy注解的proxyTargetClass</span></span><br><span class="line">   <span class="comment">//proxyTargetClass 表示是否使用基于CGLIB子类的代理</span></span><br><span class="line">   <span class="keyword">if</span> (proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">      <span class="comment">// Explicit handling of JDK proxy targets (for introduction advice scenarios)</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (Proxy.isProxyClass(beanClass)) &#123;</span><br><span class="line">         <span class="comment">// Must allow for introductions; can&#x27;t just set interfaces to the proxy&#x27;s interfaces only.</span></span><br><span class="line">         <span class="comment">// 必须允许介绍；不能仅将接口设置为代理的接口。</span></span><br><span class="line">         <span class="keyword">for</span> (Class&lt;?&gt; ifc : beanClass.getInterfaces()) &#123;</span><br><span class="line">            proxyFactory.addInterface(ifc);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// No proxyTargetClass flag enforced, let&#x27;s apply our default checks...</span></span><br><span class="line">      <span class="comment">// shouldProxyTargetClass 方法就是去BeanFactory中看当前bean的BeanDefinition中是否存在AutoProxy.PRESERVE_TARGET_CLASS_ATTRIBUTE=trued的attribute，当我们手动注入bean的时候可以使用这个强制让当前bean使用CGLIB增强</span></span><br><span class="line">      <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">         proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 获取当前类中非Spring回调（InitializingBean，DisposableBean，Aware）类型的接口，且如果接口的方法大于0，那么会把接口类型加入到proxyFactory中，否则设置ProxyTargetClass（没有接口那么没办法使用JDK动态代理）</span></span><br><span class="line">         evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 主要是把上面找到的advise 适配成Advisor。调用的是advisorAdapterRegistry的wrap方法</span></span><br><span class="line">   Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">   proxyFactory.addAdvisors(advisors);</span><br><span class="line">   <span class="comment">// 这里的targetSource是SingletonTargetSource</span></span><br><span class="line">   proxyFactory.setTargetSource(targetSource);</span><br><span class="line">   <span class="comment">//留给子类扩展的方法</span></span><br><span class="line">   customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">   proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">   <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">      proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//生成代理对象</span></span><br><span class="line">   <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实和我们上面的<code>Aop</code>编程体验中基于<code>Advisor</code>类似，最后都是<code>AopProxy</code>创建代理对象</p><h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p><code>AnnotationAwareAspectJAutoProxyCreator</code>会将@Aspect注解类解析成<code>Advisor</code>，下面我们重点看下<code>AnnotationAwareAspectJAutoProxyCreator</code>是怎么将@Aspect注解类解析成<code>Advisor</code>的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line">   List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">   <span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 找到容器中所有的bean，如果bean标注了@Aspect注解就处理</span></span><br><span class="line">      advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BeanFactoryAspectJAdvisorsBuilder</code>，它会遍历所有bean，并调用<code>isAspect</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAspect</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasAspectAnnotation</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (AnnotationUtils.findAnnotation(clazz, Aspect.class) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用<code>ReflectiveAspectJAdvisorFactory</code>的<code>getAdvisors</code>方法将其适配成多个<code>Advisor</code>，会遍历每一个没有标注<code>@Pointcut</code>的方法，然后获取<code>@Around, @Before, @After, @AfterReturning, @AfterThrowing</code>(如果没有那么直接返回)然后获取<code>value</code>中的内容包装成<code>AspectJExpressionPointcut</code>(AspectJ表达式pointcut)，然后包装成<code>InstantiationModelAwarePointcutAdvisorImpl</code>在这个类中会把对应注解的方法封装成对应的<code>AbstractAspectJAdvice</code>的子类</p><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/AbstractAspectJAdvice.png" alt="image-20220824191958027"></p><p>调用对应方法依旧采用反射，其子类在合适的实际进行调用。</p><p>参考：</p><p><a href="https://www.cnblogs.com/cuzzz/p/16621320.html">https://www.cnblogs.com/cuzzz/p/16621320.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;AOP概述&quot;&gt;&lt;a href=&quot;#AOP概述&quot; class=&quot;headerlink&quot; title=&quot;AOP概述&quot;&gt;&lt;/a&gt;AOP概述&lt;/h2&gt;&lt;p&gt;AOP为&lt;code&gt;Aspect Oriented Programming&lt;/code&gt;的缩写，意为：&lt;strong&gt;面向切面编程&lt;/strong&gt;，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。 是一种新的模块化机制，用来描述分散在对象，类，或函数中的横切关注点，分离关注点使解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑代码中不在含义针对特定领域的代码调用，业务逻辑同特定领域问题的关系通过切面封装，维护，这样原本分散在整个应用程序中的变动可以很好地管理起来。&lt;/p&gt;
&lt;p&gt;用人话说就是，通过切面完成特定逻辑（事务，入参出参日志等） 可以和业务逻辑（CRUD）抽离开，便于维护&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Advice 通知&lt;/strong&gt;：定义在连接点做什么，为切面增强提供植入接口。描述Spring AOP围绕方法调而注入的切面行为&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pointcut切入点&lt;/strong&gt;：切点决定Advice通知应该作用在哪个连接点，也就是通过&lt;code&gt;Poincut&lt;/code&gt;来定义需要增强的方法集合，这些集合可以按照一定规则来完成，这种情况下，&lt;code&gt;Pointcut&lt;/code&gt;意味着标识方法（比如事务切面定义了事务注解方法上生效）切入点是一些列织入逻辑代码的连接点集合&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Advisor通知器&lt;/strong&gt;：整合Advice 和 Pointcut，定义应该在哪个关注点使用什么通知进行增强。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;AOP重要接口和编程体验&quot;&gt;&lt;a href=&quot;#AOP重要接口和编程体验&quot; class=&quot;headerlink&quot; title=&quot;AOP重要接口和编程体验&quot;&gt;&lt;/a&gt;AOP重要接口和编程体验&lt;/h2&gt;&lt;p&gt;我们先抛弃Spring框架，利用&lt;code&gt;Spring AOP&lt;/code&gt;中存在的工具实现AOP增强。&lt;/p&gt;
&lt;h3 id=&quot;基于Advice&quot;&gt;&lt;a href=&quot;#基于Advice&quot; class=&quot;headerlink&quot; title=&quot;基于Advice&quot;&gt;&lt;/a&gt;基于Advice&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/Advice.png&quot; alt=&quot;image-20220824154409542&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Advice&lt;/code&gt;接口的实现有&lt;code&gt;AfterAdvice后置通知&lt;/code&gt;，&lt;code&gt;Beforeadvice前置通知&lt;/code&gt;，&lt;code&gt;MethodInterceptor方法拦截器&lt;/code&gt;可以看做是环绕通知。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;服务类&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AopService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;service doSomething&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自定义advice 环绕通知&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyAdvice&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MethodInterceptor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MethodInvocation invocation)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;my advice before&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 方法执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object res = invocation.proceed();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;my advice after&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;客户端&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Client&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 代理工程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ProxyFactory proxyFactory = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ProxyFactory();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 目标对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AopService aopService = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AopService();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 设置需要代理的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        proxyFactory.setTarget(aopService);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        proxyFactory.addAdvice(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyAdvice());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 生成代理对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AopService proxy = (AopService)proxyFactory.getProxy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        proxy.doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;my advice before&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;service doSomething&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;my advice after&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
</feed>
