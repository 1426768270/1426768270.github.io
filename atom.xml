<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>naive的博客</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-12-04T15:09:15.319Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>naive</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring AOP</title>
    <link href="http://yoursite.com/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/"/>
    <id>http://yoursite.com/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/</id>
    <published>2022-12-04T09:31:08.000Z</published>
    <updated>2022-12-04T15:09:15.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOP概述"><a href="#AOP概述" class="headerlink" title="AOP概述"></a>AOP概述</h2><p>AOP为<code>Aspect Oriented Programming</code>的缩写，意为：<strong>面向切面编程</strong>，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。 是一种新的模块化机制，用来描述分散在对象，类，或函数中的横切关注点，分离关注点使解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑代码中不在含义针对特定领域的代码调用，业务逻辑同特定领域问题的关系通过切面封装，维护，这样原本分散在整个应用程序中的变动可以很好地管理起来。</p><p>用人话说就是，通过切面完成特定逻辑（事务，入参出参日志等） 可以和业务逻辑（CRUD）抽离开，便于维护</p><ul><li><strong>Advice 通知</strong>：定义在连接点做什么，为切面增强提供植入接口。描述Spring AOP围绕方法调而注入的切面行为</li><li><strong>Pointcut切入点</strong>：切点决定Advice通知应该作用在哪个连接点，也就是通过<code>Poincut</code>来定义需要增强的方法集合，这些集合可以按照一定规则来完成，这种情况下，<code>Pointcut</code>意味着标识方法（比如事务切面定义了事务注解方法上生效）切入点是一些列织入逻辑代码的连接点集合</li><li><strong>Advisor通知器</strong>：整合Advice 和 Pointcut，定义应该在哪个关注点使用什么通知进行增强。</li></ul><h2 id="AOP重要接口和编程体验"><a href="#AOP重要接口和编程体验" class="headerlink" title="AOP重要接口和编程体验"></a>AOP重要接口和编程体验</h2><p>我们先抛弃Spring框架，利用<code>Spring AOP</code>中存在的工具实现AOP增强。</p><h3 id="基于Advice"><a href="#基于Advice" class="headerlink" title="基于Advice"></a>基于Advice</h3><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/Advice.png" alt="image-20220824154409542"></p><p><code>Advice</code>接口的实现有<code>AfterAdvice后置通知</code>，<code>Beforeadvice前置通知</code>，<code>MethodInterceptor方法拦截器</code>可以看做是环绕通知。</p><ol><li><p>服务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service doSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义advice 环绕通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my advice before&quot;</span>);</span><br><span class="line">        <span class="comment">// 方法执行</span></span><br><span class="line">        Object res = invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;my advice after&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代理工程</span></span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        AopService aopService = <span class="keyword">new</span> AopService();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置需要代理的对象</span></span><br><span class="line">        proxyFactory.setTarget(aopService);</span><br><span class="line">        proxyFactory.addAdvice(<span class="keyword">new</span> MyAdvice());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成代理对象</span></span><br><span class="line">        AopService proxy = (AopService)proxyFactory.getProxy();</span><br><span class="line">        proxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">my advice before</span></span><br><span class="line"><span class="comment">service doSomething</span></span><br><span class="line"><span class="comment">my advice after</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="基于Advisor"><a href="#基于Advisor" class="headerlink" title="基于Advisor"></a>基于Advisor</h3><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/Advisor.png" alt="image-20220824162331408"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 代理工程</span></span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        AopService aopService = <span class="keyword">new</span> AopService();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// advisor</span></span><br><span class="line">        DefaultPointcutAdvisor advisor = <span class="keyword">new</span> DefaultPointcutAdvisor();</span><br><span class="line">        <span class="comment">// 根据名称匹配方法的pointcut</span></span><br><span class="line">        NameMatchMethodPointcut pointcut = <span class="keyword">new</span> NameMatchMethodPointcut();</span><br><span class="line">        <span class="comment">// 指定只有doSomething才增强</span></span><br><span class="line">        pointcut.setMappedName(<span class="string">&quot;doSomething&quot;</span>);</span><br><span class="line">        advisor.setPointcut(pointcut);</span><br><span class="line">        advisor.setAdvice(<span class="keyword">new</span> MyAdvice());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置需要代理的对象</span></span><br><span class="line">        proxyFactory.setTarget(aopService);</span><br><span class="line">        proxyFactory.addAdvice(<span class="keyword">new</span> MyAdvice());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成代理对象</span></span><br><span class="line">        AopService proxy = (AopService)proxyFactory.getProxy();</span><br><span class="line">        proxy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有名称匹配的方法才生效。</p><p><code>Advisor</code>接口具备方法<code>Advice getAdvice()</code>来获取通知。<code>PointcutAdvisor</code>实现了<code>Advisor</code>并且新增方法<code>Pointcut getPointcut()</code>来获取切入点的定义。<code>Pointcut</code>接口定义了两个方法<code>ClassFilter getClassFilter()</code>,<code>MethodMatcher getMethodMatcher()</code>分别是对类和方法的筛选，来决定Advise是不是应该作用于当前类。</p><h2 id="ProxyFactory-和-ProxyFactoryBean"><a href="#ProxyFactory-和-ProxyFactoryBean" class="headerlink" title="ProxyFactory 和 ProxyFactoryBean"></a>ProxyFactory 和 ProxyFactoryBean</h2><h3 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h3><p>类图</p><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/ProxyFactory%E7%B1%BB%E5%9B%BE.png" alt="image-20221204222328470"></p><p><code>TargetSource</code> 用于获取 AOP 调用的当前“目标”</p><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/TargetSource%E7%B1%BB%E5%9B%BE.png" alt="image-20221204222936584"></p><p><code>getTargetClass</code>可以获取被代理对象的类型，<code>getTarget</code>可以获取被代理对象，<code>HotSwappableTargetSource</code>中的swap方法可以替换掉代理对象，<code>Spring Aop</code>常用的是<code>SingletonTargetSource</code>它持有了原始的被代理对象。</p><h3 id="ProxyFactory是如何创建代理对象的"><a href="#ProxyFactory是如何创建代理对象的" class="headerlink" title="ProxyFactory是如何创建代理对象的"></a>ProxyFactory是如何创建代理对象的</h3><p>在<code>ProxyFactory</code>类中有个<code>getProxy()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> createAopProxy().getProxy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createAopProxy()</code>方法通过<code>getAopProxyFactory()</code>来创建代理对象，一般默认是<code>AopProxyFactory</code>的实现类<code>DefaultAopProxyFactory</code>。</p><h4 id="DefaultAopProxyFactory-createAopProxy"><a href="#DefaultAopProxyFactory-createAopProxy" class="headerlink" title="DefaultAopProxyFactory # createAopProxy"></a>DefaultAopProxyFactory # createAopProxy</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">   <span class="comment">// Spring支持优化 设置了代理目标类 用户没有指定代理的接口</span></span><br><span class="line">   <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">      Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">      <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">               <span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 代理目标类是一个接口 或者说已经被JDK动态代理了</span></span><br><span class="line">      <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">         <span class="comment">// 使用JDK动态代理</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 使用cglib动态代理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 使用JDK动态代理</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里生成的<code>AopProxy</code> 才是负责生成代理对象的，其中spring内置了两种策略——<strong>JDK动态代理</strong>和<strong>CGLIB动态代理</strong>。</p><p>只有设置了需要代理目标类，或者说没有指定代理的接口，且代理目标类不是接口，不是已经被JDK动态代理后的类，那么才会使用CGLIB进行动态代理。</p><h4 id="AopPorxy"><a href="#AopPorxy" class="headerlink" title="AopPorxy"></a>AopPorxy</h4><p><code>AopPorxy</code>有2个实现类<code>CglibAopProxy</code>和<code>JdkDynamicAopProxy</code></p><h5 id="JdkDynamicAopProxy"><a href="#JdkDynamicAopProxy" class="headerlink" title="JdkDynamicAopProxy"></a><code>JdkDynamicAopProxy</code></h5><p><code>JdkDynamicAopProxy</code>还实现了<code>InvocationHandler</code></p><ul><li><p>生成代理对象<code>getProxy()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Creating JDK dynamic proxy: &quot;</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">   &#125;</span><br><span class="line">   Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">   findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">   <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>); <span class="comment">//this只自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>invoke()</code><br>首先是对<code>equals</code>,<code>hashCode</code>的处理，目标对象声明了让目标对象执行，反之调用<code>JdkDynamicAopProxy</code>对应的方法，其次是如果配置中设置了暴露代理对象，那么将其放入到<code>AopContext</code>中的<code>ThreadLocal</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">   <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">   oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">   setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后获取当前对象的拦截器链，如果拦截器链为空 那么直接反射调用目标对象的方法。如果存在拦截器链那么new 一个<code>ReflectiveMethodInvocation</code>利用反射依次执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">target = targetSource.getTarget();</span><br><span class="line">Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether we have any advice. If we don&#x27;t, we can fallback on direct</span></span><br><span class="line"><span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">   <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">   <span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">   <span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">   Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">   retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">   MethodInvocation invocation =</span><br><span class="line">         <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">   <span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">   retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring只支持方法拦截器<code>MethodInterceptor</code>进行代理增强，对于Advise都会适配成<code>MethodInterceptor</code>,Spring采用适配器模式，具体的适配器如下</p><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/AdvisorAdapter%E7%B1%BB%E5%9B%BE.png" alt="image-20220824172451573"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//支持什么Advise被适配</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适配</span></span><br><span class="line">    <span class="function">MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring遍历每一个Advise责任链模式依次找到<code>AdvisorAdapter</code>然后调用适配方法得到一个<code>MethodInterceptor</code>，下面是适配成的<code>MethodInterceptor</code>。</p><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/MethodInterceptor.png" alt="image-20220824172904504"></p></li></ul><h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h5><p>设置<code>CallBack</code></p><p>首先<code>new</code> 一个<code>Enhancer</code>设置父类为被代理对象的类型，这里会将<code>Aop</code>的逻辑转变为一个<code>DynamicAdvisedInterceptor</code>，equals和hashCode方法也有对应的<code>callBack</code></p><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/Callback.png" alt="image-20220824174533939"></p><p>注意这里的<code>MethodInterceptor</code>是<code>org.springframework.cglib.proxy.MethodInterceptor</code>,其中的intercept 方法的逻辑和JDK动态代理的invoke类似，都是链式调用。</p><h3 id="ProxyFactoryBean"><a href="#ProxyFactoryBean" class="headerlink" title="ProxyFactoryBean"></a>ProxyFactoryBean</h3><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/ProxyFactoryBean%E7%B1%BB%E5%9B%BE.png" alt="image-20220824175124978"></p><p><code>ProxyFactoryBean</code>创建代理对象的逻辑和<code>ProxyFactory</code>类似，但是<code>ProxyFactoryBean</code>是一个<code>FactoryBean</code>，我们可以利用这一点在bean初始化的时候生成一个代理对象</p><p>使用<code>ProxyFactoryBean</code>或其他IOC类来创建AOP代理的最重要好处之一是，这意味着<strong>advice和切入点也可以由IoC管理</strong>。<code>ProxyFactoryBean</code>的<code>getObject()</code>将创建一个<strong>包装目标对象的AOP代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 初始化advisor链条</span></span><br><span class="line">   initializeAdvisorChain();</span><br><span class="line">   <span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line">      <span class="keyword">return</span> getSingletonInstance();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">         logger.info(<span class="string">&quot;Using non-singleton proxies with singleton targets is often undesirable. &quot;</span> +</span><br><span class="line">               <span class="string">&quot;Enable prototype proxies by setting the &#x27;targetName&#x27; property.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> newPrototypeInstance();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getSingletonInstance()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Object <span class="title">getSingletonInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.singletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 没有创建过单例对象 进行创建</span></span><br><span class="line">      <span class="keyword">this</span>.targetSource = freshTargetSource();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.autodetectInterfaces &amp;&amp; getProxiedInterfaces().length == <span class="number">0</span> &amp;&amp; !isProxyTargetClass()) &#123;</span><br><span class="line">         <span class="comment">// Rely on AOP infrastructure to tell us what interfaces to proxy.</span></span><br><span class="line">         Class&lt;?&gt; targetClass = getTargetClass();</span><br><span class="line">         <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="string">&quot;Cannot determine target class for proxy&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, <span class="keyword">this</span>.proxyClassLoader));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Initialize the shared singleton instance.</span></span><br><span class="line">      <span class="keyword">super</span>.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">      <span class="comment">// 最终还是通过AopProxyFactory创建AopProxy生成代理对象</span></span><br><span class="line">      <span class="keyword">this</span>.singletonInstance = getProxy(createAopProxy());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.singletonInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-AOP-和IOC是如何结合起来的"><a href="#Spring-AOP-和IOC是如何结合起来的" class="headerlink" title="Spring AOP 和IOC是如何结合起来的"></a>Spring AOP 和IOC是如何结合起来的</h2><p>我们在使用<code>Spring AOP</code>的时候会在启动类上加一个<code>@EnableAspectJAutoProxy</code>注解，这个注解<code>@Import(AspectJAutoProxyRegistrar.class)</code>导入了<code>AspectJAutoProxyRegistrar</code>,这个类实现了<code>ImportBeanDefinitionRegistrar</code>,Spring容器会调用其<code>registerBeanDefinitions</code>方法为我们注入<code>BeanDefinition</code>,后续会实例化一个<code>AnnotationAwareAspectJAutoProxyCreator</code>类型的bean，它是Spring IOC和AOP结合的关键</p><p><code>AnnotationAwareAspectJAutoProxyCreator</code>类结构图</p><p><img src="/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/AnnotationAwareAspectJAutoProxyCreator%E7%B1%BB%E5%9B%BE.png" alt="image-20220824180746690"></p><p>这其中最为关键的必然是<code>AnnotationAwareAspectJAutoProxyCreator</code>，它是一个<code>BeanPostProcessor</code>,从而在Spring 回调<code>postProcessAfterInitialization</code>对bean进行代理的增强,并且它实现了<code>SmartInstantiationAwareBeanPostProcessor</code> Spring容器创建bean的时候如果出现了循环依赖那么会调用到<code>getEarlyBeanReference</code>,在这个方法里面同样也会进行aop的增强</p><ul><li><code>AbstractAutoProxyCreator</code> 实现了<code>SmartInstantiationAwareBeanPostProcessor</code>是一个bean后置处理器，使用 AOP 代理包装每个符合条件的 bean，在调用 bean 本身之前委托给指定的拦截器，AOP代理发生的地方。</li></ul><p>参考：</p><p><a href="https://www.cnblogs.com/cuzzz/p/16621320.html">https://www.cnblogs.com/cuzzz/p/16621320.html</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;AOP概述&quot;&gt;&lt;a href=&quot;#AOP概述&quot; class=&quot;headerlink&quot; title=&quot;AOP概述&quot;&gt;&lt;/a&gt;AOP概述&lt;/h2&gt;&lt;p&gt;AOP为&lt;code&gt;Aspect Oriented Programming&lt;/code&gt;的缩写，意为：&lt;strong&gt;面向切面编程&lt;/strong&gt;，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。 是一种新的模块化机制，用来描述分散在对象，类，或函数中的横切关注点，分离关注点使解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑代码中不在含义针对特定领域的代码调用，业务逻辑同特定领域问题的关系通过切面封装，维护，这样原本分散在整个应用程序中的变动可以很好地管理起来。&lt;/p&gt;
&lt;p&gt;用人话说就是，通过切面完成特定逻辑（事务，入参出参日志等） 可以和业务逻辑（CRUD）抽离开，便于维护&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Advice 通知&lt;/strong&gt;：定义在连接点做什么，为切面增强提供植入接口。描述Spring AOP围绕方法调而注入的切面行为&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pointcut切入点&lt;/strong&gt;：切点决定Advice通知应该作用在哪个连接点，也就是通过&lt;code&gt;Poincut&lt;/code&gt;来定义需要增强的方法集合，这些集合可以按照一定规则来完成，这种情况下，&lt;code&gt;Pointcut&lt;/code&gt;意味着标识方法（比如事务切面定义了事务注解方法上生效）切入点是一些列织入逻辑代码的连接点集合&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Advisor通知器&lt;/strong&gt;：整合Advice 和 Pointcut，定义应该在哪个关注点使用什么通知进行增强。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;AOP重要接口和编程体验&quot;&gt;&lt;a href=&quot;#AOP重要接口和编程体验&quot; class=&quot;headerlink&quot; title=&quot;AOP重要接口和编程体验&quot;&gt;&lt;/a&gt;AOP重要接口和编程体验&lt;/h2&gt;&lt;p&gt;我们先抛弃Spring框架，利用&lt;code&gt;Spring AOP&lt;/code&gt;中存在的工具实现AOP增强。&lt;/p&gt;
&lt;h3 id=&quot;基于Advice&quot;&gt;&lt;a href=&quot;#基于Advice&quot; class=&quot;headerlink&quot; title=&quot;基于Advice&quot;&gt;&lt;/a&gt;基于Advice&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2022/12/04/%E6%A1%86%E6%9E%B6/Spring/SpringAOP/Advice.png&quot; alt=&quot;image-20220824154409542&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Advice&lt;/code&gt;接口的实现有&lt;code&gt;AfterAdvice后置通知&lt;/code&gt;，&lt;code&gt;Beforeadvice前置通知&lt;/code&gt;，&lt;code&gt;MethodInterceptor方法拦截器&lt;/code&gt;可以看做是环绕通知。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;服务类&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AopService&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;service doSomething&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自定义advice 环绕通知&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyAdvice&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MethodInterceptor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MethodInvocation invocation)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;my advice before&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 方法执行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Object res = invocation.proceed();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;my advice after&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;客户端&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Client&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 代理工程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ProxyFactory proxyFactory = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ProxyFactory();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 目标对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AopService aopService = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AopService();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 设置需要代理的对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        proxyFactory.setTarget(aopService);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        proxyFactory.addAdvice(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MyAdvice());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 生成代理对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AopService proxy = (AopService)proxyFactory.getProxy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        proxy.doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;my advice before&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;service doSomething&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;my advice after&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC(6) Spring Bean的创建 中</title>
    <link href="http://yoursite.com/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC6Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%AD/"/>
    <id>http://yoursite.com/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC6Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%AD/</id>
    <published>2022-11-30T14:00:35.000Z</published>
    <updated>2022-12-04T08:20:02.413Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，我们知道<code>Spring</code>创建<code>Bean</code>对象有5中方法，分别是：</p><ul><li>使用<code>FactoryBean</code>的<code>getObject</code>方法创建</li><li>使用<code>BeanPostProcessor</code>的子接口<code>InstantiationAwareBeanPostProcessor</code>的<code>postProcessBeforeInstantiation</code>方法创建</li><li>设置<code>BeanDefinition</code>的<code>Supplier</code>属性进行创建</li><li>设置<code>BeanDefinition</code>的<code>factory-method</code>进行创建</li><li>使用全过程：<code>getBean--&gt;doGetBean--&gt;createBean--&gt;doCreateBean</code> 反射进行创建</li></ul><p>现在讲述使用全过程创建一个Bean</p><h2 id="解析构造函数"><a href="#解析构造函数" class="headerlink" title="解析构造函数"></a>解析构造函数</h2><p>继续看<code>AbstractAutowireCapableBeanFactory</code>的<code>createBeanInstance</code>方法中的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line"><span class="comment">// 明确构造器 在BeanPostProcessor，对应的是 AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">// 它是 SmartInstantiationAwareBeanPostProcessor 的子类，使用determineCandidateConstructors进行</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在前面讲过<code>InstantiationAwareBeanPostProcessor</code> 是用来提前实例化对象的，而<code>SmartInstantiationAwareBeanPostProcessor</code> 是<code>InstantiationAwareBeanPostProcessor</code> 的子接口</p><p><code>determineConstructorsFromBeanPostProcessors</code>方法就是解析构造函数的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(<span class="meta">@Nullable</span> Class&lt;?&gt; beanClass, String beanName)</span><br><span class="line">      <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);</span><br><span class="line">            <span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> ctors;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法是用来解析<code>BeanClass</code>的构造函数的，<code>SmartInstantiationAwareBeanPostProcessor</code>的实现类<code>AutowiredAnnotationBeanPostProcessor</code>，这个类是用来解析确定合适的构造函数，重点解析了<code>@Autowired</code>注解，并且还解析了<code>@Value</code>注解和<code>@Lookup</code>注解。</p><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>当解析出来构造函数之后，那么就调用<code>autowireConstructor</code>方法进行实例化，解析时会<code>new</code>一个构造器解析器<code>ConstructorResolver</code> ，在解析<code>factoryMethod</code>时也是使用的这个类使用的是<code>instantiateUsingFactoryMethod</code>这个方法，并且解析<code>factoryMethod</code>更加复杂，需要判断是否是静态的工厂创建还是实例工厂创建，而自动装配的构造解析相对来说简单一些，使用<code>autowireConstructor</code>方法进行解析。</p><h3 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h3><p>最终解析出构造方法和构造参数之后进行实例化，位于 <code>ConstructorResolver</code>#<code>autowireConstructor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用合适的构造方法和构造参数进行实例化</span></span><br><span class="line">bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));</span><br></pre></td></tr></table></figure><p>实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">instantiate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt; constructorToUse, Object[] argsToUse)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取实例化策略，一般使用 CglibSubClassingInstantiationStrategy</span></span><br><span class="line">      InstantiationStrategy strategy = <span class="keyword">this</span>.beanFactory.getInstantiationStrategy();</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">               strategy.instantiate(mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse),</span><br><span class="line">               <span class="keyword">this</span>.beanFactory.getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 开始实例化</span></span><br><span class="line">         <span class="keyword">return</span> strategy.instantiate(mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">&quot;Bean instantiation via constructor failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据实例化策略，来实例化对象，<code>SimpleInstantiationStrategy</code>#<code>instantiate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">final</span> Constructor&lt;?&gt; ctor, Object... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// use own privileged to change accessibility (when security is on)</span></span><br><span class="line">         AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 实例化类，反射调用</span></span><br><span class="line">      <span class="keyword">return</span> BeanUtils.instantiateClass(ctor, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果方法被覆盖，lookup-method 和 replace-method</span></span><br><span class="line">      <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果前面的解析都没有得到到<code>Bean</code>，那么就会使用无参构造函数进行解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line"><span class="comment">// 首选的构造器为默认的创建方式，使用了@Primary注解的为首选的创建对象方式</span></span><br><span class="line">ctors = mbd.getPreferredConstructors();</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="comment">// 调用无参构造函数实例化对象</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br></pre></td></tr></table></figure><h3 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h3><p>一般都会从这里<code>instantiateBean</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Object beanInstance;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">         beanInstance = AccessController.doPrivileged(</span><br><span class="line">               (PrivilegedAction&lt;Object&gt;) () -&gt; getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>),</span><br><span class="line">               getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 实例化对象，使用反射进行创建</span></span><br><span class="line">         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建一个Bean的包装器</span></span><br><span class="line">      BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">       <span class="comment">// 初始化Bean的包装器</span></span><br><span class="line">      initBeanWrapper(bw);</span><br><span class="line">      <span class="keyword">return</span> bw;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到前面使用<code>factoryMethod</code> 和<code>autowireConstructor</code> 解析构造函数进行实例化还是使用无参构造函数进行实例化都是将<code>Bean</code>进行了包装，那这个包装有啥作用呢？</p><h4 id="BeanWrapper的作用"><a href="#BeanWrapper的作用" class="headerlink" title="BeanWrapper的作用"></a>BeanWrapper的作用</h4><p><code>BeanWrapper</code>的使用地方</p><ul><li><code>factory-method</code> 解析：<code>ConstructorResolver#instantiateUsingFactoryMethod</code> 方法。</li><li><code>SmartInstantiationAwareBeanPostProcessor</code>子类<code>AutowiredAnnotationBeanPostProcessor</code> 解析出构造函数，然后使用<code>ConstructorResolver#autowireConstructor</code> 执行。</li></ul><p>这2除都存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个包装器</span></span><br><span class="line">BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line"><span class="comment">// 初始化包装器</span></span><br><span class="line"><span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br></pre></td></tr></table></figure><p><code>initBeanWrapper</code>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBeanWrapper</span><span class="params">(BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">   bw.setConversionService(getConversionService());</span><br><span class="line">   registerCustomEditors(bw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终都是会进行转换服务<code>ConversionService</code>和<code>PropertyEditorRegistry</code>的注册，一个是用来进行属性类型转换的，一个是用来属性值解析的。</p><h2 id="回调MergedBeanDefinitionPostProcessor"><a href="#回调MergedBeanDefinitionPostProcessor" class="headerlink" title="回调MergedBeanDefinitionPostProcessor"></a>回调MergedBeanDefinitionPostProcessor</h2><p>回到doCreateBean中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">   instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">   instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从包装器中获取Bean对象</span></span><br><span class="line"><span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// 从包装器中获取Bean类型</span></span><br><span class="line">Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 合并Bean</span></span><br><span class="line">         applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">               <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里有一个方法<code>applyMergedBeanDefinitionPostProcessors</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">         MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">         bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了一个接口<code>MergedBeanDefinitionPostProcessor</code>，这个接口也是<code>BeanPostProcessor</code>的子接口。</p><p>点击发现这个接口的实现类全是跟注解相关的，包括<code>AutowiredAnnotationBeanPostProcessor</code>、<code>CommonAnnotationBeanPostProcessor</code>及<code>InitDestroyAnnotationBeanPostProcessor</code> 实现类。</p><p>回调 <code>postProcessMergedBeanDefinition</code> 方法时，已经拿到了 <code>merged bean definition</code>，并且还未开始 <code>poplateBean</code> 填充 <code>bean</code> 属性、 <code>initlializeBean</code> 初始化 <code>bean</code> 对象， 因此可以在这里对 <code>merged bean definition</code> 进行一些操作 ，在 <code>poplateBean</code> 或 <code>initlializeBean</code> 阶段使用前面操作结果实现所需功能 </p><p><code>@PostConstruct</code>,<code>@PreInit</code>、 <code>@Resouce</code>,<code>@Autowired</code>  <code>@InitMethod</code> 都在这里实现的</p><h3 id="PostConstruct、-PreDestroy"><a href="#PostConstruct、-PreDestroy" class="headerlink" title="@PostConstruct、@PreDestroy"></a>@PostConstruct、@PreDestroy</h3><p><code>CommonAnnotationBeanPostProcessor</code>在构造函数中设置了两个注解：<code>@PostConstruct</code>和<code>@PreDestroy</code>，一个是在初始化完之后调用，一个是容器销毁时调用。<code>CommonAnnotationBeanPostProcessor</code>这个类的父类为<code>InitDestroyAnnotationBeanPostProcessor</code>，用于处理初始化和销毁方法的。</p><p><code>CommonAnnotationBeanPostProcessor</code> 的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommonAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">3</span>);</span><br><span class="line">   setInitAnnotationType(PostConstruct.class);</span><br><span class="line">   setDestroyAnnotationType(PreDestroy.class);</span><br><span class="line">   ignoreResourceType(<span class="string">&quot;javax.xml.ws.WebServiceContext&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CommonAnnotationBeanPostProcessor</code> 合并方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);</span><br><span class="line">   InjectionMetadata metadata = findResourceMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">   metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击<code>postProcessMergedBeanDefinition</code>方法发现调用了父类的这个方法，然后执行了一个叫查找生命周期元数据的方法<code>findLifecycleMetadata</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">   LifecycleMetadata metadata = findLifecycleMetadata(beanType);</span><br><span class="line">   metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找生命周期元数据<code>findLifecycleMetadata</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LifecycleMetadata <span class="title">findLifecycleMetadata</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.lifecycleMetadataCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Happens after deserialization, during destruction...</span></span><br><span class="line">      <span class="keyword">return</span> buildLifecycleMetadata(clazz);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">   <span class="comment">// 查询缓存</span></span><br><span class="line">   LifecycleMetadata metadata = <span class="keyword">this</span>.lifecycleMetadataCache.get(clazz);</span><br><span class="line">   <span class="keyword">if</span> (metadata == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.lifecycleMetadataCache) &#123;</span><br><span class="line">         metadata = <span class="keyword">this</span>.lifecycleMetadataCache.get(clazz);</span><br><span class="line">         <span class="keyword">if</span> (metadata == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有查询到就去构建生命周期的元数据</span></span><br><span class="line">            metadata = buildLifecycleMetadata(clazz);</span><br><span class="line">            <span class="keyword">this</span>.lifecycleMetadataCache.put(clazz, metadata);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> metadata;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建生命周期元数据<code>buildLifecycleMetadata</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LifecycleMetadata <span class="title">buildLifecycleMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这里的initAnnotationType 就是子类set进去的@PostConstruct</span></span><br><span class="line">   <span class="comment">// destroyAnnotationType 就是子类set进去的@PreDestroy</span></span><br><span class="line">   <span class="keyword">if</span> (!AnnotationUtils.isCandidateClass(clazz, Arrays.asList(<span class="keyword">this</span>.initAnnotationType, <span class="keyword">this</span>.destroyAnnotationType))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.emptyLifecycleMetadata;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 存放初始化方法</span></span><br><span class="line">   List&lt;LifecycleElement&gt; initMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// 存放销毁方法</span></span><br><span class="line">   List&lt;LifecycleElement&gt; destroyMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> List&lt;LifecycleElement&gt; currInitMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">final</span> List&lt;LifecycleElement&gt; currDestroyMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">         <span class="comment">// 如果找到方法上有@PostConstruct注解，这加入到当前初始化方法集合中</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.initAnnotationType != <span class="keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="keyword">this</span>.initAnnotationType)) &#123;</span><br><span class="line">            LifecycleElement element = <span class="keyword">new</span> LifecycleElement(method);</span><br><span class="line">            <span class="comment">// 创建一个生命周期元素</span></span><br><span class="line">            currInitMethods.add(element);</span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 如果找到方法上标有@PreDestroy 注解，就加入到当前销毁方法集合中</span></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.destroyAnnotationType != <span class="keyword">null</span> &amp;&amp; method.isAnnotationPresent(<span class="keyword">this</span>.destroyAnnotationType)) &#123;</span><br><span class="line">            currDestroyMethods.add(<span class="keyword">new</span> LifecycleElement(method));</span><br><span class="line">           ...</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="comment">// 赋值到初始化方法集合和销毁方法集合中</span></span><br><span class="line">      initMethods.addAll(<span class="number">0</span>, currInitMethods);</span><br><span class="line">      destroyMethods.addAll(currDestroyMethods);</span><br><span class="line">      targetClass = targetClass.getSuperclass();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 遍历查找 从子类一直查找到父类</span></span><br><span class="line">   <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"><span class="comment">// 如果没有解析到，那么返回一个空的生命周期元数据，否则创建一个生命周期元素并放入初始化方法和销毁方法的集合</span></span><br><span class="line">   <span class="keyword">return</span> (initMethods.isEmpty() &amp;&amp; destroyMethods.isEmpty() ? <span class="keyword">this</span>.emptyLifecycleMetadata :</span><br><span class="line">         <span class="keyword">new</span> LifecycleMetadata(clazz, initMethods, destroyMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终发现实际上就是在解析我们的<code>Bean</code>的方法上是否标记了<code>@PostConstruc</code>t注解和<code>@PreDestroy</code>方法，如果有就加入到生命周期元数据中，并且将解析到的方法放入到<code>BeanDefinition</code>的<code>externallyManagedInitMethods</code>和<code>externallyManagedDestroyMethods</code>集合中。</p><p><code>Bean</code>初始化和销毁方法解析和执行流程如下</p><p><img src="/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC6Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%AD/Bean%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E5%92%8C%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="img"></p><p>其实<code>InitDestoryAnnotationBeanPostProcessor</code> 主要是对<code>Bean</code>的做了自定义初始化和销毁方法的解析，以及在后期调用<code>BPP</code>时执行。</p><h3 id="自动装配注解的解析"><a href="#自动装配注解的解析" class="headerlink" title="自动装配注解的解析"></a>自动装配注解的解析</h3><p>在<code>Spring</code>中自动装配的注解一般来说比较常用的有两个，一个<code>@Autowired</code> 是<code>Spring</code>提供的，还有个是<code>@Resource</code>是<code>Java</code>的注解，这两个注解都能够完成自动装配，不过在实现时<code>@Autowired</code>注解是由<code>AutowiredAnnotationBeanPostProcessor</code>解析的和执行，而<code>@Resource</code>注解是由<code>CommonAnnotationBeanPostProcessor</code>解析和执行的。</p><p>这些注解的解析跟解析<code>@PostConstruct</code>和<code>@PreDestroy</code>一样,不同的是这几个注解可以标在字段和方法上，解析是需要对字段和方法都要解析，其他实现基本原理一致。</p><p><img src="/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC6Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%AD/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90.png" alt="img"></p><p><code>Spring Bean</code>的实例化基本就解析完了，接下来开始解析循环依赖和<code>Bean</code>的属性填充部分。</p><h2 id="提前暴露对象"><a href="#提前暴露对象" class="headerlink" title="提前暴露对象"></a>提前暴露对象</h2><p>在<code>doCreateBean</code>中,执行完合并之后，会把对象提前暴露出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="comment">// 提前暴露对象，用于解决循环依赖</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">            <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 添加一个lambda表达式到三级缓存中</span></span><br><span class="line">   addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码这里就添加了一个<code>lambda</code>表达式到一个<code>Map</code>中，然后结束了，并且明确说明了提前暴露是为了解决循环依赖问题。</p><h3 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h3><p>循环依赖顾名思义，就是你中有我，我中有你，打个比方现在有个对象<code>A</code>，他有个属性<code>b</code>，这个属性b是对象<code>B</code>的，然后对象<code>B</code>中有个属性<code>a</code>，属性<code>a</code>是对象<code>A</code>的。</p><p>现在开始创建对象，按照<code>Spring</code>的标准创建流程<code>getBean</code>–&gt;<code>doGetBean</code>–&gt;<code>createBean</code>–&gt;<code>doCreateBean</code>，先实例化，然后属性填充，然后执行<code>aware</code>方法，然后执行<code>BeanPostProcessor</code>的<code>before</code>方法，然后执行<code>init-method</code>，然后执行<code>BeanPostProcessor</code>的<code>after</code>方法。那么在执行属性填充时必然会去查找<code>a</code>或者<code>b</code>属性对应的对象，如果找不到就会去创建，那么就会出现下图的样子：</p><p><img src="/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC6Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%AD/%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.png" alt="img"></p><h3 id="Spring为什么进行提前暴露对象呢"><a href="#Spring为什么进行提前暴露对象呢" class="headerlink" title="Spring为什么进行提前暴露对象呢"></a><code>Spring</code>为什么进行提前暴露对象呢</h3><p><code>Bean</code>的创建是<strong>将实例化和初始化分开的</strong>，实例化之后的对象在<code>JVM</code>堆中已经开辟了内存空间地址，这个地址是不会变的，除非山崩地裂，海枯石烂，也就是应用重启了。</p><p>因此可以将已经实例化的对象放在另外一个<code>Map</code>中，一般来说都称之为<strong>半成品</strong>，当填充属性时，可以将先设置半成品对象，等到对象创建完之后在将半成品换成成品，这样的话对象进行属性填充时就可以直接先使用半成品填充，等到开始初始化时再将对象创建出来即可。</p><img src="/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC6Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%AD/半成品对象.png" alt="img" style="zoom:80%;"><p>这样看来循环依赖只需要二级缓存就够了，但是在<code>Spring</code>中，存在一种特殊的对象，就是<strong>代理对象</strong>。也就是说在放入的半成品我们现在多了一种对象，那就是代理对象，这个时候就会出现使用代理对象还是普通对象呢？所以干脆在搞一个<code>Map</code>专门存放代理对象，这样就区分出来了，然后在使用的时候先判断下我们创建的对象是需要代理还是不需要代理，如果需要代理，那么就创建一个代理对象放在<code>map</code>中，否则直接使用普通对象就可以了。</p><img src="/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC6Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%AD/三级缓存.png" alt="img" style="zoom:80%;"><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><code>Spring</code>是将所有的对象都放在三级缓存中，也就是<code>lambda</code>表达式中。在<code>doCreateBean</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 判断一级缓存中是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 没有就放入三级缓存中</span></span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="comment">// 清空二级缓存</span></span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="comment">// 添加到已经注册的单例集合中</span></span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在属性填充的时候，会执行到<code>getBean</code>，然后从缓存中获取<code>getSingleton</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">    <span class="comment">// 从一级缓存中获取bean实例</span></span><br><span class="line">   Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">   <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">      <span class="comment">// 如果有正在创建的Bean，那么从二级缓存中获取，早期的单例对象</span></span><br><span class="line">      singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">            <span class="comment">// 二次检查一级缓存中是否有单例对象</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 二次判断二级缓存中是否存在单例对象</span></span><br><span class="line">               singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">               <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 从三级缓存中获取Bean</span></span><br><span class="line">                  ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                  <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">// 如果三级缓存中 单例工厂中有对象，那么就将该对象放在二级缓存中，并且将bean从三级缓存去除</span></span><br><span class="line">                     singletonObject = singletonFactory.getObject();</span><br><span class="line">                     <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                     <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取单例对象时，会执行到三级缓存，然后执行<code>getObject</code>方法，最终就会触发<code>AbstractAutowireCapableBeanFactory</code>#<code>getEarlyBeanReference</code>方法的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   <span class="comment">// 添加 三级缓存，判断是否需要进行代理创建对象，是一个动态代理创建的代理对象</span></span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ibp.getEarlyBeanReference</code>方法在<code>Spring</code>中只有<code>AbstractAutoProxyCreator</code>类进行了实质的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = <span class="keyword">this</span>.getCacheKey(bean.getClass(), beanName);</span><br><span class="line">    <span class="comment">// 早期代理对象的引用集合</span></span><br><span class="line">    <span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">    <span class="comment">// 创建代理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wrapIfNecessary</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">   Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">      <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">      <span class="comment">// 创建代理对象</span></span><br><span class="line">      Object proxy = createProxy(</span><br><span class="line">            bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">      <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">      <span class="keyword">return</span> proxy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先进行了判断，如果不满足创建代理的条件，都是直接返回这个对象，否则进入创建代理的方法，创建出代理对象，最终放入缓存中。点入到最后会发现使用了两种代理创建方式<code>CglibAopProxy</code>和<code>JdkDynamicAopProxy</code>.</p><p>参考</p><p><a href="https://www.cnblogs.com/redwinter/p/16268667.html">https://www.cnblogs.com/redwinter/p/16268667.html</a></p><p><a href="https://www.cnblogs.com/redwinter/p/16286745.html">https://www.cnblogs.com/redwinter/p/16286745.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止，我们知道&lt;code&gt;Spring&lt;/code&gt;创建&lt;code&gt;Bean&lt;/code&gt;对象有5中方法，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;FactoryBean&lt;/code&gt;的&lt;code&gt;getObject&lt;/code&gt;方法创建&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;BeanPostProcessor&lt;/code&gt;的子接口&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;的&lt;code&gt;postProcessBeforeInstantiation&lt;/code&gt;方法创建&lt;/li&gt;
&lt;li&gt;设置&lt;code&gt;BeanDefinition&lt;/code&gt;的&lt;code&gt;Supplier&lt;/code&gt;属性进行创建&lt;/li&gt;
&lt;li&gt;设置&lt;code&gt;BeanDefinition&lt;/code&gt;的&lt;code&gt;factory-method&lt;/code&gt;进行创建&lt;/li&gt;
&lt;li&gt;使用全过程：&lt;code&gt;getBean--&amp;gt;doGetBean--&amp;gt;createBean--&amp;gt;doCreateBean&lt;/code&gt; 反射进行创建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在讲述使用全过程创建一个Bean&lt;/p&gt;
&lt;h2 id=&quot;解析构造函数&quot;&gt;&lt;a href=&quot;#解析构造函数&quot; class=&quot;headerlink&quot; title=&quot;解析构造函数&quot;&gt;&lt;/a&gt;解析构造函数&lt;/h2&gt;&lt;p&gt;继续看&lt;code&gt;AbstractAutowireCapableBeanFactory&lt;/code&gt;的&lt;code&gt;createBeanInstance&lt;/code&gt;方法中的源码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Candidate constructors for autowiring?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 明确构造器 在BeanPostProcessor，对应的是 AutowiredAnnotationBeanPostProcessor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 它是 SmartInstantiationAwareBeanPostProcessor 的子类，使用determineCandidateConstructors进行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ctors != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; autowireConstructor(beanName, mbd, ctors, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在前面讲过&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt; 是用来提前实例化对象的，而&lt;code&gt;SmartInstantiationAwareBeanPostProcessor&lt;/code&gt; 是&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt; 的子接口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;determineConstructorsFromBeanPostProcessors&lt;/code&gt;方法就是解析构造函数的方法&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; Constructor&amp;lt;?&amp;gt;[] determineConstructorsFromBeanPostProcessors(&lt;span class=&quot;meta&quot;&gt;@Nullable&lt;/span&gt; Class&amp;lt;?&amp;gt; beanClass, String beanName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (beanClass != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (BeanPostProcessor bp : getBeanPostProcessors()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (bp &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; SmartInstantiationAwareBeanPostProcessor) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Constructor&amp;lt;?&amp;gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ctors != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ctors;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;可以看到这个方法是用来解析&lt;code&gt;BeanClass&lt;/code&gt;的构造函数的，&lt;code&gt;SmartInstantiationAwareBeanPostProcessor&lt;/code&gt;的实现类&lt;code&gt;AutowiredAnnotationBeanPostProcessor&lt;/code&gt;，这个类是用来解析确定合适的构造函数，重点解析了&lt;code&gt;@Autowired&lt;/code&gt;注解，并且还解析了&lt;code&gt;@Value&lt;/code&gt;注解和&lt;code&gt;@Lookup&lt;/code&gt;注解。&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC(7) Spring Bean的创建 下</title>
    <link href="http://yoursite.com/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC7Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8B/"/>
    <id>http://yoursite.com/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC7Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8B/</id>
    <published>2022-11-30T14:00:02.412Z</published>
    <updated>2022-12-04T09:05:14.547Z</updated>
    
    <content type="html"><![CDATA[<p>在上节中，将述了Spring Bean的实例化，循环依赖在Spring中是如何解决的，这一节 继续完成Bean的创建流程。</p><h2 id="对象的属性填充"><a href="#对象的属性填充" class="headerlink" title="对象的属性填充"></a>对象的属性填充</h2><p>属性填充，可能会涉及到很多东西，比如填充的属性是基本类型还是引用类型，填充的方式又可以分为按类型、按名称还是其他的，然后填充时值的类型是否需要进行类型转换等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br></pre></td></tr></table></figure><p><img src="/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC7Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8B/%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85.png" alt="img"></p><p>属性填充大致可以分为对基本类型的数据进行填充和对应用类型的数据填充，<code>populateBean</code>方法中代码比较繁琐，会设计到很多的递归调用，最终解析并填充属性。</p><img src="/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC7Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8B/populateBean.png" alt="img" style="zoom:80%;"><ul><li>使用<code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code>接口的调用，可以在属性填充前对<code>Bean</code>进行修改，并且可以定制字段的填充,<code>postProcessAfterInstantiation</code>入参有<code>Bean</code>对象和<code>Bean</code>的名称，可以在这里面进行自定义的属性注入，如果返回false表示后续不需要spring帮我们进行依赖注入，反之需要spring帮我们进行依赖注入</li><li>按照注入方式进行属性的填充，最终会将解析到的属性和引用放入<code>PropertyValues</code>中<ul><li>按<code>autowireByType</code>自动装配</li><li>按<code>autowireByName</code>自动装配</li></ul></li><li>如果存在<code>InstantiationAwareBeanPostProcessor</code>接口(<code>CommonAnnotationBeanPostProcessor</code>和<code>AtowiredAnnotationBeanPostProcessor</code>)，那么循环去调用<code>postProcessProperties</code>这个方法进行注解的注入，这里调用的实际上就是前面进行<code>Bean</code>的合并时解析的注解，比如：<code>@Autowired</code>、<code>@Resource</code>、<code>@Value</code>等</li><li>属性值的处理和解析<ul><li>创建一个<code>BeanDefinitionValueResolver</code> 值解析器</li><li>循环去遍历解析属性值，解析过程中会用到类型转换的转换服务<code>ConversionService</code>、<code>SPEL</code>表达式的解析、属性编辑器<code>PropertyEditor</code></li><li>最终解析完，会调用到属性的<code>set</code>方法进行写入</li></ul></li></ul><p>在填充的过程中，发现需要的<code>Bean</code>不存在，那么又会进行<code>getBean</code>、<code>doGetBean</code>、<code>createBean</code>、<code>doCreateBean</code>的调用，然后递归的入栈出栈调用，最终完成属性的填充。</p><h4 id="Resouce-Autowried的异同"><a href="#Resouce-Autowried的异同" class="headerlink" title="@Resouce @Autowried的异同"></a>@Resouce @Autowried的异同</h4><p>相同</p><ol><li>都可以标注在方法上和字段上</li><li>都可以使用@Qualifier 限定候选者</li><li>都可以进行依赖注入</li><li>都是通过 <code>MergedBeanDefinitionPostProcessor</code>和<code>InstantiationAwareBeanPostProcessor</code>的回调实现依赖注入的</li><li>底层原理都是反射，反射设置字段的值，反射调用方法</li><li>二者都是在实例化bean之后，调用<code>MergedBeanDefinitionPostProcessor</code>#<code>postProcessMergedBeanDefinition</code>方法扫描需要注入的字段 和 方法 放入到缓存中</li><li>依赖注入都是发生在<code>InstantiationAwareBeanPostProcessor</code>#<code>postProcessPropertyValues</code>的方法中</li><li>依赖注入存在多个符合条件的bean都是通过@Primary 的bean胜出（实际上调用<code>BeanDefinition</code>中的<code>isPrimary()</code>），如果都<code>isPrimary</code> 不能决出胜负则比较优先级，如果还是存在多个那么抛出异常</li><li>二者都在找不到合适的bean的时候抛出异常</li></ol><p>不同</p><ol><li><p><code>@Resouce</code> 是基于<code>CommonAnnotationBeanPostProcessor</code> 实现的</p></li><li><p><code>@Autowried</code> 是基于<code>AutowiredAnnotationBeanPostProcessor</code> 实现的</p></li><li><p><code>@Resouce</code>注解默认是根据<strong>bean的名称去注入</strong>，如果没有指定name，会将字段的名称作为bean的名称，set方法会去掉set前缀且第一个字母小写作为bean的名称，非set方法 方法名称就是bean的名称，如果指定了name 就以name中的内容作为bean的名称</p><p>如果没有指定name，使用默认的name，且默认的name在容器中存在，那么调用<code>resolveByBeanName</code>获取bean，要求类型必须兼容字段声明类型or方法入参类型</p><p>如果没有指定name且name不存在容器中，会根据类型注入</p></li><li><p><code>@Autowried</code> 默认根据<strong>类型注入</strong>，比如Service存在实现类A和B，字段or方法声明类型为AService但是字段or参数名称为b，还是会根据类型找到符合的bean名称找到a，而不会因为名称是b选择B注入，如果字段or方法参数类型是Service，但是字段or参数名称为a，且没有标注@Qualifier 那么会找到a和b作为候选者，但是后面比较Primary，再比较javax.annotation.Priority注解，然后再根据字段的名称or参数的名称去筛选</p></li><li><p><code>@Autowried</code> 标注在方法上支持 0个参数 和任意多个参数 但是@Resouce 要求必须有一个参数</p></li></ol><h2 id="bean的初始化"><a href="#bean的初始化" class="headerlink" title="bean的初始化"></a>bean的初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">         invokeAwareMethods(beanName, bean);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;, getAccessControlContext());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 执行Aware 方法</span></span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Object wrappedBean = bean;</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// 执行 BeanPostProcessor before 接口</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 执行 init-method 方法</span></span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">       <span class="comment">// 执行BeanPostProcessor after 方法</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码逻辑也很简单，大概就分成了4步：</p><ul><li>执行<code>Aware</code>接口的方法<code>invokeAwareMethods</code></li><li>执行<code>BeanPostProcessor#postProcessBeforeInitialization</code></li><li>执行初始化方法</li><li>执行<code>BeanPostProcessor#postProcessAfterInitialization</code></li></ul><h3 id="执行invokeAwareMethods"><a href="#执行invokeAwareMethods" class="headerlink" title="执行invokeAwareMethods"></a>执行<code>invokeAwareMethods</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(String beanName, Object bean)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">       <span class="comment">// 执行BeanNameAware</span></span><br><span class="line">      <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">         ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 执行BeanClassLoaderAware</span></span><br><span class="line">      <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">         ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">         <span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行BeanFactoryAware</span></span><br><span class="line">      <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">         ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只执行了3个接口的方法，<code>BeanNameAware</code>，<code>BeanClassLoaderAwre</code>，<code>BeanFactoryAware</code>，在<code>Spring</code>容器中不止这些<code>Aware</code>接口，这里为什么只执行了三个Aware接口？</p><p>在<code>Spring</code>容器<code>BeanFactory</code>构造时，对这三个接口进行了忽略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractAutowireCapableBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  ignoreDependencyInterface(BeanNameAware.class);</span><br><span class="line">  ignoreDependencyInterface(BeanFactoryAware.class);</span><br><span class="line">  ignoreDependencyInterface(BeanClassLoaderAware.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行BPP的Before方法"><a href="#执行BPP的Before方法" class="headerlink" title="执行BPP的Before方法"></a>执行BPP的Before方法</h3><p>循环的执行了<code>BPP</code>的<code>before</code>接口，这里在执行的时候，实现上也执行了在<code>Bean</code>进行<code>merge</code>的时候解析的<code>@PostConstruct</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">   Object result = existingBean;</span><br><span class="line">   <span class="comment">// 执行所有的BeanPostProcessor</span></span><br><span class="line">   <span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">      Object current = processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      result = current;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@PostConstruct 这个方法的实现类为InitDestroyAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行初始化方法</span></span><br><span class="line">        metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex.getTargetException());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">&quot;Failed to invoke init method&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在开始的准备<code>BeanFactory</code>的时候又进行了忽略<code>Aware</code>接口：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.ignore<span class="constructor">DependencyInterface(EnvironmentAware.<span class="params">class</span>)</span>;</span><br><span class="line">beanFactory.ignore<span class="constructor">DependencyInterface(EmbeddedValueResolverAware.<span class="params">class</span>)</span>;</span><br><span class="line">beanFactory.ignore<span class="constructor">DependencyInterface(ResourceLoaderAware.<span class="params">class</span>)</span>;</span><br><span class="line">beanFactory.ignore<span class="constructor">DependencyInterface(ApplicationEventPublisherAware.<span class="params">class</span>)</span>;</span><br><span class="line">beanFactory.ignore<span class="constructor">DependencyInterface(MessageSourceAware.<span class="params">class</span>)</span>;</span><br><span class="line">beanFactory.ignore<span class="constructor">DependencyInterface(ApplicationContextAware.<span class="params">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>这6个接口在哪里执行的呢？在<code>BeanFactory</code>准备阶段注册了一个<code>BeanPostProcessor</code>的实现叫<code>ApplicationContextAwareProcessor</code>类，这个类负责回调一些<code>Aware</code>接口（和<code>BeanFactory</code>无关的Aware）,这个类的<code>before</code>方法中就进行了调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(bean <span class="keyword">instanceof</span> EnvironmentAware || bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware ||</span><br><span class="line">        bean <span class="keyword">instanceof</span> ResourceLoaderAware || bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware ||</span><br><span class="line">        bean <span class="keyword">instanceof</span> MessageSourceAware || bean <span class="keyword">instanceof</span> ApplicationContextAware))&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">  AccessControlContext acc = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    acc = <span class="keyword">this</span>.applicationContext.getBeanFactory().getAccessControlContext();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (acc != <span class="keyword">null</span>) &#123;</span><br><span class="line">    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">      invokeAwareInterfaces(bean);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;, acc);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 执行Aware接口</span></span><br><span class="line">    invokeAwareInterfaces(bean);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">    ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">    ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">    ((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">    ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">    ((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">    ((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人认为主要是做了个区分而已，前面三个接口输入<code>BeanFactory</code>范畴，而这6个接口属于<code>ApplicationContext</code>范畴，只是进行了归类处理而已。</p><h3 id="执行初始化方法"><a href="#执行初始化方法" class="headerlink" title="执行初始化方法"></a>执行初始化方法</h3><p>执行初始化方法的时候，会分为两步，一个是执行<code>InitializingBean</code> 的<code>afterPropertiesSet</code>方法，另一个是执行自定义的<code>init-method</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断当前Bean是否是实现了InitializingBean</span></span><br><span class="line">   <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">   <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">            <span class="keyword">throw</span> pae.getException();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 执行</span></span><br><span class="line">         ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String initMethodName = mbd.getInitMethodName();</span><br><span class="line">      <span class="keyword">if</span> (initMethodName != <span class="keyword">null</span> &amp;&amp; !(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">            !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">         <span class="comment">// 执行自定义的初始化方法</span></span><br><span class="line">         invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行BPP的after接口"><a href="#执行BPP的after接口" class="headerlink" title="执行BPP的after接口"></a>执行BPP的after接口</h3><p>BPP的after主要是用来实现AOP的，所以这里简单介绍下，循环执行after方法的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">   Object result = existingBean;</span><br><span class="line">   <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">      result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化就解读完了，<code>Spring</code>的<code>Bean</code>的创建也基本讲完，最终创建出来的<code>Bean</code>对象就会放入到一级缓存<code>singletonObjects</code>中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上节中，将述了Spring Bean的实例化，循环依赖在Spring中是如何解决的，这一节 继续完成Bean的创建流程。&lt;/p&gt;
&lt;h2 id=&quot;对象的属性填充&quot;&gt;&lt;a href=&quot;#对象的属性填充&quot; class=&quot;headerlink&quot; title=&quot;对象的属性填充&quot;&gt;&lt;/a&gt;对象的属性填充&lt;/h2&gt;&lt;p&gt;属性填充，可能会涉及到很多东西，比如填充的属性是基本类型还是引用类型，填充的方式又可以分为按类型、按名称还是其他的，然后填充时值的类型是否需要进行类型转换等。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;populateBean(beanName, mbd, instanceWrapper);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC7Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8B/%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;属性填充大致可以分为对基本类型的数据进行填充和对应用类型的数据填充，&lt;code&gt;populateBean&lt;/code&gt;方法中代码比较繁琐，会设计到很多的递归调用，最终解析并填充属性。&lt;/p&gt;
&lt;img src=&quot;/2022/11/30/%E6%A1%86%E6%9E%B6/Spring/IOC7Springbean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8B/populateBean.png&quot; alt=&quot;img&quot; style=&quot;zoom:80%;&quot;&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation&lt;/code&gt;接口的调用，可以在属性填充前对&lt;code&gt;Bean&lt;/code&gt;进行修改，并且可以定制字段的填充,&lt;code&gt;postProcessAfterInstantiation&lt;/code&gt;入参有&lt;code&gt;Bean&lt;/code&gt;对象和&lt;code&gt;Bean&lt;/code&gt;的名称，可以在这里面进行自定义的属性注入，如果返回false表示后续不需要spring帮我们进行依赖注入，反之需要spring帮我们进行依赖注入&lt;/li&gt;
&lt;li&gt;按照注入方式进行属性的填充，最终会将解析到的属性和引用放入&lt;code&gt;PropertyValues&lt;/code&gt;中&lt;ul&gt;
&lt;li&gt;按&lt;code&gt;autowireByType&lt;/code&gt;自动装配&lt;/li&gt;
&lt;li&gt;按&lt;code&gt;autowireByName&lt;/code&gt;自动装配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果存在&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;接口(&lt;code&gt;CommonAnnotationBeanPostProcessor&lt;/code&gt;和&lt;code&gt;AtowiredAnnotationBeanPostProcessor&lt;/code&gt;)，那么循环去调用&lt;code&gt;postProcessProperties&lt;/code&gt;这个方法进行注解的注入，这里调用的实际上就是前面进行&lt;code&gt;Bean&lt;/code&gt;的合并时解析的注解，比如：&lt;code&gt;@Autowired&lt;/code&gt;、&lt;code&gt;@Resource&lt;/code&gt;、&lt;code&gt;@Value&lt;/code&gt;等&lt;/li&gt;
&lt;li&gt;属性值的处理和解析&lt;ul&gt;
&lt;li&gt;创建一个&lt;code&gt;BeanDefinitionValueResolver&lt;/code&gt; 值解析器&lt;/li&gt;
&lt;li&gt;循环去遍历解析属性值，解析过程中会用到类型转换的转换服务&lt;code&gt;ConversionService&lt;/code&gt;、&lt;code&gt;SPEL&lt;/code&gt;表达式的解析、属性编辑器&lt;code&gt;PropertyEditor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最终解析完，会调用到属性的&lt;code&gt;set&lt;/code&gt;方法进行写入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在填充的过程中，发现需要的&lt;code&gt;Bean&lt;/code&gt;不存在，那么又会进行&lt;code&gt;getBean&lt;/code&gt;、&lt;code&gt;doGetBean&lt;/code&gt;、&lt;code&gt;createBean&lt;/code&gt;、&lt;code&gt;doCreateBean&lt;/code&gt;的调用，然后递归的入栈出栈调用，最终完成属性的填充。&lt;/p&gt;
&lt;h4 id=&quot;Resouce-Autowried的异同&quot;&gt;&lt;a href=&quot;#Resouce-Autowried的异同&quot; class=&quot;headerlink&quot; title=&quot;@Resouce @Autowried的异同&quot;&gt;&lt;/a&gt;@Resouce @Autowried的异同&lt;/h4&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC(5) Spring Bean的创建 上</title>
    <link href="http://yoursite.com/2022/11/29/%E6%A1%86%E6%9E%B6/Spring/IOC5Springbean%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>http://yoursite.com/2022/11/29/%E6%A1%86%E6%9E%B6/Spring/IOC5Springbean%E7%9A%84%E5%88%9B%E5%BB%BA/</id>
    <published>2022-11-29T08:25:41.000Z</published>
    <updated>2022-11-30T13:59:28.298Z</updated>
    
    <content type="html"><![CDATA[<p>到目前为止，<code>Spring</code>源码中<code>AbstractApplicationContext#refresh</code>方法的已经解读到第11个方法<code>finishBeanFactoryInitialization</code>,前10个方法介绍了：</p><ul><li><code>BeanFactory</code>的准备，创建，刷新，个性化<code>BeanFactory</code>的扩展点，自定义属性解析；</li><li>环境信息<code>Environment</code>的加载（包括环境变量、系统变量等）；</li><li><code>BeanDefinition</code>的加载，解析；</li><li><code>BeanFactoryPostProcessor</code>的注册与执行流程，<code>BeanDefinitionRegistryPostProcessor</code>的解析，<code>ConfigurationClassPostProcessor</code>对<code>Spring</code>注解的解析过程（<code>@Component、@PropertySources、@PropertySource、@ComponentScans、@ComponentScan、@Import</code>等注解的解析）</li><li><code>BeanPostProcessor</code>的注册流程；</li><li>国际化，<code>Spring</code>事件驱动的加载执行过程；</li></ul><p>在前面，通过注解或XML的方式解析生成了<code>BeanDefinition</code>，接下来就是Spring最为核心的，根据<code>BeanDefinition</code>实例化Bean，并且对Bean的属性进行依赖注入。</p><p><img src="/2022/11/29/%E6%A1%86%E6%9E%B6/Spring/IOC5Springbean%E7%9A%84%E5%88%9B%E5%BB%BA/Bean%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.png" alt="image-20220601203530779"></p><p>其中Spring给了我们众多的扩展点，也涉及到面试常问的点——循环依赖的问题，本章我们探讨较为简单的内容——Spring怎么实例化一个Bean，根据<code>JavaSE</code>知识，我们知道实例化一个Bean 可以通过new or 反射的方式，Spring也不外呼这两种方式</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><h3 id="finishBeanFactoryInitialization-解析过程"><a href="#finishBeanFactoryInitialization-解析过程" class="headerlink" title="finishBeanFactoryInitialization 解析过程"></a><code>finishBeanFactoryInitialization</code> 解析过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">      beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">    <span class="comment">// 设置转换服务，转换服务用来对属性值进行解析的</span></span><br><span class="line">    beanFactory.setConversionService(</span><br><span class="line">      beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register a default embedded value resolver if no BeanFactoryPostProcessor</span></span><br><span class="line">  <span class="comment">// (such as a PropertySourcesPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">  <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">  <span class="comment">// 如果之前没有注册过任何 BeanFactoryPostProcessor（例如 PropertySourcesPlaceholderConfigurer bean），</span></span><br><span class="line">  <span class="comment">// 则注册一个默认的嵌入值解析器：此时，主要用于解析注释属性值。</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">  <span class="comment">// 在prepareBeanFactory 准备BeanFactory时设置进去的，如果存在，则开始早期Bean的创建</span></span><br><span class="line">  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">    getBean(weaverAwareName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">  beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">  <span class="comment">// 允许缓存所有 bean 定义元数据，而不是期望进一步的更改</span></span><br><span class="line">  beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">  <span class="comment">// 实例化所有剩余的（非惰性初始化）单例</span></span><br><span class="line">  beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个方法的大致流程：</p><ol><li>判断是否存在转换服务，有就设置，<code>Spring</code>转换器接口<code>ConversionService</code> 的默认实现是<code>DefaultConversionService</code>,这个默认的转换器实现中，内置了很多的转换器</li><li>判断是否有内置的值解析器，没有就创建一个处理占位符的解析器</li><li>实例化<code>LoadTimeWeaverAware</code>，这里从容器中获取了<code>AOP</code>的织入，如果有的话就开始进行早期的<code>Bean</code>的创建</li><li>停止使用临时的类加载器</li><li>冻结<code>BeanDefinition</code>的元数据信息，防止被修改</li><li>开始实例化所有的单例bean对象</li></ol><p>除了<code>beanFactory.preInstantiateSingletons()</code> 方法，其他都是<code>Bean</code>创建的准备，接下来一个一个分析，首先是转换服务的设置。</p><h2 id="Bean-的创建步骤"><a href="#Bean-的创建步骤" class="headerlink" title="Bean 的创建步骤"></a>Bean 的创建步骤</h2><p>在<code>Spring</code>源码中对<code>Bean</code>的创建遵循一个步骤就是：<code>getBean</code> –&gt; <code>doGetBean</code> –&gt; <code>createBean</code> –&gt; <code>doCreateBean</code> ，常规的<code>Bean</code>的创建过程都是按照这个步骤执行，然后反射实例化，属性填充，初始化，放到一级缓存中。那么非常规的有可能就不遵循这个步骤，比如<code>FactoryBean</code>，<code>InstantiationAwareBeanPostProcessor</code> 等。</p><p><code>DefaultListableBeanFactory</code>#<code>preInstantiateSingletons</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">   <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      <span class="comment">// 根据bean的名称获取BeanDefintion</span></span><br><span class="line">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      <span class="comment">// 不是抽象，是单例，不是懒加载</span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="comment">// 对FactoryBean的处理，这也是mybatis feignClient实现的原理</span></span><br><span class="line">            <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">               FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">               <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                  isEagerInit = AccessController.doPrivileged(</span><br><span class="line">                        (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                        getAccessControlContext());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                        ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                  getBean(beanName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 触发bean的实例化和初始化</span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">   <span class="comment">// 触发 所有Bean初始化后的回调</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      Object singletonInstance = getSingleton(beanName);</span><br><span class="line">      <span class="comment">// 获取单例对象，如果是SmartInitializingSingleton 则调用afterSingletonsInstantiated</span></span><br><span class="line">    <span class="comment">// 在监听器中使用@EventListener注解标记的方法就是在这个方法中进行监听器的添加的，会创建一个监听器的适配器</span></span><br><span class="line">    <span class="comment">// 调用类为 EventListenerMethodProcessor</span></span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">               smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Spring</code>前期解析bean后解析 出来的<code>BeanDefinition</code>放入两个集合<code>BeanDefinitionMap</code> 和<code>BeanDefinitionNames</code>，这里遍历的是<code>BeanDefinitionNames</code>这个集合，存放的是<code>beanName</code>。</p><p>进行了<code>BeanDefinition</code>的合并处理,最终返回的全是<code>RootBeanDefinition</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedLocalBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">   RootBeanDefinition mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">   <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; !mbd.stale) &#123;</span><br><span class="line">      <span class="keyword">return</span> mbd;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> getMergedBeanDefinition(beanName, getBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p><code>FactoryBean</code>是用来创建<code>Bean</code>对象的，他是一个接口，方法：</p><ul><li><code>getObject</code> 获取bean对象</li><li><code>getObjectType</code> 获取bean的类型</li><li><code>isSingleton</code> 是否是单例的，默认是<code>true</code></li></ul><p>在创建对象时，你可以直接在<code>getObject</code>方法中进行<code>new</code>，或者反射，或者是其他都可以，非常的灵活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">MyUser</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MyUser <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 直接new一个对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line"><span class="keyword">return</span> MyUser.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FactoryBean</code> 创建<code>Bean</code>的时候，如果<code>xml</code>注册的是一个<code>FactoryBean</code>的实现，但是获取出来又是具体的<code>MyUser</code>对象，这里<code>Spring</code>使用了懒加载的机制，在<code>Spring</code> 对<code>Bean</code>进行初始化时，实际上只将<code>FactoryBean</code>的实现类注册到了<code>Spring</code>容器中，当我们需要使用的时候，才去判断，如果是<code>FactoryBean</code>类型的，那么就去调用<code>getObject</code>方法去创建对象。如果是第二次去获取<code>Bean</code>，那么是从缓存中获取的，如果是获取<code>&amp;</code>前缀的<code>Bean</code>，那就直接返回。</p><p><img src="/2022/11/29/%E6%A1%86%E6%9E%B6/Spring/IOC5Springbean%E7%9A%84%E5%88%9B%E5%BB%BA/FacoryBean%E7%9A%84%E5%88%9B%E5%BB%BA.png" alt="img"></p><h3 id="BeanFactory-和FactoryBean-的区别？"><a href="#BeanFactory-和FactoryBean-的区别？" class="headerlink" title="BeanFactory 和FactoryBean 的区别？"></a>BeanFactory 和FactoryBean 的区别？</h3><p><code>BeanFactory</code>是一个<code>Bean</code>的创建工厂，比如<code>AbstractApplicationContext</code>就是<code>BeanFactory</code>的实现类，这个类就是用来创建<code>Bean</code>的，创建出来的<code>Bean</code>放在缓存中。</p><p><code>FactoryBean</code>就是<code>Bean</code>实例，是由<code>BeanFactory</code>创建的，并且<code>FactoryBean</code>也是用来创建<code>Bean</code>对象，使用<code>getObject</code>方法进行创建，也是会放在缓存中供下次直接获取，而且如果在使用时需要使用<code>FactoryBean</code>的实例时需要以<code>&amp;</code>前缀才能获取到，比如<code>getBean(&quot;&amp;myFactoryBean&quot;);</code> 如果是获取通过<code>getObject</code>方法创建的对象时，就不需要添加<code>&amp;</code>前缀，比如<code>getBean(&quot;myFactoryBean&quot;);</code> </p><p>相同点：</p><ul><li>都是用来创建对象的</li><li>都是创建出来之后放入缓存中供下次直接使用</li></ul><p>不同点：</p><ul><li><code>BeanFactory</code>是一个对象创建工厂，而<code>FactoryBean</code>是一个<code>Bean</code>实例</li><li><code>BeanFactory</code>创建的对象一般来说都是使用反射调用构造函数创建的，而<code>FactoryBean</code>创建对象是调用<code>getObject</code>方法创建，并且创建方式不一定是通过反射，可以是直接<code>new</code>对象或者其他方式</li><li><code>FactoryBean</code> 在获取对象时，可以获取到两个对象，一个是存放在<code>BeanFactory</code>创建的缓存中，通过<code>&amp;beanName</code>获取的<code>FactoryBean</code>的实现类对象，一个是调用<code>getObject</code>创建的，通过<code>beanName</code>获取的具体对象。</li></ul><img src="/2022/11/29/%E6%A1%86%E6%9E%B6/Spring/IOC5Springbean%E7%9A%84%E5%88%9B%E5%BB%BA/FacoryBean和BeanFactory.png" alt="img" style="zoom:80%;"><h2 id="单例Bean的创建"><a href="#单例Bean的创建" class="headerlink" title="单例Bean的创建"></a>单例Bean的创建</h2><p>在创建时会调用<code>getBean</code>，然后<code>doGetBean</code>，一般来说在<code>Spring</code>中只要是<code>do</code>开头方法基本就是真正干活的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 解析成规范的Bean name ，因为可能是FactoryBean加了&amp; 前缀的Bean或者是有别名的Bean</span></span><br><span class="line">String beanName = transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="comment">// 获取缓存中的Bean, 第一次一定为null</span></span><br><span class="line">Object sharedInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">... </span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 如果缓存中没有，那么就会按照单例或者多例的方式创建</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记已经被创建</span></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 合并BeanDefinition</span></span><br><span class="line">RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">                <span class="comment">// 判断是否存在依赖的Bean的创建，比如dependsOn 依赖 A 这个Bean，那么就需要先创建A这个bean</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">                        <span class="comment">// 注册依赖的Bean，放在集合中</span></span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 创建Bean</span></span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">                    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line"><span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> convertedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉不重要的代码，可以看到首先是从缓存中获取，如果没有获取到就进行一些列检查，最终检查是否单例的<code>Bean</code>，此时这里的缓存为<code>singletonObjects</code>被称为一级缓存 是一个<code>ConcurrentHashMap</code> key是bean的名称 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">   Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">   <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是，那么就会调用<code>getSingleton</code>方法，传入一个<code>beanName</code>,一个<code>ObjectFactory</code>的<code>lambda</code>表达式，表达式中有个<code>createBean</code>方法，这个方法就是创建的<code>Bean</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br></pre></td></tr></table></figure><p>执行<code>lambda</code>表达式的具体方法时执行<code>createBean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Return an instance (possibly shared or independent)</span></span><br><span class="line"><span class="comment">    * of the object managed by this factory.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an instance of the bean (should never be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getSingleton"><a href="#getSingleton" class="headerlink" title="getSingleton"></a><code>getSingleton</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">   Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="comment">// 从一级缓存中获取</span></span><br><span class="line">      Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 标记当前bean正在创建</span></span><br><span class="line">         beforeSingletonCreation(beanName);</span><br><span class="line">         <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">         <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">            <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行具体的方法，调用createBean方法,这和spring的循环依赖密切相关，后续循环依赖分析的时候进行详细学习</span></span><br><span class="line">            singletonObject = singletonFactory.getObject();</span><br><span class="line">            newSingleton = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">           ...</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">               <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移除正在创建的bean</span></span><br><span class="line">            afterSingletonCreation(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">            <span class="comment">// 添加bean带单例池</span></span><br><span class="line">            addSingleton(beanName, singletonObject);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> singletonObject;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现这个<code>getSingleton</code>方法，功能是，如果当前bean在单例池没有，那么调用<code>ObjectFactory</code>的<code>getObject</code>方法获取，在外层其实调用了<code>createBean</code>方法，让我们来看看<code>createBean</code></p><h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><p>这个方法其实是在<code>AbstractAutowireCapableBeanFactory</code>中实现（ <code>DefaultListableBeanFactory</code>的父类）<code>AbstractAutowireCapableBeanFactory</code>的定位是一个提供 bean 创建（使用构造函数解析）、属性填充、和初始化的<code>BeanFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">   <span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">   <span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">   <span class="comment">// 解析Bean的Class 用于反射创建对象</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Prepare method overrides.</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 方法覆盖准备 lookup-method replace-method 当前bean的方法由另外方法覆盖</span></span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">      <span class="comment">// 解析提前实例化，使用InstantiationAwareBeanPostProcessor实现</span></span><br><span class="line">      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 实例化 + 初始化 Bean</span></span><br><span class="line">      <span class="comment">// 真正的创建Bean</span></span><br><span class="line">      Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span> beanInstance;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123; ...</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是进行了<code>Bean</code>的类型的解析，主要是用于后面的反射创建对象时使用，并设置到<code>RootBeanDefinition</code>中，然后进行方法覆盖操作。在里面遇到了重要bean的提前初始化，由<code>resolveBeforeInstantiation</code>实现。</p><h4 id="提前初始化"><a href="#提前初始化" class="headerlink" title="提前初始化"></a>提前初始化</h4><p>这是spring给我们的一个扩展点。让对象可以提前创建，而不用再继续走<code>doCreateBean</code>方法里面的复杂逻辑，这样的话就提供给用户能够自己控制对象的创建过程以及执行增强等操作。</p><h5 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">   Object bean = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">      <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">      <span class="comment">// 存在InstantiationAwareBeanPostProcessor实现</span></span><br><span class="line">      <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">          <span class="comment">//bean的类型</span></span><br><span class="line">         Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">         <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 调用before</span></span><br><span class="line">            bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">            <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 调研after方法</span></span><br><span class="line">               bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>InstantiationAwareBeanPostProcessor</code> 是具备实例化感知能力的bean后置处理器，这里重点在于<code>postProcessBeforeInstantiation</code> 和 <code>postProcessAfterInitialization</code> 方法。</p><blockquote><p>注意Instantiation 和 Initialization 的区别，前者是<strong>实例化</strong>（反射生成bean对象，任何属性都没有赋值，生成对象叫实例化）后者是<strong>初始化</strong>（属性赋值，初始化方法调用叫初始化）</p></blockquote><img src="/2022/11/29/%E6%A1%86%E6%9E%B6/Spring/IOC5Springbean%E7%9A%84%E5%88%9B%E5%BB%BA/InstantiationAwareBeanPostProcessor.png" alt="image-20220601224404292" style="zoom:80%;"><ul><li><code>applyBeanPostProcessorsBeforeInstantiation</code> 提供我们自己定一个bean，而不是spring帮我们反射生成bean的扩展，后续spring不会帮我们进行依赖注入</li><li><code>applyBeanPostProcessorsAfterInitialization</code> 提供对bean进行代理的扩展,初始化后，我们可以对这个bean进行代理</li></ul><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ol><li><p>需要提前实例化的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeforeInstantiation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeInvoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;提前实例化，开始执行业务....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>InstantiationAwareBeanPostProcessor</code>的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInstantiationAwareBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beanName: &quot;</span> + beanName + <span class="string">&quot;执行了 postProcessBeforeInstantiation 方法&quot;</span>);</span><br><span class="line">        <span class="comment">// 提前进行实例化</span></span><br><span class="line">        <span class="keyword">if</span> (beanClass == MyBeforeInstantiation.class) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(beanClass);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MyMethodInterceptor());</span><br><span class="line">            Object obj = enhancer.create();</span><br><span class="line">            System.out.println(<span class="string">&quot;创建对象：&quot;</span> + obj);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beanName: &quot;</span> + beanName + <span class="string">&quot;执行了 postProcessAfterInstantiation 方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beanName: &quot;</span> + beanName + <span class="string">&quot;执行了 postProcessProperties 方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beanName: &quot;</span> + beanName + <span class="string">&quot;执行了 postProcessBeforeInitialization 方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beanName: &quot;</span> + beanName + <span class="string">&quot;执行了 postProcessAfterInitialization 方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用了CGLIB 动态代理去增强创建代理对象，编写一个回调拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前：&quot;</span>+method);</span><br><span class="line">        Object o1 = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后：&quot;</span>+method);</span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(Context.class);</span><br><span class="line">MyBeforeInstantiation bean = ac.getBean(MyBeforeInstantiation.class);</span><br><span class="line">bean.beforeInvoke();</span><br></pre></td></tr></table></figure></li></ol><p>结果</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">方法执行前：public void com<span class="selector-class">.lq</span><span class="selector-class">.spring</span><span class="selector-class">.Instantiation</span><span class="selector-class">.MyBeforeInstantiation</span><span class="selector-class">.beforeInvoke</span>()</span><br><span class="line">提前实例化，开始执行业务....</span><br><span class="line">方法执行后：public void com<span class="selector-class">.lq</span><span class="selector-class">.spring</span><span class="selector-class">.Instantiation</span><span class="selector-class">.MyBeforeInstantiation</span><span class="selector-class">.beforeInvoke</span>()</span><br></pre></td></tr></table></figure><p>里只执行了两个方法，一个是<code>postProcessBeforeInstantiation</code>，是<code>InstantiationAwareBeanPostProcessor</code>的前置实例化接口，一个是<code>postProcessAfterInitialization</code>，是<code>BeanPostProcessor</code>的后置实例化接口。</p><h3 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h3><p>如果前面的<code>InstantiationAwareBeanPostProcessor</code> 没有返回一个bean 那么接下来就是spring容器为我们生成这个bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 实例化对象</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">   Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">   <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">      mbd.resolvedTargetType = beanType;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会先从缓存中获取<code>FactoryBean</code>实例化的对象，如果有就进行下面的逻辑，一般来说基本是获取不到的，来看 <code>createBeanInstance</code></p><h4 id="createBeanInstance"><a href="#createBeanInstance" class="headerlink" title="createBeanInstance"></a>createBeanInstance</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断class必须是public修饰的，否则报错</span></span><br><span class="line">   <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取到supplier，如果不为空，则创建对象直接返回</span></span><br><span class="line">   <span class="comment">// 扩展点，可以在这里进行对象的初始化创建，使用BFPP对BeanDefinition进行设置supplier</span></span><br><span class="line">   Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">   <span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用FactoryMethod进行对象的创建</span></span><br><span class="line">   <span class="comment">// 扩展点</span></span><br><span class="line">   <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有2个扩展点，分别是2个return，意味着只要获取到<code>Bean</code>，那么就不需要进行下一步的执行</p><h5 id="obtainFromSupplier"><a href="#obtainFromSupplier" class="headerlink" title="obtainFromSupplier"></a>obtainFromSupplier</h5><p>这里先用<code>getInstanceSupplier</code>获取Supplier，是<code>BeanDefinition</code>的方法，在解析<code>BeanFactoryPostProcessor</code>时可以进行<code>BeanDefinition</code>的处理。而在<code>BeanFactoryPostProcessor</code>接口注册和执行的时候，完全是可以自己定义一个<code>BeanFactoryPostProcessor</code>进行扩展实现。</p><p>这个属性位于<code>AbstractBeanDefinition</code>类中，一般来说用户自定义的<code>BeanDefinition</code>都是<code>GenericBeanDefinition</code>，而<code>GenericBeanDefinition</code>是继承这个抽象类的，所以我们在进行<code>BFPP</code>扩展实现时可以对<code>GenericBeanDefinition</code>设置这个属性值，这个属性值是一个<code>Supplier</code>函数式接口，相当于<code>lambda</code>表达式的用法，接下来自己实现一个验证一下。</p><ol><li><p>创建一个<code>SupplierUser</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SupplierUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SupplierUser</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;SupplierUser&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建一个创建<code>SupplierUser</code>的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateSupplier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SupplierUser <span class="title">createUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SupplierUser(<span class="string">&quot;redwinter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建BFPP的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(<span class="string">&quot;supplierUser&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取原生的BeanDefinition</span></span><br><span class="line">        GenericBeanDefinition genericBeanDefinition = (GenericBeanDefinition) beanDefinition;</span><br><span class="line">        <span class="comment">// 实例化Supplier</span></span><br><span class="line">        genericBeanDefinition.setInstanceSupplier(CreateSupplier::createUser);</span><br><span class="line">        <span class="comment">// 设置类型</span></span><br><span class="line">        genericBeanDefinition.setBeanClass(CreateSupplier.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SupplierBeanTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(Context.class);</span><br><span class="line">    SupplierUser bean = ac.getBean(SupplierUser.class);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SupplierUser&#123;username=<span class="string">&#x27;redwinter&#x27;</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="FactoryMethod-对象的创建"><a href="#FactoryMethod-对象的创建" class="headerlink" title="FactoryMethod 对象的创建"></a>FactoryMethod 对象的创建</h5><p> 这也是一个扩展点，根据源码可以看出这个属性也是在<code>BeanDefinition</code>中的，但是这个可以通过标签的方式进行设置，在<code>Spring</code>中<code>factory-method</code>创建<code>Bean</code>有两种方式，一种是静态工厂创建，一种是实例工厂创建。</p><p>目前创建bean的几种方式：</p><ul><li>使用FactoryBean创建</li><li>使用InstantiationAwreBeanPostProcessor的前置实例化方法postProcessBeforeInstantiation进行创建</li><li>使用Supplier进行创建</li><li>使用factory-method标签进行创建<ul><li>实例工厂创建（配合factory-bean标签）</li><li>静态工厂创建</li></ul></li><li>反射创建（常规的，完整的创建流程）</li></ul><p><img src="/2022/11/29/%E6%A1%86%E6%9E%B6/Spring/IOC5Springbean%E7%9A%84%E5%88%9B%E5%BB%BA/%E5%88%9B%E5%BB%BAbean%E7%9A%84%E6%96%B9%E5%BC%8F.png" alt="img"></p><p>下一篇继续介绍<code>Bean</code>的创建流程。</p><p>参考</p><p><a href="https://www.cnblogs.com/redwinter/p/16241328.html">https://www.cnblogs.com/redwinter/p/16241328.html</a></p><p><a href="https://www.cnblogs.com/redwinter/p/16261003.html">https://www.cnblogs.com/redwinter/p/16261003.html</a></p><p><a href="https://www.cnblogs.com/cuzzz/p/16609681.html">https://www.cnblogs.com/cuzzz/p/16609681.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;到目前为止，&lt;code&gt;Spring&lt;/code&gt;源码中&lt;code&gt;AbstractApplicationContext#refresh&lt;/code&gt;方法的已经解读到第11个方法&lt;code&gt;finishBeanFactoryInitialization&lt;/code&gt;,前10个方法介绍了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt;的准备，创建，刷新，个性化&lt;code&gt;BeanFactory&lt;/code&gt;的扩展点，自定义属性解析；&lt;/li&gt;
&lt;li&gt;环境信息&lt;code&gt;Environment&lt;/code&gt;的加载（包括环境变量、系统变量等）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanDefinition&lt;/code&gt;的加载，解析；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;的注册与执行流程，&lt;code&gt;BeanDefinitionRegistryPostProcessor&lt;/code&gt;的解析，&lt;code&gt;ConfigurationClassPostProcessor&lt;/code&gt;对&lt;code&gt;Spring&lt;/code&gt;注解的解析过程（&lt;code&gt;@Component、@PropertySources、@PropertySource、@ComponentScans、@ComponentScan、@Import&lt;/code&gt;等注解的解析）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanPostProcessor&lt;/code&gt;的注册流程；&lt;/li&gt;
&lt;li&gt;国际化，&lt;code&gt;Spring&lt;/code&gt;事件驱动的加载执行过程；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在前面，通过注解或XML的方式解析生成了&lt;code&gt;BeanDefinition&lt;/code&gt;，接下来就是Spring最为核心的，根据&lt;code&gt;BeanDefinition&lt;/code&gt;实例化Bean，并且对Bean的属性进行依赖注入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/11/29/%E6%A1%86%E6%9E%B6/Spring/IOC5Springbean%E7%9A%84%E5%88%9B%E5%BB%BA/Bean%E7%9A%84%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;image-20220601203530779&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中Spring给了我们众多的扩展点，也涉及到面试常问的点——循环依赖的问题，本章我们探讨较为简单的内容——Spring怎么实例化一个Bean，根据&lt;code&gt;JavaSE&lt;/code&gt;知识，我们知道实例化一个Bean 可以通过new or 反射的方式，Spring也不外呼这两种方式&lt;/p&gt;
&lt;h2 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h2&gt;&lt;h3 id=&quot;finishBeanFactoryInitialization-解析过程&quot;&gt;&lt;a href=&quot;#finishBeanFactoryInitialization-解析过程&quot; class=&quot;headerlink&quot; title=&quot;finishBeanFactoryInitialization 解析过程&quot;&gt;&lt;/a&gt;&lt;code&gt;finishBeanFactoryInitialization&lt;/code&gt; 解析过程&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;finishBeanFactoryInitialization&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// Initialize conversion service for this context.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 设置转换服务，转换服务用来对属性值进行解析的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    beanFactory.setConversionService(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// Register a default embedded value resolver if no BeanFactoryPostProcessor&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// (such as a PropertySourcesPlaceholderConfigurer bean) registered any before:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// at this point, primarily for resolution in annotation attribute values.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 如果之前没有注册过任何 BeanFactoryPostProcessor（例如 PropertySourcesPlaceholderConfigurer bean），&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 则注册一个默认的嵌入值解析器：此时，主要用于解析注释属性值。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!beanFactory.hasEmbeddedValueResolver()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    beanFactory.addEmbeddedValueResolver(strVal -&amp;gt; getEnvironment().resolvePlaceholders(strVal));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 在prepareBeanFactory 准备BeanFactory时设置进去的，如果存在，则开始早期Bean的创建&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (String weaverAwareName : weaverAwareNames) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getBean(weaverAwareName);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// Stop using the temporary ClassLoader for type matching.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  beanFactory.setTempClassLoader(&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// Allow for caching all bean definition metadata, not expecting further changes.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 允许缓存所有 bean 定义元数据，而不是期望进一步的更改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  beanFactory.freezeConfiguration();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// Instantiate all remaining (non-lazy-init) singletons.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 实例化所有剩余的（非惰性初始化）单例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  beanFactory.preInstantiateSingletons();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这个方法的大致流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断是否存在转换服务，有就设置，&lt;code&gt;Spring&lt;/code&gt;转换器接口&lt;code&gt;ConversionService&lt;/code&gt; 的默认实现是&lt;code&gt;DefaultConversionService&lt;/code&gt;,这个默认的转换器实现中，内置了很多的转换器&lt;/li&gt;
&lt;li&gt;判断是否有内置的值解析器，没有就创建一个处理占位符的解析器&lt;/li&gt;
&lt;li&gt;实例化&lt;code&gt;LoadTimeWeaverAware&lt;/code&gt;，这里从容器中获取了&lt;code&gt;AOP&lt;/code&gt;的织入，如果有的话就开始进行早期的&lt;code&gt;Bean&lt;/code&gt;的创建&lt;/li&gt;
&lt;li&gt;停止使用临时的类加载器&lt;/li&gt;
&lt;li&gt;冻结&lt;code&gt;BeanDefinition&lt;/code&gt;的元数据信息，防止被修改&lt;/li&gt;
&lt;li&gt;开始实例化所有的单例bean对象&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC(4) 国际化和事件发布</title>
    <link href="http://yoursite.com/2022/11/25/%E6%A1%86%E6%9E%B6/Spring/IOC4%E5%9B%BD%E9%99%85%E5%8C%96%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83/"/>
    <id>http://yoursite.com/2022/11/25/%E6%A1%86%E6%9E%B6/Spring/IOC4%E5%9B%BD%E9%99%85%E5%8C%96%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83/</id>
    <published>2022-11-25T08:27:53.000Z</published>
    <updated>2022-11-29T08:25:49.703Z</updated>
    
    <content type="html"><![CDATA[<p>在 Spring IOC(3) 我们介绍了<code>Spring IOC</code>中的<code>prepareRefresh</code>、<code>obtainFreshBeanFactory</code>、<code>prepareBeanFactory</code>。</p><p>本章介绍<code>AbstractApplicationContext#refresh</code>的第7, 8, 10个方法，国际化和事件发布。第9个方法<code>onRefresh</code>刷新蓉器这个方法是一个空方法，由子类实现，这里直接跳过了。</p><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>单纯的<code>Spring</code>中设置国际化实际上是体现不出来的，需要用到<code>Spring MVC</code> 才能有所体现。</p><h3 id="初始化国际化"><a href="#初始化国际化" class="headerlink" title="初始化国际化"></a>初始化国际化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initMessageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取beanFactory</span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="comment">// 如果工厂中已经有这个bean，那就获取出来设置到messageSource上</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">      <span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">      <span class="comment">// 判断父类是否存在，如果存在则将判断父类是否设置了消息源，没有设置就设置给他</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">         HierarchicalMessageSource hms = (HierarchicalMessageSource) <span class="keyword">this</span>.messageSource;</span><br><span class="line">         <span class="keyword">if</span> (hms.getParentMessageSource() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">            <span class="comment">// registered already.</span></span><br><span class="line">            hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">      <span class="comment">// 如果容器中没有注册bean，那么new一个</span></span><br><span class="line">      DelegatingMessageSource dms = <span class="keyword">new</span> DelegatingMessageSource();</span><br><span class="line">      dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">      <span class="keyword">this</span>.messageSource = dms;</span><br><span class="line">      <span class="comment">// 注册到容器中</span></span><br><span class="line">      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="keyword">this</span>.messageSource);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="keyword">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是从容器中获取<code>MessageSource</code>接口的实现，如果存在则直接赋值给<code>AbstractApplicationContext</code>的<code>messageSource</code>属性，用于解析国际化和参数化。如果没有就直接<code>new</code>一个委派的实现类，然后赋值给<code>messageSource</code>属性，并注册到容器中。</p><p>在Spring中提供了两个默认的实现：</p><ul><li><code>ResourceBundleMessageSource</code> ：基于Java的<code>ResourceBundle</code>基础类实现，允许仅通过资源名加载国际化资源</li><li><code>ReloadableResourceBundleMessageSource</code>：这个功能和第一个类的功能类似，多了定时刷新功能，允许在不重启系统的情况下，更新资源的信息</li></ul><h3 id="国际化的使用"><a href="#国际化的使用" class="headerlink" title="国际化的使用"></a>国际化的使用</h3><p>通常我们在<code>ApplicationContext</code>类型的容器中使用国际化3个步骤</p><ol><li><p>创建国际化文件</p><p><img src="/2022/11/25/%E6%A1%86%E6%9E%B6/Spring/IOC4%E5%9B%BD%E9%99%85%E5%8C%96%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83/%E5%9B%BD%E9%99%85%E5%8C%96%E6%96%87%E4%BB%B6.png" alt="image-20221125165613192"></p></li><li><p>向容器中注册一个<code>MessageSource</code>类型的bean，bean名称必须为：<code>messageSource</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceBundleMessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResourceBundleMessageSource result = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">        <span class="comment">//可以指定国际化化配置文件的位置，格式：路径/文件名称,注意不包含【语言_国家.properties】含这部分</span></span><br><span class="line">        result.setBasenames(<span class="string">&quot;i18n/message&quot;</span>); <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用<code>AbstractApplicationContext</code>中的<code>getMessage</code>来获取国际化信息，其内部将交给第二步中注册的<code>messageSource</code>名称的bean进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.lq.spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(Context.class);</span><br><span class="line">        <span class="comment">//未指定Locale，此时系统会取默认的locale对象，本地默认的值中文【中国】，即：zh_CN</span></span><br><span class="line">        System.out.println(ac.getMessage(<span class="string">&quot;username&quot;</span>, <span class="keyword">null</span>, Locale.CHINA));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h2><h3 id="初始化多播器、刷新容器、注册监听器"><a href="#初始化多播器、刷新容器、注册监听器" class="headerlink" title="初始化多播器、刷新容器、注册监听器"></a>初始化多播器、刷新容器、注册监听器</h3><p>refresh的第8个方法<code>initApplicationEventMulticaster</code>初始化多播器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="comment">// 从容器中获取bean，applicationEventMulticaster</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">            beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有事件多播器就new一个，多播器会创建一个监听器的集合，用于存放监听器</span></span><br><span class="line">      <span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">      beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line">               <span class="string">&quot;[&quot;</span> + <span class="keyword">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registerListeners</code>注册监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">    <span class="comment">// 循环已经存在的监听器，并将监听器加入到多播器中</span></span><br><span class="line">   <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">   <span class="comment">// 在容器中获取所有实现了ApplicationListener接口的bd，并将beaName加入到多播器中</span></span><br><span class="line"><span class="comment">// 这些都还没有实例化 实际是添加到了org.springframework.context.event.AbstractApplicationEventMulticaster.DefaultListenerRetriever#applicationListenerBeans中</span></span><br><span class="line">   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">   <span class="comment">// 遍历bean，并加入到监听器bean集合中</span></span><br><span class="line">   <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">   <span class="comment">// 获取早期的事件，这个事件是在准备刷新阶段（第一个阶段前戏阶段）设置进来的，是一个空的集合</span></span><br><span class="line">    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">         getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring的事件发布是如何设计的？"><a href="#Spring的事件发布是如何设计的？" class="headerlink" title="Spring的事件发布是如何设计的？"></a>Spring的事件发布是如何设计的？</h3><p>Spring的事件机制实际上是使用了观察者模式进行设计的，观察者模式分为两大角色，观察者和被观察者，只是Spring更加的抽象，在Spring中分为:</p><ul><li>事件<code>ApplicationEvent</code>。被观察者角色，监听器重点监听对象</li><li>监听器<code>ApplicationListener</code>。观察者角色，用来监听对应的事件，做相应的处理</li><li>事件发布者<code>ApplicationEventPublisher</code>。用来创建并发布事件</li><li>事件的多播器<code>ApplicationEventMulticaster</code>。拥有监听器对象，提供发布事件的功能，遍历监听器，监听器来处理自己需要处理的事件,<code>ApplicationEventMulticaster</code> 是 <code>ApplicationEventPublisher</code> 的底层实现</li></ul><p><code>AbstractApplicationContext</code>这个<code>Spring</code> 的<code>BeanFactory</code>容器就是实现了<code>ApplicationEventPublisher</code>,可以对事件进行发布。在<code>Spring</code>中内置了很多的事件，比如：<code>ContextClosedEvent</code>、<code>ContextRefreshedEvent</code>、<code>ContextStartedEvent</code>、<code>ContextStopedEvent</code>，而监听器的话<code>Spring</code>内置不多，<code>Spring</code>还提供了注解方式的配置监听器，注解为<code>@EventListener</code>。</p><p><img src="/2022/11/25/%E6%A1%86%E6%9E%B6/Spring/IOC4%E5%9B%BD%E9%99%85%E5%8C%96%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83/Spring%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%92%8C%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="img"></p><p>官网提供了两种配置监听器的方式，一种是实现<code>ApplicationListener</code>接口，一种是使用<code>@EventLister</code>注解配置，基于注解还可以配置异步的，排序的。</p><p>在自定义的事件发布时需要实现<code>ApplicationEventPublisherAware</code> 接口获取到<code>ApplicationEventPublisher</code> 进行发布事件。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>代码是Spring官网提供的，功能就是如果邮箱被拉黑，那么就不发送消息给邮箱，而是发布一个事件进行其他处理</p><ol><li>定义一个事件源发布者：用来处理黑名单的邮箱</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; blackList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布事件</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmailService</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        blackList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        blackList.add(<span class="string">&quot;123@qq.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getBlackList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> blackList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlackList</span><span class="params">(List&lt;String&gt; blackList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blackList = blackList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">(String address, String context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (blackList.contains(address))&#123;</span><br><span class="line">            <span class="comment">// 发布一个事件，不发生消息到邮箱</span></span><br><span class="line">            applicationEventPublisher.publishEvent(<span class="keyword">new</span> EmailEvent(<span class="keyword">this</span>, address, context));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;.......发送邮箱 ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>定义事件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new &#123;<span class="doctag">@code</span> ApplicationEvent&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source the object on which the event initially occurred or with</span></span><br><span class="line"><span class="comment">     *               which the event is associated (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmailEvent</span><span class="params">(Object source, String address, String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EmailEvent&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;address=&#x27;&quot;</span> + address + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, context=&#x27;&quot;</span> + context + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义监听器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">EmailEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String notifyAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNotifyAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> notifyAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNotifyAddress</span><span class="params">(String notifyAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notifyAddress = notifyAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(EmailEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到事件，开始发布&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息给&quot;</span> + notifyAddress + event.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>定义客户端</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.lq.spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(Context.class);</span><br><span class="line">        EmailService bean = ac.getBean(EmailService.class);</span><br><span class="line">        bean.sendEmail(<span class="string">&quot;123@qq.com&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>结果</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">收到事件，开始发布</span><br><span class="line">发送消息给nullEmailEvent&#123;<span class="attribute">address</span>=<span class="string">&#x27;123@qq.com&#x27;</span>, <span class="attribute">context</span>=<span class="string">&#x27;test&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>当然可有使用注解<code>@EventListener</code>进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailNotifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String notifyAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNotifyAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> notifyAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNotifyAddress</span><span class="params">(String notifyAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notifyAddress = notifyAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(EmailEvent event)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到事件，开始发布&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息给&quot;</span> + notifyAddress + event.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EventListener解析流程"><a href="#EventListener解析流程" class="headerlink" title="@EventListener解析流程"></a>@EventListener解析流程</h3><p>在Spring对注解进行扫描的时候，Spring会默认在容器中添加几个内置的<code>Bean</code>，并且以<strong><code>internal</code></strong>开头的<code>Bean</code>对象，这些<code>Bean</code>都是在<code>AnnotationConfigUtils</code>这个类的<code>registerAnnotationConfigProcessors</code>中设置的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 EventListenerMethodProcessor 的BeanDefinition</span></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">   RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">   def.setSource(source);</span><br><span class="line">   beanDefs.add(registerPostProcessor(registry, def, </span><br><span class="line"> EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 DefaultEventListenerFactory 的BeanDefinition</span></span><br><span class="line"><span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">   RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">   def.setSource(source);</span><br><span class="line">   beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置了一个<code>EventListenerMethodProcessor</code>类还有一个<code>DefaultEventListenerFactory</code>，这两个类分别用来解析<code>@EvenListener</code>和创建<code>ApplicationListener</code>接口的适配器。</p><p><img src="/2022/11/25/%E6%A1%86%E6%9E%B6/Spring/IOC4%E5%9B%BD%E9%99%85%E5%8C%96%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83/EventListenerMethodProcessor%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="image-20220529154240747"></p><p><code>EventListenerMethodProcessor</code> 实现了<code>Bean</code></p><p><code>FactoryPostProcessor</code>接口、<code>SmartInitializingSingleton</code>接口和<code>ApplicationContextAware</code>接口，<code>BeanFactoryPostProcessor</code>接口是用来对<code>BeanDefinition</code>进行个性化设置解析等操作，<code>SmartInitializingSingleton</code>接口是在初始化所有的单例<code>Bean</code>之后触发的，也就是在<code>preInstantiateSingletons</code>方法中初始化<code>Bean</code>之后调用，<code>ApplicationContextAware</code>是用来获取<code>ApplicationContext</code>的。</p><ol><li><p><code>EventListenerMethodProcessor</code>的 <code>postProcessBeanFactory</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line"><span class="comment">// 获取所有的 EventListenerFactory</span></span><br><span class="line">   Map&lt;String, EventListenerFactory&gt; beans = beanFactory.getBeansOfType(EventListenerFactory.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">   List&lt;EventListenerFactory&gt; factories = <span class="keyword">new</span> ArrayList&lt;&gt;(beans.values());</span><br><span class="line">   AnnotationAwareOrderComparator.sort(factories);</span><br><span class="line">   <span class="keyword">this</span>.eventListenerFactories = factories;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>EventListenerFactory</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventListenerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否可以把当前方法包装成一个 ApplicationListener</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">supportsMethod</span><span class="params">(Method method)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当前bean的名称 和 标注事件监听注解的方法 生成一个ApplicationListener</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   ApplicationListener&lt;?&gt; createApplicationListener(String beanName, Class&lt;?&gt; type, Method method);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类有2个实现<code>DefaultEventListenerFactory</code>和<code>TransactionalEventListenerFactory</code>，<code>EventListenerMethodProcessor</code>使用策略模式，调用者两个类，把符合要求的方法封装成<code>ApplicationLister</code>对象，注册到上下文（上下文会把它们注册到多播器）</p></li><li><p>封装成<code>ApplicationListener</code></p><p>在<code>afterSingletonsInstantiated</code>方法中实现，在bean初始化后会被容器回调使用，获取容器中所有的bean，调用<code>processBean</code>方法把其中标注<code>@EventListener</code>的方法，or <code>@EventListener</code>符合注册的方法，包装一个<code>ApplicationListener</code> 并且注册到上下文中</p><p><code>EventListenerMethodProcessor</code>类中<code>processBean</code>的部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 省略代码....</span></span><br><span class="line"><span class="comment">// 遍历所有标有@EventListener注解的方法</span></span><br><span class="line"><span class="keyword">for</span> (Method method : annotatedMethods.keySet()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (EventListenerFactory factory : factories) &#123;</span><br><span class="line">    <span class="keyword">if</span> (factory.supportsMethod(method)) &#123; <span class="comment">// 选择合适的策略，EventListenerFactory的2个实现类</span></span><br><span class="line">      Method methodToUse = AopUtils.selectInvocableMethod(method, context.getType(beanName));</span><br><span class="line">      <span class="comment">// 使用工厂创建一个监听器，实际上创建的就是一个ApplicationListenerMethodAdapter</span></span><br><span class="line">      ApplicationListener&lt;?&gt; applicationListener =</span><br><span class="line">        factory.createApplicationListener(beanName, targetType, methodToUse);</span><br><span class="line">      <span class="keyword">if</span> (applicationListener <span class="keyword">instanceof</span> ApplicationListenerMethodAdapter) &#123;</span><br><span class="line">        ((ApplicationListenerMethodAdapter) applicationListener).init(context, <span class="keyword">this</span>.evaluator);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 添加到容器中，如果多播器不为空，则添加到多播器的监听器集合中</span></span><br><span class="line">      context.addApplicationListener(applicationListener);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 省略代码....</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ApplicationListener&lt;?&gt; createApplicationListener(String beanName, Class&lt;?&gt; type, Method method) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ApplicationListenerMethodAdapter(beanName, type, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典的 策略（2种策略）+工厂（创建<code>ApplicationListener</code>）+ 责任链设计模式</p></li></ol><p><img src="/2022/11/25/%E6%A1%86%E6%9E%B6/Spring/IOC4%E5%9B%BD%E9%99%85%E5%8C%96%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83/%E4%BA%8B%E4%BB%B6%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90.png" alt="img"></p><h3 id="ApplicationListenerMethodAdapter"><a href="#ApplicationListenerMethodAdapter" class="headerlink" title="ApplicationListenerMethodAdapter"></a>ApplicationListenerMethodAdapter</h3><h4 id="DefaultEventListenerFactory"><a href="#DefaultEventListenerFactory" class="headerlink" title="DefaultEventListenerFactory"></a>DefaultEventListenerFactory</h4><p>这个类是在<code>DefaultEventListenerFactory</code>方法中创建而出的一个<code>ApplicationListener</code>适配器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ApplicationListenerMethodAdapter</span><span class="params">(String beanName, Class&lt;?&gt; targetClass, Method method)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.beanName = beanName;</span><br><span class="line">   <span class="keyword">this</span>.method = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">   <span class="keyword">this</span>.targetMethod = (!Proxy.isProxyClass(targetClass) ?</span><br><span class="line">         AopUtils.getMostSpecificMethod(method, targetClass) : <span class="keyword">this</span>.method);</span><br><span class="line">   <span class="keyword">this</span>.methodKey = <span class="keyword">new</span> AnnotatedElementKey(<span class="keyword">this</span>.targetMethod, targetClass);</span><br><span class="line"></span><br><span class="line">   EventListener ann = AnnotatedElementUtils.findMergedAnnotation(<span class="keyword">this</span>.targetMethod, EventListener.class);</span><br><span class="line">   <span class="comment">// 解析第一个参数的类型， 没有参数会抛出异常</span></span><br><span class="line">   <span class="keyword">this</span>.declaredEventTypes = resolveDeclaredEventTypes(method, ann);</span><br><span class="line">   <span class="keyword">this</span>.condition = (ann != <span class="keyword">null</span> ? ann.condition() : <span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">this</span>.order = resolveOrder(<span class="keyword">this</span>.targetMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">   Object[] args = resolveArguments(event); <span class="comment">// 解析参数</span></span><br><span class="line">   <span class="keyword">if</span> (shouldHandle(event, args)) &#123;</span><br><span class="line">      Object result = doInvoke(args);<span class="comment">//反射调用方法</span></span><br><span class="line">      <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">         handleResult(result);<span class="comment">// 如果方法有返回值，后续还会处理返回值</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;No result object given - no result to handle&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TransactionalEventListenerFactory"><a href="#TransactionalEventListenerFactory" class="headerlink" title="TransactionalEventListenerFactory"></a>TransactionalEventListenerFactory</h4><p>事务时讨论</p><h3 id="发布事件"><a href="#发布事件" class="headerlink" title="发布事件"></a>发布事件</h3><p>在<code>refresh</code>方法的最后一个 方法<code>finishRefresh</code>中有个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">ApplicationEvent applicationEvent;</span><br><span class="line"><span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line"><span class="comment">// 把ContextRefreshedEvent变成ApplicationEvent </span></span><br><span class="line">applicationEvent = (ApplicationEvent) event;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line"><span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 将给定的ContextRefreshedEvent事件多播到适当的侦听器</span></span><br><span class="line">getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish event via parent context as well...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跟进<code>SimpleApplicationEventMulticaster</code>#<code>multicastEvent(applicationEvent, eventType);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 入参的event为ContextRefreshedEvent  eventType为null</span></span><br><span class="line"><span class="comment">// 所以先确定eventType的值 因为eventType为null  所以获取的type为ContextRefreshedEvent的ResolvableType </span></span><br><span class="line">ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line"><span class="comment">// 这里是异步监听的处理  获取执行器的   默认是同步监听处理的</span></span><br><span class="line">Executor executor = getTaskExecutor();</span><br><span class="line"><span class="comment">// getApplicationListeners(event, type) 是获取所有符合事件类型的监听  然后循环依次通知</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line"><span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果不是异步  那么在这里执行监听通知</span></span><br><span class="line"><span class="comment">// 实际就是执行ApplicationListener的onApplicationEvent方法   也就是我们监听器的自定义监听内容</span></span><br><span class="line">invokeListener(listener, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考</p><p><a href="https://blog.csdn.net/chenzoff/article/details/124682235">https://blog.csdn.net/chenzoff/article/details/124682235</a></p><p><a href="https://www.cnblogs.com/redwinter/p/16229572.html">https://www.cnblogs.com/redwinter/p/16229572.html</a></p><p><a href="https://www.cnblogs.com/cuzzz/p/16609679.html">https://www.cnblogs.com/cuzzz/p/16609679.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Spring IOC(3) 我们介绍了&lt;code&gt;Spring IOC&lt;/code&gt;中的&lt;code&gt;prepareRefresh&lt;/code&gt;、&lt;code&gt;obtainFreshBeanFactory&lt;/code&gt;、&lt;code&gt;prepareBeanFactory&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;本章介绍&lt;code&gt;AbstractApplicationContext#refresh&lt;/code&gt;的第7, 8, 10个方法，国际化和事件发布。第9个方法&lt;code&gt;onRefresh&lt;/code&gt;刷新蓉器这个方法是一个空方法，由子类实现，这里直接跳过了。&lt;/p&gt;
&lt;h2 id=&quot;国际化&quot;&gt;&lt;a href=&quot;#国际化&quot; class=&quot;headerlink&quot; title=&quot;国际化&quot;&gt;&lt;/a&gt;国际化&lt;/h2&gt;&lt;p&gt;单纯的&lt;code&gt;Spring&lt;/code&gt;中设置国际化实际上是体现不出来的，需要用到&lt;code&gt;Spring MVC&lt;/code&gt; 才能有所体现。&lt;/p&gt;
&lt;h3 id=&quot;初始化国际化&quot;&gt;&lt;a href=&quot;#初始化国际化&quot; class=&quot;headerlink&quot; title=&quot;初始化国际化&quot;&gt;&lt;/a&gt;初始化国际化&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initMessageSource&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 获取beanFactory&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   ConfigurableListableBeanFactory beanFactory = getBeanFactory();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 如果工厂中已经有这个bean，那就获取出来设置到messageSource上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// Make MessageSource aware of parent MessageSource.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 判断父类是否存在，如果存在则将判断父类是否设置了消息源，没有设置就设置给他&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.parent != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.messageSource &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; HierarchicalMessageSource) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         HierarchicalMessageSource hms = (HierarchicalMessageSource) &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.messageSource;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (hms.getParentMessageSource() == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Only set parent context as parent MessageSource if no parent MessageSource&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// registered already.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            hms.setParentMessageSource(getInternalParentMessageSource());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (logger.isTraceEnabled()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         logger.trace(&lt;span class=&quot;string&quot;&gt;&amp;quot;Using MessageSource [&amp;quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.messageSource + &lt;span class=&quot;string&quot;&gt;&amp;quot;]&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// Use empty MessageSource to be able to accept getMessage calls.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 如果容器中没有注册bean，那么new一个&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      DelegatingMessageSource dms = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DelegatingMessageSource();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      dms.setParentMessageSource(getInternalParentMessageSource());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.messageSource = dms;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 注册到容器中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.messageSource);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (logger.isTraceEnabled()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         logger.trace(&lt;span class=&quot;string&quot;&gt;&amp;quot;No &amp;#x27;&amp;quot;&lt;/span&gt; + MESSAGE_SOURCE_BEAN_NAME + &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;#x27; bean, using [&amp;quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.messageSource + &lt;span class=&quot;string&quot;&gt;&amp;quot;]&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;首先是从容器中获取&lt;code&gt;MessageSource&lt;/code&gt;接口的实现，如果存在则直接赋值给&lt;code&gt;AbstractApplicationContext&lt;/code&gt;的&lt;code&gt;messageSource&lt;/code&gt;属性，用于解析国际化和参数化。如果没有就直接&lt;code&gt;new&lt;/code&gt;一个委派的实现类，然后赋值给&lt;code&gt;messageSource&lt;/code&gt;属性，并注册到容器中。&lt;/p&gt;
&lt;p&gt;在Spring中提供了两个默认的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ResourceBundleMessageSource&lt;/code&gt; ：基于Java的&lt;code&gt;ResourceBundle&lt;/code&gt;基础类实现，允许仅通过资源名加载国际化资源&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReloadableResourceBundleMessageSource&lt;/code&gt;：这个功能和第一个类的功能类似，多了定时刷新功能，允许在不重启系统的情况下，更新资源的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;国际化的使用&quot;&gt;&lt;a href=&quot;#国际化的使用&quot; class=&quot;headerlink&quot; title=&quot;国际化的使用&quot;&gt;&lt;/a&gt;国际化的使用&lt;/h3&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC(3) BeanFactoryPostProcessor和registerBeanPostProcessors</title>
    <link href="http://yoursite.com/2022/11/23/%E6%A1%86%E6%9E%B6/Spring/IOC3BeanFactoryPostProcessor%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2022/11/23/%E6%A1%86%E6%9E%B6/Spring/IOC3BeanFactoryPostProcessor%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</id>
    <published>2022-11-23T13:15:41.000Z</published>
    <updated>2022-11-25T08:27:22.737Z</updated>
    
    <content type="html"><![CDATA[<p>在 Spring IOC(2) 我们介绍了<code>Spring IOC</code>中的<code>prepareRefresh</code>、<code>obtainFreshBeanFactory</code>、<code>prepareBeanFactory</code>。</p><p>本章介绍<code>AbstractApplicationContext#refresh</code>的第4、5、6个方法</p><ul><li><p><code>postProcessBeanFactory(beanFactory)</code></p></li><li><p><code>invokeBeanFactoryPostProcessors</code></p></li><li><p><code>registerBeanPostProcessors</code> </p></li></ul><h2 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h2><p><code>AbstractApplicationContext</code>中的<code>postProcessBeanFactory</code>方法为空方法。</p><p><code>postProcessBeanFactory</code>这个方法跟<code>BeanFactoryPostProcessor</code>接口中的方法一样，但是它的功能是提供给子类进行添加一些额外的功能，比如<strong>添加<code>BeanPostProcessor</code>接口的实现</strong>，或者<strong>定制一些其他的功能</strong>，因为这个方法你可以拿到<code>BeanFactory</code>，自然是可以对它进行一些功能的定制的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看下Spring 提供的子类<code>GenericWebApplicationContext</code>是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ServletContextAwareProcessor(<span class="keyword">this</span>.servletContext));</span><br><span class="line">      beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">   &#125;</span><br><span class="line">   WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class="keyword">this</span>.servletContext);</span><br><span class="line">   WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class="keyword">this</span>.servletContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注册了一个<code>ServletContextAwreProcessor</code> 到<code>beanFactory</code>中，<code>ServletContexAwareProcessor</code>是一个<code>BeanPostProcessor</code>接口的子类。</p><h2 id="重点BeanFactoryPostProcessor"><a href="#重点BeanFactoryPostProcessor" class="headerlink" title="重点BeanFactoryPostProcessor"></a>重点BeanFactoryPostProcessor</h2><p>接下来分析<code>AbstractApplicationContext#refresh</code>中的第5个方法<code>invokeBeanFactoryPostProcessors</code>方法，这个方法用来<strong>注册和执行</strong><code>BeanFactoryPostProcessor</code>的。</p><h3 id="invokeBeanFactoryPostProcessors方法"><a href="#invokeBeanFactoryPostProcessors方法" class="headerlink" title="invokeBeanFactoryPostProcessors方法"></a>invokeBeanFactoryPostProcessors方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 执行所有的BeanFactoryPostProcessor 这里是重点</span></span><br><span class="line">   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">   <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">   <span class="comment">// aop的处理</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的重点在<code>invokeBeanFactoryPostProcessors</code>，获取<code>BeanFactoryPostProcessor</code>的集合，这里获取到都是用户在定制<code>BeanFactory</code>时<code>add</code>加入进去的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">   <span class="comment">// 放置已经处理的Bean</span></span><br><span class="line">   Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 先进性外部BFPP的处理，并且判断当前Factory是否是BeanDefinitionRegistry</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">      BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">      <span class="comment">// 保存BFPP的Bean</span></span><br><span class="line">      List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="comment">// 保存BDRPP的Bean</span></span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开始处理外部传入的BFPP</span></span><br><span class="line">      <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">         <span class="comment">// 先处理BDRPP</span></span><br><span class="line">          <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">            BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">                  (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">            <span class="comment">// 直接调用BDRPP的接口方法，后面的postProcessBeanFactory 方法统一处理</span></span><br><span class="line">            registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">             <span class="comment">// 加入到BDRPP的集合中</span></span><br><span class="line">            registryProcessors.add(registryProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">// 加入到BDRPP的集合中</span></span><br><span class="line">            regularPostProcessors.add(postProcessor);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">      <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">      <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">      <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">      <span class="comment">// 不要在这里初始化FactoryBeans：我们需要保留所有常规bean</span></span><br><span class="line">      <span class="comment">// 未初始化，让bean工厂后处理器应用于它们！</span></span><br><span class="line">       <span class="comment">// 在实现PriorityOrdered、Ordered和其余的BeanDefinitionRegistryPostProcessors之间分离</span></span><br><span class="line">      List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">      <span class="comment">// 首先，调用实现PriorityOrdered的BeanDefinitionRegistryPostProcessors。按类型获取BeanName</span></span><br><span class="line">      String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">         <span class="comment">// 判断当前的beanName是否实现了PriorityOrdered</span></span><br><span class="line">         <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            <span class="comment">// 加入到当前注册的BDRPP集合中</span></span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">             <span class="comment">// 加入到已经处理的bean集合中</span></span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对当前的BDRPP进行排序</span></span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      <span class="comment">// 将当前的BDRPP全部加入到最前面定义的BDRPP的集合中</span></span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      <span class="comment">// 执行当前的BDRPP的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      <span class="comment">// 清空当前的BDRPP</span></span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">      <span class="comment">// 再次获取BDRPP,因为上面的执行可能还会加入新的BDRPP进来</span></span><br><span class="line">      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">          <span class="comment">// 判断是否已经处理过，并且是否实现了Ordered接口</span></span><br><span class="line">         <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">            processedBeans.add(ppName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 再次进行排序、将当前的BDRPP全部加入到最前面定义的BDRPP的集合中、执行当前的BDRPP的postProcessBeanDefinitionRegistry方法</span></span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">      <span class="comment">// 最后，调用所有其他BeanDefinitionRegistryPostProcessors，直到不再出现。</span></span><br><span class="line">      <span class="comment">// 循环去获取BDRPP,然后进行排序、执行操作，直到所有的BDRPP全部执行完</span></span><br><span class="line">      <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">         reiterate = <span class="keyword">false</span>;</span><br><span class="line">         postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">         <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">               currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">               processedBeans.add(ppName);</span><br><span class="line">               reiterate = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">         registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">         invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">         currentRegistryProcessors.clear();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">      <span class="comment">// 执行bdrpp、bfpp  中的postProcessBeanFactory方法</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">      invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">      <span class="comment">// 如果不是，那么直接执行bfpp的postProcessBeanFactory</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">   <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">   <span class="comment">// 获取BFPP的beanName集合</span></span><br><span class="line">   String[] postProcessorNames =</span><br><span class="line">         beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">   <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">   <span class="comment">// 定义实现了PriorityOrdered的BFPP</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="comment">// 如果已经处理过了就不做处理</span></span><br><span class="line">      <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">         <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">         priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">         orderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">   invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">      orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">   &#125;</span><br><span class="line">   sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">   invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">   List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">      nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">   &#125;</span><br><span class="line">   invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">   <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">   beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要流程如下：</p><ol><li><p>先执行外部传入的<code>BeanFactoryPostProcessor</code>的实现</p></li><li><p>处理时先处理<code>BeanFactoryPostProcessor</code>的子接口<code>BeanDefinitionRegistryPostProcessor</code>的实现</p></li><li><p>处理<code>BeanDefinitionRegistryPostProcessor</code>实现的时候先处理实现了<code>PriorityOrdered</code>接口的实现</p></li><li><p>处理完<code>PriorityOrdered</code>接口实现的类之后再处理实现了<code>Ordered</code>接口的实现</p></li><li><p>处理完<code>Ordered</code>接口的实现类之后处理没有排序的</p></li><li><p>处理完<code>BeanDefinitionRegistryPostProcessor</code>的实现之后处理<code>BeanFactoryPostProcessor</code>的实现</p></li><li><p>处理顺序也是<code>PriorityOreded</code>，<code>Ordered</code>，没有排序的</p></li></ol><p><img src="/2022/11/23/%E6%A1%86%E6%9E%B6/Spring/IOC3BeanFactoryPostProcessor%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/E:%5CBlog%5Csource_posts%5C%E6%A1%86%E6%9E%B6%5CSpring%5CIOC3BeanFactoryPostProcessor%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%5CinvokeBeanFactoryPostProcessors%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="img"></p><p>通过流程图可以简化为：先遍历执行外部传入的<code>BFPP</code>，再执行<code>BDRPP</code>，再执行<code>BFPP</code>三部分，处理每一部分可能会进行排序操作，排序按照<code>PriorityOrdered</code>，<code>Ordered</code>，<code>noSort</code>进行排序再执行。</p><p>这其中有1个接口比较关键<code>BeanDefinitionRegistryPostProcessor</code>,它是<code>BeanFactoryPostProcessor</code> 的一个子类，它里面包含一个方法叫<code>postProcessBeanDefinitionRegistry</code>，这个方法非常重要，在实现类<code>ConfigurationClassPostProcessor</code>中就是使用这个方法进行注解的解析的，而且这个类也是实现<code>SpringBoot</code>自动装配的关键。</p><p><code>ConfigurationClassPostProcessor</code>这个类是什么时候加入到<code>Spring</code>容器的呢？</p><p>在我们启动容器的时候，<code>Spring</code>会进行<code>BeanDefinition</code>的扫描，如果我们在开启了注解扫描，那么这注解扫描的类中个时候就会自动添加多个<code>BeanDefinition</code>到<code>Spring</code>容器中，<code>beanName</code>为<code>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</code></p><p>其他还有几个：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.context</span><span class="selector-class">.annotation</span><span class="selector-class">.internalConfigurationAnnotationProcessor</span></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.context</span><span class="selector-class">.event</span><span class="selector-class">.internalEventListenerFactory</span></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.context</span><span class="selector-class">.event</span><span class="selector-class">.internalEventListenerProcessor</span> </span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.context</span><span class="selector-class">.annotation</span><span class="selector-class">.internalAutowiredAnnotationProcessor</span></span><br><span class="line">org<span class="selector-class">.springframework</span><span class="selector-class">.context</span><span class="selector-class">.annotation</span>.internalCommonAnnotationProcessor</span><br></pre></td></tr></table></figure><h3 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><p><code>ConfigurationClassPostProcessor</code>同时实现了<code>BeanDefinitionRegisterPostProcessor</code>方法的<code>postProcessBeanDefinitionRegistry</code>和<code>BeanFactoryPostProcessor</code>的<code>postProcessBeanFactory</code>方法，在解析时先执行<code>postProcessBeanDefinitionRegistry</code>，再执行<code>postProcessBeanFactory</code>。</p><p>先看<code>postProcessBeanDefinitionRegistry</code>做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> registryId = System.identityHashCode(registry);</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + registry);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.registriesPostProcessed.add(registryId);</span><br><span class="line"><span class="comment">// 处理配置的BeanDefinition</span></span><br><span class="line">   processConfigBeanDefinitions(registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的核心是<code>processConfigBeanDefinitions</code>流程如下：</p><ol><li>先进行合格的<code>beanDefinition</code>的检查<ol><li>获取到注解的元数据信息</li><li>判断是包含<code>@Configuration</code>注解，包含则合格，否则判断是否包含了<code>@Component</code>、<code>@ComponentScan</code>、<code>@Import</code>、<code>@ImportResource</code>注解，包含则合格，如果都不包含则不合格</li></ol></li><li>对合格的<code>BeanDefinition</code>排序</li><li>创建一个解析<code>@Configuration</code>注解的解析器</li><li>对合格的<code>BeanDefinition</code>集合进行解析</li></ol><p>总的来说就是解析了这些注解：<code>@Component</code>、<code>@PropertySource</code>、<code>@PropertySources</code>、<code>@ComponentScan</code>、<code>@ComponentScans</code>、<code>@Import</code>、<code>@ImportResource</code>、<code>@Bean</code>，然后将标有这些注解的解析成<code>BeanDefinition</code>，如果加上了<code>@Conditionnal</code>注解，那么按照条件进行解析</p><p><img src="/2022/11/23/%E6%A1%86%E6%9E%B6/Spring/IOC3BeanFactoryPostProcessor%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90.png" alt="img"></p><h2 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors"></a>registerBeanPostProcessors</h2><p>接下来讲解<code>refresh</code>方法的第6个方法<code>registerBeanPostProcessors</code> ，对<code>BeanPostProcessor</code>的注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法还是在<code>PostProcessorRegistrationDelegate</code>类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 通过类型获取beanNames</span></span><br><span class="line">   String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">   <span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">   <span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">   <span class="comment">// 计算beanPostProcessor的数量</span></span><br><span class="line">   <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">   <span class="comment">// 注册BeanPostProcessorChecker</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">   <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">   <span class="comment">// PriorityOrdered的BPP</span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// 内部的BPP</span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="comment">// 匹配是否是PriorityOrdered类型的BPP，是就加入进去</span></span><br><span class="line">      <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">         BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">         priorityOrderedPostProcessors.add(pp);</span><br><span class="line">         <span class="comment">// 判断是否是合并的mbdpp，</span></span><br><span class="line">         <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">         orderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">   <span class="comment">// 首先，注册实现PriorityOrdered的BeanPostProcessors。</span></span><br><span class="line">   sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">   registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">   <span class="comment">// 接下来，注册实现Ordered的BeanPostProcessors。</span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">      orderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">         internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">   registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">   <span class="comment">// 现在，注册所有常规BeanPostProcessors。</span></span><br><span class="line">   List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">   <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">      nonOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">         internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">   <span class="comment">// 最终，注册所有常规内部BeanPostProcessors。</span></span><br><span class="line">   sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">   registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">   <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">   <span class="comment">// 将用于检测内部bean的后处理器重新注册为ApplicationListeners，</span></span><br><span class="line">   <span class="comment">// 将其移动到处理器链的末端（用于拾取代理等）。</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的解析与BeanFactoryPostProcessor的执行和解析很相似了，基本套路都是一样的。</p><ol><li>通过<code>getBeanNamesByType</code> 获取BPP的数组</li><li>设置集合存储<code>BPP</code></li><li>按照顺序解析注册<code>PriorityOrdered</code>、<code>Orderd</code>、<code>NoOrderd</code>、<code>Internal</code>的BPP</li><li>将<code>ApplicationListenerDetector</code> 注册到容器的后面，这个类是之前添加过的（这里：<code>prepareBeanFactory</code>），这里移到了最后</li></ol><p>与<code>BFPP</code> 不同的是，<code>BPP</code>只是进行了注册并没有进行执行，<code>BFPP</code>是注册并执行。</p><p>参考：</p><p><a href="https://www.cnblogs.com/redwinter/p/16198942.html">https://www.cnblogs.com/redwinter/p/16198942.html</a></p><p><a href="https://www.cnblogs.com/redwinter/p/16229572.html">https://www.cnblogs.com/redwinter/p/16229572.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 Spring IOC(2) 我们介绍了&lt;code&gt;Spring IOC&lt;/code&gt;中的&lt;code&gt;prepareRefresh&lt;/code&gt;、&lt;code&gt;obtainFreshBeanFactory&lt;/code&gt;、&lt;code&gt;prepareBeanFactory&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;本章介绍&lt;code&gt;AbstractApplicationContext#refresh&lt;/code&gt;的第4、5、6个方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;postProcessBeanFactory(beanFactory)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;invokeBeanFactoryPostProcessors&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;registerBeanPostProcessors&lt;/code&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;postProcessBeanFactory&quot;&gt;&lt;a href=&quot;#postProcessBeanFactory&quot; class=&quot;headerlink&quot; title=&quot;postProcessBeanFactory&quot;&gt;&lt;/a&gt;postProcessBeanFactory&lt;/h2&gt;&lt;p&gt;&lt;code&gt;AbstractApplicationContext&lt;/code&gt;中的&lt;code&gt;postProcessBeanFactory&lt;/code&gt;方法为空方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;postProcessBeanFactory&lt;/code&gt;这个方法跟&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;接口中的方法一样，但是它的功能是提供给子类进行添加一些额外的功能，比如&lt;strong&gt;添加&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口的实现&lt;/strong&gt;，或者&lt;strong&gt;定制一些其他的功能&lt;/strong&gt;，因为这个方法你可以拿到&lt;code&gt;BeanFactory&lt;/code&gt;，自然是可以对它进行一些功能的定制的。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BeanFactoryPostProcessor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;postProcessBeanFactory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里看下Spring 提供的子类&lt;code&gt;GenericWebApplicationContext&lt;/code&gt;是如何实现的：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;postProcessBeanFactory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.servletContext != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      beanFactory.addBeanPostProcessor(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ServletContextAwareProcessor(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.servletContext));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      beanFactory.ignoreDependencyInterface(ServletContextAware.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.servletContext);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.servletContext);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里注册了一个&lt;code&gt;ServletContextAwreProcessor&lt;/code&gt; 到&lt;code&gt;beanFactory&lt;/code&gt;中，&lt;code&gt;ServletContexAwareProcessor&lt;/code&gt;是一个&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口的子类。&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC(2) 容器的的创建的工作</title>
    <link href="http://yoursite.com/2022/11/15/%E6%A1%86%E6%9E%B6/Spring/IOC2%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E5%89%8D%E7%9A%84%E5%B7%A5%E4%BD%9C/"/>
    <id>http://yoursite.com/2022/11/15/%E6%A1%86%E6%9E%B6/Spring/IOC2%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E5%89%8D%E7%9A%84%E5%B7%A5%E4%BD%9C/</id>
    <published>2022-11-15T15:33:11.000Z</published>
    <updated>2022-11-23T13:15:15.817Z</updated>
    
    <content type="html"><![CDATA[<p>在IOC（1）中介绍了<code>Spring Bean</code>的生命周期，并引出了<code>AbstractApplicationContext</code>#<code>refresh</code>方法，本节将介绍<code>refresh</code>方法中的</p><ol><li><code>prepareRefresh</code>：创建容器前的工作。</li><li><code>obtainFreshBeanFactory</code>: 创建<code>BeanFactory</code>。</li><li><code>prepareBeanFactory</code>: 准备<code>BeanFactory</code>。</li></ol><h2 id="prepareRefresh-方法"><a href="#prepareRefresh-方法" class="headerlink" title="prepareRefresh 方法"></a>prepareRefresh 方法</h2><p>Spring的前戏准备大概就是做了以下几件事：</p><ul><li>设置容器的启动时间</li><li>设置容器的停止状态为false</li><li>设置容器的激活状态为true</li><li>获取环境信息并验证必要的属性</li><li>准备监听器和事件的容器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Switch to active.</span></span><br><span class="line">   <span class="comment">// 设置启动时间 设置标识位</span></span><br><span class="line">   <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="comment">// 设置容器停止标识为false</span></span><br><span class="line">   <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">   <span class="comment">// 设置容器激活标识为true</span></span><br><span class="line">   <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// ...日志</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment.</span></span><br><span class="line">   <span class="comment">// 初始化上下文环境中的任何占位符属性源</span></span><br><span class="line">   <span class="comment">// 留给子类进行扩展，比如添加必须的属性值验证</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Validate that all properties marked as required are resolvable:</span></span><br><span class="line">   <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">    <span class="comment">// 获取环境对象，并验证需要的属性</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">    <span class="comment">// 准备应用监听器和实践的容器初始化</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">       <span class="comment">// 如果不为空，那么就清空掉，并设置新的早期的监听器进去</span></span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">   <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>环境信息是何时设置进去的呢？</p><p>在容器启动时调用了父类构造函数时设置进去的，<code>Environment</code>他是一个接口，他有个重要的实现类叫<code>StandardEnvironment</code> ，在Spring启动的时候就会使用这个类进行环境信息的加载，最终他会调用到<code>System#getProperties</code> 和<code>System#getenv</code>方法，然后将加载到属性放在Map中进行保存。</p><p><img src="/2022/11/15/%E6%A1%86%E6%9E%B6/Spring/IOC2%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E5%89%8D%E7%9A%84%E5%B7%A5%E4%BD%9C/%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF%E7%9A%84%E8%AE%BE%E7%BD%AE.png" alt="img"></p><p>要加载的信息就是系统的环境变量，比如在<code>Windows</code>中配置的环境变量或者启动类中使用<code>-D</code>参数配置的启动参数都会进行加载到<code>StandardEnvironment</code> 这个类中，类似于使用-<code>Dxxx.name=123</code>这种参数会加载到<code>systemProperties</code>中，配置的<code>windows</code>环境变量会加载<code>systemEnvironment</code>中。</p><h2 id="创建BeanFactory"><a href="#创建BeanFactory" class="headerlink" title="创建BeanFactory"></a>创建BeanFactory</h2><h3 id="Spring创建-BeanFactory-的方式"><a href="#Spring创建-BeanFactory-的方式" class="headerlink" title="Spring创建 BeanFactory 的方式"></a>Spring创建 BeanFactory 的方式</h3><p>按照<code>Bean</code>的配置方式手动创建可以分为两种：</p><ol><li><p>使用<code>XMl</code>配置的<code>Bean</code></p><p>这种方式使用<code>xml</code>配置文件配置<code>Bean</code>的信息并且设置扫描的路径，扫描到的包可以使用注解进行配置<code>Bean</code>信息，一般来说手动创建<code>BeanFactory</code>容器的实现类为<code>ClassPathXmlApplicationContext</code> 和<code>SystemFileXmlApplicationContext</code>，设置<code>xml</code>的路径即可创建出<code>IOC</code>容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:spring-test.xml&quot;</span>);</span><br><span class="line">User user = context.getBean(User.class);</span><br></pre></td></tr></table></figure></li><li><p>使用注解配置的<code>Bean</code></p><p>这种方式不使用<code>xml</code>配置文件，全部基于注解方式配置<code>Bean</code>的信息，比如使用<code>@Component</code>、<code>@Configuration</code>进行<code>Bean</code>的配置，实现类为<code>AnnotationConfigApplicationContext</code> 设置扫描的包，然后调用<code>refresh</code>方法进行<code>IOC</code>容器的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">context.scan(<span class="string">&quot;com.redwinter.test&quot;</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure></li></ol><p>我们在开发中一般是使用<code>web</code>容器进行IOC容器的创建，例如<code>tomcat</code>容器、<code>jetty</code>容器、<code>undertow</code>容器、<code>netty</code>容器。</p><p><code>Spring</code>中有一个<code>BeanFactory</code>的实现类：<code>GenericApplicationContext</code>，他的子类有一个叫<code>GenericWebApplicationContext</code>，在<code>Spring Boot</code>中，就是通过实现这个类完成<code>Web</code>容器的创建+<code>IOC</code>容器的创建的。在<code>Spring Boot</code>中有个类叫<code>ServletWebServerApplicationContext</code>就是继承了<code>GenericWebApplicationContext</code>这个类，然后<code>ServletWebServerApplicationContext</code>中有个属性叫<code>webServer</code>，这个是一个接口，这个接口对应的实现就是<code>Web</code>容器的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletWebServerApplicationContext</span> <span class="keyword">extends</span> <span class="title">GenericWebApplicationContext</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ConfigurableWebServerApplicationContext</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DISPATCHER_SERVLET_NAME = <span class="string">&quot;dispatcherServlet&quot;</span>;</span><br><span class="line"><span class="comment">// web 容器，实现类有TomcatWebServer、JettyWebServer、NettyWebServer、UndertowWebServer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WebServer webServer;</span><br><span class="line"><span class="comment">// .... 去掉其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建IOC容器"><a href="#创建IOC容器" class="headerlink" title="创建IOC容器"></a>创建IOC容器</h3><p><code>Spring Bean IOC</code> 的创建流程中的第二个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br></pre></td></tr></table></figure><p>这个方法会创建一个<code>DefaultListableBeanFactory</code>,默认的可列出<code>Bean</code>的工厂,主要功能是刷新<code>BeanFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">   <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractApplicationContext子类 AbstractRefreshableApplicationContext</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果有BeanFactory 就销毁掉并关闭</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 直接new一个BeanFactory  DefaultListableBeanFactory</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        <span class="comment">// 根据上一步创建BeanFactory创建的Id进行获取</span></span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">// 定制化BanFactory ,比如设置allowBeanDefinitionOverriding 和allowCircularReferences 的属性</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 加载BeanDefinitions 从xml 和注解定义的Bean,有从注解加载的</span></span><br><span class="line">   <span class="comment">// 从configLocations -&gt; String[] -&gt; String -&gt; Resource[] -&gt; Resource -&gt; InputStream -&gt; Document -&gt; 解析成一个一个的BeanDefinition 对象</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanFactory的创建流程分为：</p><ol><li>首先判断是否已经有<code>BeanFactory</code>了，如果有就销毁掉并且关闭工厂。</li><li>直接创建一个<code>BeanFactory</code>，默认就是使用<code>DefaultListableBeanFactory</code>，不过在创建的过程中可能会默认初始化一些属性，比如：<code>allowBeanDefinitionOverriding</code> 和 <code>allowCircularReferences</code> 允许<code>Bean</code>覆盖和解决循环依赖的问题，还有就是<code>BeanFactory</code>的序列化id等属性。</li><li>设置序列化<code>id</code></li><li><code>customizeBeanFactory(beanFactory)</code>，定制<code>BeanFactory</code>，这里是一个扩展点，你可以对<code>BeanFactory</code>进行定制</li><li>加载<code>BeanDefinition</code>，这里从由他的子类进行实现。例如XML，Annoation等多种加载的方法。</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException, IOException</span>;</span><br></pre></td></tr></table></figure><p>至此BeanFactory初始化完成</p><h4 id="定制个性化的BeanFactory"><a href="#定制个性化的BeanFactory" class="headerlink" title="定制个性化的BeanFactory"></a>定制个性化的BeanFactory</h4><p>在<code>customizeBeanFactory(beanFactory)</code>这个方法中，<code>spring</code>设置了两个属性，一个是设置是否可以覆盖<code>Bean</code>，一个是否允许循环依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">      beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们新建一个类继承<code>ClassPathXmlApplicationContext</code>，然后重写<code>customizeBeanFactory</code>这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://www.cnblogs.com/redwinter/&quot;&gt;redwinter&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">ClassPathXmlApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyClassPathXmlApplicationContext</span><span class="params">(String... configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(configLocation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 扩展点 设置不去处理循环依赖或者beanDefinition覆盖</span></span><br><span class="line"><span class="keyword">super</span>.setAllowBeanDefinitionOverriding(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 设置不允许循环依赖</span></span><br><span class="line"><span class="keyword">super</span>.setAllowCircularReferences(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 调用父类的方法</span></span><br><span class="line"><span class="keyword">super</span>.customizeBeanFactory(beanFactory);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当<code>Spring</code>发现我们在代码出现循环依赖，就会在创建<code>Spring IOC</code>时报错。</p><h4 id="BeanDefinition-的加载"><a href="#BeanDefinition-的加载" class="headerlink" title="BeanDefinition 的加载"></a>BeanDefinition 的加载</h4><p>在刷新<code>BeanFactory</code>的方法中，有个方法叫<code>loadBeanDefinitions</code>，这个方法就是进行<code>BeanDefinition</code>的加载的，他的大致流程是这样的：</p><img src="/2022/11/15/%E6%A1%86%E6%9E%B6/Spring/IOC2%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E5%89%8D%E7%9A%84%E5%B7%A5%E4%BD%9C/BeanDefinition加载.png" alt="img" style="zoom:80%;"><p>在<code>Spring</code>中一般解析<code>XML</code>文件的时候都是从网上下载对应的标签解析，比如<code>Spring</code>配置文件中的<code>https://www.springframework.org/schema/beans/spring-beans-3.1.xsd</code> ，但是一般来说都是不需要进行下载的，<code>Spring</code>提供了本地文件的<code>xsd</code>文件，这些<code>xsd</code>文件就配置在<code>META-INF/spring.schemas</code>文件中进行配置，由于文件中内容比较多我就不复制出来了。</p><p>在<code>Spring</code>进行<code>xml</code>解析之前会创建一个<code>namespace</code>的处理器的解,解析完之后就会调用注册，将解析到的<code>BeanDefinition</code>放在<code>beanDefinitionMap</code>和<code>beanDefinitionNames</code>集合中，最终完成了<code>BeanDefinition</code>的加载过程。</p><p>现在开发基本都是使用<code>Spring Boot</code>，是全注解方式，这种<code>BeanDefinition</code>的加载实际上就是指定了一个包的扫描，然后扫描这些包下标记了</p><p>解析的主要流程在<code>AnnotationConfigApplicationContext</code>这个类中。</p><h2 id="准备BeanFactory"><a href="#准备BeanFactory" class="headerlink" title="准备BeanFactory"></a>准备BeanFactory</h2><p><code>AbstractApplicationContext#refresh</code>方法的第三个方法：<code>prepareBeanFactory</code>，准备<code>BeanFactory</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">   <span class="comment">// 设置类加载器</span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">   <span class="comment">// 设置Spel 表达式解析器,用于属性填充时对值进行表达式解析</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    <span class="comment">// 扩展点，添加一个属性编辑器的注册器,也可以使用 CustomEditorConfigurer 进行设置</span></span><br><span class="line"><span class="comment">// 后面在进行属性填充的时候会调用这个属性编辑器进行属性的解析</span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">   <span class="comment">// 扩展点，添加一个BeanPostProcessor 这里添加这个进行处理，使用前置处理器执行下面忽略的六个Aware接口</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">   <span class="comment">// 由于上面设置了这六个接口，因此需要忽略掉，不让Spring使用自动装配进行Bean的装配，而是使用BeanPostProcessor</span></span><br><span class="line">    <span class="comment">// 的后置处理器的前置方法进行调用，因为如果不忽略，那么自定义的Bean中就会使用Setter注入进行装配，</span></span><br><span class="line">    <span class="comment">// spring 这样做是为了统一的进行处理在Bean增强的时候</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">   <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">    <span class="comment">// 添加一个事件监听器的装饰器</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="comment">// aop织入 编译器织入、运行期织入、类加载织入</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register default environment beans.</span></span><br><span class="line">    <span class="comment">// 注册环境信息</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>这个方法中主要做了以下事情：</p><ol><li>设置<code>BeanFactory</code>的类加载器。</li><li>设置Bean的<code>SPEL</code>表达式的解析器，其作用是对值进行表达式的解析，比如在属性填充时，针对值是Properties或者String类型的时候就会使用el表达式进行解析。</li><li>设置属性编辑器的注册器，作用是对属性进行解析，比如在属性填充时，针对字符串String类型的时候进行类型转换，就可以自定义属性编辑器针对性的进行解析操作。</li><li>添加一些内置的<code>BeanPostProcessor</code>用于后面对象初始化时调用。</li><li>设置环境信息，系统属性，系统环境变量等。</li></ol><p>这个方法预留了一些扩展点，比如可以添加自定义的属性编辑器，添加自定义的<code>BeanPostProcessor</code>等。</p><p>参考：</p><p><a href="https://www.cnblogs.com/redwinter/p/16165274.html">https://www.cnblogs.com/redwinter/p/16165274.html</a></p><p><a href="https://www.cnblogs.com/redwinter/p/16167214.html">https://www.cnblogs.com/redwinter/p/16167214.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在IOC（1）中介绍了&lt;code&gt;Spring Bean&lt;/code&gt;的生命周期，并引出了&lt;code&gt;AbstractApplicationContext&lt;/code&gt;#&lt;code&gt;refresh&lt;/code&gt;方法，本节将介绍&lt;code&gt;refresh&lt;/code&gt;方法中的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;prepareRefresh&lt;/code&gt;：创建容器前的工作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obtainFreshBeanFactory&lt;/code&gt;: 创建&lt;code&gt;BeanFactory&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prepareBeanFactory&lt;/code&gt;: 准备&lt;code&gt;BeanFactory&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;prepareRefresh-方法&quot;&gt;&lt;a href=&quot;#prepareRefresh-方法&quot; class=&quot;headerlink&quot; title=&quot;prepareRefresh 方法&quot;&gt;&lt;/a&gt;prepareRefresh 方法&lt;/h2&gt;&lt;p&gt;Spring的前戏准备大概就是做了以下几件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置容器的启动时间&lt;/li&gt;
&lt;li&gt;设置容器的停止状态为false&lt;/li&gt;
&lt;li&gt;设置容器的激活状态为true&lt;/li&gt;
&lt;li&gt;获取环境信息并验证必要的属性&lt;/li&gt;
&lt;li&gt;准备监听器和事件的容器&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;prepareRefresh&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// Switch to active.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 设置启动时间 设置标识位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.startupDate = System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 设置容器停止标识为false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.closed.set(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 设置容器激活标识为true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.active.set(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// ...日志&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// Initialize any placeholder property sources in the context environment.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 初始化上下文环境中的任何占位符属性源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 留给子类进行扩展，比如添加必须的属性值验证&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   initPropertySources();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// Validate that all properties marked as required are resolvable:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// see ConfigurablePropertyResolver#setRequiredProperties&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 获取环境对象，并验证需要的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   getEnvironment().validateRequiredProperties();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// Store pre-refresh ApplicationListeners...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 准备应用监听器和实践的容器初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.earlyApplicationListeners == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.earlyApplicationListeners = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.applicationListeners);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// Reset local application listeners to pre-refresh state.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;comment&quot;&gt;// 如果不为空，那么就清空掉，并设置新的早期的监听器进去&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.applicationListeners.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.applicationListeners.addAll(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.earlyApplicationListeners);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// Allow for the collection of early ApplicationEvents,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// to be published once the multicaster is available...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.earlyApplicationEvents = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;环境信息是何时设置进去的呢？&lt;/p&gt;
&lt;p&gt;在容器启动时调用了父类构造函数时设置进去的，&lt;code&gt;Environment&lt;/code&gt;他是一个接口，他有个重要的实现类叫&lt;code&gt;StandardEnvironment&lt;/code&gt; ，在Spring启动的时候就会使用这个类进行环境信息的加载，最终他会调用到&lt;code&gt;System#getProperties&lt;/code&gt; 和&lt;code&gt;System#getenv&lt;/code&gt;方法，然后将加载到属性放在Map中进行保存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2022/11/15/%E6%A1%86%E6%9E%B6/Spring/IOC2%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA%E5%89%8D%E7%9A%84%E5%B7%A5%E4%BD%9C/%E7%8E%AF%E5%A2%83%E4%BF%A1%E6%81%AF%E7%9A%84%E8%AE%BE%E7%BD%AE.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;要加载的信息就是系统的环境变量，比如在&lt;code&gt;Windows&lt;/code&gt;中配置的环境变量或者启动类中使用&lt;code&gt;-D&lt;/code&gt;参数配置的启动参数都会进行加载到&lt;code&gt;StandardEnvironment&lt;/code&gt; 这个类中，类似于使用-&lt;code&gt;Dxxx.name=123&lt;/code&gt;这种参数会加载到&lt;code&gt;systemProperties&lt;/code&gt;中，配置的&lt;code&gt;windows&lt;/code&gt;环境变量会加载&lt;code&gt;systemEnvironment&lt;/code&gt;中。&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC(1) Bean创建的整体流程</title>
    <link href="http://yoursite.com/2022/11/05/%E6%A1%86%E6%9E%B6/Spring/IOC1Bean%E5%88%9B%E5%BB%BA%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2022/11/05/%E6%A1%86%E6%9E%B6/Spring/IOC1Bean%E5%88%9B%E5%BB%BA%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/</id>
    <published>2022-11-05T14:52:21.000Z</published>
    <updated>2022-11-15T15:56:04.213Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-IOC-中涉及的重要接口"><a href="#Spring-IOC-中涉及的重要接口" class="headerlink" title="Spring IOC 中涉及的重要接口"></a><code>Spring IOC</code> 中涉及的重要接口</h3><ul><li><p><code>BeanDefinition</code><br><code>Bean</code>的描述信息，实现类包括 <code>RootBeanDefinition</code> 和 <code>GenericBeanDefinition</code>，Bean的描述信息中定义了一系列Bean的信息，比如：<code>beanClassName</code>、<code>scope</code>、<code>lazyinit</code>、<code>dependsOn</code>、<code>primary</code>、<code>initMethodName</code>、<code>destroyMethodName</code>、<code>isSington</code>、<code>isAbstract</code>等信息。</p></li><li><p><code>BeanDefinitionReader</code></p><p>用于解析<code>Bean</code>的资源阅读器，比如针对于<code>XML</code>文件的配置的<code>Bean</code>，实现类<code>XmlBeanDefinitionReader</code>，针对<code>properties</code>文件的配置的<code>Bean</code>，实现类为<code>PropertiesBeanDefinitionReader</code>，<code>Spring</code>在启动时会将<code>xml</code>文件通过<code>loadBeanDefinitions</code>方法进行解析。</p></li><li><p><code>BeanFactory</code><br>是<code>IOC</code>容器实现的顶层接口，默认的实现为<code>DefaultListableBeanFactory</code>，<code>Spring Bean</code> 的整个生命周期都是由<code>DefaultListableBeanFactory</code>去管理的，<strong>这个类非常的重要</strong>。</p></li><li><p><code>BeanFactoryPostProcessor</code></p><p>这个接口是<code>BeanFactory</code>的增强处理器，用于在<code>Bean</code>加载为<code>BeanDefinition</code>之后的扩展，比如实现类<code>PlaceHolderConfigurerSupport</code> 就是用来处理占位符解析的，当我在<code>xml</code>文件中配置<code>jdbc</code>信息的时候，通过是用<code>$&#123;xxx.jdbUrl&#125;</code>这种方式配置数据库连接的时候，就是通过这个类来处理和解析的。</p></li><li><p><code>Aware</code></p><p>这个接口，他下面有一堆的子接口，比如<code>BeanNameAware</code>、<code>ApplicationContextAware</code>、<code>BeanFactoryAware</code>、<code>EnvironmentAware</code>等，可以通过实现这些接口完成<code>ioc</code>容器中特定信息的设置，比如<code>EnvironmentAware</code>，可以在<code>Bean</code>创建过程中设置环境信息到对应的<code>Bean</code>对象中，后期通过<code>bean</code>对象获取环境信息数据。</p></li><li><p><code>BeanPostProcessor</code></p><p>这个接口是<code>Bean</code>的增强处理器，用于在<code>Bean</code>进行初始化时调用<code>init-method</code>方法的前后进行增强，他有两个方法：<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>，分别用于<code>bean</code>初始化方法<code>init-method</code>之前和之后调用，当然还可以进行很多扩展，比如<code>aop</code>就是通过<code>postProcessAfterInitialization</code>方法中去创建动态代理对象。</p></li></ul><h3 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a><code>Spring Bean</code> 的生命周期</h3><p><img src="/2022/11/05/%E6%A1%86%E6%9E%B6/Spring/IOC1Bean%E5%88%9B%E5%BB%BA%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/IOC1Bean%E5%88%9B%E5%BB%BA%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%5CIOC1Bean%E5%88%9B%E5%BB%BA%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" alt="img"></p><ol><li><p>首先通过<code>BeanDefinitionReader</code>将xml中的Bean配置加载到<code>BeanDefinition</code>中</p></li><li><p>然后将<code>BeanDefinition</code>放入<code>DefaultListableBeanFacotry</code>的<code>beanDefinitionMap</code>和<code>beanDefinitionNames</code>集合中</p></li><li><p>然后调用<code>BeanFactoryPostProcessor</code>@<code>postProcessorBeanFactory</code>对容器中的<code>BeanDefinition</code>的属性进行增强解析</p></li><li><p>然后通过反射调用对象的构造函数进行对象的实例化</p></li><li><p>然后调用<code>populateBean</code>进行属性填充</p></li><li><p>然后调用初始化方法<code>initializeBean</code>，初始化时又会先调用<code>invokeAwareMethods</code>方法执行一堆的Aware方法</p></li><li><p>然后<code>BeanPostProcessor</code>@<code>postProcessBeforeInitialization</code>方法执行bean增强器的前置处理</p></li><li><p>然后调用<code>InitializingBean</code>@<code>afterPropertiesSet</code>方法或者是调用自定义的init-method方法</p></li><li><p>然后调用<code>BeanPostProcessor</code>@<code>postProcessAfterInitialization</code>方法执行bean增强的后置处理</p></li><li><p>最后完成Bean的创建，最终放入一级缓存<code>singletonObjects</code>中</p></li></ol><h2 id="Spring创建bean"><a href="#Spring创建bean" class="headerlink" title="Spring创建bean"></a>Spring创建bean</h2><p>在我们使用Spring时一般通过下的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.lq.spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(Context.class);</span><br><span class="line">        UserService bean = ac.getBean(UserService.class);</span><br><span class="line">        System.out.println(bean.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>AnnotationConfigApplicationContext</code>是<code>ApplicationContext</code>的一个实现类。这个类是用来解析注解的，其他的还有解析<code>xml</code>的，解析<code>classpath</code>的，但这些类中最核心的方法<code>refresh</code>来自它们一个父类的<code>AbstractApplicationContext</code>。下面是这类的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>();</span><br><span class="line">   register(componentClasses); <span class="comment">//扫描需要把哪些类加载到Springr容器</span></span><br><span class="line">   refresh(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="refresh方法"><a href="#refresh方法" class="headerlink" title="refresh方法"></a>refresh方法</h2><p><code>AbstractApplicationContext</code>#<code>refresh</code>，这个方法中总共有15个方法，Spring源码的精髓就是这15个方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      <span class="comment">// 准备工作,加载环境变量等操作</span></span><br><span class="line">      <span class="comment">// 1、设置容器启动时间</span></span><br><span class="line">      <span class="comment">// 2、设置停止状态为false</span></span><br><span class="line">      <span class="comment">// 3、设置活跃状态为true</span></span><br><span class="line">      <span class="comment">// 4、获取Environment对象，并设置属性值</span></span><br><span class="line">      <span class="comment">// 5、设置监听器和事件的集合，模式为空的集合</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      <span class="comment">// 告诉子类刷新内部bean工厂，获取刷新的bean工厂 默认为DefaultListableBeanFactory 并且加载BeanDefinition</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      <span class="comment">// 准备BeanFactory 设置一些属性</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         <span class="comment">// 允许子类进行扩展BeanFactoryPostProcessor 自定义的BeanFactoryPostProcessor</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         <span class="comment">// 实例化并执行BeanFactoryPostProcessor</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         <span class="comment">// 实例化并注册BeanPostProcessor</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         <span class="comment">// 国际化设置</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         <span class="comment">// 实例化事件多播器</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         <span class="comment">// 初始化特定上下文子类中的其他特殊bean，web容器</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         <span class="comment">// 检查listener bean 并注册它们  注册监听器</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         <span class="comment">// 实例化所有剩余的（非惰性初始化）单例。</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">          </span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         <span class="comment">// 发布相应的事件</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁Bean</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Spring-IOC-中涉及的重要接口&quot;&gt;&lt;a href=&quot;#Spring-IOC-中涉及的重要接口&quot; class=&quot;headerlink&quot; title=&quot;Spring IOC 中涉及的重要接口&quot;&gt;&lt;/a&gt;&lt;code&gt;Spring IOC&lt;/code&gt; 中涉及的重要接口&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;BeanDefinition&lt;/code&gt;&lt;br&gt;&lt;code&gt;Bean&lt;/code&gt;的描述信息，实现类包括 &lt;code&gt;RootBeanDefinition&lt;/code&gt; 和 &lt;code&gt;GenericBeanDefinition&lt;/code&gt;，Bean的描述信息中定义了一系列Bean的信息，比如：&lt;code&gt;beanClassName&lt;/code&gt;、&lt;code&gt;scope&lt;/code&gt;、&lt;code&gt;lazyinit&lt;/code&gt;、&lt;code&gt;dependsOn&lt;/code&gt;、&lt;code&gt;primary&lt;/code&gt;、&lt;code&gt;initMethodName&lt;/code&gt;、&lt;code&gt;destroyMethodName&lt;/code&gt;、&lt;code&gt;isSington&lt;/code&gt;、&lt;code&gt;isAbstract&lt;/code&gt;等信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;BeanDefinitionReader&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;用于解析&lt;code&gt;Bean&lt;/code&gt;的资源阅读器，比如针对于&lt;code&gt;XML&lt;/code&gt;文件的配置的&lt;code&gt;Bean&lt;/code&gt;，实现类&lt;code&gt;XmlBeanDefinitionReader&lt;/code&gt;，针对&lt;code&gt;properties&lt;/code&gt;文件的配置的&lt;code&gt;Bean&lt;/code&gt;，实现类为&lt;code&gt;PropertiesBeanDefinitionReader&lt;/code&gt;，&lt;code&gt;Spring&lt;/code&gt;在启动时会将&lt;code&gt;xml&lt;/code&gt;文件通过&lt;code&gt;loadBeanDefinitions&lt;/code&gt;方法进行解析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt;&lt;br&gt;是&lt;code&gt;IOC&lt;/code&gt;容器实现的顶层接口，默认的实现为&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;，&lt;code&gt;Spring Bean&lt;/code&gt; 的整个生命周期都是由&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;去管理的，&lt;strong&gt;这个类非常的重要&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个接口是&lt;code&gt;BeanFactory&lt;/code&gt;的增强处理器，用于在&lt;code&gt;Bean&lt;/code&gt;加载为&lt;code&gt;BeanDefinition&lt;/code&gt;之后的扩展，比如实现类&lt;code&gt;PlaceHolderConfigurerSupport&lt;/code&gt; 就是用来处理占位符解析的，当我在&lt;code&gt;xml&lt;/code&gt;文件中配置&lt;code&gt;jdbc&lt;/code&gt;信息的时候，通过是用&lt;code&gt;$&amp;#123;xxx.jdbUrl&amp;#125;&lt;/code&gt;这种方式配置数据库连接的时候，就是通过这个类来处理和解析的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Aware&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个接口，他下面有一堆的子接口，比如&lt;code&gt;BeanNameAware&lt;/code&gt;、&lt;code&gt;ApplicationContextAware&lt;/code&gt;、&lt;code&gt;BeanFactoryAware&lt;/code&gt;、&lt;code&gt;EnvironmentAware&lt;/code&gt;等，可以通过实现这些接口完成&lt;code&gt;ioc&lt;/code&gt;容器中特定信息的设置，比如&lt;code&gt;EnvironmentAware&lt;/code&gt;，可以在&lt;code&gt;Bean&lt;/code&gt;创建过程中设置环境信息到对应的&lt;code&gt;Bean&lt;/code&gt;对象中，后期通过&lt;code&gt;bean&lt;/code&gt;对象获取环境信息数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;BeanPostProcessor&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个接口是&lt;code&gt;Bean&lt;/code&gt;的增强处理器，用于在&lt;code&gt;Bean&lt;/code&gt;进行初始化时调用&lt;code&gt;init-method&lt;/code&gt;方法的前后进行增强，他有两个方法：&lt;code&gt;postProcessBeforeInitialization&lt;/code&gt;和&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;，分别用于&lt;code&gt;bean&lt;/code&gt;初始化方法&lt;code&gt;init-method&lt;/code&gt;之前和之后调用，当然还可以进行很多扩展，比如&lt;code&gt;aop&lt;/code&gt;就是通过&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;方法中去创建动态代理对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Spring-Bean-的生命周期&quot;&gt;&lt;a href=&quot;#Spring-Bean-的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring Bean 的生命周期&quot;&gt;&lt;/a&gt;&lt;code&gt;Spring Bean&lt;/code&gt; 的生命周期&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2022/11/05/%E6%A1%86%E6%9E%B6/Spring/IOC1Bean%E5%88%9B%E5%BB%BA%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/IOC1Bean%E5%88%9B%E5%BB%BA%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%5CIOC1Bean%E5%88%9B%E5%BB%BA%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先通过&lt;code&gt;BeanDefinitionReader&lt;/code&gt;将xml中的Bean配置加载到&lt;code&gt;BeanDefinition&lt;/code&gt;中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后将&lt;code&gt;BeanDefinition&lt;/code&gt;放入&lt;code&gt;DefaultListableBeanFacotry&lt;/code&gt;的&lt;code&gt;beanDefinitionMap&lt;/code&gt;和&lt;code&gt;beanDefinitionNames&lt;/code&gt;集合中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后调用&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;@&lt;code&gt;postProcessorBeanFactory&lt;/code&gt;对容器中的&lt;code&gt;BeanDefinition&lt;/code&gt;的属性进行增强解析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后通过反射调用对象的构造函数进行对象的实例化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后调用&lt;code&gt;populateBean&lt;/code&gt;进行属性填充&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后调用初始化方法&lt;code&gt;initializeBean&lt;/code&gt;，初始化时又会先调用&lt;code&gt;invokeAwareMethods&lt;/code&gt;方法执行一堆的Aware方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后&lt;code&gt;BeanPostProcessor&lt;/code&gt;@&lt;code&gt;postProcessBeforeInitialization&lt;/code&gt;方法执行bean增强器的前置处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后调用&lt;code&gt;InitializingBean&lt;/code&gt;@&lt;code&gt;afterPropertiesSet&lt;/code&gt;方法或者是调用自定义的init-method方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后调用&lt;code&gt;BeanPostProcessor&lt;/code&gt;@&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;方法执行bean增强的后置处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最后完成Bean的创建，最终放入一级缓存&lt;code&gt;singletonObjects&lt;/code&gt;中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Spring创建bean&quot;&gt;&lt;a href=&quot;#Spring创建bean&quot; class=&quot;headerlink&quot; title=&quot;Spring创建bean&quot;&gt;&lt;/a&gt;Spring创建bean&lt;/h2&gt;&lt;p&gt;在我们使用Spring时一般通过下的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@ComponentScan(&amp;quot;com.lq.spring&amp;quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Context&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ApplicationContext ac = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(Context.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UserService bean = ac.getBean(UserService.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(bean.getUsername());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上面代码中的&lt;code&gt;AnnotationConfigApplicationContext&lt;/code&gt;是&lt;code&gt;ApplicationContext&lt;/code&gt;的一个实现类。这个类是用来解析注解的，其他的还有解析&lt;code&gt;xml&lt;/code&gt;的，解析&lt;code&gt;classpath&lt;/code&gt;的，但这些类中最核心的方法&lt;code&gt;refresh&lt;/code&gt;来自它们一个父类的&lt;code&gt;AbstractApplicationContext&lt;/code&gt;。下面是这类的构造方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Class&amp;lt;?&amp;gt;... componentClasses)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   register(componentClasses); &lt;span class=&quot;comment&quot;&gt;//扫描需要把哪些类加载到Springr容器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   refresh(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://yoursite.com/2022/09/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2022/09/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/KMP%E7%AE%97%E6%B3%95/</id>
    <published>2022-09-21T14:37:06.000Z</published>
    <updated>2022-10-15T05:46:38.856Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h3 id="KMP解决的问题"><a href="#KMP解决的问题" class="headerlink" title="KMP解决的问题"></a>KMP解决的问题</h3><p>字符串str1和字符串str2，str1是否包含str2，如果包含返回str2在str1中的位置。如何做到时间复杂度O(n)完成？</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">str1</span> <span class="number">111111112</span></span><br><span class="line"><span class="attribute">str2</span> <span class="number">1112</span></span><br></pre></td></tr></table></figure><p>这样如果使用暴力查找，复杂度较高，<code>O(n*m)</code> str1是n,str2是m</p><h3 id="最长前缀和"><a href="#最长前缀和" class="headerlink" title="最长前缀和"></a>最长前缀和</h3><p>求字符串中字符k前面的前缀和后缀的最大匹配个数。</p><p>例如字符串 <code>abbabbk</code>前后缀如下</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>前缀</td><td>a</td><td>ab</td><td>abb</td><td>abba</td><td>abbab</td></tr><tr><td>后缀</td><td>b</td><td>bb</td><td>abb</td><td>babb</td><td>bbabb</td></tr><tr><td></td><td>x</td><td>x</td><td>√</td><td>x</td><td>x</td></tr></tbody></table><p>对于k来说就前缀和后缀的最大匹配个数为3。</p><p>对于 <code>aaaaak</code>前后缀如下：</p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>前缀</td><td>a</td><td>aa</td><td>aaa</td><td>aaaa</td></tr><tr><td>后缀</td><td>a</td><td>aa</td><td>aaa</td><td>aaaa</td></tr><tr><td></td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>对于k来说就前缀和后缀的最大匹配个数为4。</p><h3 id="KMP算法-1"><a href="#KMP算法-1" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP算法第一步就是求解字符串str每一位字符前面字符的前缀和后缀的最大匹配个数，叫<code>nextarr</code>，利用数组对查找进行加速。</p><p>对于字符串 aabaabsaa每一位的前缀和后缀的最大匹配个数如下（nextarr数组）：</p><table><thead><tr><th>a</th><th>a</th><th>b</th><th>a</th><th>a</th><th>b</th><th>s</th><th>…</th></tr></thead><tbody><tr><td>-1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>2</td><td>3</td><td>…</td></tr></tbody></table><p>对两个字符串str1,str2有如下：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">str<span class="number">1</span>i......<span class="keyword">X</span></span><br><span class="line">str<span class="number">2</span><span class="number">0</span>......<span class="keyword">Y</span></span><br><span class="line"></span><br><span class="line">经典算法</span><br><span class="line">当<span class="keyword">X</span>不等于<span class="keyword">Y</span>时</span><br><span class="line">对于暴力匹配算法str<span class="number">1</span>会从<span class="keyword">X</span>跳到第i+<span class="number">1</span>位置，str<span class="number">2</span>从<span class="keyword">Y</span>跳到<span class="number">0</span>位置开始匹配</span><br><span class="line"></span><br><span class="line">对于KMP算法</span><br><span class="line">就会获得<span class="keyword">Y</span>字符串之前的最大前缀最大，</span><br><span class="line">比对的<span class="keyword">X</span>会停留，比对的<span class="keyword">Y</span>位置回跳到最大前缀的结束位置.从这<span class="number">2</span>个位置开始继续比对</span><br><span class="line">因为<span class="keyword">X</span>之前的位置与<span class="keyword">Y</span>位置之前的位置已经比较过，利用前缀和后缀做一个小加速</span><br><span class="line">例如：</span><br><span class="line">str<span class="number">1</span>  ...abb[abbs]</span><br><span class="line">str<span class="number">2</span>     abbabbc</span><br></pre></td></tr></table></figure><p>当比到s和c时发现2个字符串不相等，这时使用kmp算法 将str2直接从c调到第2个位置a,理解成以str1的的第4位a为开头能不能配成str2。</p><ol><li><p>从<strong>可能不相等的位置</strong>开始往下走</p></li><li><p>证明从str1 第1位到第4位 中间<strong>任何一个位置配不成str2</strong>。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str1 i<span class="params">...</span>k<span class="params">...</span>j<span class="params">...</span>X</span><br><span class="line">str2 <span class="number">0.</span><span class="params">...</span><span class="params">...</span><span class="params">...</span>.Y</span><br><span class="line">j是最大前缀的位置</span><br><span class="line"><span class="number">1.</span>假设i到j 中存在k可以配出str2 </span><br><span class="line"><span class="number">2.</span>那么k..x为str2前缀</span><br><span class="line"><span class="number">3.</span>那么Y之前就找到了一个更大的前缀， k到x 这样就矛盾了。</span><br><span class="line">所以直接跳过到j</span><br></pre></td></tr></table></figure></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KMP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 总复杂度O(N)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndexOf</span><span class="params">(String s, String m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || m == <span class="keyword">null</span> || m.length() &lt; <span class="number">1</span> || s.length() &lt; m.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] str1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] str2 = m.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] next = getNextArray(str2); <span class="comment">//O(M)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// O(N)</span></span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1[i1] == str2[i2]) &#123; <span class="comment">// 字符相等，2个字符串同时往后移动</span></span><br><span class="line">                i1++;</span><br><span class="line">                i2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[i2] == -<span class="number">1</span>) &#123; <span class="comment">// i2 == 0 str2比对的位置不能再往前了，已经是0位置了，让str1换个开头继续推 str1[i + 1]</span></span><br><span class="line">                i1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// str2可以往前跳 调到最大前缀的位置进行比对</span></span><br><span class="line">                i2 = next[i2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果str2匹配完成，找到该位置。 否则返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> i2 == str2.length ? i1 - i2 : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNextArray(<span class="keyword">char</span>[] ms) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ms.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[ms.length];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>; <span class="comment">//默认为-1</span></span><br><span class="line">        next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>; <span class="comment">// next数组开始的位置</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">//表示最长的公共子串长度</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; ms.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ms[i - <span class="number">1</span>] == ms[len]) &#123; <span class="comment">//如果相等 abbe[len] abbe[i]</span></span><br><span class="line">                next[i++] = ++len; <span class="comment">//这一位的next数组就等于 上一位的最大前缀 + 1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123; <span class="comment">// abbe abbc</span></span><br><span class="line">                len = next[len]; <span class="comment">// 如果不相等找len位置的最大前缀进行比较</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next[i++] = <span class="number">0</span>; <span class="comment">//这一位没有最大前缀</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getIndexOf(<span class="string">&quot;babcabcd&quot;</span>, <span class="string">&quot;abcabcd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h1&gt;&lt;h3 id=&quot;KMP解决的问题&quot;&gt;&lt;a href=&quot;#KMP解决的问题&quot; class=&quot;headerlink&quot; title=&quot;KMP解决的问题&quot;&gt;&lt;/a&gt;KMP解决的问题&lt;/h3&gt;&lt;p&gt;字符串str1和字符串str2，str1是否包含str2，如果包含返回str2在str1中的位置。如何做到时间复杂度O(n)完成？&lt;/p&gt;
&lt;figure class=&quot;highlight apache&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;str1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;111111112&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;str2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1112&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这样如果使用暴力查找，复杂度较高，&lt;code&gt;O(n*m)&lt;/code&gt; str1是n,str2是m&lt;/p&gt;
&lt;h3 id=&quot;最长前缀和&quot;&gt;&lt;a href=&quot;#最长前缀和&quot; class=&quot;headerlink&quot; title=&quot;最长前缀和&quot;&gt;&lt;/a&gt;最长前缀和&lt;/h3&gt;&lt;p&gt;求字符串中字符k前面的前缀和后缀的最大匹配个数。&lt;/p&gt;
&lt;p&gt;例如字符串 &lt;code&gt;abbabbk&lt;/code&gt;前后缀如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;4&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;前缀&lt;/td&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;ab&lt;/td&gt;
&lt;td&gt;abb&lt;/td&gt;
&lt;td&gt;abba&lt;/td&gt;
&lt;td&gt;abbab&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;后缀&lt;/td&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;bb&lt;/td&gt;
&lt;td&gt;abb&lt;/td&gt;
&lt;td&gt;babb&lt;/td&gt;
&lt;td&gt;bbabb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;√&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;对于k来说就前缀和后缀的最大匹配个数为3。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>有序表并查集</title>
    <link href="http://yoursite.com/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2022-09-18T10:25:41.000Z</published>
    <updated>2022-09-21T15:16:40.247Z</updated>
    
    <content type="html"><![CDATA[<p>来源 左神 有序表并查集</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="岛问题"><a href="#岛问题" class="headerlink" title="岛问题"></a>岛问题</h3><p>【题目】leetcode 200<br>一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛? </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【举例】</span><br><span class="line">001010</span><br><span class="line">111010</span><br><span class="line">100100</span><br><span class="line">000000</span><br><span class="line">这个矩阵中有三个岛</span><br></pre></td></tr></table></figure><p>遍历二维数组每一位， 如果这一位为1，就调用感染函数进行感染（周围的岛屿都变为2），记录了调用几次感染函数,就有几个岛屿。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountIslands</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义 遍历二维数组每一位， 如果这一位为1，就调用感染函数进行感染，最后记录了调用几次感染函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="keyword">null</span> || m[<span class="number">0</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = m.length;</span><br><span class="line">        <span class="keyword">int</span> M = m[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    infect(m, i, j, N, M);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 感染函数， 感染这个数值周围所有的联通 dfs</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">char</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= N || j &lt; <span class="number">0</span> || j &gt;= M || m[i][j] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i，j没有越界，并且都为1</span></span><br><span class="line">        m[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        infect(m, i + <span class="number">1</span>, j, N, M);</span><br><span class="line">        infect(m, i - <span class="number">1</span>, j, N, M);</span><br><span class="line">        infect(m, i, j + <span class="number">1</span>, N, M);</span><br><span class="line">        infect(m, i, j - <span class="number">1</span>, N, M);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] m = &#123;&#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>&#125;&#125;;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> CountIslands().numIslands(m));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：在遍历阶段，每个位置遍历一次，感染阶段，每个位置只遍历4次（上下左右调用），<code>O(n*m)</code>。</p><p><strong>如何设计一个并行算法解决这个问题？</strong></p><h3 id="并查集介绍"><a href="#并查集介绍" class="headerlink" title="并查集介绍"></a>并查集介绍</h3><ol><li><p>并查集是一种<strong>树型的数据结构</strong>，用于处理一些<strong>不相交集合（disjoint sets）的合并及查询问题。</strong></p></li><li><p>并查集通常包含两种操作</p><ul><li><code>init(s)</code>：建立一个新的并查集，其中包含s个单元素集合</li><li><code>union(x, y)</code>：把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并</li><li><code>find(x)</code>：找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了</li></ul></li></ol><p><strong>find(D)和find(F)分别返回元素D和元素F所属集合的代表A和H：</strong></p><img src="/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/并查集查找.png" alt="img" style="zoom:80%;"><p><strong>union(D, F)将元素D和元素F所在的集合合并：</strong></p><p><img src="/2022/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%90%88%E5%B9%B6.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 样本进来会包一层，叫做元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;V, Element&lt;V&gt;&gt; elementMap;</span><br><span class="line">        <span class="comment">// key某个元素value该元素的父</span></span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Element&lt;V&gt;, Element&lt;V&gt;&gt; fatherMap;</span><br><span class="line">        <span class="comment">// key某个集合的代表元素value该集合的大小</span></span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Element&lt;V&gt;, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">(List&lt;V&gt; list)</span> </span>&#123;</span><br><span class="line">            elementMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            fatherMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            sizeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (V val : list) &#123;</span><br><span class="line">                Element&lt;V&gt; element = <span class="keyword">new</span> Element&lt;&gt;(val);</span><br><span class="line">                elementMap.put(val, element);</span><br><span class="line">                fatherMap.put(element, element);</span><br><span class="line">                sizeMap.put(element, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给定一个ele，往上一直找，把代表元素返回</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Element&lt;V&gt; <span class="title">findHead</span><span class="params">(Element&lt;V&gt; element)</span> </span>&#123;</span><br><span class="line">            Stack&lt;Element&lt;V&gt;&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="comment">// 一直找到最上方节点</span></span><br><span class="line">            <span class="keyword">while</span> (element != fatherMap.get(element)) &#123;</span><br><span class="line">                path.push(element);</span><br><span class="line">                element = fatherMap.get(element);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把路径上元素的 父节点 都设置成顶部元素</span></span><br><span class="line">            <span class="keyword">while</span> (!path.isEmpty()) &#123;</span><br><span class="line">                fatherMap.put(path.pop(), element);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> element;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否是同一个集合</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (elementMap.containsKey(a) &amp;&amp; elementMap.containsKey(b)) &#123;</span><br><span class="line">                <span class="keyword">return</span> findHead(elementMap.get(a)) == findHead(elementMap.get(b));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 联合2个集合</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(V a, V b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (elementMap.containsKey(a) &amp;&amp; elementMap.containsKey(b)) &#123;</span><br><span class="line">                Element&lt;V&gt; af = findHead(elementMap.get(a));</span><br><span class="line">                Element&lt;V&gt; bf = findHead(elementMap.get(b));</span><br><span class="line">                <span class="comment">// 如果两个元素不是同一个父</span></span><br><span class="line">                <span class="keyword">if</span> (af != bf) &#123;</span><br><span class="line">                    <span class="comment">// 数量少的集合要挂在数量多集合的下面</span></span><br><span class="line">                    Element&lt;V&gt; big = sizeMap.get(af)&gt;=sizeMap.get(bf) ? af : bf;</span><br><span class="line">                    Element&lt;V&gt; small = big == af ? af : bf;</span><br><span class="line">                    <span class="comment">// 更新 small的父节点为big</span></span><br><span class="line">                    fatherMap.put(small, big);</span><br><span class="line">                    <span class="comment">// 更新各自集合的尺寸</span></span><br><span class="line">                    sizeMap.put(big, sizeMap.get(af) + sizeMap.get(bf));</span><br><span class="line">                    sizeMap.remove(small);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单次时间复杂度可以是<code>O(1)</code></p><h3 id="并查集解决岛问题"><a href="#并查集解决岛问题" class="headerlink" title="并查集解决岛问题"></a>并查集解决岛问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> row, col;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        row = grid.length;</span><br><span class="line">        col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> n = row * col;</span><br><span class="line">        <span class="keyword">int</span> ocean = <span class="number">0</span>;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    ocean += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) uf.union(node(i, j), node(i - <span class="number">1</span>, j));</span><br><span class="line">                    <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) uf.union(node(i, j), node(i, j - <span class="number">1</span>));</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; row - <span class="number">1</span> &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span>) uf.union(node(i, j), node(i + <span class="number">1</span>, j));</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; col - <span class="number">1</span> &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) uf.union(node(i, j), node(i, j + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uf.size - ocean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">node</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i * col + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] roots;</span><br><span class="line">    <span class="keyword">int</span> size;   <span class="comment">// 岛屿数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        roots = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            roots[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        size = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != roots[i]) &#123;</span><br><span class="line">            roots[i] =roots[roots[i]];</span><br><span class="line">            i = roots[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line">        <span class="keyword">if</span> (pRoot != qRoot) &#123;</span><br><span class="line">            roots[pRoot] = qRoot;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用并查集在多个cpu上计算岛屿，将矩阵拆分为多块，每块各自使用感染算法计算各自的的岛屿，并记录各自块的边界上的岛屿的联通情况（<code>land[i][j] = a</code>），当所有块的岛屿计算完成后，在根据边界上的岛屿如果联通，就合并为一个集合。</p><h3 id="并查集题"><a href="#并查集题" class="headerlink" title="并查集题"></a>并查集题</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;来源 左神 有序表并查集&lt;/p&gt;
&lt;h2 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h2&gt;&lt;h3 id=&quot;岛问题&quot;&gt;&lt;a href=&quot;#岛问题&quot; class=&quot;headerlink&quot; title=&quot;岛问题&quot;&gt;&lt;/a&gt;岛问题&lt;/h3&gt;&lt;p&gt;【题目】leetcode 200&lt;br&gt;一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛? &lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;【举例】&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;001010&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111010&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;000000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个矩阵中有三个岛&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;遍历二维数组每一位， 如果这一位为1，就调用感染函数进行感染（周围的岛屿都变为2），记录了调用几次感染函数,就有几个岛屿。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CountIslands&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;    定义 遍历二维数组每一位， 如果这一位为1，就调用感染函数进行感染，最后记录了调用几次感染函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;numIslands&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[][] m)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (m == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || m[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; N = m.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; M = m[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; res = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; M; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (m[i][j] == &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    res++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    infect(m, i, j, N, M);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 感染函数， 感染这个数值周围所有的联通 dfs&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;infect&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[][] m, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; N, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; M)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || i &amp;gt;= N || j &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; || j &amp;gt;= M || m[i][j] != &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// i，j没有越界，并且都为1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        m[i][j] = &lt;span class=&quot;string&quot;&gt;&amp;#x27;2&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        infect(m, i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, j, N, M);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        infect(m, i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, j, N, M);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        infect(m, i, j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, N, M);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        infect(m, i, j - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, N, M);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;[][] m = &amp;#123;&amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;1&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;0&amp;#x27;&lt;/span&gt;&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; CountIslands().numIslands(m));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;时间复杂度：在遍历阶段，每个位置遍历一次，感染阶段，每个位置只遍历4次（上下左右调用），&lt;code&gt;O(n*m)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何设计一个并行算法解决这个问题？&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;并查集介绍&quot;&gt;&lt;a href=&quot;#并查集介绍&quot; class=&quot;headerlink&quot; title=&quot;并查集介绍&quot;&gt;&lt;/a&gt;并查集介绍&lt;/h3&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈希函数和哈希表</title>
    <link href="http://yoursite.com/2022/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2022/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/</id>
    <published>2022-09-04T07:52:47.000Z</published>
    <updated>2022-09-06T16:22:29.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>out = f(in)</p><ol><li><p>in -&gt; 无穷，out -&gt; string 有限</p><ul><li>md5： 0 - 2^64^-1 </li><li>sha1： 0 - 2^128^-1</li></ul></li><li><p>same in -&gt; same out 不随机</p></li><li><p>different in -&gt; same out （哈希碰撞）</p></li><li><p>离散性和均匀性 （输入有规律，输出无规律）</p></li></ol><blockquote><p>in 通过hash函数得到 out 再取模 %m 就可以的带 <code>0 - (m-1)</code> 范围的数</p></blockquote><h3 id="题"><a href="#题" class="headerlink" title="题"></a>题</h3><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">一个大文件 无符号整数 (</span><span class="number">2</span><span class="keyword">^32</span><span class="keyword">^-1</span><span class="xml"> 就是 </span><span class="number">0</span><span class="xml">- </span><span class="number">42</span><span class="xml">亿范围）有</span><span class="number">40</span><span class="xml">亿个数，</span><span class="number">1</span><span class="xml">g内存求出现次数最多的数是哪一个？</span></span><br></pre></td></tr></table></figure><p>如果使用hash表来做 <code>key - value</code> ,key是(4B),value是int(4B), 一个数就要8B，如果40亿个数都不一样，就需要 320亿B（32G）。</p><p>对数据a 先使用 <code>hash函数</code>得到数 b，然后  <code>% 100</code>得到 0-99范围的数，相同的数据进同一个文件，不同的数种类上进不同文件。对每一个小文件使用hash表，然后求出这100个数的最大值。不怕同一种数太多，怕不同种的数太多，内存不够。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>表 + 链表（ in通过hash函数得到 out 再取模 %m 就）当 某条链表太长触发扩容 机制。n个字符串 ，会触发<code>logn</code>次扩容，最坏是<code>logN</code>。每一次扩容的代价是<code>O(N)</code>，每个数全部要计算hash，扩容的代价<code>O（N * logN）</code>。单次插入代价<code>O（N * logN）/ N</code> 就是<code>logN</code>，通过设置链表长度特别小，使<code>logN</code>特别小，就是O(1)。在使用的时候认为是O(1).</p><blockquote><p>jvm等虚拟机语言，可以做到在扩容时使用旧表，扩容完使用新表。离线计算。</p></blockquote><p>开放地址法</p><h3 id="题-1"><a href="#题-1" class="headerlink" title="题"></a>题</h3><p>1.设计RandomPool结构</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【题目】</span><br><span class="line">设计一种结构，在该结构中有如下三个功能:</span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">(key)</span></span>:将某个key加入到该结构，做到不重复加入</span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(key)</span></span>:将原本在结构中的某个key移除</span><br><span class="line"><span class="function"><span class="title">getRandom</span><span class="params">()</span></span>:等概率随机返回结构中的任何一个key。</span><br><span class="line"></span><br><span class="line">【要求】</span><br><span class="line">lnsert、 delete和getRandom方法的时间复杂度都是O(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>使用2张hash表</p><p>map1 (str -&gt; index), 存放”A” -&gt; 0…</p><p>map2 (index-&gt;str),  存放0 -&gt; “A”…</p><p>size,</p><p><code>getRandom()</code>如果存放了26个数，要等概率返回，使用系统提供的随机数生成，生成0-25的数，返回map2这个位置的str</p><p><code>delete(key)</code>删除时不能让index区域出现<strong>洞</strong>，保证连续性。删除时，让最后一条区域填补这个洞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, Integer&gt; keyIndexMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, K&gt; indexKeyMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.keyIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.indexKeyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 没加过加入</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.keyIndexMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.keyIndexMap.put(key, <span class="keyword">this</span>.size);</span><br><span class="line">            <span class="keyword">this</span>.indexKeyMap.put(<span class="keyword">this</span>.size, key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.keyIndexMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">int</span> deleteIndex = <span class="keyword">this</span>.keyIndexMap.get(key);</span><br><span class="line">            <span class="keyword">int</span> lastIndex = --<span class="keyword">this</span>.size;</span><br><span class="line">            K lastKey = <span class="keyword">this</span>.indexKeyMap.get(lastIndex);</span><br><span class="line">            <span class="keyword">this</span>.keyIndexMap.put(lastKey, deleteIndex);</span><br><span class="line">            <span class="keyword">this</span>.indexKeyMap.put(deleteIndex, lastKey);</span><br><span class="line">            <span class="keyword">this</span>.keyIndexMap.remove(key);</span><br><span class="line">            <span class="keyword">this</span>.indexKeyMap.remove(lastIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * <span class="keyword">this</span>.size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.indexKeyMap.get(random);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>解决黑名单过滤、对100亿url(64Byte)进行黑名单过滤过滤，如果使用hashset,需要640G内存。</p><p>爬虫去重，多个线程爬url, 如果已经爬过，就不要再爬，爬虫之间不要爬同一个。</p><p><strong>集合有添加、有查询，没有查询、极大程度减少内存使用，允许有一定程度失误率。</strong>如果一个数据不在布隆过滤器中，可能会误报，但一个数据在布隆过滤器中，一定不会误报。</p><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>bitmap, 基础类型数组,int[],long[]每一个占32bit、64bit</p><p><strong>bit[] 每一位占1bit</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 32bit * 10 320 bits</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// arr[0] int 0  - 31</span></span><br><span class="line">        <span class="comment">// arr[1] int 32 - 64</span></span><br><span class="line">        <span class="comment">// arr[2] int 64 - 95</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">178</span>; <span class="comment">//得到178个 bit</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numIndex = i / <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIndex = i % <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到178位 状态</span></span><br><span class="line">        <span class="keyword">int</span> s = ((arr[numIndex] &gt;&gt; bitIndex) &amp; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把178位状态改为1</span></span><br><span class="line">        arr[numIndex] = arr[numIndex] | (<span class="number">1</span> &lt;&lt; bitIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把178位状态改为0</span></span><br><span class="line">        arr[numIndex] = arr[numIndex] &amp; (~(<span class="number">1</span> &lt;&lt; bitIndex));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>是一个超大的<strong>位数组</strong>和<strong>几个哈希函数</strong>,假设集合里面有 3 个元素 {x, y, z}，哈希函数的个数为 3。首先将位数组进行初始化，初始化状态的维数组的每个位都设置位 0。对于集合里面的每一个元素，将元素依次通过 3 个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为 1。</p><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p>将要添加的元素分别通过k个哈希函数计算得到k个哈希值，这k个hash值对应位数组上的k个位置，然后将这k个位置设置为1。</p><h5 id="查询元素"><a href="#查询元素" class="headerlink" title="查询元素"></a>查询元素</h5><p>将要查询的元素分别通过k个哈希函数计算<strong>得到k个哈希值</strong>，这k个hash值对应位数组上的k个位置，<strong>如果这k个位置中有一个位置为0，则此元素一定不存在集合中</strong>，如果这k个位置全部为1，则这个元素可能存在。</p><p>hash函数到底多少个，bitmap到底多长。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>相比于其它的数据结构，布隆过滤器在<strong>空间和时间</strong>方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（即hash函数的个数）</li><li>Hash 函数相互之间没有关系，方便由硬件并行实现</li><li>布隆过滤器<strong>不需要存储元素本身</strong>，在某些对保密要求非常严格的场合有优势</li><li>布隆过滤器可以<strong>表示全集</strong>，其它任何数据结构都不能。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>误算率（False Positive）是其中之一。随着存入的元素数量增加，<strong>误算率随之增加</strong>（误判补救方法是：再建立一个小的白名单，存储那些可能被误判的信息）。但是如果元素数量太少，则使用散列表足矣。</li><li>一般情况下<strong>不能从布隆过滤器中删除元素</strong>。我们很容易想到把位列阵变成整数数组，每插入一个元素相应的计数器加 1, 这样删除元素时将计数器减掉就可以了。然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</li></ul><h3 id="重要参数"><a href="#重要参数" class="headerlink" title="重要参数"></a>重要参数</h3><p>n = 样本量， P = 失误率 单样本大小</p><p><strong>m = - ( n * lnP / ln2^2^ )</strong> 需要多少空间 0.0001失误率 ，100亿url,需要^26G^</p><p><strong>k = （ln2 * (m/n) ）= 0.7 * (m/n)</strong> 向上取整</p><p>P真 = （1 - e^a^）(a = - n*k真/m真)</p><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>数据服务器怎么组织， 数据种类均匀分配。有3台服务器、一个数据同算hash然后取模方法，觉定这个数据在哪个服务器存储。hash key怎么选择，让高、中、低频的数据均匀分配的key，身份证之类。上面的算法好像可以把图片均衡地分配到不同的服务器,但<strong>增加和减少服务器时，如果要重新算hash会造成数据迁移</strong>。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>决分布式缓存的问题。 在移除或者添加一个服务器时，能够<strong>尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系</strong>。一致性哈希解决了简单哈希算法在分布式哈希表中存在的动态伸缩等问题 。</p><p>一致性hash算法会建立一个有2^32个槽点(0 - 2^32-1^)的hash环，假设现在有A、B、C三台服务器，以A为例，会进行hash(A)%2^32^，得到一个0 - 2^32-1^之间的数，然后映射到hash环上</p><p>接下来，我们以m1为例，我们照样算出hash(m1)%2^32^的值，然后映射到hash环上，然后以该点出发，<strong>顺时针遇到的第一个服务器，即为数据即将存储的服务器。</strong></p><p>如果这个时候在A - C之间插入了服务器D，请求获取getKey(m1)时，顺时针获得的服务器是D，从D上获取数据理所当然会失败，因为数据存在A上缓存。这样看缓存好像还是失效了。</p><p>虽然增加了节点D后，m1的缓存失效了，但是，分布在 A-B，B-C 以及 D-A上面的数据仍然有效，<strong>失效的只是C-D段的数据</strong>(数据存在A节点，但是顺时针获取的服务器是D)。这样就保证了缓存数据<strong>不会像hash算法那样大面积失效</strong>，同样起到减轻数据库压力的效果。</p><p><strong>一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</strong></p><h4 id="hash偏斜"><a href="#hash偏斜" class="headerlink" title="hash偏斜"></a>hash偏斜</h4><p>A、B、C服务节点，如果接近于将hash环平均分配那固然理想，但是如果他们hash值十分相近,就会导致某一段直接会被大量分配，给某一节点大量分配，如果这时这个节点被删除，会有大量请求涌向相邻的节点，给这个节点带来巨大压力，这部分缓存也就失效了，导致了缓存雪崩。</p><p>如何保证节点的负载均衡？如何保证在添加节点后的负载均衡？</p><h4 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h4><p>如果我们的节点足够多，就应该可以防止服务器节点分布不均的问题了。</p><p>以A节点为例，虚拟构造出(A0,A1,A2….AN)，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为<strong>虚拟节点</strong>。<strong>只要是落在这些虚拟节点上的数据，都存入A节点</strong>。读取时也相同，顺时针获取的是A0虚拟节点，就到A节点上获取数据，这样就能解决数据分布不均的问题。</p><p>虚拟节点读写大概流程为:  数据读写 -&gt; 虚拟节点 -&gt; 真实节点 -&gt; 读写</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;哈希函数&quot;&gt;&lt;a href=&quot;#哈希函数&quot; class=&quot;headerlink&quot; title=&quot;哈希函数&quot;&gt;&lt;/a&gt;哈希函数&lt;/h2&gt;&lt;p&gt;out = f(in)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;in -&amp;gt; 无穷，out -&amp;gt; string 有限&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;md5： 0 - 2^64^-1 &lt;/li&gt;
&lt;li&gt;sha1： 0 - 2^128^-1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;same in -&amp;gt; same out 不随机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;different in -&amp;gt; same out （哈希碰撞）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;离散性和均匀性 （输入有规律，输出无规律）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;in 通过hash函数得到 out 再取模 %m 就可以的带 &lt;code&gt;0 - (m-1)&lt;/code&gt; 范围的数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;题&quot;&gt;&lt;a href=&quot;#题&quot; class=&quot;headerlink&quot; title=&quot;题&quot;&gt;&lt;/a&gt;题&lt;/h3&gt;&lt;figure class=&quot;highlight parser3&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;一个大文件 无符号整数 (&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;^32&lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;^-1&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt; 就是 &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;- &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;亿范围）有&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;亿个数，&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;g内存求出现次数最多的数是哪一个？&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;如果使用hash表来做 &lt;code&gt;key - value&lt;/code&gt; ,key是(4B),value是int(4B), 一个数就要8B，如果40亿个数都不一样，就需要 320亿B（32G）。&lt;/p&gt;
&lt;p&gt;对数据a 先使用 &lt;code&gt;hash函数&lt;/code&gt;得到数 b，然后  &lt;code&gt;% 100&lt;/code&gt;得到 0-99范围的数，相同的数据进同一个文件，不同的数种类上进不同文件。对每一个小文件使用hash表，然后求出这100个数的最大值。不怕同一种数太多，怕不同种的数太多，内存不够。&lt;/p&gt;
&lt;h2 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h2&gt;&lt;p&gt;表 + 链表（ in通过hash函数得到 out 再取模 %m 就）当 某条链表太长触发扩容 机制。n个字符串 ，会触发&lt;code&gt;logn&lt;/code&gt;次扩容，最坏是&lt;code&gt;logN&lt;/code&gt;。每一次扩容的代价是&lt;code&gt;O(N)&lt;/code&gt;，每个数全部要计算hash，扩容的代价&lt;code&gt;O（N * logN）&lt;/code&gt;。单次插入代价&lt;code&gt;O（N * logN）/ N&lt;/code&gt; 就是&lt;code&gt;logN&lt;/code&gt;，通过设置链表长度特别小，使&lt;code&gt;logN&lt;/code&gt;特别小，就是O(1)。在使用的时候认为是O(1).&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>RPC</title>
    <link href="http://yoursite.com/2022/06/25/%E5%88%86%E5%B8%83%E5%BC%8F/RPC/"/>
    <id>http://yoursite.com/2022/06/25/%E5%88%86%E5%B8%83%E5%BC%8F/RPC/</id>
    <published>2022-06-25T13:16:32.000Z</published>
    <updated>2022-06-25T13:16:42.422Z</updated>
    
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="RPC" scheme="http://yoursite.com/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>结果处理器</title>
    <link href="http://yoursite.com/2022/05/29/%E6%A1%86%E6%9E%B6/mybatis/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://yoursite.com/2022/05/29/%E6%A1%86%E6%9E%B6/mybatis/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2022-05-29T10:01:52.000Z</published>
    <updated>2022-05-29T10:24:55.174Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/05/29/%E6%A1%86%E6%9E%B6/mybatis/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8.png" alt="image-20220418233415695"></p><ul><li>ResultSetHandler：结果集处理器</li><li>ResultContext：结果提出</li><li>ResultHandler：结果处理器</li></ul><h4 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//包装结果集</span></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">//处理存储过程输出参数的</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleOutputParameters</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultResultSetHandler</code>，在默认的情况下都是通过这个类进行处理的。这个实现有些复杂，它涉及使用<code>JAVASSIST</code> 或者<code>CGLIB</code>作为<strong>延迟加载</strong>，然后通过<code>typeHandler</code>和<code>ObjectFactory</code><strong>进行组装结果再返回</strong>。</p><h4 id="ResultContext"><a href="#ResultContext" class="headerlink" title="ResultContext"></a>ResultContext</h4><p>控制结果的获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultContext</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//当前结果</span></span><br><span class="line">  <span class="function">T <span class="title">getResultObject</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//当前的数量</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getResultCount</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//当前是否停止</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isStopped</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">//停止</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ResultHandler"><a href="#ResultHandler" class="headerlink" title="ResultHandler"></a>ResultHandler</h4><p>纯粹对应的值这个默认实现只是把结果放入list中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultHandler</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(ResultContext&lt;? extends T&gt; resultContext)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/05/29/%E6%A1%86%E6%9E%B6/mybatis/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8.png&quot; alt=&quot;image-20220418233415695&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ResultSetHandler：结果集处理器&lt;/li&gt;
&lt;li&gt;ResultContext：结果提出&lt;/li&gt;
&lt;li&gt;ResultHandler：结果处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;ResultSetHandler&quot;&gt;&lt;a href=&quot;#ResultSetHandler&quot; class=&quot;headerlink&quot; title=&quot;ResultSetHandler&quot;&gt;&lt;/a&gt;ResultSetHandler&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ResultSetHandler&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//包装结果集&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;E&amp;gt; &lt;span class=&quot;function&quot;&gt;List&amp;lt;E&amp;gt; &lt;span class=&quot;title&quot;&gt;handleResultSets&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Statement stmt)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//处理存储过程输出参数的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;handleOutputParameters&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(CallableStatement cs)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; SQLException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;DefaultResultSetHandler&lt;/code&gt;，在默认的情况下都是通过这个类进行处理的。这个实现有些复杂，它涉及使用&lt;code&gt;JAVASSIST&lt;/code&gt; 或者&lt;code&gt;CGLIB&lt;/code&gt;作为&lt;strong&gt;延迟加载&lt;/strong&gt;，然后通过&lt;code&gt;typeHandler&lt;/code&gt;和&lt;code&gt;ObjectFactory&lt;/code&gt;&lt;strong&gt;进行组装结果再返回&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;ResultContext&quot;&gt;&lt;a href=&quot;#ResultContext&quot; class=&quot;headerlink&quot; title=&quot;ResultContext&quot;&gt;&lt;/a&gt;ResultContext&lt;/h4&gt;&lt;p&gt;控制结果的获取&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ResultContext&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//当前结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;getResultObject&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//当前的数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getResultCount&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//当前是否停止&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isStopped&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;//停止&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;ResultHandler&quot;&gt;&lt;a href=&quot;#ResultHandler&quot; class=&quot;headerlink&quot; title=&quot;ResultHandler&quot;&gt;&lt;/a&gt;ResultHandler&lt;/h4&gt;&lt;p&gt;纯粹对应的值这个默认实现只是把结果放入list中&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>SqlSeesion缓存</title>
    <link href="http://yoursite.com/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/</id>
    <published>2022-04-04T16:01:47.000Z</published>
    <updated>2022-11-05T15:05:40.928Z</updated>
    
    <content type="html"><![CDATA[<p>SqlSession原理中介绍了在SQL查询时一级缓存和二级缓存的调用过程。这里介绍一下缓存的场景和失效。</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/Mybatis缓存.png" alt="image-20220405134607618" style="zoom:80%;"><h2 id="一、一级缓存"><a href="#一、一级缓存" class="headerlink" title="一、一级缓存"></a>一、一级缓存</h2><p>一级缓存与<code>SqlSession</code>相关，是一个<strong>会话级别的缓存</strong>，会话关闭清空缓存。在会话中一级缓存与运行时参数和操作配置相关</p><h3 id="命中场景"><a href="#命中场景" class="headerlink" title="命中场景"></a>命中场景</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstCacheTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SQLException </span>&#123;</span><br><span class="line">        SqlSessionFactoryBuilder factoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        SqlSessionFactory build = factoryBuilder.build(inputStream);</span><br><span class="line">        configuration = build.getConfiguration();</span><br><span class="line">        sqlSession = build.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AccountMapper mapper = sqlSession.getMapper(AccountMapper.class);</span><br><span class="line">        List&lt;Account&gt; accounts1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        List&lt;Account&gt; accounts2 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(accounts1 == accounts2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存命中有几个运行时参数要求</p><ol><li>sql和参数必须相同</li><li>必须是相同的<code>statementID</code>，sql相同也不行</li><li><code>sqlSession</code>必须相同</li><li><code>RowBounds</code> 返回行返回必须相同</li></ol><p><strong>清理缓存之后就无法命中</strong>，默认采用的是simple执行器，编译2次，执行2次。建议采用的reuse执行器。只有有一条执行语句加入了<code>flushCache=true</code>等同于 <code>sqlSession.clearCache()</code>。共有4种操作配置导致缓存无法命中的场景：</p><ol><li>手动<code>sqlSession.clearCache()</code>,<code>sqlSession.commit()</code>, <code>sqlSession.rollback()</code></li><li>执行的方法上加入<code>flushCache=true</code></li><li>中间执行Update语句</li><li>缓存作用域不是<code>SESSION</code> 改为<code>STATEMENT</code>这里是嵌套查询（子查询）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AccountMapper mapper = sqlSession.getMapper(AccountMapper.class);</span><br><span class="line">    List&lt;Account&gt; accounts1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    sqlSession.clearCache();</span><br><span class="line">    List&lt;Account&gt; accounts2 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(accounts1 == accounts2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一级缓存源码解析"><a href="#一级缓存源码解析" class="headerlink" title="一级缓存源码解析"></a>一级缓存源码解析</h3><p><code>sqlSession</code>查询时的流程：</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/一级缓存.png" alt="image-20220405140905640" style="zoom:80%;"><h4 id="命中缓存"><a href="#命中缓存" class="headerlink" title="命中缓存"></a>命中缓存</h4><p>其中的<code>BaseExecutor</code>中的<code>localCache</code>的流程：</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/localCache.png" alt="image-20220405142235268" style="zoom: 50%;"><p><code>BaseExecutor</code>中的query源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">   <span class="comment">//query实现嵌套查询，查询中有子查询，这里就会变大</span></span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;E&gt; list;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queryStack++;</span><br><span class="line">      <span class="comment">//查询一级缓存</span></span><br><span class="line">    list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">      handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    queryStack--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">      deferredLoad.load();</span><br><span class="line">    &#125;</span><br><span class="line">    deferredLoads.clear(); <span class="comment">// issue 601</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">      clearLocalCache(); <span class="comment">// issue 482</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询数据库</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="comment">//先占位，为了嵌套查询</span></span><br><span class="line">    localCache.putObject(key, EXECUTION_PLACEHOLDER);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//执行子类的查询</span></span><br><span class="line">      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      localCache.removeObject(key);</span><br><span class="line">    &#125;</span><br><span class="line">    localCache.putObject(key, list);</span><br><span class="line">    <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">      localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一级缓存的key，只有都相同才能命中：</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/一级缓存key.png" alt="image-20220405143753736" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheKey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1146682552656046210L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CacheKey NULL_CACHE_KEY = <span class="keyword">new</span> NullCacheKey();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLYER = <span class="number">37</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> multiplier;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这5个参数分别为，statementID、分页上下限、sql语句、参数</p><h4 id="清空缓存"><a href="#清空缓存" class="headerlink" title="清空缓存"></a>清空缓存</h4><p>清空缓存的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">    localCache.clear();</span><br><span class="line">    localOutputParameterCache.clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一共有4个地方调用了这个方法query、update、commit、rollback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">//如果第一次查询并且配置了查询前刷新缓存</span></span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123; <span class="comment">//清空缓存不能发生在子查询，子查询依赖了一级缓存</span></span><br><span class="line">        <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">            deferredLoad.load();</span><br><span class="line">        &#125;</span><br><span class="line">        deferredLoads.clear(); <span class="comment">// issue 601</span></span><br><span class="line">        <span class="comment">//如果缓存是作用域是 LocalCacheScope.STATEMENT也会去清空缓存</span></span><br><span class="line">        <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">            clearLocalCache(); <span class="comment">// issue 482</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Cannot commit, transaction is already closed&quot;</span>);</span><br><span class="line">  clearLocalCache();</span><br><span class="line">  flushStatements();</span><br><span class="line">  <span class="keyword">if</span> (required) &#123;</span><br><span class="line">    transaction.commit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!closed) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">      flushStatements(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (required) &#123;</span><br><span class="line">        transaction.rollback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring一级缓存失效"><a href="#Spring一级缓存失效" class="headerlink" title="Spring一级缓存失效"></a>Spring一级缓存失效</h3><p>会话不相同，如果不配置事务，每次都会新建一个session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBySpring</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    AccountMapper mapper = context.getBean(AccountMapper.class);</span><br><span class="line">    List&lt;Account&gt; accounts1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    List&lt;Account&gt; accounts2 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(accounts1 == accounts2);  <span class="comment">//false 无法命中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>UserMapper</code>与从<code>SqlSession</code>取出的<code>UserMapper</code>不同，每次构造都会构造一个新会话，两次查询都是一个新会话。<code>SqlSession</code>和<code>Executor</code>是一对一的关系。每次查询的<code>Executor</code>不同。</p><p>开启事务,后就会有效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBySpring</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    AccountMapper mapper = context.getBean(AccountMapper.class);</span><br><span class="line"></span><br><span class="line">    DataSourceTransactionManager transactionManager =(DataSourceTransactionManager) context.getBean(<span class="string">&quot;txManager&quot;</span>);</span><br><span class="line">    <span class="comment">//手动开启事务</span></span><br><span class="line">    TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());<span class="comment">// 获得事务状态</span></span><br><span class="line">    List&lt;Account&gt; accounts1 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    List&lt;Account&gt; accounts2 = mapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(accounts1 == accounts2);  <span class="comment">//false 无法命中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper -&gt; <code>SqlSessionTemplate</code> -&gt; <code>SqlSessionInterceptor</code> -&gt; <code>SqlSessionFactory</code></p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/一级缓存失效.png" alt="image-20220414222558730" style="zoom:80%;"><p>动态代理嵌入动态代理最终调用<code>Mybatis</code>的 <code>SqlSessionFactory</code></p><p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E8%B0%83%E8%AF%95.png" alt="image-20220414222932796"></p><p>这里的<code>sqlSession</code>是<code>SqlSessionTemplate</code>,<code>sqlSessionProxy</code>就是<code>SqlSessionInterceptor</code></p><h4 id="SqlSessionTemplate"><a href="#SqlSessionTemplate" class="headerlink" title="SqlSessionTemplate"></a>SqlSessionTemplate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionTemplate</span> <span class="keyword">implements</span> <span class="title">SqlSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ExecutorType executorType;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy; <span class="comment">//这里还是一个SqlSession</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PersistenceExceptionTranslator exceptionTranslator;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="params"><span class="function">      PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    notNull(sqlSessionFactory, <span class="string">&quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;</span>);</span><br><span class="line">    notNull(executorType, <span class="string">&quot;Property &#x27;executorType&#x27; is required&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">    <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">     <span class="comment">//JDK的动态代理，所有的都在SqlSessionInterceptor，这个就是动态代理</span></span><br><span class="line">    <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(</span><br><span class="line">        SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> Class[] &#123; SqlSession.class &#125;,</span><br><span class="line">        <span class="keyword">new</span> SqlSessionInterceptor());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过2层的动态代理，实现Spring的事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="comment">//从这里获取SqlSession</span></span><br><span class="line">    SqlSession sqlSession = getSqlSession(</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory,</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.executorType,</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Object result = method.invoke(sqlSession, args);</span><br><span class="line">      <span class="keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory)) &#123;</span><br><span class="line">        <span class="comment">// force commit even on non-dirty sessions because some databases require</span></span><br><span class="line">        <span class="comment">// a commit/rollback before calling close()</span></span><br><span class="line">        sqlSession.commit(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      Throwable unwrapped = unwrapThrowable(t);</span><br><span class="line">      <span class="keyword">if</span> (SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator != <span class="keyword">null</span> &amp;&amp; unwrapped <span class="keyword">instanceof</span> PersistenceException) &#123;</span><br><span class="line">        <span class="comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span></span><br><span class="line">        closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">        sqlSession = <span class="keyword">null</span>;</span><br><span class="line">        Throwable translated = SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);</span><br><span class="line">        <span class="keyword">if</span> (translated != <span class="keyword">null</span>) &#123;</span><br><span class="line">          unwrapped = translated;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> unwrapped;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取会话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  notNull(sessionFactory, <span class="string">&quot;No SqlSessionFactory specified&quot;</span>);</span><br><span class="line">  notNull(executorType, <span class="string">&quot;No ExecutorType specified&quot;</span>);</span><br><span class="line">  <span class="comment">//SqlSessionHolder就是一个ThreadLocal变量,如果当前的事务是打开的，就可以获得事务</span></span><br><span class="line">  SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (holder != <span class="keyword">null</span> &amp;&amp; holder.isSynchronizedWithTransaction()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (holder.getExecutorType() != executorType) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TransientDataAccessResourceException(<span class="string">&quot;Cannot change the ExecutorType when there is an existing transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    holder.requested();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Fetched SqlSession [&quot;</span> + holder.getSqlSession() + <span class="string">&quot;] from current transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获得事务</span></span><br><span class="line">    <span class="keyword">return</span> holder.getSqlSession();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Creating a new SqlSession&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//获得新事务</span></span><br><span class="line">  SqlSession session = sessionFactory.openSession(executorType);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将断点打在holder，通过堆栈查看</p><p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%A0%86%E6%A0%88.png" alt="image-20220417141343151"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">    <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">  <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用SqlSessionTemplate的方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sqlSessionProxy.&lt;E&gt; selectList(statement, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>invoke的动态代理是<code>Mybatis</code>的动态代理,<strong>这里的<code>sqlSession</code>是<code>SqlSessionTemplate</code></strong>,原本的<code>SqlSession</code>是<code>DefaultSqlSession</code>。发起会话的调用是会调用到<code>SqlSessionTemplate</code>的逻辑。但是<code>SqlSessionTemplate</code>没有能力发起对<code>Mybatis</code>代码的代用，所以最终还是会调用<code>DefaultSqlSession</code>中的逻辑，<strong>而<code>SqlSessionTemplate</code>中的每个方法都会打开会话构造<code>SqlSession</code></strong>，所以将这些方法中构造<code>DefaultSqlSession</code>的逻辑使用动态代理来实现。</p><p>而<code>getSqlSession</code>方法获取<code>SqlSession</code>,不使用事务时，每次从获取一个<code>SqlSession</code>都是null，都会使用工厂方法创建一个<code>SqlSession</code>，然后注册到事务上，当方法中<strong>不使用事务时，就会注册失败。</strong>每次的SqlSession都是新构建的，所以无法命中一级缓存。</p><h2 id="二、二级缓存"><a href="#二、二级缓存" class="headerlink" title="二、二级缓存"></a>二、二级缓存</h2><h3 id="定义和需求"><a href="#定义和需求" class="headerlink" title="定义和需求"></a>定义和需求</h3><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/缓存体系.png" alt="image-20220417143217651" style="zoom:80%;"><p><code>Mybatis</code>中是先走会话，再走二级缓存，再走一级缓存。</p><h4 id="二级缓存定义："><a href="#二级缓存定义：" class="headerlink" title="二级缓存定义："></a>二级缓存定义：</h4><p>二级缓存也称作是应用级缓存，与一级缓存不同的是它的<strong>作用范围是整个应用</strong>，而宜可以<strong>跨线程使用</strong>。所以二级缓存有更高的命中率，适合<strong>缓存一些修改较少的数据</strong>。</p><h4 id="二级缓存扩展性要求"><a href="#二级缓存扩展性要求" class="headerlink" title="二级缓存扩展性要求"></a>二级缓存扩展性要求</h4><p>因为二级缓存是应用级别的缓存，必然对缓存有所要求。</p><ol><li>存储：需要多种方式的缓存，分为内存、硬盘、第三方集成。</li><li>缓存策略：当缓存到容量上限时，就需要有一些策略淘汰其中的缓存。FIFO先进先出、LRU最近最少使用。</li><li>过期清理：缓存设置过期清理。</li><li>线程安全：多线程场景下，必须保证数据一致。</li><li>命中率统计：对缓存中数据进行命中统计。</li><li>序列化：跨线程使用，2个对象必须不一样。</li><li>…</li></ol><h3 id="二级缓存组件结构"><a href="#二级缓存组件结构" class="headerlink" title="二级缓存组件结构"></a>二级缓存组件结构</h3><p>MyBatis的缓存接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mybait的二级缓存采用了装饰器加责任链的设计模式。每一层都实现自己的功能，并通过代理的方式实现Cache的所有功能。</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/二级缓存实现.png" alt="image-20220417145818712" style="zoom:80%;"><h4 id="开启mybatis二级缓存"><a href="#开启mybatis二级缓存" class="headerlink" title="开启mybatis二级缓存"></a>开启mybatis二级缓存</h4><table><thead><tr><th>配置</th><th>解释</th></tr></thead><tbody><tr><td>cacheEnabled</td><td>全局缓存开关默认true</td></tr><tr><td>useCache</td><td>statement 缓存开关默认true</td></tr><tr><td>flushCache</td><td>清除默认:修改true、查询false</td></tr><tr><td><cache>或<br>@CacheNamespace</cache></td><td>声明缓存空间</td></tr><tr><td><cache-ref>或<br>@CacheNamespaceRef</cache-ref></td><td>引用缓存空间</td></tr></tbody></table><p>配置文件中加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mapper文件中加入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>就开启了二级缓存</p><p>对应的sql语句加上useCache，flushCache就会开启响应策略</p><blockquote><p><cache>和@<code>CacheNamespace</code>不是一个命名空间</cache></p></blockquote><h4 id="测试二级缓存"><a href="#测试二级缓存" class="headerlink" title="测试二级缓存"></a>测试二级缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//cache就包含了若干个缓存节点。</span></span><br><span class="line">    Cache cache = configuration.getCache(<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper&quot;</span>);</span><br><span class="line">    Account account = <span class="keyword">new</span> Account();</span><br><span class="line">    account.setId(<span class="number">1</span>);</span><br><span class="line">    account.setMoney(<span class="number">1000.0</span>);</span><br><span class="line">    account.setName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    cache.putObject(<span class="string">&quot;lq&quot;</span>, account);</span><br><span class="line">    cache.getObject(<span class="string">&quot;lq&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheTest5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession session1 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    AccountMapper mapper1 = session1.getMapper(AccountMapper.class);</span><br><span class="line">    mapper1.selectById(<span class="number">1</span>);</span><br><span class="line">    session1.commit();</span><br><span class="line"></span><br><span class="line">    SqlSession session2 = factory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    AccountMapper mapper2 = session2.getMapper(AccountMapper.class);</span><br><span class="line">    mapper2.selectById(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样设计Cache就可以屏蔽内部复杂性</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/二级缓存调试.png" alt="image-20220417163913111" style="zoom: 67%;"><h4 id="二级缓存的命中条件"><a href="#二级缓存的命中条件" class="headerlink" title="二级缓存的命中条件"></a>二级缓存的命中条件</h4><ol><li>会话提交之后</li><li>Sql语句、参数相同</li><li>相同的statementID</li><li>RowBounds相同</li></ol><h3 id="二级缓存源码分析"><a href="#二级缓存源码分析" class="headerlink" title="二级缓存源码分析"></a>二级缓存源码分析</h3><h4 id="二级缓存命中"><a href="#二级缓存命中" class="headerlink" title="二级缓存命中"></a>二级缓存命中</h4><p>为什么要提交后才能命中缓存?</p><p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/%E6%8F%90%E4%BA%A4%E5%90%8E%E5%91%BD%E4%B8%AD%E7%BC%93%E5%AD%98.png" alt="image-20220417170340680"></p><p>如果不提交就命中会产生脏数据。</p><p>会话中访问缓存空间</p><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/二级缓存空间.png" alt="image-20220417170801574" style="zoom:80%;"><p>每次执行mapper的方法时都会把代码提交到暂存区，只有当commit时才会提交到缓冲区。</p><p>这里的缓冲区就是<code>SynchronizedCache</code></p><h4 id="二级缓存执行流程"><a href="#二级缓存执行流程" class="headerlink" title="二级缓存执行流程"></a>二级缓存执行流程</h4><img src="/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/二级缓存执行流程.png" alt="image-20220417215007525" style="zoom:67%;"><h5 id="CachingExecutor"><a href="#CachingExecutor" class="headerlink" title="CachingExecutor"></a>CachingExecutor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">//获取缓存</span></span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//清空缓存</span></span><br><span class="line">      flushCacheIfRequired(ms);</span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, parameterObject, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">          <span class="comment">//通过缓存管理器获取</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">          list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578. Query must be not synchronized to prevent deadlocks</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="TransactionalCacheManager缓存管理器，管理暂存区"><a href="#TransactionalCacheManager缓存管理器，管理暂存区" class="headerlink" title="TransactionalCacheManager缓存管理器，管理暂存区"></a>TransactionalCacheManager缓存管理器，管理暂存区</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCacheManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Cache, TransactionalCache&gt; transactionalCaches = <span class="keyword">new</span> HashMap&lt;Cache, TransactionalCache&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取缓冲区作为key,暂存区作为value</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Cache cache, CacheKey key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getTransactionalCache(cache).getObject(key);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Cache cache, CacheKey key, Object value)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).putObject(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.commit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TransactionalCache txCache : transactionalCaches.values()) &#123;</span><br><span class="line">      txCache.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TransactionalCache <span class="title">getTransactionalCache</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    TransactionalCache txCache = transactionalCaches.get(cache);</span><br><span class="line">    <span class="keyword">if</span> (txCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">      txCache = <span class="keyword">new</span> TransactionalCache(cache);</span><br><span class="line">      transactionalCaches.put(cache, txCache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> txCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="TransactionalCache暂存区"><a href="#TransactionalCache暂存区" class="headerlink" title="TransactionalCache暂存区"></a>TransactionalCache暂存区</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionalCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// issue #116</span></span><br><span class="line">     <span class="comment">//防止缓存穿透</span></span><br><span class="line">    Object object = delegate.getObject(key);</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123; <span class="comment">//填充一个值</span></span><br><span class="line">      entriesMissedInCache.add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #146</span></span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123; <span class="comment">//二级缓存有值，但是已经清空了，还是返回一个null,在同一个会话中，当先执行修改时，会清空二级缓存，但是因为没有commit不会真正清空，而在这个会话中执行查询，查到的是脏数据，所有要返回一个null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//清空，并没有清空，只是加了一个标记</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    clearOnCommit = <span class="keyword">true</span>;</span><br><span class="line">    entriesToAddOnCommit.clear(); <span class="comment">//只是清空了暂存区</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (clearOnCommit) &#123;</span><br><span class="line">      delegate.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    flushPendingEntries();</span><br><span class="line">    reset();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;SqlSession原理中介绍了在SQL查询时一级缓存和二级缓存的调用过程。这里介绍一下缓存的场景和失效。&lt;/p&gt;
&lt;img src=&quot;/2022/04/05/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%BC%93%E5%AD%98/Mybatis缓存.png&quot; alt=&quot;image-20220405134607618&quot; style=&quot;zoom:80%;&quot;&gt;

&lt;h2 id=&quot;一、一级缓存&quot;&gt;&lt;a href=&quot;#一、一级缓存&quot; class=&quot;headerlink&quot; title=&quot;一、一级缓存&quot;&gt;&lt;/a&gt;一、一级缓存&lt;/h2&gt;&lt;p&gt;一级缓存与&lt;code&gt;SqlSession&lt;/code&gt;相关，是一个&lt;strong&gt;会话级别的缓存&lt;/strong&gt;，会话关闭清空缓存。在会话中一级缓存与运行时参数和操作配置相关&lt;/p&gt;
&lt;h3 id=&quot;命中场景&quot;&gt;&lt;a href=&quot;#命中场景&quot; class=&quot;headerlink&quot; title=&quot;命中场景&quot;&gt;&lt;/a&gt;命中场景&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FirstCacheTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Configuration configuration;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; SqlSession sqlSession;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Before&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException, SQLException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SqlSessionFactoryBuilder factoryBuilder = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SqlSessionFactoryBuilder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        InputStream inputStream = Resources.getResourceAsStream(&lt;span class=&quot;string&quot;&gt;&amp;quot;mybatis-config.xml&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SqlSessionFactory build = factoryBuilder.build(inputStream);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        configuration = build.getConfiguration();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sqlSession = build.openSession();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        AccountMapper mapper = sqlSession.getMapper(AccountMapper.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Account&amp;gt; accounts1 = mapper.selectById(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Account&amp;gt; accounts2 = mapper.selectById(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(accounts1 == accounts2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;缓存命中有几个运行时参数要求&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sql和参数必须相同&lt;/li&gt;
&lt;li&gt;必须是相同的&lt;code&gt;statementID&lt;/code&gt;，sql相同也不行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sqlSession&lt;/code&gt;必须相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RowBounds&lt;/code&gt; 返回行返回必须相同&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;清理缓存之后就无法命中&lt;/strong&gt;，默认采用的是simple执行器，编译2次，执行2次。建议采用的reuse执行器。只有有一条执行语句加入了&lt;code&gt;flushCache=true&lt;/code&gt;等同于 &lt;code&gt;sqlSession.clearCache()&lt;/code&gt;。共有4种操作配置导致缓存无法命中的场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手动&lt;code&gt;sqlSession.clearCache()&lt;/code&gt;,&lt;code&gt;sqlSession.commit()&lt;/code&gt;, &lt;code&gt;sqlSession.rollback()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行的方法上加入&lt;code&gt;flushCache=true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;中间执行Update语句&lt;/li&gt;
&lt;li&gt;缓存作用域不是&lt;code&gt;SESSION&lt;/code&gt; 改为&lt;code&gt;STATEMENT&lt;/code&gt;这里是嵌套查询（子查询）&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>SqlSeesion原理</title>
    <link href="http://yoursite.com/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-04T09:30:09.000Z</published>
    <updated>2022-11-05T15:21:38.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、sqlSession运行过程"><a href="#一、sqlSession运行过程" class="headerlink" title="一、sqlSession运行过程"></a>一、sqlSession运行过程</h2><p>SqlSession采用了门面模式，提供了API（增删改查），辅助API（提交关闭）。</p><p>核心执行组件Executor，执行操作。提供了（改和查的操作），维护缓存，辅助API（提交、关闭执行器、批处理刷新）</p><h3 id="映射器的动态代理"><a href="#映射器的动态代理" class="headerlink" title="映射器的动态代理"></a>映射器的动态代理</h3><p>Mapper映射是通过动态代理来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是动态代理</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[]&#123;<span class="keyword">this</span>.mapperInterface&#125;, mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">        MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy(sqlSession, <span class="keyword">this</span>.mapperInterface, <span class="keyword">this</span>.methodCache);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.newInstance(mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到动态代理对接口的绑定，它的<strong>作用是生成动态代理对象</strong>，代理的方法放入<code>MapperProxy</code>类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">        <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">        <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//判断它是否是一个类</span></span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</span><br><span class="line">            <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        MapperMethod mapperMethod = (MapperMethod)<span class="keyword">this</span>.methodCache.get(method);</span><br><span class="line">        <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mapperMethod = <span class="keyword">new</span> MapperMethod(<span class="keyword">this</span>.mapperInterface, method, <span class="keyword">this</span>.sqlSession.getConfiguration());</span><br><span class="line">            <span class="keyword">this</span>.methodCache.put(method, mapperMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapperMethod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mybatis使用的是<code>InvocationHandler</code>，是一个JDK动态代理。上面运用了invoke方法。<strong>一旦mapper是一个代理对象，那么它就会运行到invoke方法里面</strong>，invoke首先判断它是否是一个类，显然这里Mapper是一个接口不是类，所以判定失败。那么就会生成<code>MapperMethod</code>对象<strong>，它是通过<code>cachedMapperMethod</code>方法对其初始化的，然后执行execute方法，把sqlSession和当前运行的参数传递进去。</strong></p><p><code>MapperMethod</code>采用<strong>命令模式</strong>运行，根据上下文跳转，它可能跳转到许多方法中，我们不需要全部明白。我们可以看到里面的<code>executeForMany</code>方法，再看看它的实现，实际上它<strong>最后就是通过sqlSession对象去运行对象的SQL</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    List result;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.method.hasRowBounds()) &#123;</span><br><span class="line">        RowBounds rowBounds = <span class="keyword">this</span>.method.extractRowBounds(args);</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.method.getReturnType().isArray() ? <span class="keyword">this</span>.convertToArray(result) : <span class="keyword">this</span>.convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><p>Mybatis映射器的XML文件的命名空间<strong>对应的便是这个接口的全路径</strong>，那么它根据全路径<strong>和方法名便能够绑定起来，通过动态代理技术，让这个接口跑起来</strong>。而后<strong>采用命令模式，最后还是使用SqlSession接口的方法使得它能够执行查询</strong>，有了这层封装我们便可以使用接口编程，这样编程就更简单了。</p><h2 id="二、SqlSession的四大对象"><a href="#二、SqlSession的四大对象" class="headerlink" title="二、SqlSession的四大对象"></a>二、SqlSession的四大对象</h2><p>Mapper执行的过程是通过 <code>Executor</code>、<code>StatementHandler</code> 、<code>ParameterHandler</code> 和 <code>ResultHandler</code>来完成数据库操作和结果返回的。</p><ul><li><code>Executor</code> 代表执行器,由它来<strong>调度</strong>StatementHandler、ParameterHandler.ResultHandler等来执行对应的SQL。</li><li><code>StatementHandler</code>的作用是<strong>使用数据库的Statement (PreparedStatement)执行操作</strong>，它是四大对象的核心，起到承上启下的作用。</li><li><code>ParameterHandler</code> 用于SQL<strong>对参数的处理</strong>。</li><li><code>ResultHandler</code>是进行<strong>最后数据集（ResultSet）的封装返回处理</strong>的。</li></ul><h3 id="执行器（Executor）"><a href="#执行器（Executor）" class="headerlink" title="执行器（Executor）"></a>执行器（Executor）</h3><p>执行器（Executor）起到了至关重要的作用。它是一个真正执行Java和数据库交互的东西。在 MyBatis中存在三种执行器。我们可以在 MyBatis 的配置文件中进行选择</p><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/Executor.png" alt="image-20220404232203027" style="zoom:80%;"><ul><li><code>SIMPLE</code>，简易执行器，不配置它就是默认执行器。</li><li><code>REUSE</code>，是一种执行器<strong>重用预处理语句</strong>。</li><li><code>BATCH</code>，执行器<strong>重用语句和批量更新</strong>，它是针对批量专用的执行器。</li></ul><p><code>Configuration</code>类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction， ExecutorTypeexecutorType)</span></span>&#123;</span><br><span class="line">executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;executorType =executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="comment">//根据配置选择执行器</span></span><br><span class="line"><span class="keyword">if</span>(ExecutorType. BATCH == executorType) &#123;</span><br><span class="line">executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE ==executorType)&#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>,transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction) ;</span><br><span class="line"><span class="keyword">if</span> (cacheEnabled)&#123;</span><br><span class="line">executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//mybatus插件，这里为我们构建一层层的动态代理对象</span></span><br><span class="line">executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单执行器"><a href="#简单执行器" class="headerlink" title="简单执行器"></a>简单执行器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//根据Configuration来构建StatementHandler</span></span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      <span class="comment">// 使用prepareStatement方法,对SQL编译并对参数进行初始化</span></span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 调用StatementHandler的 prepare()进行了预编译和基础设置</span></span><br><span class="line">    stmt = handler.prepare(connection);</span><br><span class="line">    <span class="comment">//通过StatementHandler 的 parameterize()来设置参数并执行,resultHandler 再组装查询结果返回给调用者来完成一次查询</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Executor需要2个参数configuration和transaction，configuration是从配置文件中获取，由SqlSessionFactory获取，而事务是从connection中获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> JdbcTransaction jdbcTransaction;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">&quot;jdbc:mysql://localhost:3306/ssm&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SQLException </span>&#123;</span><br><span class="line">        SqlSessionFactoryBuilder factoryBuilder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        SqlSessionFactory build = factoryBuilder.build(inputStream);</span><br><span class="line">        configuration = build.getConfiguration();</span><br><span class="line">        connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br><span class="line">        jdbcTransaction = <span class="keyword">new</span> JdbcTransaction(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Executor之后，就可以通过<code>executor.doQuery()</code>执行具体的查询语句。这里需要5个参数</p><ul><li><code>MappedStatement ms</code> : SQL声明</li><li><code>Object parameter</code>: 参数</li><li><code>RowBounds rowBounds</code>: 行范围，要不要分页</li><li><code>ResultHandler resultHandler</code>: 结果处理器</li><li><code>BoundSql boundSql</code>: 动态SQL语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单执行器</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">simpleTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    SimpleExecutor executor = <span class="keyword">new</span> SimpleExecutor(configuration, jdbcTransaction);</span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper.selectById&quot;</span>);</span><br><span class="line">    List&lt;Object&gt; objects = executor.doQuery(ms, <span class="number">1</span>, RowBounds.DEFAULT,</span><br><span class="line">            SimpleExecutor.NO_RESULT_HANDLER,</span><br><span class="line">            ms.getBoundSql(<span class="number">10</span>));</span><br><span class="line">    System.out.println(objects);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单执行器，无论SQL是否一样，每次都会进行预编译，浪费性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt;  Preparing: select id ,name ,money from account where id = ? </span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt; Parameters: 1(Integer)</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-&lt;==      Total: 1</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-ooo Using Connection [com.mysql.jdbc.JDBC4Connection@5bb21b69]</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt;  Preparing: select id ,name ,money from account where id = ? </span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt; Parameters: 1(Integer)</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-&lt;==      Total: 1</span><br></pre></td></tr></table></figure><h4 id="批处理执行器"><a href="#批处理执行器" class="headerlink" title="批处理执行器"></a>批处理执行器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批处理</span></span><br><span class="line"><span class="comment">//批处理执行器</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        BatchExecutor executor = <span class="keyword">new</span> BatchExecutor(configuration, jdbcTransaction);</span><br><span class="line">        MappedStatement ms = configuration.getMappedStatement(<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper.selectById&quot;</span>);</span><br><span class="line">        List&lt;Object&gt; objects = executor.doQuery(ms, <span class="number">1</span>, RowBounds.DEFAULT,</span><br><span class="line">                SimpleExecutor.NO_RESULT_HANDLER,</span><br><span class="line">                ms.getBoundSql(<span class="number">10</span>));</span><br><span class="line">        System.out.println(objects);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是打印日志还是显示2次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt;  Preparing: select id ,name ,money from account where id = ? </span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt; Parameters: 1(Integer)</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-&lt;==      Total: 1</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-ooo Using Connection [com.mysql.jdbc.JDBC4Connection@c46bcd4]</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt;  Preparing: select id ,name ,money from account where id = ? </span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-==&gt; Parameters: 1(Integer)</span><br><span class="line">[com.lq.mybatis.mapper.AccountMapper.selectById]-&lt;==      Total: 1</span><br></pre></td></tr></table></figure><p>批处理值针对修改操作才执行一次。必须要手动刷新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批处理执行器，必须进行手动刷新</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchUpdateTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    BatchExecutor executor = <span class="keyword">new</span> BatchExecutor(configuration, jdbcTransaction);</span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper.updateAccount&quot;</span>);</span><br><span class="line">    Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Account account = <span class="keyword">new</span> Account();</span><br><span class="line">    account.setId(<span class="number">1</span>);</span><br><span class="line">    account.setName(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    account.setMoney(<span class="number">2000.0</span>);</span><br><span class="line">    map.put(<span class="string">&quot;account&quot;</span>, account);</span><br><span class="line">    <span class="comment">//需要2个参数,SQL声明，具体参数</span></span><br><span class="line">    executor.doUpdate(ms, map);</span><br><span class="line">    executor.doUpdate(ms, map);</span><br><span class="line">    executor.flushStatements(<span class="keyword">false</span>); <span class="comment">//只是在设置参数，必须手动刷新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="基础执行器"><a href="#基础执行器" class="headerlink" title="基础执行器"></a>基础执行器</h4><p>基础执行器中包含了一级缓存，query和update，这两个方法都会调用具体的方法执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Transaction transaction;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ConcurrentLinkedQueue&lt;DeferredLoad&gt; deferredLoads;</span><br><span class="line">    <span class="keyword">protected</span> PerpetualCache localCache;</span><br><span class="line">    <span class="keyword">protected</span> PerpetualCache localOutputParameterCache;</span><br><span class="line">    <span class="keyword">protected</span> Configuration configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> queryStack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> closed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">        <span class="comment">//创建缓存key</span></span><br><span class="line">        CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">        <span class="keyword">return</span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查询的方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//走缓存的逻辑， localCache获取本地一级缓存</span></span><br><span class="line">      queryStack++;</span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//没有就会从数据库查询</span></span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//这里就会调用子类的doQuery方法</span></span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      deferredLoads.clear(); <span class="comment">// issue 601</span></span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        clearLocalCache(); <span class="comment">// issue 482</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>SimpleExecutor和ReuseExecutor都只会进行一次调用，相同的查询会走缓存的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">baseQueryTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    SimpleExecutor executor = <span class="keyword">new</span> SimpleExecutor(configuration, jdbcTransaction);</span><br><span class="line">    MappedStatement ms = configuration.getMappedStatement(<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper.selectById&quot;</span>);</span><br><span class="line">    executor.query(ms, <span class="number">1</span>, RowBounds.DEFAULT,</span><br><span class="line">            SimpleExecutor.NO_RESULT_HANDLER);</span><br><span class="line">    executor.query(ms, <span class="number">1</span>, RowBounds.DEFAULT,</span><br><span class="line">            SimpleExecutor.NO_RESULT_HANDLER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CachingExecutor"><a href="#CachingExecutor" class="headerlink" title="CachingExecutor"></a>CachingExecutor</h4><p><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/CacheExecutor.png" alt="image-20220404235522241"></p><p>缓存执行器，二级缓存，装饰者模式<strong>装饰了具体的Executor</strong>。二级缓存和一级缓存不同，一级缓存执行过就会缓存。二级缓存必须提交之后才会有缓存。是一个跨线程的缓存。</p><p>先走二级缓存，再走一级缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheQueryTest</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        SimpleExecutor executor = <span class="keyword">new</span> SimpleExecutor(configuration, jdbcTransaction);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//装饰者模式，二级缓存相关逻辑</span></span><br><span class="line">        CachingExecutor cachingExecutor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line"></span><br><span class="line">        MappedStatement ms = configuration.getMappedStatement(<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper.selectById&quot;</span>);</span><br><span class="line">        cachingExecutor.query(ms, <span class="number">1</span>, RowBounds.DEFAULT,</span><br><span class="line">                SimpleExecutor.NO_RESULT_HANDLER);</span><br><span class="line">        cachingExecutor.commit(<span class="keyword">true</span>);</span><br><span class="line">        cachingExecutor.query(ms, <span class="number">1</span>, RowBounds.DEFAULT,</span><br><span class="line">                SimpleExecutor.NO_RESULT_HANDLER);</span><br><span class="line">        cachingExecutor.commit(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数据库会话器"><a href="#数据库会话器" class="headerlink" title="数据库会话器"></a>数据库会话器</h3><p>数据库会话器(StatementHandler）就是<strong>专门处理数据库会话</strong>的</p><p>JDBC处理器,基于JDBC构建Slatement并设置参数,然后执行Sql。<strong>每调用会话当中一次SQL，都会有与之相对应的且唯一的Statemet实例。</strong></p><p><code>Configuration</code>类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建的真实对象是一个RoutingStatementHandler对象,和Executor一样，用代理对象做一层层的封装</span></span><br><span class="line">  StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RoutingStatementHandler</code>不是我们真实的服务对象，它是<strong>通过适配模式找到对应的</strong><code>StatementHandler</code> 来执行的。在 MyBatis 中，StatementHandler和Executor一样分为三种:普通<code>SimpleStatementHandler</code>、预处理<code>PreparedStatementHandler</code>、存储过程<code>CallableStatementHandler</code>。</p><p>在初始化 <code>RoutingStatementHandler</code>对象的时候它会根据上下文环境决定创建哪个<code>StatementHandler</code>对象，我们看看<code>RoutingStatementHandler</code> 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StatementHandler delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库会话器定义了一个<strong>对象的适配器<code>delegate</code></strong>,它是一个<code>StatementHandler</code>接口对象，构造方法<strong>根据配置来适配对应的StatementHandler对象</strong>。它的作用是<strong>给实现类对象的使用提供一个统一、简易的使用适配器</strong>。此为对象的适配模式，可以让<strong>我们使用现有的类和方法对外提供服务，也可以根据实际的需求对外屏蔽一些方法，甚至是加入新的服务</strong>。<br>我们现在以最常用的<code>PreparedStatementHandler</code>为例,看看MyBatis是怎么执行查询的。执行器有三个主要的方法，<strong>prepare、parameterize和 query</strong>，</p><p>先看他们的父类<code>BaseStatementHandler</code>，这个类主要用于处理共性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      statement = instantiateStatement(connection);</span><br><span class="line">        <span class="comment">//设置超时时间</span></span><br><span class="line">      setStatementTimeout(statement);</span><br><span class="line">        <span class="comment">//设置返回行数</span></span><br><span class="line">      setFetchSize(statement);</span><br><span class="line">      <span class="keyword">return</span> statement;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个抽象方法来具体实现statement</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instantiateStatement()</code>方法是<strong>对SQL进行了预编译</strong>。首先<strong>，做一些基础配置，比如超时，获取的最大行数等的设置。</strong>然后，Executor 会调用<code>parameterize()</code>方法去设置参数。这个时候它是调用<code>ParameterHandler</code>去完成的，这里先看<code>StatementHandler</code>的查询方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementHandler</span> <span class="keyword">extends</span> <span class="title">BaseStatementHandler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">        ps.execute();</span><br><span class="line">        <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用参数处理器设置参数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//创建statement</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">      String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">      <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() == ResultSetType.DEFAULT) &#123;</span><br><span class="line">       <span class="comment">//这里就会创建一个预处理的Statement</span></span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在执行前参数和SQL都被prepare()方法预编译，参数在<code>parameterize()</code>方法上已经进行了设置。所以到这里已经很简单了。我们<strong>只要执行SQL，然后返回结果就可以了</strong>。执行之后我们看到了<code>ResultSetHandler</code><strong>对结果的封装和返回</strong>。</p><p>一条查询SQL的执行流程：预编译、设置参数、执行、结果集映射</p><ol><li>Executor先调用<code>StatementHandler</code> 的 <code>prepare()</code>方法<strong>预编译SQL语句</strong>，同时设置一些基本运行的参数。</li><li>然后用<code>parameterize()</code>方法启用<code>ParameterHandler</code> 设置参数，完成预编译。</li><li>跟着就是执行查询，而update()也是这样的，最后如果需要查询，我们就用<code>ResultSetHandler</code>封装结果返回给调用者。</li></ol><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/Statement处理流程.png" alt="image-20220417224757303" style="zoom:80%;"><h3 id="参数处理器"><a href="#参数处理器" class="headerlink" title="参数处理器"></a>参数处理器</h3><p>完成对预编译参数的设置，javabean转换为jdbc</p><h4 id="参数转换"><a href="#参数转换" class="headerlink" title="参数转换"></a>参数转换</h4><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/参数处理.png" alt="image-20220417230107195" style="zoom:67%;"><p><code>ParamNameResolver</code>帮助我们把参数转换为Object就是查询的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//没有Param注解 并且参数为1直接返回</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">     <span class="comment">//多参数</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">      param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">      <span class="comment">// add generic param names (param1, param2, ...)</span></span><br><span class="line">       <span class="comment">//参数 key为param注解的值，value为具体的值</span></span><br><span class="line">      <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// ensure not to overwrite parameter named with @Param</span></span><br><span class="line">      <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">        param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数映射处理"><a href="#参数映射处理" class="headerlink" title="参数映射处理"></a>参数映射处理</h4><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/参数转换.png" alt="image-20220418231724430" style="zoom:80%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//作用是返回参数对象</span></span><br><span class="line">  <span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//设置预编译SQL语句参数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看实现类<code>DefaultParameterHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">    <span class="comment">//根据sql语句中参数？解析为parameterMappings参数映射就是#&#123;&#125;中的值</span></span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    MetaObject metaObject = parameterObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : configuration.newMetaObject(parameterObject);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">         <span class="comment">//获得参数名 例如id</span></span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//如果参数类型匹配，直接放入</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> </span><br><span class="line">           <span class="comment">//只有单个值才会有单个值映射处理器</span></span><br><span class="line">          (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">            <span class="comment">//如果是一个map对象</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//把map对象换成一个metaObejct,这样就可以通过属性名称获取对应的值</span></span><br><span class="line">            <span class="comment">//属性名和映射名一一对应</span></span><br><span class="line">          value = metaObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">//通过TypeHandler设置对应的值</span></span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">          <span class="comment">//这里会根据类型，自动设置sql语句的类型 </span></span><br><span class="line">        typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是从<code>parameterObject</code>对象中取参数,然后使用<code>typeHandler</code>进行参数处理，如果你有设置typeHandler，那么它就会根据签名注册的<code>typeHandler</code>对参数进行处理。而typeHandler也是在 MyBatis初始化的时候，注册在Configuration里面的，我们需要的时候可以直接拿来用。这样就完成了参数的设置。</p><h3 id="结果处理器"><a href="#结果处理器" class="headerlink" title="结果处理器"></a>结果处理器</h3><p><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86%E5%99%A8.png" alt="image-20220418233415695"></p><ul><li>ResultSetHandler：结果集处理器</li><li>ResultContext：结果提出</li><li>ResultHandler：结果处理器</li></ul><h2 id="三、SqlSession运行总结"><a href="#三、SqlSession运行总结" class="headerlink" title="三、SqlSession运行总结"></a>三、SqlSession运行总结</h2><img src="/2022/04/04/%E6%A1%86%E6%9E%B6/mybatis/SqlSession%E5%8E%9F%E7%90%86/SqlSession运行.png" alt="image-20220404160855195" style="zoom:80%;"><p>SqlSession是<strong>通过Executor创建StatementHandler来运行</strong>的，而<code>StatementHandler</code>要经过下<br>面三步。</p><ul><li>prepared 预编译SQL。</li><li>parameterize设置参数。</li><li>query/update执行SQL。</li></ul><p>其中parameterize是调用<code>parameterHandler</code>的方法去设置的，而参数是根据类型处理器.<code>typeHandler</code>去处理的。<code>query/update</code> 方法是通过<code>resultHandler</code>进行处理结果的封装，如果是update的语句，它就<strong>返回整数</strong>，否则它就<strong>通过<code>typeHandler</code> 处理结果类型</strong>，然后用  <code>ObjectFactory</code>提供的规则<strong>组装对象</strong>，返回给调用者。这便是SqlSession 执行的过程。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、sqlSession运行过程&quot;&gt;&lt;a href=&quot;#一、sqlSession运行过程&quot; class=&quot;headerlink&quot; title=&quot;一、sqlSession运行过程&quot;&gt;&lt;/a&gt;一、sqlSession运行过程&lt;/h2&gt;&lt;p&gt;SqlSession采用了门面模式，提供了API（增删改查），辅助API（提交关闭）。&lt;/p&gt;
&lt;p&gt;核心执行组件Executor，执行操作。提供了（改和查的操作），维护缓存，辅助API（提交、关闭执行器、批处理刷新）&lt;/p&gt;
&lt;h3 id=&quot;映射器的动态代理&quot;&gt;&lt;a href=&quot;#映射器的动态代理&quot; class=&quot;headerlink&quot; title=&quot;映射器的动态代理&quot;&gt;&lt;/a&gt;映射器的动态代理&lt;/h3&gt;&lt;p&gt;Mapper映射是通过动态代理来实现的&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MapperProxyFactory&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; mapperInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Map&amp;lt;Method, MapperMethod&amp;gt; methodCache = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ConcurrentHashMap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MapperProxyFactory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Class&amp;lt;T&amp;gt; mapperInterface)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface = mapperInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Class&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;getMapperInterface&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Map&amp;lt;Method, MapperMethod&amp;gt; &lt;span class=&quot;title&quot;&gt;getMethodCache&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.methodCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//这里就是动态代理&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MapperProxy&amp;lt;T&amp;gt; mapperProxy)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Proxy.newProxyInstance(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface.getClassLoader(), &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Class[]&amp;#123;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface&amp;#125;, mapperProxy);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(SqlSession sqlSession)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MapperProxy&amp;lt;T&amp;gt; mapperProxy = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MapperProxy(sqlSession, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.methodCache);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.newInstance(mapperProxy);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里可以看到动态代理对接口的绑定，它的&lt;strong&gt;作用是生成动态代理对象&lt;/strong&gt;，代理的方法放入&lt;code&gt;MapperProxy&lt;/code&gt;类中&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MapperProxy&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InvocationHandler&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; serialVersionUID = -&lt;span class=&quot;number&quot;&gt;6424540398559729838L&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; SqlSession sqlSession;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; mapperInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Map&amp;lt;Method, MapperMethod&amp;gt; methodCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MapperProxy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(SqlSession sqlSession, Class&amp;lt;T&amp;gt; mapperInterface, Map&amp;lt;Method, MapperMethod&amp;gt; methodCache)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sqlSession = sqlSession;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface = mapperInterface;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.methodCache = methodCache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//判断它是否是一个类&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Object.class.equals(method.getDeclaringClass())) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; method.invoke(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            MapperMethod mapperMethod = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.cachedMapperMethod(method);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mapperMethod.execute(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sqlSession, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; MapperMethod &lt;span class=&quot;title&quot;&gt;cachedMapperMethod&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Method method)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MapperMethod mapperMethod = (MapperMethod)&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.methodCache.get(method);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mapperMethod == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mapperMethod = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MapperMethod(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.mapperInterface, method, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.sqlSession.getConfiguration());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.methodCache.put(method, mapperMethod);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; mapperMethod;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Mybatis使用的是&lt;code&gt;InvocationHandler&lt;/code&gt;，是一个JDK动态代理。上面运用了invoke方法。&lt;strong&gt;一旦mapper是一个代理对象，那么它就会运行到invoke方法里面&lt;/strong&gt;，invoke首先判断它是否是一个类，显然这里Mapper是一个接口不是类，所以判定失败。那么就会生成&lt;code&gt;MapperMethod&lt;/code&gt;对象&lt;strong&gt;，它是通过&lt;code&gt;cachedMapperMethod&lt;/code&gt;方法对其初始化的，然后执行execute方法，把sqlSession和当前运行的参数传递进去。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MapperMethod&lt;/code&gt;采用&lt;strong&gt;命令模式&lt;/strong&gt;运行，根据上下文跳转，它可能跳转到许多方法中，我们不需要全部明白。我们可以看到里面的&lt;code&gt;executeForMany&lt;/code&gt;方法，再看看它的实现，实际上它&lt;strong&gt;最后就是通过sqlSession对象去运行对象的SQL&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="http://yoursite.com/2022/04/04/%E5%85%B6%E4%BB%96/markdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2022/04/04/%E5%85%B6%E4%BB%96/markdown%E8%AF%AD%E6%B3%95/</id>
    <published>2022-04-04T08:30:52.000Z</published>
    <updated>2022-04-04T08:47:39.858Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一级标题</span><br><span class="line">## 这是二级标题</span><br><span class="line">### 这是三级标题</span><br><span class="line">#### 这是四级标题</span><br><span class="line">##### 这是五级标题</span><br><span class="line">###### 这是六级标题</span><br></pre></td></tr></table></figure><h2 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h2><ul><li><p>加粗：要加粗的文字左右分别用两个*号包起来</p></li><li><p>斜体：要倾斜的文字左右分别用一个*号包起来</p></li><li><p>斜体加粗：要倾斜和加粗的文字左右分别用三个*号包起来</p></li><li><p>删除线：要加删除线的文字左右分别用两个~~号包起来</p></li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em>`<br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del></p><h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;，n个…<br>貌似可以一直加下去，但没神马卵用</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line">&gt;&gt;这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>这是引用的内容</p><blockquote><p>这是引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p>效果如下：</p><hr><hr><hr><hr><h2 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h2><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &#x27;&#x27;图片title&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><p>示例：<br>![blockchain](<a href="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/">https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</a><br>u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”)</p><p>上传本地图片直接点击导航栏的图片标志，选择图片即可</p><p>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。<br>关于图床的选择<br><a href="https://www.jianshu.com/p/ea1eb11db63f">https://www.jianshu.com/p/ea1eb11db63f</a></p><h2 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h2><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[简书](http://jianshu.com)</span><br><span class="line">[百度](http://baidu.com)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="http://jianshu.com">简书</a><br><a href="http://baidu.com">百度</a></p><p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt;</span><br></pre></td></tr></table></figure><h2 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h2><p>无序列表</p><p>语法：<br>无序列表用 - + * 任何一种都可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>语法：<br>数字加点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><p>列表嵌套</p><p>上一级和下一级之间敲三个空格即可</p><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 | 包起来。此处省略</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">txt姓名|技能|排行</span><br><span class="line">--|:--:|--:</span><br><span class="line">刘备|哭|大哥</span><br><span class="line">关羽|打|二哥</span><br><span class="line">张飞|骂|三弟</span><br></pre></td></tr></table></figure><p>效果如下：<br>姓名|技能|排行<br>–|:–:|–:<br>刘备|哭|大哥<br>关羽|打|二哥<br>张飞|骂|三弟</p><h2 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h2><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`代码内容`</span><br></pre></td></tr></table></figure><p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(```)</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure><blockquote><p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p></blockquote><h2 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;```</span><br></pre></td></tr></table></figure><p>效果如下：</p><pre><code class="flow">st=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;```</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。&lt;/p&gt;
&lt;h2 id=&quot;一、标题&quot;&gt;&lt;a href=&quot;#一、标题&quot; class=&quot;headerlink&quot; title=&quot;一、标题&quot;&gt;&lt;/a&gt;一、标题&lt;/h2&gt;&lt;p&gt;在想要设置为标题的文字前面加#来表示&lt;br&gt;一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。&lt;/p&gt;
&lt;p&gt;注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 这是一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 这是二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 这是三级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 这是四级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 这是五级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### 这是六级标题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;二、字体&quot;&gt;&lt;a href=&quot;#二、字体&quot; class=&quot;headerlink&quot; title=&quot;二、字体&quot;&gt;&lt;/a&gt;二、字体&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;加粗：要加粗的文字左右分别用两个*号包起来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;斜体：要倾斜的文字左右分别用一个*号包起来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;斜体加粗：要倾斜和加粗的文字左右分别用三个*号包起来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除线：要加删除线的文字左右分别用两个~~号包起来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;**这是加粗的文字**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*这是倾斜的文字*`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***这是斜体加粗的文字***&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~~这是加删除线的文字~~&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis原理</title>
    <link href="http://yoursite.com/2022/04/03/%E6%A1%86%E6%9E%B6/mybatis/MyBatis%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2022/04/03/%E6%A1%86%E6%9E%B6/mybatis/MyBatis%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-03T14:56:26.000Z</published>
    <updated>2022-04-04T09:29:56.832Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis的解析和运行原理</p><p>MyBatis 的运行分为两大部分，第一部分是读取配置文件缓存到Configuration对象，用以创建SqISessionFactory,第二部分是SqISession的执行过程。</p><h2 id="构建SqlSessionFactory过程"><a href="#构建SqlSessionFactory过程" class="headerlink" title="构建SqlSessionFactory过程"></a>构建<code>SqlSessionFactory</code>过程</h2><ol><li>通过<code>org.apache.ibatis.builder.xm1.XMLConfigBuilder</code>解析配置的XML文件，读出配置参数，并将读取的数据存入这个<code>org.apache.ibatis.session.Configuration</code>类中。注意，<code>MyBatis</code> 几乎所有的配置都是存在这里的。</li><li>使用<code>Confinguration</code>对象去创建<code>SqISessionFactory</code>。<code>MyBatis</code>中的<code>SqISessionFactory</code>是一个接口，而不是实现类，为此 MyBatis 提供了一个默认的SqISessionFactory’实现类，我们一般都会使用它<code>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory</code>。</li></ol><p>这种创建的方式就是一种 Builder模式。对于复杂的对象而言，<strong>直接使用构造方法构建是有困难的</strong>，这会导致大量的逻辑放在构造方法中，由于对象的复杂性，在构建的时候，我们<strong>更希望一步步有秩序的来构建它，从而降低其复杂性</strong>。这个时候使用一个参数类总领全局，例如，Configuration类，然后分步构建，例如，DefaultSqSessionFactory类，就可以构建一个复杂的对象，例如，SqlSessionFactory。</p><h3 id="构建Configuration"><a href="#构建Configuration" class="headerlink" title="构建Configuration"></a>构建Configuration</h3><p>在SqlSessionFactory构建中，Configuration是最重要的，它的作用如下。</p><ul><li><strong>读入配置文件</strong>，包括基础配置的XML文件和映射器的XML文件。</li><li><strong>初始化基础配置</strong>，比如 MyBatis 的别名等，一些重要的类对象，例如，插件、映射器、ObjectFactory 和typeHandler对象。</li><li><strong>提供单例</strong>，为后续创建SessionFactory 服务并提供配置的参数。</li><li><strong>执行一些重要的对象方法</strong>，初始化配置信息。</li></ul><h3 id="映射器的内部组成"><a href="#映射器的内部组成" class="headerlink" title="映射器的内部组成"></a>映射器的内部组成</h3><p>映射器由3个部分构成</p><ul><li><code>MappedStatement</code>，它保存映射器的一个节点( <code>select|insert|delete|update</code>)。包括许多我们配置的SQL、SQL的id、缓存信息、resultMap、parameterType、resultType、languageDriver等重要配置内容。</li><li><code>SqlSource</code>，它是<strong>提供BoundSql对象的地方</strong>，它是<code>MappedStatement</code>的一个属性。</li><li><code>BoundSql</code>，它是<strong>建立SQL和参数的地方</strong>。它有3个常用的属性:SQL、parameterObject、parameterMappings。</li></ul><img src="/2022/04/03/%E6%A1%86%E6%9E%B6/mybatis/MyBatis%E5%8E%9F%E7%90%86/映射器.png" alt="image-20220404144713702" style="zoom:80%;">]]></content>
    
    
    <summary type="html">&lt;p&gt;MyBatis的解析和运行原理&lt;/p&gt;
&lt;p&gt;MyBatis 的运行分为两大部分，第一部分是读取配置文件缓存到Configuration对象，用以创建SqISessionFactory,第二部分是SqISession的执行过程。&lt;/p&gt;
&lt;h2 id=&quot;构建SqlSessionFactory过程&quot;&gt;&lt;a href=&quot;#构建SqlSessionFactory过程&quot; class=&quot;headerlink&quot; title=&quot;构建SqlSessionFactory过程&quot;&gt;&lt;/a&gt;构建&lt;code&gt;SqlSessionFactory&lt;/code&gt;过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;org.apache.ibatis.builder.xm1.XMLConfigBuilder&lt;/code&gt;解析配置的XML文件，读出配置参数，并将读取的数据存入这个&lt;code&gt;org.apache.ibatis.session.Configuration&lt;/code&gt;类中。注意，&lt;code&gt;MyBatis&lt;/code&gt; 几乎所有的配置都是存在这里的。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;Confinguration&lt;/code&gt;对象去创建&lt;code&gt;SqISessionFactory&lt;/code&gt;。&lt;code&gt;MyBatis&lt;/code&gt;中的&lt;code&gt;SqISessionFactory&lt;/code&gt;是一个接口，而不是实现类，为此 MyBatis 提供了一个默认的SqISessionFactory’实现类，我们一般都会使用它&lt;code&gt;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种创建的方式就是一种 Builder模式。对于复杂的对象而言，&lt;strong&gt;直接使用构造方法构建是有困难的&lt;/strong&gt;，这会导致大量的逻辑放在构造方法中，由于对象的复杂性，在构建的时候，我们&lt;strong&gt;更希望一步步有秩序的来构建它，从而降低其复杂性&lt;/strong&gt;。这个时候使用一个参数类总领全局，例如，Configuration类，然后分步构建，例如，DefaultSqSessionFactory类，就可以构建一个复杂的对象，例如，SqlSessionFactory。&lt;/p&gt;
&lt;h3 id=&quot;构建Configuration&quot;&gt;&lt;a href=&quot;#构建Configuration&quot; class=&quot;headerlink&quot; title=&quot;构建Configuration&quot;&gt;&lt;/a&gt;构建Configuration&lt;/h3&gt;&lt;p&gt;在SqlSessionFactory构建中，Configuration是最重要的，它的作用如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读入配置文件&lt;/strong&gt;，包括基础配置的XML文件和映射器的XML文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化基础配置&lt;/strong&gt;，比如 MyBatis 的别名等，一些重要的类对象，例如，插件、映射器、ObjectFactory 和typeHandler对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提供单例&lt;/strong&gt;，为后续创建SessionFactory 服务并提供配置的参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行一些重要的对象方法&lt;/strong&gt;，初始化配置信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;映射器的内部组成&quot;&gt;&lt;a href=&quot;#映射器的内部组成&quot; class=&quot;headerlink&quot; title=&quot;映射器的内部组成&quot;&gt;&lt;/a&gt;映射器的内部组成&lt;/h3&gt;&lt;p&gt;映射器由3个部分构成&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis简介</title>
    <link href="http://yoursite.com/2022/03/30/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2022/03/30/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%AE%80%E4%BB%8B/</id>
    <published>2022-03-30T14:56:26.000Z</published>
    <updated>2022-04-04T13:40:10.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>JDBC是java提供的连接数据库的规范。</p><p>JDBC连接数据库的步骤：</p><ol><li>注册驱动和数据库信息</li><li>操作<code>Connection</code>，打开<code>Statement</code>对象</li><li>通过<code>Statement</code>执行SQL,返回结果到<code>ResultSet</code>中</li><li>使用<code>ResultSet</code>读取数据，通过代码转换为具体的POJO对象</li><li>关闭数据库。</li></ol><h3 id="ORM模型"><a href="#ORM模型" class="headerlink" title="ORM模型"></a>ORM模型</h3><p>操作数据库的过程复杂，ORM模型基于JDBC进行封装。ORM模型就是<strong>数据库的表和简单Java对象(Plain Ordinary Java Object,简称POJO)的映射关系模型</strong>，它主要解决数据库数据和POJO对象的相互映射。</p><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p><code>MyBatis</code>是一个半自动映射的框架。之所以称它为半自动，是因为它需要<strong>手工匹配提供POJO、SQL和映射关系</strong>。</p><h2 id="二、Mybatis的构成"><a href="#二、Mybatis的构成" class="headerlink" title="二、Mybatis的构成"></a>二、Mybatis的构成</h2><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul><li><code>SqlSessionFactoryBuilder</code>（构造器):它会<strong>根据配置信息</strong>或者代码来生成<code>SqlSessionFactory</code> （工厂接口)。</li><li><code>SqlSessionFactory</code>:依靠工厂来生成<code>SqlSession</code>(会话)。</li><li><code>SqlSession</code>:是一个既可以<strong>发送SQL去执行并返回结果</strong>,也可以获取 Mapper的接口。</li><li><code>SQL Mapper</code>:它是<code>MyBaits</code> 新设计的组件，它是<strong>由一个Java接口和XML文件(或注解）构成的</strong>，需要给出对应的SQL和映射规则。它负责发送SQL 去执行，并返回结果。</li></ul><p><img src="/2022/03/30/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%AE%80%E4%BB%8B/%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" alt="image-20220330230917222"></p><h4 id="构建SqlSessionFactory"><a href="#构建SqlSessionFactory" class="headerlink" title="构建SqlSessionFactory"></a>构建<code>SqlSessionFactory</code></h4><p>每个<code>MyBatis</code> 的应用都是以 <code>SqlSessionFactory</code> 的实例为中心的。<code>SqlSessionFactory</code> 的实例可以通过<code>SqlSessionFactoryBuilder</code> 获得。需要注意<code>SqISessionFactory</code>是一个<strong>工厂接口而不是现实类</strong>，它的任务是创建<code>SqlSession</code>。<code>SqISession</code>类似于一个JDBC 的Connection对象。<code>MyBatis</code>提供了两种模式去创建<code>SqlSessionFactory</code>:一种是XML 配置的方式,另一种是代码的方式。</p><img src="/2022/03/30/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%AE%80%E4%BB%8B/SqlSessionFactory实现类.png" alt="image-20220402194701463" style="zoom:80%;"><p>Configuration的类全限定名为<code>org.apache.ibatis.session.Configuration</code>，它在MyBatis 中将以一个<code>Configuration</code>类对象的形式存在，而这个对象将<strong>存在于整个MyBatis应用的生命期中</strong>，以便重复读取和运用。在内存中的数据是计算机系统中读取速度最快的,我们可以<strong>解析一次配置的XML文件保存到Configuration类对象中</strong>，方便我们从这个对象中读取配置信息，性能高。<strong>单例占用空间小，基本不占用存储空间，而且可以反复使用</strong>。Configuration类对象保存着我们配置在 MyBatis的信息。在MyBatis中提供了两个<code>SqlSessionFactory</code>的实现类，<code>DefaultSqISessionFactory</code>和 <code>SqISessionManager</code>。不过<code>SqlSessionManager</code>目前还没有使用，MyBatis 中目前使用的是DefaultSqISessionFactory。</p><h5 id="使用xml配置"><a href="#使用xml配置" class="headerlink" title="使用xml配置"></a>使用xml配置</h5><p>配置一个XML，包含获取数据库连接实例的数据源(<code>DataSource</code>)、决定事务范围和控制方式的事务管理器(<code>TransactionManager</code>)和映射器(SQL Mapper)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;role&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.learn.chapter2.po.Role&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义数据库信息，默认使用development数据库构建环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--采用jdbc事务管理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置数据库链接信息--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/number&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义映射器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/AccountMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>采用JDBC的事务管理模式</p><p>使用代码创建<code>SqlSessionFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseInitialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String config = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DatabaseInitialize instance = <span class="keyword">new</span> DatabaseInitialize();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DatabaseInitialize</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DatabaseInitialize <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream inputstream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputstream = Resources.getResourceAsStream(config);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputstream) ;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建SqlSession"><a href="#创建SqlSession" class="headerlink" title="创建SqlSession"></a>创建SqlSession</h4><p>在MyBatis 中 SqlSession接口的实现类有两个，分别是<code>DefaultSqlSession</code>和 <code>SqlSessionManager</code>。我们构建了<code>SqlSessionFactory</code>，然后生成 <code>MyBatis</code> 的门面接口 <code>SqlSession</code>。<code>SqlSession</code>接口<strong>类似于一个JDBC中的Connection接口对象</strong>，需要保证每次用完正常关闭它，所以正确的做法是把关闭<code>SqlSession</code>接口的代码写在 finally语句中保证每次都会关闭<code>SqlSession</code>，让连接资源归还给数据库。如果我们不及时关闭资源，数据库的连接资源将很快被耗尽，系统很快因为数据库资源的匮乏而瘫痪。让我们看看实现的伪代码，如代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义sqlSession</span></span><br><span class="line">sqlsession sqlsession = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//打开sqlsession会话</span></span><br><span class="line">sqlsession = sqlSessionFactory.openSession ();</span><br><span class="line">    <span class="comment">//some code ....</span></span><br><span class="line">sqlsession.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">system.err.println (ex.getMessage ( ));</span><br><span class="line">    sqlSession.rollback();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//在finally语句中确保资源被顺利关闭</span></span><br><span class="line">    <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>)&#123;</span><br><span class="line">    sqlsession.close();</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个mapper文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lq.mybatis.mapper.AccountMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;Account&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.lq.mybatis.bean.Account&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>  <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;money&quot;</span> <span class="attr">column</span>=<span class="string">&quot;money&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;Account&quot;</span>&gt;</span></span><br><span class="line">        select id ,name ,money from account where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h4><p>SqlSessionFactoryBuilder是利用XML或者Java编码获得资源来构建<code>SqISessionFactory</code>的，通过它可以构建多个SessionFactory。它的作用就是一个<strong>构建器</strong>，一旦我们构建了<code>SqlSessionFactory</code>，它的作用就已经完结，失去了存在的意义。所以它的<strong>生命周期只存在于方法的局部</strong>，它的作用就是生成<code>sqlSessionFactory</code>对象。</p><h4 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h4><p><code>SqlSessionFactory</code>的作用是<strong>创建SqlSession</strong>,而<code>SqlSession</code>就是一个会话,相当于JDBC中的Connection对象。每次应用程序需要访问数据库，我们就要通过SqlSessionFactory 创建SqISession，所以 SqlSessionFactory应该在MyBatis应用的整个生命周期中。而如果我们多次创建同一个数据库的<code>SqlSessionFactory</code>,则每次创建<code>SqlSessionFactory</code> 会打开更多的数据库连接(Connection）资源，那么连接资源就很快会被耗尽。<strong>因此<code>SqlSessionFactory</code>的责任是唯一的，它的责任就是创建SqlSession，所以我们果断采用单例模式</strong>。</p><h4 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h4><p><strong>SqlSession是一个会话</strong>，相当于JDBC的一个Connection对象，它的生命周期应该是在<strong>请求数据库处理事务的过程中</strong>。它<strong>是一个线程不安全的对象</strong>，在涉及多线程的时候我们需要特别的当心，操作数据库需要注意其隔离级别，数据库锁等高级特性。此外，每次创建的SqlSession都必须及时关闭它，它长期存在就会使数据库连接池的活动资源减少，对系统性能的影响很大。它<strong>存活于一个应用的请求和操作</strong>，可以执行多条SQL，保证事务的一致性。</p><h4 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h4><p>Mapper是一个接口，而没有任何实现类，它的<strong>作用是发送SQL</strong>，然后<strong>返回我们需要的结果</strong>，或者执行SQL从而修改数据库的数据，因此它应该<strong>在一个 SqISession事务方法之内,是一个方法级别的东西</strong>。它就如同JDBC中的一条SQL语句的执行，它最大的范围和SqlSession是相同的。</p><h2 id="三、MyBatis的解析和运行原理"><a href="#三、MyBatis的解析和运行原理" class="headerlink" title="三、MyBatis的解析和运行原理"></a>三、MyBatis的解析和运行原理</h2><p>MyBatis 的运行分为两大部分，第一部分是读取配置文件缓存到Configuration对象，用以创建SqISessionFactory,第二部分是SqISession的执行过程。</p><h3 id="构建SqlSessionFactory过程"><a href="#构建SqlSessionFactory过程" class="headerlink" title="构建SqlSessionFactory过程"></a>构建<code>SqlSessionFactory</code>过程</h3><ol><li>通过<code>org.apache.ibatis.builder.xm1.XMLConfigBuilder</code>解析配置的XML文件，读出配置参数，并将读取的数据存入这个<code>org.apache.ibatis.session.Configuration</code>类中。注意，<code>MyBatis</code> 几乎所有的配置都是存在这里的。</li><li>使用<code>Confinguration</code>对象去创建<code>SqISessionFactory</code>。<code>MyBatis</code>中的<code>SqISessionFactory</code>是一个接口，而不是实现类，为此 MyBatis 提供了一个默认的SqISessionFactory’实现类，我们一般都会使用它<code>org.apache.ibatis.session.defaults.DefaultSqlSessionFactory</code>。</li></ol><p>这种创建的方式就是一种 Builder模式。对于复杂的对象而言，<strong>直接使用构造方法构建是有困难的</strong>，这会导致大量的逻辑放在构造方法中，由于对象的复杂性，在构建的时候，我们<strong>更希望一步步有秩序的来构建它，从而降低其复杂性</strong>。这个时候使用一个参数类总领全局，例如，Configuration类，然后分步构建，例如，DefaultSqSessionFactory类，就可以构建一个复杂的对象，例如，SqlSessionFactory。</p><h4 id="构建Configuration"><a href="#构建Configuration" class="headerlink" title="构建Configuration"></a>构建Configuration</h4><p>在SqlSessionFactory构建中，Configuration是最重要的，它的作用如下。</p><ul><li><strong>读入配置文件</strong>，包括基础配置的XML文件和映射器的XML文件。</li><li><strong>初始化基础配置</strong>，比如 MyBatis 的别名等，一些重要的类对象，例如，插件、映射器、ObjectFactory 和typeHandler对象。</li><li><strong>提供单例</strong>，为后续创建SessionFactory 服务并提供配置的参数。</li><li><strong>执行一些重要的对象方法</strong>，初始化配置信息。</li></ul><h4 id="映射器的内部组成"><a href="#映射器的内部组成" class="headerlink" title="映射器的内部组成"></a>映射器的内部组成</h4><p>映射器由3个部分构成</p><ul><li><code>MappedStatement</code>，它保存映射器的一个节点( <code>select|insert|delete|update</code>)。包括许多我们配置的SQL、SQL的id、缓存信息、resultMap、parameterType、resultType、languageDriver等重要配置内容。</li><li><code>SqlSource</code>，它是<strong>提供BoundSql对象的地方</strong>，它是<code>MappedStatement</code>的一个属性。</li><li><code>BoundSql</code>，它是<strong>建立SQL和参数的地方</strong>。它有3个常用的属性:SQL、parameterObject、parameterMappings。</li></ul><img src="/2022/03/30/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%AE%80%E4%BB%8B/映射器.png" alt="image-20220404144713702" style="zoom:80%;"><h3 id="sqlSession运行过程"><a href="#sqlSession运行过程" class="headerlink" title="sqlSession运行过程"></a>sqlSession运行过程</h3><h4 id="映射器的动态代理"><a href="#映射器的动态代理" class="headerlink" title="映射器的动态代理"></a>映射器的动态代理</h4><p>Mapper映射是通过动态代理来实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里就是动态代理</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[]&#123;<span class="keyword">this</span>.mapperInterface&#125;, mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">        MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy(sqlSession, <span class="keyword">this</span>.mapperInterface, <span class="keyword">this</span>.methodCache);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.newInstance(mapperProxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到动态代理对接口的绑定，它的<strong>作用是生成动态代理对象</strong>，代理的方法放入<code>MapperProxy</code>类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">        <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">        <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//判断它是否是一个类</span></span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</span><br><span class="line">            <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        MapperMethod mapperMethod = (MapperMethod)<span class="keyword">this</span>.methodCache.get(method);</span><br><span class="line">        <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mapperMethod = <span class="keyword">new</span> MapperMethod(<span class="keyword">this</span>.mapperInterface, method, <span class="keyword">this</span>.sqlSession.getConfiguration());</span><br><span class="line">            <span class="keyword">this</span>.methodCache.put(method, mapperMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapperMethod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mybatis使用的是<code>InvocationHandler</code>，是一个JDK动态代理。上面运用了invoke方法。<strong>一旦mapper是一个代理对象，那么它就会运行到invoke方法里面</strong>，invoke首先判断它是否是一个类，显然这里Mapper是一个接口不是类，所以判定失败。那么就会生成<code>MapperMethod</code>对象<strong>，它是通过<code>cachedMapperMethod</code>方法对其初始化的，然后执行execute方法，把sqlSession和当前运行的参数传递进去。</strong></p><p><code>MapperMethod</code>采用<strong>命令模式</strong>运行，根据上下文跳转，它可能跳转到许多方法中，我们不需要全部明白。我们可以看到里面的<code>executeForMany</code>方法，再看看它的实现，实际上它<strong>最后就是通过sqlSession对象去运行对象的SQL</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    List result;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.method.hasRowBounds()) &#123;</span><br><span class="line">        RowBounds rowBounds = <span class="keyword">this</span>.method.extractRowBounds(args);</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.method.getReturnType().isArray() ? <span class="keyword">this</span>.convertToArray(result) : <span class="keyword">this</span>.convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><p>Mybatis映射器的XML文件的命名空间<strong>对应的便是这个接口的全路径</strong>，那么它根据全路径<strong>和方法名便能够绑定起来，通过动态代理技术，让这个接口跑起来</strong>。而后<strong>采用命令模式，最后还是使用SqlSession接口的方法使得它能够执行查询</strong>，有了这层封装我们便可以使用接口编程，这样编程就更简单了。</p><h3 id="SqlSession的四大对象"><a href="#SqlSession的四大对象" class="headerlink" title="SqlSession的四大对象"></a>SqlSession的四大对象</h3><p>Mapper执行的过程是通过 <code>Executor</code>、<code>StatementHandler</code> 、<code>ParameterHandler</code> 和 <code>ResultHandler</code>来完成数据库操作和结果返回的。</p><ul><li><code>Executor</code> 代表执行器,由它来<strong>调度</strong>StatementHandler、ParameterHandler.ResultHandler等来执行对应的SQL。</li><li><code>StatementHandler</code>的作用是<strong>使用数据库的Statement (PreparedStatement)执行操作</strong>，它是四大对象的核心，起到承上启下的作用。</li><li><code>ParameterHandler</code> 用于SQL<strong>对参数的处理</strong>。</li><li><code>ResultHandler</code>是进行<strong>最后数据集（ResultSet）的封装返回处理</strong>的。</li></ul><h4 id="执行器（Executor）"><a href="#执行器（Executor）" class="headerlink" title="执行器（Executor）"></a>执行器（Executor）</h4><p>执行器（Executor）起到了至关重要的作用。它是一个真正执行Java和数据库交互的东西。在 MyBatis中存在三种执行器。我们可以在 MyBatis 的配置文件中进行选择</p><ul><li><code>SIMPLE</code>，简易执行器，不配置它就是默认执行器。</li><li><code>REUSE</code>，是一种执行器<strong>重用预处理语句</strong>。</li><li><code>BATCH</code>，执行器<strong>重用语句和批量更新</strong>，它是针对批量专用的执行器。</li></ul><p><code>Configuration</code>类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction， ExecutorTypeexecutorType)</span></span>&#123;</span><br><span class="line">executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;executorType =executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="comment">//根据配置选择执行器</span></span><br><span class="line"><span class="keyword">if</span>(ExecutorType. BATCH == executorType) &#123;</span><br><span class="line">executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE ==executorType)&#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>,transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction) ;</span><br><span class="line"><span class="keyword">if</span> (cacheEnabled)&#123;</span><br><span class="line">executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//mybatus插件，这里为我们构建一层层的动态代理对象</span></span><br><span class="line">executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<code>SimpleExecutor</code>为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExecutor</span> <span class="keyword">extends</span> <span class="title">BaseExecutor</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//根据Configuration来构建StatementHandler</span></span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      <span class="comment">// 使用prepareStatement方法,对SQL编译并对参数进行初始化</span></span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">      <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);</span><br><span class="line">    <span class="comment">// 调用StatementHandler的 prepare()进行了预编译和基础设置</span></span><br><span class="line">    stmt = handler.prepare(connection);</span><br><span class="line">    <span class="comment">//通过StatementHandler 的 parameterize()来设置参数并执行,resultHandler 再组装查询结果返回给调用者来完成一次查询</span></span><br><span class="line">    handler.parameterize(stmt);</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据库会话器"><a href="#数据库会话器" class="headerlink" title="数据库会话器"></a>数据库会话器</h4><p>数据库会话器(StatementHandler）就是<strong>专门处理数据库会话</strong>的</p><p><code>Configuration</code>类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建的真实对象是一个RoutingStatementHandler对象,和Executor一样，用代理对象做一层层的封装</span></span><br><span class="line">  StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RoutingStatementHandler</code>不是我们真实的服务对象，它是<strong>通过适配模式找到对应的</strong><code>StatementHandler</code> 来执行的。在 MyBatis 中，StatementHandler和Executor一样分为三种:<code>SimpleStatementHandler</code>、<code>PreparedStatementHandler</code>、<code>CallableStatementHandler</code>。</p><p>在初始化 <code>RoutingStatementHandler</code>对象的时候它会根据上下文环境决定创建哪个<code>StatementHandler</code>对象，我们看看<code>RoutingStatementHandler</code> 的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StatementHandler delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">switch</span> (ms.getStatementType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> STATEMENT:</span><br><span class="line">        delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PREPARED:</span><br><span class="line">        delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> CALLABLE:</span><br><span class="line">        delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库会话器定义了一个<strong>对象的适配器<code>delegate</code></strong>,它是一个<code>StatementHandler</code>接口对象，构造方法<strong>根据配置来适配对应的StatementHandler对象</strong>。它的作用是<strong>给实现类对象的使用提供一个统一、简易的使用适配器</strong>。此为对象的适配模式，可以让<strong>我们使用现有的类和方法对外提供服务，也可以根据实际的需求对外屏蔽一些方法，甚至是加入新的服务</strong>。<br>我们现在以最常用的<code>PreparedStatementHandler</code>为例,看看MyBatis是怎么执行查询的。执行器有三个主要的方法，prepare、parameterize和 query，</p><p>先看他们的父类<code>BaseStatementHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseStatementHandler</span> <span class="keyword">implements</span> <span class="title">StatementHandler</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      statement = instantiateStatement(connection);</span><br><span class="line">      setStatementTimeout(statement);</span><br><span class="line">      setFetchSize(statement);</span><br><span class="line">      <span class="keyword">return</span> statement;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instantiateStatement()</code>方法是<strong>对SQL进行了预编译</strong>。首先<strong>，做一些基础配置，比如超时，获取的最大行数等的设置。</strong>然后，Executor 会调用<code>parameterize()</code>方法去设置参数。这个时候它是调用<code>ParameterHandler</code>去完成的，这里先看<code>StatementHandler</code>的查询方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementHandler</span> <span class="keyword">extends</span> <span class="title">BaseStatementHandler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">        ps.execute();</span><br><span class="line">        <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    parameterHandler.setParameters((PreparedStatement) statement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在执行前参数和SQL都被prepare()方法预编译，参数在<code>parameterize()</code>方法上已经进行了设置。所以到这里已经很简单了。我们<strong>只要执行SQL，然后返回结果就可以了</strong>。执行之后我们看到了<code>ResultSetHandler</code><strong>对结果的封装和返回</strong>。</p><p>一条查询SQL的执行流程</p><ol><li>Executor先调用<code>StatementHandler</code> 的 <code>prepare()</code>方法<strong>预编译SQL语句</strong>，同时设置一些基本运行的参数。</li><li>然后用<code>parameterize()</code>方法启用<code>ParameterHandler</code> 设置参数，完成预编译。</li><li>跟着就是执行查询，而update()也是这样的，最后如果需要查询，我们就用<code>ResultSetHandler</code>封装结果返回给调用者。</li></ol><h4 id="参数处理器"><a href="#参数处理器" class="headerlink" title="参数处理器"></a>参数处理器</h4><p>完成对预编译参数的设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ParameterHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//作用是返回参数对象</span></span><br><span class="line">  <span class="function">Object <span class="title">getParameterObject</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//设置预编译SQL语句参数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看实现类<code>DefaultParameterHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    MetaObject metaObject = parameterObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : configuration.newMetaObject(parameterObject);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">      ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">      <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        String propertyName = parameterMapping.getProperty();</span><br><span class="line">        <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">          value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">          value = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">          value = parameterObject;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          value = metaObject == <span class="keyword">null</span> ? <span class="keyword">null</span> : metaObject.getValue(propertyName);</span><br><span class="line">        &#125;</span><br><span class="line">        TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">        JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">        typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是从<code>parameterObject</code>对象中取参数,然后使用<code>typeHandler</code>进行参数处理，如果你有设置typeHandler，那么它就会根据签名注册的<code>typeHandler</code>对参数进行处理。而typeHandler也是在 MyBatis初始化的时候，注册在Configuration里面的，我们需要的时候可以直接拿来用。这样就完成了参数的设置。</p><h4 id="结果处理器"><a href="#结果处理器" class="headerlink" title="结果处理器"></a>结果处理器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetHandler</span> </span>&#123;</span><br><span class="line"><span class="comment">//包装结果集</span></span><br><span class="line">  &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">//处理存储过程输出参数的</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleOutputParameters</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultResultSetHandler</code>，在默认的情况下都是通过这个类进行处理的。这个实现有些复杂，它涉及使用<code>JAVASSIST</code> 或者<code>CGLIB</code>作为<strong>延迟加载</strong>，然后通过<code>typeHandler</code>和<code>ObjectFactory</code><strong>进行组装结果再返回</strong>，因为我们需要改变它们的概率很小。</p><h3 id="SqlSession运行总结"><a href="#SqlSession运行总结" class="headerlink" title="SqlSession运行总结"></a>SqlSession运行总结</h3><img src="/2022/03/30/%E6%A1%86%E6%9E%B6/mybatis/Mybatis%E7%AE%80%E4%BB%8B/SqlSession运行.png" alt="image-20220404160855195" style="zoom:80%;"><p>SqlSession是<strong>通过Executor创建StatementHandler来运行</strong>的，而<code>StatementHandler</code>要经过下<br>面三步。</p><ul><li>prepared 预编译SQL。</li><li>parameterize设置参数。</li><li>query/update执行SQL。</li></ul><p>其中parameterize是调用<code>parameterHandler</code>的方法去设置的，而参数是根据类型处理器.<code>typeHandler</code>去处理的。<code>query/update</code> 方法是通过<code>resultHandler</code>进行处理结果的封装，如果是update的语句，它就<strong>返回整数</strong>，否则它就<strong>通过<code>typeHandler</code> 处理结果类型</strong>，然后用  <code>ObjectFactory</code>提供的规则<strong>组装对象</strong>，返回给调用者。这便是SqlSession 执行的过程。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h2&gt;&lt;h3 id=&quot;JDBC&quot;&gt;&lt;a href=&quot;#JDBC&quot; class=&quot;headerlink&quot; title=&quot;JDBC&quot;&gt;&lt;/a&gt;JDBC&lt;/h3&gt;&lt;p&gt;JDBC是java提供的连接数据库的规范。&lt;/p&gt;
&lt;p&gt;JDBC连接数据库的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册驱动和数据库信息&lt;/li&gt;
&lt;li&gt;操作&lt;code&gt;Connection&lt;/code&gt;，打开&lt;code&gt;Statement&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Statement&lt;/code&gt;执行SQL,返回结果到&lt;code&gt;ResultSet&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;ResultSet&lt;/code&gt;读取数据，通过代码转换为具体的POJO对象&lt;/li&gt;
&lt;li&gt;关闭数据库。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;ORM模型&quot;&gt;&lt;a href=&quot;#ORM模型&quot; class=&quot;headerlink&quot; title=&quot;ORM模型&quot;&gt;&lt;/a&gt;ORM模型&lt;/h3&gt;&lt;p&gt;操作数据库的过程复杂，ORM模型基于JDBC进行封装。ORM模型就是&lt;strong&gt;数据库的表和简单Java对象(Plain Ordinary Java Object,简称POJO)的映射关系模型&lt;/strong&gt;，它主要解决数据库数据和POJO对象的相互映射。&lt;/p&gt;
&lt;h3 id=&quot;Mybatis&quot;&gt;&lt;a href=&quot;#Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Mybatis&quot;&gt;&lt;/a&gt;Mybatis&lt;/h3&gt;&lt;p&gt;&lt;code&gt;MyBatis&lt;/code&gt;是一个半自动映射的框架。之所以称它为半自动，是因为它需要&lt;strong&gt;手工匹配提供POJO、SQL和映射关系&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二、Mybatis的构成&quot;&gt;&lt;a href=&quot;#二、Mybatis的构成&quot; class=&quot;headerlink&quot; title=&quot;二、Mybatis的构成&quot;&gt;&lt;/a&gt;二、Mybatis的构成&lt;/h2&gt;</summary>
    
    
    
    <category term="框架" scheme="http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper源码</title>
    <link href="http://yoursite.com/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/</id>
    <published>2022-03-27T05:53:21.000Z</published>
    <updated>2022-03-30T12:28:19.409Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据存储"><a href="#一、数据存储" class="headerlink" title="一、数据存储"></a>一、数据存储</h2><p>持久化</p><p>Leader 和 Follower 中的数据会在<strong>内存和磁盘中各保存一份</strong>。所以需要将内存中的数据持久化到磁盘中。<br>在<code>org.apache.zookeeper.server.persistence</code>包下的相关类都是序列化相关的代码。</p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/持久化.png" alt="image-20220327142001515" style="zoom: 67%;"><p>处理日志接口<code>TxnLog</code></p><p>处理快照接口<code>SnapShot</code></p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/序列化.png" alt="image-20220327143155959" style="zoom: 67%;"><p><code>zookeeper-jute</code>代码是关于Zookeeper序列化相关源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface InputArchive</span><br><span class="line">interface OutputArchive</span><br></pre></td></tr></table></figure><h2 id="二、服务端初始源码"><a href="#二、服务端初始源码" class="headerlink" title="二、服务端初始源码"></a>二、服务端初始源码</h2><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/zk%E5%90%AF%E5%8A%A8.png" alt="image-20220327144747642"></p><h3 id="zkServer-sh"><a href="#zkServer-sh" class="headerlink" title="zkServer.sh"></a>zkServer.sh</h3><p>从zk的脚本看加载的类是<code>org.apache.zookeeper.server.quorum.QuorumPeerMain</code></p><p>加载的配置的<code>zkEnv.sh</code>中的<code>zoo.cfg</code></p><h3 id="QuorumPeerMain"><a href="#QuorumPeerMain" class="headerlink" title="QuorumPeerMain"></a>QuorumPeerMain</h3><ol><li><p>main方法中初始化一个<code>QuorumPeerMain</code>对象，调用<code>initializeAndRun()</code>方法王超初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initializeAndRun</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ConfigException, IOException, AdminServerException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QuorumPeerConfig config = <span class="keyword">new</span> QuorumPeerConfig();</span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">        config.parse(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start and schedule the the purge task</span></span><br><span class="line">    DatadirCleanupManager purgeMgr = <span class="keyword">new</span> DatadirCleanupManager(config</span><br><span class="line">            .getDataDir(), config.getDataLogDir(), config</span><br><span class="line">            .getSnapRetainCount(), config.getPurgeInterval());</span><br><span class="line">    purgeMgr.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">1</span> &amp;&amp; config.isDistributed()) &#123;</span><br><span class="line">        runFromConfig(config);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Either no config or no quorum defined in config, running &quot;</span></span><br><span class="line">                + <span class="string">&quot; in standalone mode&quot;</span>);</span><br><span class="line">        <span class="comment">// there is only server in the quorum -- run as standalone</span></span><br><span class="line">        ZooKeeperServerMain.main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>initializeAndRun</code>的第一步就是new一个<code>QuorumPeerConfig</code>对象，调用<code>parse</code>解析参数，通过文件流的方式读取参数， <code>parseProperties</code>方法读取参数，最后调用<code>setupQuorumPeerConfig</code>进一步解析参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupQuorumPeerConfig</span><span class="params">(Properties prop, <span class="keyword">boolean</span> configBackwardCompatibilityMode)</span> <span class="keyword">throws</span> IOException, ConfigException </span>&#123;</span><br><span class="line">    quorumVerifier = parseDynamicConfig(prop, electionAlg, <span class="keyword">true</span>, configBackwardCompatibilityMode);</span><br><span class="line">    setupMyId();  <span class="comment">//读取myid赋值给serverId</span></span><br><span class="line">    setupClientPort();<span class="comment">//设置客户端端口</span></span><br><span class="line">    setupPeerType();</span><br><span class="line">    checkValidity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二步new一个 <code>DatadirCleanupManager</code>，执行过期快照删除的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> DatadirCleanupManager purgeMgr = <span class="keyword">new</span> DatadirCleanupManager(config</span><br><span class="line">            .getDataDir(), config.getDataLogDir(), config</span><br><span class="line">            .getSnapRetainCount(), config.getPurgeInterval());</span><br><span class="line">    purgeMgr.start();</span><br><span class="line"><span class="comment">//config.getSnapRetainCount() 最少保留的快照数3</span></span><br><span class="line"><span class="comment">//config.getPurgeInterval() 执行删除历史快照</span></span><br></pre></td></tr></table></figure><p><code>DatadirCleanupManager</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatadirCleanupManager</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (PurgeTaskStatus.STARTED == purgeTaskStatus) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Purge task is already running.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Don&#x27;t schedule the purge task with zero or negative purge interval.</span></span><br><span class="line">        <span class="keyword">if</span> (purgeInterval &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;Purge task is not scheduled.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer = <span class="keyword">new</span> Timer(<span class="string">&quot;PurgeTask&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//启动一个线程，执行清理任务</span></span><br><span class="line">        TimerTask task = <span class="keyword">new</span> PurgeTask(dataLogDir, snapDir, snapRetainCount);</span><br><span class="line">        timer.scheduleAtFixedRate(task, <span class="number">0</span>, TimeUnit.HOURS.toMillis(purgeInterval));</span><br><span class="line"></span><br><span class="line">        purgeTaskStatus = PurgeTaskStatus.STARTED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第4步<code>runFromConfig(config)</code>,创建通信工厂，启动通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config.getClientPortAddress() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cnxnFactory = ServerCnxnFactory.createFactory();</span><br><span class="line">    cnxnFactory.configure(config.getClientPortAddress(),</span><br><span class="line">            config.getMaxClientCnxns(),</span><br><span class="line">            <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建通信工厂默认NIO， <code>NIOServerCnxnFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> ServerCnxnFactory <span class="title">createFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String serverCnxnFactoryName =</span><br><span class="line">        System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);</span><br><span class="line">    <span class="keyword">if</span> (serverCnxnFactoryName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName)</span><br><span class="line">                .getDeclaredConstructor().newInstance();</span><br><span class="line">        LOG.info(<span class="string">&quot;Using &#123;&#125; as server connection factory&quot;</span>, serverCnxnFactoryName);</span><br><span class="line">        <span class="keyword">return</span> serverCnxnFactory;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        IOException ioe = <span class="keyword">new</span> IOException(<span class="string">&quot;Couldn&#x27;t instantiate &quot;</span></span><br><span class="line">                + serverCnxnFactoryName);</span><br><span class="line">        ioe.initCause(e);</span><br><span class="line">        <span class="keyword">throw</span> ioe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>configure()</code>,初始化NIO的socket，绑定2181端口</p><p>启动对应zk</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quorumPeer.initialize();</span><br><span class="line">quorumPeer.start();</span><br><span class="line">quorumPeer.join();</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、服务端加载数据"><a href="#三、服务端加载数据" class="headerlink" title="三、服务端加载数据"></a>三、服务端加载数据</h2><ol><li>zk中的数据模型，是一棵树，<code>DataTree</code>，每个节点，叫做<code>DataNode</code></li><li>zk集群中的<code>DataTree</code>.时刻保持状态同步</li><li>Zookeeper集群中每个zk节点中，数据在内存和磁盘中都有一份完整的数据。<ul><li>内存数据:<code>DataTrees</code></li><li>磁盘数据:<strong>快照文件＋编辑日志</strong></li></ul></li></ol><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/加载数据源.png" alt="image-20220327201531840" style="zoom: 67%;"><p><code>QuorumPeer.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getView().containsKey(myid)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;My id &quot;</span> + myid + <span class="string">&quot; not in the peer list&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    loadDataBase();</span><br><span class="line">    startServerCnxnFactory();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        adminServer.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AdminServerException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Problem starting AdminServer&quot;</span>, e);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    startLeaderElection();</span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载数据</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDataBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        zkDb.loadDataBase();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// load the epochs</span></span><br><span class="line">        <span class="keyword">long</span> lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;</span><br><span class="line">        <span class="keyword">long</span> epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">           <span class="comment">// pick a reasonable epoch number</span></span><br><span class="line">           <span class="comment">// this should only happen once when moving to a</span></span><br><span class="line">           <span class="comment">// new code version</span></span><br><span class="line">           currentEpoch = epochOfZxid;</span><br><span class="line">           LOG.info(CURRENT_EPOCH_FILENAME</span><br><span class="line">                   + <span class="string">&quot; not found! Creating with a reasonable default of &#123;&#125;. This should only happen when you are upgrading your installation&quot;</span>,</span><br><span class="line">                   currentEpoch);</span><br><span class="line">           writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (epochOfZxid &gt; currentEpoch) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;The current epoch, &quot;</span> + ZxidUtils.zxidToString(currentEpoch) + <span class="string">&quot;, is older than the last zxid, &quot;</span> + lastProcessedZxid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(FileNotFoundException e) &#123;</span><br><span class="line">           <span class="comment">// pick a reasonable epoch number</span></span><br><span class="line">           <span class="comment">// this should only happen once when moving to a</span></span><br><span class="line">           <span class="comment">// new code version</span></span><br><span class="line">           acceptedEpoch = epochOfZxid;</span><br><span class="line">           LOG.info(ACCEPTED_EPOCH_FILENAME</span><br><span class="line">                   + <span class="string">&quot; not found! Creating with a reasonable default of &#123;&#125;. This should only happen when you are upgrading your installation&quot;</span>,</span><br><span class="line">                   acceptedEpoch);</span><br><span class="line">           writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acceptedEpoch &lt; currentEpoch) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;The accepted epoch, &quot;</span> + ZxidUtils.zxidToString(acceptedEpoch) + <span class="string">&quot; is less than the current epoch, &quot;</span> + ZxidUtils.zxidToString(currentEpoch));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException ie) &#123;</span><br><span class="line">        LOG.error(<span class="string">&quot;Unable to load database on disk&quot;</span>, ie);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Unable to run quorum server &quot;</span>, ie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">loadDataBase</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//加载数据</span></span><br><span class="line">    <span class="keyword">long</span> zxid = snapLog.restore(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> zxid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//restore方法 </span></span><br><span class="line"><span class="comment">//将磁盘的数据反序列化到磁盘中</span></span><br><span class="line"><span class="comment">//如何从编辑日志中恢复数据</span></span><br></pre></td></tr></table></figure><h2 id="四、选举"><a href="#四、选举" class="headerlink" title="四、选举"></a>四、选举</h2><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95.png" alt="image-20220327203528530"></p><p>流程</p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/选举源码.png" alt="image-20220328222437258"><h3 id="选举准备"><a href="#选举准备" class="headerlink" title="选举准备"></a>选举准备</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!getView().containsKey(myid)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;My id &quot;</span> + myid + <span class="string">&quot; not in the peer list&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    loadDataBase();</span><br><span class="line">    startServerCnxnFactory();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        adminServer.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AdminServerException e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Problem starting AdminServer&quot;</span>, e);</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    startLeaderElection(); <span class="comment">//开始选举</span></span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>startLeaderElection</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startLeaderElection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//创建选票，myid,zxid事务id，epoch任期</span></span><br><span class="line">       <span class="keyword">if</span> (getPeerState() == ServerState.LOOKING) &#123;</span><br><span class="line">           currentVote = <span class="keyword">new</span> Vote(myid, getLastLoggedZxid(), getCurrentEpoch());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">       RuntimeException re = <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">       re.setStackTrace(e.getStackTrace());</span><br><span class="line">       <span class="keyword">throw</span> re;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// if (!getView().containsKey(myid)) &#123;</span></span><br><span class="line">  <span class="comment">//      throw new RuntimeException(&quot;My id &quot; + myid + &quot; not in the peer list&quot;);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (electionType == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            udpSocket = <span class="keyword">new</span> DatagramSocket(getQuorumAddress().getPort());</span><br><span class="line">            responder = <span class="keyword">new</span> ResponderThread();</span><br><span class="line">            responder.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.electionAlg = createElectionAlgorithm(electionType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createElectionAlgorithm</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Election <span class="title">createElectionAlgorithm</span><span class="params">(<span class="keyword">int</span> electionAlgorithm)</span></span>&#123;</span><br><span class="line">    Election le=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> use a factory rather than a switch</span></span><br><span class="line">    <span class="keyword">switch</span> (electionAlgorithm) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        le = <span class="keyword">new</span> LeaderElection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        le = <span class="keyword">new</span> AuthFastLeaderElection(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="comment">//创建通讯，相关队列，创建各种队列</span></span><br><span class="line">        QuorumCnxManager qcm = createCnxnManager();</span><br><span class="line">        QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);</span><br><span class="line">        <span class="keyword">if</span> (oldQcm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Clobbering already-set QuorumCnxManager (restarting leader election?)&quot;</span>);</span><br><span class="line">            oldQcm.halt();</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">//启动监听，一下线程，客户端会一直接收消息，阻塞</span></span><br><span class="line">        QuorumCnxManager.Listener listener = qcm.listener;</span><br><span class="line">        <span class="keyword">if</span>(listener != <span class="keyword">null</span>)&#123;</span><br><span class="line">            listener.start();</span><br><span class="line">            <span class="comment">//创建FastLeaderElection，创建发送队列，发送选票，创建接收队列接收选票</span></span><br><span class="line">            FastLeaderElection fle = <span class="keyword">new</span> FastLeaderElection(<span class="keyword">this</span>, qcm);</span><br><span class="line">            fle.start();</span><br><span class="line">            le = fle;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.error(<span class="string">&quot;Null listener when initializing cnx manager&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> le;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选举执行"><a href="#选举执行" class="headerlink" title="选举执行"></a>选举执行</h3><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/%E9%80%89%E6%8B%A9%E6%89%A7%E8%A1%8C.png" alt="image-20220328225324352"></p><p>start方法中的<code>super.start();</code>启动线程中的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    updateThreadName();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Main loop</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (running) &#123; </span><br><span class="line">            <span class="keyword">switch</span> (getPeerState()) &#123;</span><br><span class="line">            <span class="keyword">case</span> LOOKING:</span><br><span class="line">                LOG.info(<span class="string">&quot;LOOKING&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (Boolean.getBoolean(<span class="string">&quot;readonlymode.enabled&quot;</span>)) &#123;</span><br><span class="line">                    LOG.info(<span class="string">&quot;Attempting to start ReadOnlyZooKeeperServer&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Create read-only server but don&#x27;t start it immediately</span></span><br><span class="line">                    <span class="keyword">final</span> ReadOnlyZooKeeperServer roZk =</span><br><span class="line">                        <span class="keyword">new</span> ReadOnlyZooKeeperServer(logFactory, <span class="keyword">this</span>, <span class="keyword">this</span>.zkDb);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Instead of starting roZk immediately, wait some grace</span></span><br><span class="line">                    <span class="comment">// period before we decide we&#x27;re partitioned.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// Thread is used here because otherwise it would require</span></span><br><span class="line">                    <span class="comment">// changes in each of election strategy classes which is</span></span><br><span class="line">                    <span class="comment">// unnecessary code coupling.</span></span><br><span class="line">                    Thread roZkMgr = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// lower-bound grace period to 2 secs</span></span><br><span class="line">                                sleep(Math.max(<span class="number">2000</span>, tickTime));</span><br><span class="line">                                <span class="keyword">if</span> (ServerState.LOOKING.equals(getPeerState())) &#123;</span><br><span class="line">                                    roZk.startup();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                LOG.info(<span class="string">&quot;Interrupted while attempting to start ReadOnlyZooKeeperServer, not started&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                LOG.error(<span class="string">&quot;FAILED to start ReadOnlyZooKeeperServer&quot;</span>, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        roZkMgr.start();</span><br><span class="line">                        reconfigFlagClear();</span><br><span class="line">                        <span class="keyword">if</span> (shuttingDownLE) &#123;</span><br><span class="line">                            shuttingDownLE = <span class="keyword">false</span>;</span><br><span class="line">                            startLeaderElection();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//设置当前选票</span></span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// If the thread is in the the grace period, interrupt</span></span><br><span class="line">                        <span class="comment">// to come out of waiting.</span></span><br><span class="line">                        roZkMgr.interrupt();</span><br><span class="line">                        roZk.shutdown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                       reconfigFlagClear();</span><br><span class="line">                        <span class="keyword">if</span> (shuttingDownLE) &#123;</span><br><span class="line">                           shuttingDownLE = <span class="keyword">false</span>;</span><br><span class="line">                           startLeaderElection();</span><br><span class="line">                           &#125;</span><br><span class="line">                        setCurrentVote(makeLEStrategy().lookForLeader());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">                        setPeerState(ServerState.LOOKING);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           ...</span><br><span class="line">            start_fle = Time.currentElapsedTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;QuorumPeer main thread exited&quot;</span>);</span><br><span class="line">        MBeanRegistry instance = MBeanRegistry.getInstance();</span><br><span class="line">        instance.unregister(jmxQuorumBean);</span><br><span class="line">        instance.unregister(jmxLocalPeerBean);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) &#123;</span><br><span class="line">            instance.unregister(remotePeerBean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jmxQuorumBean = <span class="keyword">null</span>;</span><br><span class="line">        jmxLocalPeerBean = <span class="keyword">null</span>;</span><br><span class="line">        jmxRemotePeerBean = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lookForLeader</code>寻找Leader时</p><p>第一步,更新选择人</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">    logicalclock.incrementAndGet();</span><br><span class="line">    updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：发送选票<code>sendNotifications</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendNotifications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> sid : self.getCurrentAndNextConfigVoters()) &#123;</span><br><span class="line">            QuorumVerifier qv = self.getQuorumVerifier();</span><br><span class="line">            ToSend notmsg = <span class="keyword">new</span> ToSend(ToSend.mType.notification,</span><br><span class="line">                    proposedLeader,</span><br><span class="line">                    proposedZxid,</span><br><span class="line">                    logicalclock.get(),</span><br><span class="line">                    QuorumPeer.ServerState.LOOKING,</span><br><span class="line">                    sid,</span><br><span class="line">                    proposedEpoch, qv.toString().getBytes());</span><br><span class="line">            <span class="keyword">if</span>(LOG.isDebugEnabled())&#123;</span><br><span class="line">                LOG.debug(<span class="string">&quot;Sending Notification: &quot;</span> + proposedLeader + <span class="string">&quot; (n.leader), 0x&quot;</span>  +</span><br><span class="line">                      Long.toHexString(proposedZxid) + <span class="string">&quot; (n.zxid), 0x&quot;</span> + Long.toHexString(logicalclock.get())  +</span><br><span class="line">                      <span class="string">&quot; (n.round), &quot;</span> + sid + <span class="string">&quot; (recipient), &quot;</span> + self.getId() +</span><br><span class="line">                      <span class="string">&quot; (myid), 0x&quot;</span> + Long.toHexString(proposedEpoch) + <span class="string">&quot; (n.peerEpoch)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//由队列发送消息</span></span><br><span class="line">            sendqueue.offer(notmsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第三步：由内部类<code>WorkerSender</code>负责发送选票，循环处理消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ToSend m = sendqueue.poll(<span class="number">3000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span>(m == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            process(m);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG.info(<span class="string">&quot;WorkerSender is down&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(ToSend m)</span> </span>&#123;</span><br><span class="line">    ByteBuffer requestBuffer = buildMsg(m.state.ordinal(),</span><br><span class="line">                                        m.leader,</span><br><span class="line">                                        m.zxid,</span><br><span class="line">                                        m.electionEpoch,</span><br><span class="line">                                        m.peerEpoch,</span><br><span class="line">                                        m.configData);</span><br><span class="line"><span class="comment">//由具体管理者发送</span></span><br><span class="line">    manager.toSend(m.sid, requestBuffer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步 由具体manager发送这里是QuorumCnxManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toSend</span><span class="params">(Long sid, ByteBuffer b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If sending message to myself, then simply enqueue it (loopback).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mySid == sid) &#123; <span class="comment">//发送给自己，添加到自己的接收队列中</span></span><br><span class="line">         b.position(<span class="number">0</span>);</span><br><span class="line">         addToRecvQueue(<span class="keyword">new</span> Message(b.duplicate(), sid));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Otherwise send to the corresponding thread to send.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//向外发</span></span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * Start a new connection if doesn&#x27;t have one already.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         ArrayBlockingQueue&lt;ByteBuffer&gt; bq = <span class="keyword">new</span> ArrayBlockingQueue&lt;ByteBuffer&gt;(</span><br><span class="line">            SEND_CAPACITY);</span><br><span class="line">         ArrayBlockingQueue&lt;ByteBuffer&gt; oldq = queueSendMap.putIfAbsent(sid, bq);</span><br><span class="line">         <span class="keyword">if</span> (oldq != <span class="keyword">null</span>) &#123;</span><br><span class="line">             addToSendQueue(oldq, b); <span class="comment">//添加到发送队列</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             addToSendQueue(bq, b);</span><br><span class="line">         &#125;</span><br><span class="line">         connectOne(sid); <span class="comment">//连接发送的节点</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第五步：连接到节点,创建socket连接、接收和发送的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">connectOne</span><span class="params">(<span class="keyword">long</span> sid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (senderWorkerMap.get(sid) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LOG.debug(<span class="string">&quot;There is a connection already for server &quot;</span> + sid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (self.QV_LOCK) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> knownId = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// Resolve hostname for the remote server before attempting to</span></span><br><span class="line">        <span class="comment">// connect in case the underlying ip address has changed.</span></span><br><span class="line">        self.recreateSocketAddresses(sid);</span><br><span class="line">        Map&lt;Long, QuorumPeer.QuorumServer&gt; lastCommittedView = self.getView();</span><br><span class="line">        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();</span><br><span class="line">        Map&lt;Long, QuorumPeer.QuorumServer&gt; lastProposedView = lastSeenQV.getAllMembers();</span><br><span class="line">        <span class="keyword">if</span> (lastCommittedView.containsKey(sid)) &#123;</span><br><span class="line">            knownId = <span class="keyword">true</span>;</span><br><span class="line">            LOG.debug(<span class="string">&quot;Server &#123;&#125; knows &#123;&#125; already, it is in the lastCommittedView&quot;</span>, self.getId(), sid);</span><br><span class="line">            <span class="keyword">if</span> (connectOne(sid, lastCommittedView.get(sid).electionAddr))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lastSeenQV != <span class="keyword">null</span> &amp;&amp; lastProposedView.containsKey(sid)</span><br><span class="line">                &amp;&amp; (!knownId || (lastProposedView.get(sid).electionAddr !=</span><br><span class="line">                lastCommittedView.get(sid).electionAddr))) &#123;</span><br><span class="line">            knownId = <span class="keyword">true</span>;</span><br><span class="line">            LOG.debug(<span class="string">&quot;Server &#123;&#125; knows &#123;&#125; already, it is in the lastProposedView&quot;</span>, self.getId(), sid);</span><br><span class="line">            <span class="keyword">if</span> (connectOne(sid, lastProposedView.get(sid).electionAddr))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!knownId) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Invalid server id: &quot;</span> + sid);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第六步：创建<code>SendWork</code>和<code>RecvWorker</code>，<code>SendWork</code>不断向外进行写操作，<code>RecvWorker</code>会不断接收消息添加到<code>recvQueue</code>队列中。</p><p>第七不：选举类中的<code>WorkerReceiver</code>,会不断从<code>recvQueue</code>中取得数据，处理，然后发送到接收队列<code>recequeue</code>中，选举算法就会统计这些选票有没有超过半数，超过就会成为Leader</p><h2 id="五、Follower和Leader进行状态同步"><a href="#五、Follower和Leader进行状态同步" class="headerlink" title="五、Follower和Leader进行状态同步"></a>五、Follower和Leader进行状态同步</h2><p>当选举结束后，每个节点都需要根据自己的角色更新自己的状态。<strong>选举出的Leader 更</strong><br><strong>新自己状态为Leader，其他节点更新自己状态为Follower。</strong><br>Leader 更新状态入口:<code>leader.lead()</code><br>Follower更新状态入口: <code>follower.followerLeader()</code><br>注意:</p><ol><li><strong>follower 必须要让leader 知道自己的状态</strong>: epoch、zxid、sid.<br>必须要找出谁是leader;<br>发起请求连接leader;e发送自己的信息给leader;<br>leader接收到信息，必须要返回对应的信息给follower。</li><li>当leader得知 follower的状态了,就<strong>确定需要做何种方式的数据同步</strong>DIFF、TRUNC、SNAP</li><li>执行数据同步</li><li>当leader <strong>接收到超过半数follower的 ack 之后，进入正常工作状态</strong>，集群启动完</li></ol><p>最终总结同步的方式:e</p><ol><li><code>DIFF</code> 咱两一样，不需要做什么</li><li><code>TRUNC</code> follower 的 <code>zxid</code>比 leader 的 <code>zxid</code>大，所以<strong>Follower要回滚</strong></li><li>COMMIT leader的 <code>zxid</code>,比 follower 的<code>zxid</code>,大，发送Proposal 给follower,提交执行</li><li>如果follower并没有任何数据，直接使用<code>SNAP</code>的方式来执行数据同步（直接把数裾全部序列到follower) </li></ol><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86.png" alt="image-20220328230724600"></p><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/%E5%90%8C%E6%AD%A5%E6%BA%90%E7%A0%81.png" alt="image-20220328231026796"></p><h3 id="状态变更后"><a href="#状态变更后" class="headerlink" title="状态变更后"></a>状态变更后</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> FOLLOWING:</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       LOG.info(<span class="string">&quot;FOLLOWING&quot;</span>);</span><br><span class="line">        setFollower(makeFollower(logFactory));</span><br><span class="line">        follower.followLeader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>,e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       follower.shutdown();</span><br><span class="line">       setFollower(<span class="keyword">null</span>);</span><br><span class="line">       updateServerState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> LEADING:</span><br><span class="line">    LOG.info(<span class="string">&quot;LEADING&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        setLeader(makeLeader(logFactory));</span><br><span class="line">        leader.lead();</span><br><span class="line">        setLeader(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOG.warn(<span class="string">&quot;Unexpected exception&quot;</span>,e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            leader.shutdown(<span class="string">&quot;Forcing shutdown&quot;</span>);</span><br><span class="line">            setLeader(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        updateServerState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Leader，会调用<code>leader.lead()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lead</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">        <span class="comment">//对每个节点创建接收，得到follower的注册</span></span><br><span class="line">     cnxAcceptor = <span class="keyword">new</span> LearnerCnxAcceptor();</span><br><span class="line">     cnxAcceptor.start();</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">         Socket s = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">boolean</span> error = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             s = ss.accept();</span><br><span class="line"></span><br><span class="line">             <span class="comment">// start with the initLimit, once the ack is processed</span></span><br><span class="line">             <span class="comment">// in LearnerHandler switch to the syncLimit</span></span><br><span class="line">             s.setSoTimeout(self.tickTime * self.initLimit);</span><br><span class="line">             s.setTcpNoDelay(nodelay);</span><br><span class="line"></span><br><span class="line">             BufferedInputStream is = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                 s.getInputStream());</span><br><span class="line">             <span class="comment">//为每个follower创建LearnerHandler</span></span><br><span class="line">             LearnerHandler fh = <span class="keyword">new</span> LearnerHandler(s, is, Leader.<span class="keyword">this</span>);</span><br><span class="line">             <span class="comment">//这里会接收到对应的消息，这里会把epochid发送给对方，并等待对方的应答，并且会通过syncFollower选择同步策略，2阶段提交</span></span><br><span class="line">             fh.start();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>FOLLOWING，<code>follower.followLeader();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">followLeader</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">//找到leader</span></span><br><span class="line">    QuorumServer leaderServer = findLeader(); </span><br><span class="line">    <span class="comment">//连接leader</span></span><br><span class="line">    connectToLeader(leaderServer.addr, leaderServer.hostname);</span><br><span class="line">    <span class="comment">//注册，把自己的信息发送给leader，获得对应的数据</span></span><br><span class="line">    <span class="keyword">long</span> newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);</span><br><span class="line">    <span class="comment">//同步数据</span></span><br><span class="line">    syncWithLeader(newEpochZxid); </span><br><span class="line">    <span class="comment">//一直读取服务器的信息并处理 2阶段提交。提案和提交</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.isRunning()) &#123;</span><br><span class="line">        readPacket(qp);</span><br><span class="line">        processPacket(qp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> QuorumServer <span class="title">findLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QuorumServer leaderServer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Find the leader by id</span></span><br><span class="line">        Vote current = self.getCurrentVote();</span><br><span class="line">        <span class="keyword">for</span> (QuorumServer s : self.getView().values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.id == current.getId()) &#123;</span><br><span class="line">                <span class="comment">// Ensure we have the leader&#x27;s correct IP address before</span></span><br><span class="line">                <span class="comment">// attempting to connect.</span></span><br><span class="line">                s.recreateSocketAddresses();</span><br><span class="line">                leaderServer = s;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leaderServer == <span class="keyword">null</span>) &#123;</span><br><span class="line">            LOG.warn(<span class="string">&quot;Couldn&#x27;t find the leader with id = &quot;</span></span><br><span class="line">                    + current.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leaderServer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="服务器Leader启动"><a href="#服务器Leader启动" class="headerlink" title="服务器Leader启动"></a>服务器Leader启动</h3><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/Leader%E5%90%AF%E5%8A%A8.png" alt="image-20220328233155546"></p><p>集群同步之后就启动服务<code>startZkServer()</code></p><p>调用Zookeeper中的<code>startup()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sessionTracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">        createSessionTracker();</span><br><span class="line">    &#125;</span><br><span class="line">    startSessionTracker();</span><br><span class="line">    setupRequestProcessors();</span><br><span class="line"></span><br><span class="line">    registerJMX();</span><br><span class="line"></span><br><span class="line">    setState(State.RUNNING);</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setupRequestProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RequestProcessor finalProcessor = <span class="keyword">new</span> FinalRequestProcessor(<span class="keyword">this</span>);</span><br><span class="line">    RequestProcessor syncProcessor = <span class="keyword">new</span> SyncRequestProcessor(<span class="keyword">this</span>,</span><br><span class="line">            finalProcessor);</span><br><span class="line">    ((SyncRequestProcessor)syncProcessor).start();</span><br><span class="line">    <span class="comment">//预处理线程，会一直等待请求，并根据请求执行相关操作</span></span><br><span class="line">    firstProcessor = <span class="keyword">new</span> PrepRequestProcessor(<span class="keyword">this</span>, syncProcessor);</span><br><span class="line">    ((PrepRequestProcessor)firstProcessor).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务器Follower启动"><a href="#服务器Follower启动" class="headerlink" title="服务器Follower启动"></a>服务器Follower启动</h3><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/Follower启动.png" alt="image-20220328233709486" style="zoom:80%;"><h3 id="客户端启动"><a href="#客户端启动" class="headerlink" title="客户端启动"></a>客户端启动</h3><p><img src="/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8.png" alt="image-20220328233901984"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、数据存储&quot;&gt;&lt;a href=&quot;#一、数据存储&quot; class=&quot;headerlink&quot; title=&quot;一、数据存储&quot;&gt;&lt;/a&gt;一、数据存储&lt;/h2&gt;&lt;p&gt;持久化&lt;/p&gt;
&lt;p&gt;Leader 和 Follower 中的数据会在&lt;strong&gt;内存和磁盘中各保存一份&lt;/strong&gt;。所以需要将内存中的数据持久化到磁盘中。&lt;br&gt;在&lt;code&gt;org.apache.zookeeper.server.persistence&lt;/code&gt;包下的相关类都是序列化相关的代码。&lt;/p&gt;
&lt;img src=&quot;/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/持久化.png&quot; alt=&quot;image-20220327142001515&quot; style=&quot;zoom: 67%;&quot;&gt;

&lt;p&gt;处理日志接口&lt;code&gt;TxnLog&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;处理快照接口&lt;code&gt;SnapShot&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;序列化&quot;&gt;&lt;a href=&quot;#序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化&quot;&gt;&lt;/a&gt;序列化&lt;/h3&gt;&lt;img src=&quot;/2022/03/27/%E5%88%86%E5%B8%83%E5%BC%8F/zookeeper%E6%BA%90%E7%A0%81/序列化.png&quot; alt=&quot;image-20220327143155959&quot; style=&quot;zoom: 67%;&quot;&gt;

&lt;p&gt;&lt;code&gt;zookeeper-jute&lt;/code&gt;代码是关于Zookeeper序列化相关源码&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;interface InputArchive&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;interface OutputArchive&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>分布式算法</title>
    <link href="http://yoursite.com/2022/03/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2022/03/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-26T14:35:14.000Z</published>
    <updated>2022-03-30T13:37:47.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、拜占庭将军问题"><a href="#一、拜占庭将军问题" class="headerlink" title="一、拜占庭将军问题"></a>一、拜占庭将军问题</h2><p>Zookeeper是<strong>如何保证数据一致性的</strong>?这也是困扰分布式系统框架的一个难题。</p><p>拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。<strong>叛徒可以任意行动以达到以下目标:欺骗某些将军采取进攻行动，促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动;或者迷惑某些将军，使他们无法做出决定</strong>。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。</p><h2 id="二、CAP理论"><a href="#二、CAP理论" class="headerlink" title="二、CAP理论"></a>二、CAP理论</h2><p>CAP理论告诉我们，一个分布式系统不可能同时满足以下三种</p><ul><li><strong>一致性</strong>(C:Consistency)</li><li><strong>可用性</strong>(A:Available）</li><li><strong>分区容错性</strong>（P:Partition Tolerance )</li></ul><p>这三个基本需求，最多只能同时满足其中的两项，因为P是必须的，因此往往选择就在<strong>CP</strong>或者<strong>AP</strong>中。</p><ol><li><strong>一致性</strong>(C:Consistency)：在分布式环境中，一致性是指数据在<strong>多个副本之间是否能够保持数据一致的特性</strong>。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。</li><li><strong>可用性</strong>(A:Available）：可用性是指系统提供的服务必须<strong>一直处于可用的状态</strong>，对于用户的每一个操作请求总是能够<strong>在有限的时间内返回结果</strong>。</li><li><strong>分区容错性</strong>（P:Partition Tolerance )：分布式系统在遇到任何网络分区故障的时候，<strong>仍然需要能够保证对外提供满足一致性和可用性的服务</strong>，除非是整个网络环境都发生了故障。</li></ol><h3 id="ZooKeeper保证的是CP"><a href="#ZooKeeper保证的是CP" class="headerlink" title="ZooKeeper保证的是CP"></a>ZooKeeper保证的是CP</h3><ol><li><code>ZooKeeper</code>不能保证每次服务请求的可用性。(注:<strong>在极端环境下，<code>ZooKeeper</code>可能会丢弃一些请求</strong>，消费者程序需要重新请求才能获得结果）。所以说，<code>ZooKeeper</code>不能保证服务可用性。</li><li>进行Leader<strong>选举时集群都是不可用</strong>。</li></ol><h2 id="三、2PC和3PC"><a href="#三、2PC和3PC" class="headerlink" title="三、2PC和3PC"></a>三、2PC和3PC</h2><p>当一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的ACID特性，就需要引入一个称为“<strong>协调者(Coordinator)</strong>”的组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点则被称为“参与者”(Participant)。协调者负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。</p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>二阶段提交。目前绝大多数关系型数据库采用二阶段提交完成分布式事务。将书屋分为2个阶段来进行处理。</p><h4 id="阶段一：提交事务请求"><a href="#阶段一：提交事务请求" class="headerlink" title="阶段一：提交事务请求"></a>阶段一：提交事务请求</h4><ol><li><strong>事务询问</strong><br><strong>协调者</strong>向所有的参与者发送事务内容，<strong>询问是否可以执行事务提交操作</strong>，并开始等待各参与者的响应。</li><li><strong>执行事务。</strong><br>各参与者节点执行事务操作，并将<code>Undo</code>和 <code>Redo</code>信息记入事务日志中。</li><li><strong>各参与者向协调者反馈事务询问的响应。</strong><br>如果参与者成功执行了事务操作，那么就反馈给协调者Yes 响应，表示事务可以执行﹔如果参与者没有成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行。</li></ol><p>阶段一被称为“投票阶段”，各参与者投票表明是否要继续执行下去。</p><h4 id="阶段二：执行事务提交"><a href="#阶段二：执行事务提交" class="headerlink" title="阶段二：执行事务提交"></a>阶段二：执行事务提交</h4><p>协调组根据参与者的反馈情况决定是否可以进行事务提交操作。</p><h5 id="执行事务提交"><a href="#执行事务提交" class="headerlink" title="执行事务提交"></a>执行事务提交</h5><ol><li><strong>发送提交请求</strong><br>协调者向<strong>所有参与者节点发出Commit 请求</strong>。</li><li><strong>事务提交。</strong><br>参与者接收到Commit请求后，会<strong>正式执行事务提交操作</strong>，并在完成提交之后释放在整个事务执行期间占用的事务资源。</li><li><strong>反馈事务提交结果。</strong><br>参与者在完成事务提交之后，向协调者发送 Ack 消息。</li><li><strong>完成事务。</strong><br>协调者接<strong>收到所有参与者反馈的Ack 消息后</strong>，完成事务。</li></ol><h5 id="中断事务"><a href="#中断事务" class="headerlink" title="中断事务"></a>中断事务</h5><p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p><ol><li><strong>发送回滚请求</strong>。<br>协调者向所有参与者节点发出<code>Rollback</code> 请求。</li><li><strong>事务回滚</strong>。<br>参与者接收到Rollback 请求后，会利用其在<strong>阶段一中记录的Undo信息来执行事务回滚操作</strong>，并在完成回滚之后释放在整个事务执行期间占用的资源。</li><li><strong>反馈事务回滚结果</strong>。<br>参与者在完成事务回滚之后，向协调者发送 Ack 消息。</li><li><strong>中断事务</strong>。<br>协调者接收到所有参与者反馈的Ack 消息后，完成事务中断。</li></ol><p>二阶段提交核心是采用先尝试后提交的处理方式，二阶段提交是一个强一致性算法</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：简单，实现方便</p><p>缺点：同步阻塞、单点问题、脑裂、太过保守</p><ol><li><strong>同步阻塞</strong><br>最明显也是最大的一个问题就是同步阻塞,这会极大地限制分布式系统的性能。在二阶段<strong>提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态</strong>。</li><li><strong>单点问题</strong><br>协调者的角色在整个二阶段提交协议中起到了非常重要的作用。<strong>一旦协调者出现问题，那么整个二阶段提交流程将无法运转</strong>，更为严重的是，如果协调者是在<strong>阶段二中出现问题</strong>的话，那么其他参与者将会·<strong>一直处于锁定事务资源的状态</strong>中，而无法继续完成事务操作。</li><li><strong>数据不一致</strong><br>在二阶段提交协议的阶段二，执行事务提交的时候，当协调者向所有的参与者发送Commit请求之后，发生了局部网络异常或者是协调者在尚未发送完Commit请求之前自身发生了崩溃，导致最终<strong>只有部分参与者收到了Commit请求</strong>。于是，这部分收到了Commit请求的参与者就会进行事务的提交，而其他没有收到Commit请求的参与者则无法进行事务提交。</li><li><strong>太过保守</strong><br>如果在协调者指示参与者进行事务提交询问的过程中,参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务。二阶段提交协议没有设计较为完善的容错机制,<strong>任意一个节点的失败都会导致整个事务的失败。</strong></li></ol><h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>3PC，是Three-Phase Commit的缩写，即三阶段提交,将二阶段提交协议的“<strong>提交事务请求</strong>“过程一分为二,形成了由<code>CanCommit</code>, <code>PreCommit</code>和 <code>do Commit</code></p><h4 id="CanCommit"><a href="#CanCommit" class="headerlink" title="CanCommit"></a><code>CanCommit</code></h4><ol><li><strong>事务询问。</strong><br>协调者向所有的参与者发送一个包含事务内容的 <code>canCommit</code> 请求，询问<strong>是否可以执行事务提交操作</strong>，并开始等待各参与者的响应。</li><li><strong>各参与者向协调者反馈事务询问的响应。</strong><br>参与者在接收到来自协调者的<code>canCommit</code>请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈Yes响应，并进入预备状态，否则反馈No响应。</li></ol><h4 id="PreCommit"><a href="#PreCommit" class="headerlink" title="PreCommit"></a><code>PreCommit</code></h4><p>在阶段二中，协调者会根据各参与者的反馈情况来决定是否可以进行事务的<code>PreCommit</code>操作，正常情况下，包含两种可能。</p><h5 id="执行事务预提交"><a href="#执行事务预提交" class="headerlink" title="执行事务预提交"></a>执行事务预提交</h5><p>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务预提交。</p><ol><li><strong>发送预提交请求。</strong><br>协调者向所有参与者节点发出<code>preCommit</code>的请求，并<strong>进入Prepared阶段</strong>。</li><li><strong>事务预提交。</strong><br>参与者接收到<code>preCommit</code>请求后，会执行事务操作，并将<strong>Undo和Redo信息记录到事务日志中。</strong></li><li><strong>各参与者向协调者反馈事务执行的响应。</strong><br>如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终的指令:提交(commit)或中止 (abort)。</li></ol><h5 id="中断事务-1"><a href="#中断事务-1" class="headerlink" title="中断事务"></a>中断事务</h5><p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么<strong>就会中断事务</strong>。</p><ol><li><p><strong>发送中断请求。</strong><br>协调者向所有参与者节点发出abort请求。</p></li><li><p><strong>中断事务。</strong></p><p>无论是收到来自协调者的abort请求,或者是在等待协调者请求过程中出现超时，参与者都会中断事务。</p></li></ol><h4 id="do-Commit"><a href="#do-Commit" class="headerlink" title="do Commit"></a><code>do Commit</code></h4><h5 id="执行提交"><a href="#执行提交" class="headerlink" title="执行提交"></a>执行提交</h5><ol><li><strong>发送提交请求。</strong><br>进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么它将<strong>从“预提交”状态转换到“提交”状态</strong>，并向所有的参与者发送<code>doCommit</code>请求。</li><li><strong>事务提交。</strong><br>参与者接收到<code>doCommit</code>请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</li><li><strong>反馈事务提交结果。</strong><br>参与者在完成事务提交之后，向协调者发送 Ack 消息。</li><li><strong>完成事务。</strong><br>协调者接收到所有参与者反馈的Ack 消息后，完成事务。</li></ol><h5 id="中断事务-2"><a href="#中断事务-2" class="headerlink" title="中断事务"></a>中断事务</h5><p>进入这一阶段，假设协调者处于正常工作状态，并且有<strong>任意一个参与者向协调者反馈了No响应</strong>,或者在等待超时之后,协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p><ol><li><strong>发送中断请求</strong>。<br>协调者向所有的参与者节点发送abort 请求。</li><li><strong>事务回滚。</strong><br>参与者接收到abort请求后，会利用其在阶段二中记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</li><li><strong>反锁事务回滚结果</strong>。<br>参与者在完成事务回滚之后，向协调者发送 Ack 消息。</li><li><strong>中断事务。</strong><br>协调者接收到所有参与者反馈的Ack 消息后，中断事务。</li></ol><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点：相较于二阶段提交协议，三阶段提交协议最大的优点就是<strong>降低了参与者的阻塞范围</strong>，并且能够在出现单点故障后继续达成一致。<br>缺点:三阶段提交协议在去除阻塞的同时也引入了新的问题，那就是在<strong>参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信</strong>，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性。</p><h2 id="四、Paxos算法"><a href="#四、Paxos算法" class="headerlink" title="四、Paxos算法"></a>四、Paxos算法</h2><p><code>Paxos</code>算法:一种基于消息传递且具有高度容错特性的<strong>一致性算法</strong>。</p><p><code>Paxos</code>算法解决的问题:就是如何快速正确的在一个分布式系统中对某个数据值达成一致，并且保证不论发生任何异常，都不会破坏整个系统的一致性。</p><p><img src="/2022/03/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98.png" alt="image-20220326224050431"></p><p>在一个<code>Paxos</code>系统中，首先将所有节点划分为<strong>Proposer(提议者)</strong>，<strong>Acceptor(接受者)</strong>，和<strong>Learner(学习者)</strong>。(注意:每个节点都可以身兼数职)。</p><p><strong>一个完整的<code>Paxos</code>算法流程分为三个阶段:</strong></p><ul><li>Prepare准备阶段<ol><li>Proposer向多个Acceptor发出Propose请求Promise(承诺). </li><li>Acceptor针对收到的Propose请求进行Promise(承诺)</li></ol></li><li>Accept接受阶段<ol><li>Proposer收到多数Acceptor承 诺的Promise后，向Acceptor发出Propose请求 </li><li>Acceptor针对收到的Propose请求进行Accept处理</li></ol></li><li>Learn学习阶段:<ol><li>Proposer将形成的决议发送给所有Learners</li></ol></li></ul><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ol><li><strong>Prepare</strong>: Proposer生成<strong>全局唯一且递增的Proposal ID</strong>，向所有Acceptor发送Propose请求，这里无需携带提案内容，只携带Proposal ID即可。</li><li>Promise: Acceptor收到Propose请求后，做出”<strong>两个承诺，一个应答</strong>“。<ul><li>不再接受Proposal ID<strong>小于等于（注意:这里是&lt;=）当前请求的Propose请求</strong>。</li><li>不再接受Proposal ID<strong>小于（注意:这里是&lt;）当前请求的Accept请求</strong>。</li><li>不违背以前做出的承诺下，回复已经Accept过的提案中<strong>Proposal ID最大的那个提案的Value和Proposal ID</strong>，没有则返回空值。</li></ul></li><li>Propose: Proposer收到多数Acceptor的Promise应答后，从<strong>应答中选择Proposal ID最大的提案的Value，作为本次要发起的提案</strong>。如果所有应答的提案Value均为空值，则可以自己随意决定提案Value。然后携带当前Proposal ID，向所有Acceptor发送Propose请求。</li><li>Accept: Acceptor收到Propose请求后，<strong>在不违背自己之前做出的承诺下，接受并持久化当前Proposal ID和提案Value</strong>。</li><li>Learn: Proposer收到多数Acceptor的Accept后，决议形成，将形成的决议发送给所有Learner</li></ol><h3 id="3种情况"><a href="#3种情况" class="headerlink" title="3种情况"></a>3种情况</h3><p>A1,A2,A3,A4,A5发起提案</p><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p>A1发起税率10%的提案</p><ol><li>A1发起1号Proposal的Propose，等待Promise承诺;</li><li>A2-A5回应Promise;</li><li>A1在收到两份回复时就会发起税率10%的Proposal;</li><li>A2-A5回应Accept;</li></ol><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>A1发起税率10%的提案，A5发起税率20%的提案</p><ol><li>A1，A5同时发起Propose(序号分别为1，2)</li><li>A2承诺A1，A4承诺A5，A3行为成为关键</li><li>情况1:A3先收到A1消息，承诺A1。</li><li>A1发起Proposal (1,10%)，A2，A3接受。</li><li>之后<strong>A3又收到A5消息，回复A1:(1，10%)，并承诺A5。</strong></li><li>A5发起Proposal (2，20%)，A3，A4接受。之后A1，A5同时广播决议。</li></ol><h4 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h4><p>A1发起税率10%的提案，A5发起税率20%的提案</p><ol><li>A1，A5同时发起Propose(序号分别为1，2)</li><li>A2承诺A1，A4承诺A5，A3行为成为关键</li><li>情况2:<strong>A3先收到A1消息，承诺A1。之后立刻收到A5消息，承诺A5。</strong></li><li>A1发起Proposal（1，10%)，无足该响应，A1重新Propose (序号3)，A3再次承诺A1</li><li>A5发起Proposal(2，20%），无足够相应，A5重新Propose(.序号4〕 ，A3再次承诺A5</li><li>…</li></ol><p>造成这种情况的原囚是系统中<strong>有一个以上的Proposer</strong>,<strong>多个Proposers 相互争夺Acceptor</strong>,造成迟迟无法达成一致的情况。针对这种情况，一种改进的<code>Paxos</code>,算法被提出:<strong>从系统中选出一个节点作为Leader，只有Leader 能够发起提案</strong>。这样，一次<code>Paxos</code>流程中只有一个Proposer，不会出现活锁的情况，此时只会出现例子中第一种情况。</p><h2 id="五、ZAB协议"><a href="#五、ZAB协议" class="headerlink" title="五、ZAB协议"></a>五、ZAB协议</h2><p><code>Zab</code> 借鉴了<code>Paxos</code>算法，是特别为Zookeeper设计的<strong>支持崩溃恢复的原子广播协议</strong>。基于该协议，Zookeeper设计为<strong>只有一台客户端（Leader）负责处理外部的写事务请求</strong>，然后Leader 客户端将数据同步到其他Follower节点。即Zookeeper 只有一个Leader可以发起提案。</p><p><code>Zab</code>协议包括两种基本的模式:<strong>消息广播</strong>、<strong>崩溃恢复</strong>。</p><h3 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h3><img src="/2022/03/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/消息广播.png" alt="image-20220327131940966" style="zoom:80%;"><ol><li>客户端发起一个写操作请求。</li><li>Leader服务器将客户端的请求转化为事务<strong>Proposal提案</strong>，同时为每个Proposal分配一个全局的ID，即<code>zxid</code>。</li><li>Leader服务器为每个Follower服务器<strong>分配一个单独的队列</strong>，然后将需要广播的Proposal依次放到队列中去，并且根据FIFO策略进行消息发送</li><li>Follower接收到Proposal后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向Leader反馈一个Ack响应消息。</li><li>Leader接收到超过半数以上Follower的Ack响应消息后，即认为消息发送成功，可以发送commit消息。</li><li>Leader<strong>向所有Follower广播commit消息</strong>，同时自身也会完成事务提交。Follower按收到commit消息后，会将上一条事务提交。</li><li>Zookeeper采用<code>Zab</code>协议的核心，就是<strong>只要有一台服务器提交了Proposal，就要确保所有的服务器最终都能正确提交Proposals</strong></li></ol><p>ZAB协议针对事务请求的处理过程类似于一个两阶段提交过程</p><ol><li>广播事务阶段</li><li>广播提交操作</li></ol><h3 id="奔溃恢复"><a href="#奔溃恢复" class="headerlink" title="奔溃恢复"></a>奔溃恢复</h3><h4 id="异常假设"><a href="#异常假设" class="headerlink" title="异常假设"></a>异常假设</h4><p>这两阶段提交模型，有可能因为Leader宕机带来数据不一致，比如</p><ol><li><p>假设<strong>一个事务在Leader提出之后，Leader挂了</strong>。</p></li><li><p>一个事务<strong>在Leader上提交了</strong>，并且<strong>过半的Follower都响应Ack了</strong>，但是<strong>Leader在Commit消息发出之前挂了</strong>。</p><img src="/2022/03/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/奔溃恢复.png" alt="image-20220327133025139" style="zoom:80%;"></li></ol><p>奔溃恢复满足两个要求：</p><ol><li>确保已经被Leader提交的提案Proposal，必须最终被所有的Follower服务器提交。(已经产生的提案，<strong>Follower必须执行</strong>。</li><li>确保<strong>丢弃</strong>已经被Leader提出的，但是没有被提交的Proposal。(丢弃胎死腹中的提案)</li></ol><h4 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h4><img src="/2022/03/26/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95/Leader选举.png" alt="image-20220327133547020" style="zoom:80%;"><ol><li>新选举出来的Leader不能包含未提交的Proposal。即<strong>新Leader必须都是已经提交了Proposal的Follower服务器节点。</strong></li><li>新选举的Leader节点中<strong>含有最大的<code>zxid</code></strong>。这样做的好处是可以<strong>避免Leader服务器检查Proposal的提交和丢弃工作。</strong></li></ol><h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><ol><li>完成Leader选举后，在正式开始工作之前（接收事务请求，然后提出新的Proposal),Leader服务器会首先<strong>确认事务日志中的所有的Proposal是否己经被集群中过半的服务器Commit</strong>。</li><li>Leader服务器需要确保所有的Follower服务器能够接收到每一条事务的Proposal，并且能将所有已经提交的事务Proposal应用到内存数据中。<strong>等到Follower将所有尚未同步的事务Proposal都从Leader服务器上同步过，并且应用到内存数据中以后，Leader才会把该Follower加入到真正可用的Follower列表中。</strong></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、拜占庭将军问题&quot;&gt;&lt;a href=&quot;#一、拜占庭将军问题&quot; class=&quot;headerlink&quot; title=&quot;一、拜占庭将军问题&quot;&gt;&lt;/a&gt;一、拜占庭将军问题&lt;/h2&gt;&lt;p&gt;Zookeeper是&lt;strong&gt;如何保证数据一致性的&lt;/strong&gt;?这也是困扰分布式系统框架的一个难题。&lt;/p&gt;
&lt;p&gt;拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。&lt;strong&gt;叛徒可以任意行动以达到以下目标:欺骗某些将军采取进攻行动，促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动;或者迷惑某些将军，使他们无法做出决定&lt;/strong&gt;。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利。&lt;/p&gt;
&lt;h2 id=&quot;二、CAP理论&quot;&gt;&lt;a href=&quot;#二、CAP理论&quot; class=&quot;headerlink&quot; title=&quot;二、CAP理论&quot;&gt;&lt;/a&gt;二、CAP理论&lt;/h2&gt;&lt;p&gt;CAP理论告诉我们，一个分布式系统不可能同时满足以下三种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt;(C:Consistency)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用性&lt;/strong&gt;(A:Available）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分区容错性&lt;/strong&gt;（P:Partition Tolerance )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三个基本需求，最多只能同时满足其中的两项，因为P是必须的，因此往往选择就在&lt;strong&gt;CP&lt;/strong&gt;或者&lt;strong&gt;AP&lt;/strong&gt;中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt;(C:Consistency)：在分布式环境中，一致性是指数据在&lt;strong&gt;多个副本之间是否能够保持数据一致的特性&lt;/strong&gt;。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可用性&lt;/strong&gt;(A:Available）：可用性是指系统提供的服务必须&lt;strong&gt;一直处于可用的状态&lt;/strong&gt;，对于用户的每一个操作请求总是能够&lt;strong&gt;在有限的时间内返回结果&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分区容错性&lt;/strong&gt;（P:Partition Tolerance )：分布式系统在遇到任何网络分区故障的时候，&lt;strong&gt;仍然需要能够保证对外提供满足一致性和可用性的服务&lt;/strong&gt;，除非是整个网络环境都发生了故障。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;ZooKeeper保证的是CP&quot;&gt;&lt;a href=&quot;#ZooKeeper保证的是CP&quot; class=&quot;headerlink&quot; title=&quot;ZooKeeper保证的是CP&quot;&gt;&lt;/a&gt;ZooKeeper保证的是CP&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ZooKeeper&lt;/code&gt;不能保证每次服务请求的可用性。(注:&lt;strong&gt;在极端环境下，&lt;code&gt;ZooKeeper&lt;/code&gt;可能会丢弃一些请求&lt;/strong&gt;，消费者程序需要重新请求才能获得结果）。所以说，&lt;code&gt;ZooKeeper&lt;/code&gt;不能保证服务可用性。&lt;/li&gt;
&lt;li&gt;进行Leader&lt;strong&gt;选举时集群都是不可用&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="zookeeper" scheme="http://yoursite.com/tags/zookeeper/"/>
    
  </entry>
  
</feed>
